// This project began March 30, 2020

// exe: 837/869

// all:
// (837+10+86+130+37+49)/(869+10+86+130+37+49)
// 97.29%

typedef unsigned char   undefined;

typedef unsigned char    byte;
typedef unsigned int    dword;
typedef unsigned char    uchar;
typedef unsigned long    ulong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined4;
typedef unsigned short    ushort;
typedef unsigned short    word;
typedef unsigned short    wchar16;
typedef uchar u_char;

typedef ushort u_short;

typedef ulong u_long;

typedef struct MATRIX MATRIX, *PMATRIX;

struct MATRIX {
    short m[3][3];
    long t[3];
};

typedef struct VECTOR VECTOR, *PVECTOR;

struct VECTOR {
    long vx;
    long vy;
    long vz;
    long pad;
};

typedef struct SVECTOR SVECTOR, *PSVECTOR;

struct SVECTOR {
    short vx;
    short vy;
    short vz;
    short pad;
};

typedef uchar PACKET;

typedef struct DIRENTRY DIRENTRY, *PDIRENTRY;

// Part of parsing directories in BIGFILE
struct DIRENTRY {
    char name[20];
    long attr;
    long size;
    struct DIRENTRY * next;
    long head;
    char system[4];
};

typedef struct SpuDecodedData SpuDecodedData, *PSpuDecodedData;

struct SpuDecodedData {
    short cd_left[512];
    short cd_right[512];
    short voice1[512];
    short voice3[512];
};

typedef struct SpuReverbAttr SpuReverbAttr, *PSpuReverbAttr;

typedef struct SpuVolume SpuVolume, *PSpuVolume;

struct SpuVolume {
    short left;
    short right;
};

struct SpuReverbAttr {
    ulong mask;
    long mode;
    struct SpuVolume depth;
    long delay;
    long feedback;
};

typedef void (* SpuIRQCallbackProc)(void);

typedef void (* SpuTransferCallbackProc)(void);

typedef struct CdlLOC CdlLOC, *PCdlLOC;

struct CdlLOC {
    u_char minute;
    u_char second;
    u_char sector;
    u_char track;
};

typedef struct CdlFILE CdlFILE, *PCdlFILE;

struct CdlFILE {
    struct CdlLOC pos;
    u_long size;
    char name[16];
};

typedef void (* CdlCB)(u_char, u_char *);

typedef struct RECT RECT, *PRECT;

struct RECT {
    short x;
    short y;
    short w;
    short h;
};

typedef struct DR_ENV DR_ENV, *PDR_ENV;

struct DR_ENV {
    u_long tag;
    u_long code[15];
};

typedef struct DR_MOVE DR_MOVE, *PDR_MOVE;

struct DR_MOVE {
    u_long tag;
    u_long code[5];
};

typedef struct DISPENV DISPENV, *PDISPENV;

struct DISPENV {
    struct RECT disp;
    struct RECT screen;
    u_char isinter;
    u_char isrgb24;
    u_char pad0;
    u_char pad1;
};

typedef struct DRAWENV DRAWENV, *PDRAWENV;

struct DRAWENV {
    struct RECT clip;
    short ofs[2];
    struct RECT tw;
    u_short tpage;
    u_char dtd;
    u_char dfe;
    u_char isbg;
    u_char r0;
    u_char g0;
    u_char b0;
    struct DR_ENV dr_env;
};

// .text
// ram:800123e0-ram:8008099f
// BOTS.c: 			800123e0 - 800175cb 
// CAM.c: 			800175cc - 8001c35f
// CDSYS.c:			8001c360 - 8001d093
// COLL.c:			8001d094 - 800214ff
// CTR.c:			80021500 - 800222df
// DEBUGFONT.c:		800222e0 - 800223f3
// DECALFONT.c:		800223f4 - 80022b93
// DECALGLOBAL.c:	80022b94 - 80022daf
// DECALHUD.c:		80022db0 - 80023487
// DECALMP.c:		80023488 - 80023a3f
// DISPLAY.c:		800a3a40 - 8002406b
// DOTLIGHTS.c:		8002406c - 80024463
// EffectSfxRain.c:	80024464 - 80024523
// ElimBG.c:		80024524 - 80024c4b
// FLARE.c:			80024c4c - 800251ab
// GAMEPAD.c:		800251ac - 800265bf
// GAMEPROG.c:		800265c0 - 80026ed7
// GHOSTBUFFER.c:	80026ed8 - 8002843b
// HOWL.c:			8002843c - 80030777
// INSTANCE.c:		80030778 - 80030fdb
// JitPool.c:		80030fdc - 8003116b
// LevInstDef.c:	8003116c - 800313c7
// LHMatrix.c:		800313c8 - 8003147b
// LibraryOfModels:	8003147c - 800314bf
// LinkedCollide:	800314e0 - 80031733
// LIST:			80031734 - 800319e7
// LOAD:			800319e8 - 8003495f
// MAIN:			80034960 - 8003d183
// MATH:			8003d184 - 8003d4e3
// MEMCARD:			8003d4e4 - 8003e73f
// MEMPACK:			8003e740 - 8003ea27
// MixRNG:			8003ea28 - 8003eadf
// Particles:		8003eae0 - 8004084f
// RobotcarWeapons:	80040850 - 800414f3
// StartLine:		800414f4 - 80041c83
// Tawna:			80041c84 - 80041dbf
// THREAD:			80041dc0 - 800426f7


// TileView_Init
// param_1 - tileView
// param_2 - cameraID
// param_3 - total number cameras
void FUN_800426f8(int param_1,int param_2,int param_3)

{
  undefined2 uVar1;
  undefined4 uVar2;

  // fadeStep
  *(undefined2 *)(param_1 + 0x16) = 0x88;

  // start of Proj matrix
  // 0x1c71 / 0x1000 = 16/9,
  // therefore makes image stretch horizontally (fitting 512x216),
  // then that image upscaled to 640x480 stretched vertically, is 4x3
  *(undefined2 *)(param_1 + 0x88) = 0x1c71;

  // cameraID
  *(undefined *)(param_1 + 0x108) = (char)param_2;

  // fadeFromBlack = NormalLight (no fade)
  *(undefined2 *)(param_1 + 0x12) = 0x1000;
  *(undefined2 *)(param_1 + 0x14) = 0x1000;

  // remainder of Proj matrix
  // matrix continued (from 0x88)
  *(undefined2 *)(param_1 + 0x8a) = 0;
  *(undefined2 *)(param_1 + 0x8c) = 0;
  *(undefined2 *)(param_1 + 0x8e) = 0;
  *(undefined2 *)(param_1 + 0x90) = 0x1000;
  *(undefined2 *)(param_1 + 0x92) = 0;
  *(undefined2 *)(param_1 + 0x94) = 0;
  *(undefined2 *)(param_1 + 0x96) = 0;
  *(undefined2 *)(param_1 + 0x98) = 0x1000;
  *(undefined4 *)(param_1 + 0x9c) = 0;
  *(undefined4 *)(param_1 + 0xa0) = 0;
  *(undefined4 *)(param_1 + 0xa4) = 0;

  // If this is 2P mode
  if (param_3 == 2)
  {
	// If current player is not P1
    if (param_2 != 0)
	{
	  // If current player is not P2
      if (param_2 != 1)
	  {
		// Quit
        return;
      }

	  // If current player is P2

	  // tileView dimensions
	  // Assume +1c is 0
      *(undefined2 *)(param_1 + 0x1e) = 0x6e;
      *(undefined2 *)(param_1 + 0x20) = 0x200;
      *(undefined2 *)(param_1 + 0x22) = 0x6a;

	  // "distance" to screen, for perspective
      *(undefined4 *)(param_1 + 0x18) = 0x100;
	  *(undefined4 *)(param_1 + 0x10c) = 0x100;

	  // aspectX
      uVar1 = 8;
LAB_80042810:

	  // aspect can be 4/3 or 8/3
      *(undefined2 *)(param_1 + 0x24) = uVar1;
      *(undefined2 *)(param_1 + 0x1c) = 0;
      *(undefined2 *)(param_1 + 0x26) = 3;
      return;
    }

	// If current player is P1

	// tileView dimensions
	// assume +0x1e and +1c is 0
    *(undefined2 *)(param_1 + 0x20) = 0x200;
    *(undefined2 *)(param_1 + 0x22) = 0x6a;

	// "distance" to screen, for perspective
    *(undefined4 *)(param_1 + 0x18) = 0x100;
	*(undefined4 *)(param_1 + 0x10c) = 0x100;

	// aspectX
    uVar1 = 8;
  }

  // If this is not 2P mode
  else {

	// If numPlyrCurrGame is less than 3 (1 or 2)
    if (param_3 < 3)
	{
	  // If this is not 1P mode
      if (param_3 != 1)
	  {
		// quit
        return;
      }

	  // tileView dimensions for Player 1 in 1P mode
      *(undefined2 *)(param_1 + 0x20) = 0x200;
      *(undefined2 *)(param_1 + 0x22) = 0xd8;

	  // distanceToScreen (fov)
      uVar2 = 0x100;
    }

	// If you have 3 or more screens
    else
	{
	  // If you have more than 4 screens
      if (4 < param_3)
	  {
		// Quit
        return;
      }

	  // Player 2 in 3P/4P mode
      if (param_2 == 1)
	  {
		// tileView dimensions
        // assume +1e is zero
		*(undefined2 *)(param_1 + 0x1c) = 0x103;
        *(undefined2 *)(param_1 + 0x20) = 0xfd;
        *(undefined2 *)(param_1 + 0x22) = 0x6a;

		// "distance" to screen, for perspective
        *(undefined4 *)(param_1 + 0x18) = 0x80;
        *(undefined4 *)(param_1 + 0x10c) = 0x80;

		// aspectX = 4, for 4/3 ratio
        *(undefined2 *)(param_1 + 0x24) = 4;
        goto LAB_800427a4;
      }

	  // If playerID is more than (1=P2)
	  // If this is P3 or P4
      if (1 < param_2)
	  {
		// If this is not P3
        if (param_2 != 2)
		{
		  // If this is P4
          if (param_2 == 3)
		  {
			// tileView dimensions for P4 in 4P mode
            *(undefined2 *)(param_1 + 0x1c) = 0x103;
            *(undefined2 *)(param_1 + 0x1e) = 0x6e;
            *(undefined2 *)(param_1 + 0x20) = 0xfd;
            *(undefined2 *)(param_1 + 0x22) = 0x6a;

			// "distance" to screen, for perspective
            *(undefined4 *)(param_1 + 0x18) = 0x80;
            *(undefined4 *)(param_1 + 0x10c) = 0x80;

			// aspect ratio is 4/3, aspectX and aspectY
            *(undefined2 *)(param_1 + 0x24) = 4;
            *(undefined2 *)(param_1 + 0x26) = 3;

            return;
          }

		  // If this is P1 or P2
		  // This will never happen
          return;
        }

		// tileView dimensions for P3 in 3P/4P mode
        // Assume +1c is zero
		*(undefined2 *)(param_1 + 0x1e) = 0x6e;
        *(undefined2 *)(param_1 + 0x20) = 0xfd;
        *(undefined2 *)(param_1 + 0x22) = 0x6a;

		// distanceToScreen (changes FOV)
        *(undefined4 *)(param_1 + 0x18) = 0x80;
        *(undefined4 *)(param_1 + 0x10c) = 0x80;

		// aspectX
		uVar1 = 4;

		goto LAB_80042810;
      }

	  // If this is not P1
      if (param_2 != 0)
	  {
		// Quit
        return;
      }

	  // If this is P1
      // Assume +1c and +1e are zero
	  *(undefined2 *)(param_1 + 0x20) = 0xfd;
      *(undefined2 *)(param_1 + 0x22) = 0x6a;

	  // distanceToScreen
      uVar2 = 0x80;
    }

	// distanceToScreen (changes FOV)
    *(undefined4 *)(param_1 + 0x18) = uVar2;
    *(undefined4 *)(param_1 + 0x10c) = uVar2;

	// aspectX
	uVar1 = 4;
  }

  // aspectX
  *(undefined2 *)(param_1 + 0x24) = uVar1;

  // startX
  *(undefined2 *)(param_1 + 0x1c) = 0;

LAB_800427a4:

  // startY
  *(undefined2 *)(param_1 + 0x1e) = 0;

  // aspectY
  *(undefined2 *)(param_1 + 0x26) = 3;
  return;
}


// TileView_SetPsyqGeom
void FUN_80042910(int param_1)

{
  int iVar1;
  int iVar2;

  iVar1 = (uint)*(ushort *)(param_1 + 0x20) << 0x10;
  iVar2 = (uint)*(ushort *)(param_1 + 0x22) << 0x10;

  // Geometry Origin
  // All this bit-shifting is really just
  // SetGeomOffset(width/2, height/2),
  // Trust me, copy/paste into C++ program and try yourself
  SetGeomOffset((iVar1 >> 0x10) - (iVar1 >> 0x1f) >> 1,(iVar2 >> 0x10) - (iVar2 >> 0x1f) >> 1);

  // "distance" to screen, alters FOV
  SetGeomScreen(*(long *)(param_1 + 0x18));
  return;
}


// TileView_SetDrawEnv_DecalMP
// param1 - ptrOT
// param2 - gGT->backbuffer
// param3 - RECT
// param4 - ofsX
// param5 - ofsY
void FUN_80042974(void *param_1,undefined4 *param_2,undefined2 *param_3,undefined2 param_4,
                 undefined2 param_5,undefined param_6,undefined param_7,undefined param_8,
                 undefined param_9,undefined param_10)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  void *pvVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  void *p;

  // DrawEnv:

  // RECT clip
  undefined4 local_70;
  undefined2 local_6c;
  undefined2 uStack106;

  // short ofs[2]
  undefined2 local_68;
  undefined2 uStack102;

  // RECT tw
  undefined4 local_64 [2];

  // short tpage
  undefined uStack90;
  undefined local_58;

  // char dtd, dfe, isbg
  undefined uStack87;
  undefined uStack86;
  undefined uStack85;

  // Copy DrawEnv from gGT->backBuffer (param2)
  // onto stack memory at &local_70
  puVar1 = (undefined4 *)&local_70;
  puVar5 = param_2;
  do {
    puVar4 = puVar5;
    puVar2 = puVar1;
    uVar6 = puVar4[1];
    uVar7 = puVar4[2];
    uVar8 = puVar4[3];
    *puVar2 = *puVar4;
    puVar2[1] = uVar6;
    puVar2[2] = uVar7;
    puVar2[3] = uVar8;
    puVar5 = puVar4 + 4;
    puVar1 = puVar2 + 4;
  } while (puVar5 != param_2 + 0x14);
  uVar6 = puVar4[5];
  uVar7 = puVar4[6];
  puVar2[4] = *puVar5;
  puVar2[5] = uVar6;
  puVar2[6] = uVar7;

  // Now modify DrawEnv...

  // RECT viewport (startX, startY, endX, endY)
  local_70._0_2_ = *param_3;
  local_70._2_2_ = param_3[1];
  local_6c = param_3[2];
  uStack106 = param_3[3];

  // tpage-lower (always 1)
  local_58 = param_10;

  // ofs[Y]
  uStack102 = param_5;

  // dtd (dithering)
  uStack87 = param_6;

  // dfe (blocked or permitted)
  uStack86 = param_7;

  // isbg (always 0)
  uStack85 = param_8;

  // tpage-upper (always 0)
  uStack90 = param_9;

  // gGT->backBuffer->primMem.curr
  pvVar3 = (void *)param_2[0x20];

  p = (void *)0x0;

  // curr < endMin100
  if (pvVar3 <= (void *)param_2[0x21])
  {
	// advance curr
    param_2[0x20] = (int)pvVar3 + 0x40;

	// write primitive here
    p = pvVar3;
  }

  if (p != (void *)0x0)
  {
	// ofs[X]
    local_68 = param_4;

	// DrawEnv just built
    SetDrawEnv(p,&local_70);

	// This doesn't really draw a primitive,
	// it links the ptrOT from the camera,
	// into the ptrOT of backBuffer DB, allowing
	// this camera's primitives to draw
	AddPrim(param_1,p);
  }
  return;
}

// TileView_SetDrawEnv_Normal
// param1 otmem
// param2 tileView
// param3 backbuffer
void FUN_80042a8c(void *param_1,int param_2,undefined4 *param_3,short *param_4,undefined param_5)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  void *pvVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  void *p;

  // DrawEnv:

  // RECT clip
  undefined4 local_70;
  short local_6c;
  short sStack106;

  // short ofs[2]
  short local_68;
  short sStack102;

  // RECT tw, and short tpage
  undefined4 local_64 [3];

  // dtd
  undefined local_58;

  // Copy DrawEnv from gGT->backBuffer (param2)
  // onto stack memory at &local_70
  puVar1 = (undefined4 *)&local_70;
  puVar5 = param_3;
  do {
    puVar4 = puVar5;
    puVar2 = puVar1;
    uVar6 = puVar4[1];
    uVar7 = puVar4[2];
    uVar8 = puVar4[3];
    *puVar2 = *puVar4;
    puVar2[1] = uVar6;
    puVar2[2] = uVar7;
    puVar2[3] = uVar8;
    puVar5 = puVar4 + 4;
    puVar1 = puVar2 + 4;
  } while (puVar5 != param_3 + 0x14);
  uVar6 = puVar4[5];
  uVar7 = puVar4[6];
  puVar2[4] = *puVar5;
  puVar2[5] = uVar6;
  puVar2[6] = uVar7;

  // Now modify DrawEnv...

  // always zero?
  if (param_4 == (short *)0x0)
  {
	// XXX + tileView->rect.x
    local_70._0_2_ = (short)local_70 + *(short *)(param_2 + 0x1c);

	// XXX + tileView->rect.y
    local_70._2_2_ = local_70._2_2_ + *(short *)(param_2 + 0x1e);

	// tileView->rect.w
    local_6c = *(short *)(param_2 + 0x20);

	// tileView->rect.h
    sStack106 = *(short *)(param_2 + 0x22);

	// XXX + tileView->rect.x
    local_68 = local_68 + *(short *)(param_2 + 0x1c);

	// XXX + tileView->rect.y
    sStack102 = sStack102 + *(short *)(param_2 + 0x1e);
  }

  // option to use baked data, if it exists,
  // which it never is?
  else
  {
    local_70._0_2_ = *param_4;
    local_70._2_2_ = param_4[1];
    local_6c = param_4[2];
    sStack106 = param_4[3];
    local_68 = *param_4;
    sStack102 = param_4[1];
  }

  // drawEnv.dtd (always zero)
  local_58 = param_5;

  // gGT->backBuffer->primMem.curr
  pvVar3 = (void *)param_3[0x20];

  // render no primitives if
  // less than 100 remains
  p = (void *)0x0;

  // curr < endMin100
  // if more than 100 remains
  if (pvVar3 <= (void *)param_3[0x21])
  {
	// advance curr, reserve 0x40 bytes of OT
    param_3[0x20] = (int)pvVar3 + 0x40;

	// write primitive here, with 0x40 reserved
	p = pvVar3;
  }

  if (p != (void *)0x0)
  {
	// DrawEnv just built
    SetDrawEnv(p,&local_70);

	// This doesn't really draw a primitive,
	// it links the ptrOT from the camera,
	// into the ptrOT of backBuffer DB, allowing
	// this camera's primitives to draw
    AddPrim(param_1,p);
  }
  return;
}

// TileView_SetMatrixVP -- CameraMatrix, and ViewProj
// param1 is TileView
void FUN_80042c04(short *param_1)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  short sVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  int iVar12;
  int iVar13;
  uint uVar14;
  uint uVar15;

  // tileView rotation
  DAT_1f8003f4 = param_1[3];
  DAT_1f8003f6 = param_1[4];
  DAT_1f8003f8 = param_1[5];

  // camera matrix
  FUN_8006c2a4(&DAT_1f8003d4,&DAT_1f8003f4);

  // offsets 0x7c-0x84, 
  // camera matrix position
  iVar13 = (int)param_1[1];
  *(int *)(param_1 + 0x3e) = (int)*param_1;
  uVar1 = -(int)*param_1;
  *(int *)(param_1 + 0x40) = iVar13;
  *(int *)(param_1 + 0x42) = (int)param_1[2];
  
  // camera matrix
  sVar7 = DAT_1f8003e4;
  uVar6 = DAT_1f8003e0;
  uVar5 = DAT_1f8003dc;
  uVar4 = DAT_1f8003d8;
  uVar3 = DAT_1f8003d4;
  iVar2 = -(int)param_1[2];
  iVar12 = (int)DAT_1f8003e4;
  
  // transpose camera matrix
  uVar8 = DAT_1f8003e0 & 0xffff;
  uVar15 = uVar8 | DAT_1f8003d4 & 0xffff0000;
  uVar9 = DAT_1f8003dc & 0xffff;
  uVar14 = uVar9 | DAT_1f8003e0 & 0xffff0000;
  uVar11 = DAT_1f8003d4 & 0xffff | DAT_1f8003d8 & 0xffff0000;
  uVar10 = DAT_1f8003d8 & 0xffff | DAT_1f8003dc & 0xffff0000;

  // param1 is short* so double offsets,
  // offsets 0x68 - 0x74 is for CameraMatrix matrix
  *(uint *)(param_1 + 0x34) = DAT_1f8003d4;
  *(uint *)(param_1 + 0x36) = uVar4;
  *(uint *)(param_1 + 0x38) = uVar5;
  *(uint *)(param_1 + 0x3a) = uVar6;
  
  // USELESS, Never Used
  // offsets 0x48 - 0x68 is transpose camera matrix
  *(uint *)(param_1 + 0x24) = uVar11;
  *(uint *)(param_1 + 0x26) = uVar15;
  *(uint *)(param_1 + 0x28) = uVar14;
  *(uint *)(param_1 + 0x2a) = uVar10;
  
  param_1[0x3c] = sVar7;
  param_1[0x2c] = sVar7;

  // load transpose camera matrix  
  gte_ldL11L12(uVar11);
  gte_ldL13L21(uVar15);
  gte_ldL22L23(uVar14);
  gte_ldL31L32(uVar10);
  gte_ldL33(iVar12);
  
  // load inverted camera position
  gte_ldVXY0(uVar1 & 0xffff | iVar13 * -0x10000);
  gte_ldVZ0(iVar2);
  
  // multiply
  gte_llv0();
  
  // get result
  read_mt(uVar1,-iVar13,iVar2);

  // param1 is short* so double offsets,
  // offsets 0x28 - 0x48 is for ViewProj matrix
  *(uint *)(param_1 + 0x2e) = uVar1;
  *(uint *)(param_1 + 0x1e) = uVar1;
  *(int *)(param_1 + 0x30) = -iVar13;
  *(int *)(param_1 + 0x32) = iVar2;
  *(int *)(param_1 + 0x22) = iVar2;
  *(uint *)(param_1 + 0x14) = uVar11;
  *(uint *)(param_1 + 0x1a) = uVar10;
  param_1[0x1c] = sVar7;
  
  // 0x360/0x600 = 9/16 aspect ratio, if you render an image with 9/16 aspect,
  // at a resolution of 512x216, then the final image is a 4/3 aspect ratio. 
  // Upscaling the super-wide render target to a 640x480 TV would therefore 
  // look "normal". Math: 9/16 * 512/216, you get 4/3
  
  // apply aspect ratio to perspective matrix
  *(int *)(param_1 + 0x20) = (iVar13 * -0x360) / 0x600;
  *(uint *)(param_1 + 0x16) = uVar8 | ((((int)uVar15 >> 0x10) * 0x360) / 0x600) * 0x10000;
  *(uint *)(param_1 + 0x18) =
       ((short)uVar9 * 0x360) / 0x600 & 0xffffU |
       ((((int)uVar14 >> 0x10) * 0x360) / 0x600) * 0x10000;
	   
  // load CameraMatrix into GTE, this is useless 
  // cause it gets overwritten later anyway, which means
  // storing the result on scratchpad is also useless
  gte_ldL11L12(uVar3);
  gte_ldL13L21(uVar4);
  gte_ldL22L23(uVar5);
  gte_ldL31L32(uVar6);
  return;
}


// TileView_SetFrustumPlane
// param_3 = cameraPos (x,y,z)
uint FUN_80042e50(undefined2 *param_1,short *param_2,short *param_3,short *param_4)
{
  int iVar1;
  int iVar2;
  uint uVar3;
  uint unaff_s0;
  int unaff_s1;
  int unaff_s2;
  int iVar4;
  int iVar5;
  int iVar6;
  
  // cameraPos(x,y,z)
  iVar6 = (int)*param_3;
  iVar4 = (int)param_3[1];
  iVar5 = (int)param_3[2];
  
  // param_4 - cameraPos
  gte_ldR11R12(*param_4 - iVar6);
  gte_ldR22R23(param_4[1] - iVar4);
  gte_ldR33(param_4[2] - iVar5);
  
  // param_2 - cameraPos
  gte_ldIR1(*param_2 - iVar6);
  gte_ldIR2(param_2[1] - iVar4);
  gte_ldIR3(param_2[2] - iVar5);
  
  // OP(sf,lm) - Outer product of 2 vectors
  gte_op0(0);
  
  read_mt(unaff_s0,unaff_s1,unaff_s2);
  
  uVar3 = unaff_s0;
  if ((int)unaff_s0 < 0) {
    uVar3 = -unaff_s0;
  }
  gte_ldLZCS(uVar3);
  iVar2 = gte_stLZCR();
  iVar1 = unaff_s1;
  if (unaff_s1 < 0) {
    iVar1 = -unaff_s1;
  }
  gte_ldLZCS(iVar1);
  iVar1 = gte_stLZCR();
  if (iVar1 < iVar2) {
    iVar2 = iVar1;
  }
  iVar1 = unaff_s2;
  if (unaff_s2 < 0) {
    iVar1 = -unaff_s2;
  }
  gte_ldLZCS(iVar1);
  iVar1 = gte_stLZCR();
  if (iVar1 < iVar2) {
    iVar2 = iVar1;
  }
  if (iVar2 < 0x12) {
    uVar3 = 0x12 - iVar2;
    unaff_s0 = (int)unaff_s0 >> (uVar3 & 0x1f);
    unaff_s1 = unaff_s1 >> (uVar3 & 0x1f);
    unaff_s2 = unaff_s2 >> (uVar3 & 0x1f);
  }
  iVar1 = FUN_8006c618(unaff_s0 * unaff_s0 + unaff_s1 * unaff_s1 + unaff_s2 * unaff_s2);
  iVar2 = unaff_s0 << 0xc;
  if (iVar1 != 0) {
    unaff_s0 = iVar2 / iVar1;
    if (iVar1 == 0) {
      trap(0x1c00);
    }
    if ((iVar1 == -1) && (iVar2 == -0x80000000)) {
      trap(0x1800);
    }
    iVar2 = unaff_s1 << 0xc;
    unaff_s1 = iVar2 / iVar1;
    if (iVar1 == 0) {
      trap(0x1c00);
    }
    if ((iVar1 == -1) && (iVar2 == -0x80000000)) {
      trap(0x1800);
    }
    iVar2 = unaff_s2 << 0xc;
    unaff_s2 = iVar2 / iVar1;
    if (iVar1 == 0) {
      trap(0x1c00);
    }
    if ((iVar1 == -1) && (iVar2 == -0x80000000)) {
      trap(0x1800);
    }
  }
  
  uVar3 = unaff_s0 >> 0x1f;
  
  // 8 bytes written to return parameter
  *param_1 = (short)unaff_s0;
  param_1[1] = (short)unaff_s1;
  param_1[2] = (short)unaff_s2;
  param_1[3] = (short)((int)(unaff_s0 * iVar6 + unaff_s1 * iVar4 + unaff_s2 * iVar5) >> 0xd);
  
  if (unaff_s1 < 0) {
    uVar3 = uVar3 | 2;
  }
  if (unaff_s2 < 0) {
    uVar3 = uVar3 | 4;
  }
  return uVar3;
}



// WARNING: Could not reconcile some variable overlaps

// TileView_UpdateFrustum
// param_1 is TileView
void FUN_800430f0(short *param_1)

{
  short sVar1;
  short sVar2;
  short sVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  uint uVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  undefined4 uVar12;
  int iVar13;
  int iVar14;
  undefined4 uVar15;
  int iVar16;
  int iVar17;
  undefined4 uVar18;
  int iVar19;
  int iVar20;
  int iVar21;
  uint uVar22;
  int iVar23;
  int iVar24;
  int iVar25;
  int iVar26;
  int iVar27;
  int iVar28;
  int local_3c;
  int local_38;

  // TileView_SetMatrixVP
  FUN_80042c04(param_1);

  // disable the rest of the function by setting
  // 80043124 to 0x08010E3E (j 0x800438f8),
  // proves the rest of this function updates frustum

  // cameraPosX
  sVar1 = *param_1;
  iVar23 = (int)sVar1;

  // cameraPosY
  sVar2 = param_1[1];
  iVar25 = (int)sVar2;

  // cameraPosZ
  sVar3 = param_1[2];
  iVar26 = (int)sVar3;

  // iVar6 (X Val) = rect.w - rect.w/2 ???
  iVar7 = (int)((uint)(ushort)param_1[0x10] << 0x10) >> 0x10;
  uVar6 = iVar7 - ((int)((uint)(ushort)param_1[0x10] << 0x10) >> 0x1f) >> 1 & 0xffff;
  
  // iVar5 (Y Val) = rect.h scaled with aspect (0x600 / 0x360)
  iVar4 = (((int)param_1[0x11] * 0x600000) / 0x360 >> 0xc) << 0x10;
  iVar9 = iVar4 >> 0x10;
  uVar5 = (iVar9 - (iVar4 >> 0x1f) >> 1) << 0x10;
  
  // tileView 0x18, distToScreen
  iVar24 = *(int *)(param_1 + 0xc);
  
  // first "do" loop iteration
  // X | (Y << 0x10)
  uVar22 = uVar6 | uVar5;
  
  // distToScreen
  gte_ldVZ0(iVar24);
  
  // number of times to loop
  iVar20 = 3;
  
  // -1 * rect.w/2
  uVar8 = -iVar7 / 2 & 0xffff;
  
  iVar9 = -iVar9;
  iVar21 = 0x1f800012;
  iVar4 = iVar23;
  iVar7 = iVar25;
  iVar27 = iVar26;
  iVar28 = iVar23;
  local_3c = iVar25;
  local_38 = iVar26;
  
  // uVar5, uVar6, uVar8, uVar9 never change
  // beyond this point, they are constant
  
  // 4 points (x,y,z):
  // uVar6, uVar5, distToScreen
  // uVar8, uVar5, distToScreen
  // uVar8, uVar9, distToScreen
  // uVar6, uVar9, distToFinish_checkpoint
  
  do 
  {
	// multiply corner of screen,
	// by view-projection matrix, 
	// to get frustum plane world-pos
    gte_ldVXY0(uVar22);
    gte_llv0();

	if (iVar20 == 2) 
	{
	  // prepare for third iteration
      uVar22 = uVar6 | iVar9 / 2 << 0x10;
    }
    else {
      if (iVar20 < 3) {
        if (iVar20 == 1) 
		{
		  // prepare for fourth iteration
          uVar22 = uVar8 | iVar9 / 2 << 0x10;
        }
      }
      else {
        if (iVar20 == 3) 
		{
		  // prepare for second iteration
          uVar22 = uVar8 | uVar5;
        }
      }
    }
	
	// this is ViewProj matrix, loaded into GTE
	// from end of TileView_SetMatrixVP (called earlier)
	read_mt(iVar10,iVar13,iVar16);
    
	// result of read_mt, plus cameraPos (x,y,z),
	iVar11 = iVar10 * 0x100 + iVar23;
    iVar14 = iVar13 * 0x100 + iVar25;
    iVar17 = iVar16 * 0x100 + iVar26;
    
	iVar19 = 0x1000;
    
	// result of read_mt, plus cameraPos (x,y,z),
	// over 4 loop iterations, this writes four corners,
	// 0x1f80000c = 0x1f800022
	*(short *)(iVar21 + 0x10) = (short)iVar16 + sVar3;
    *(short *)(iVar21 + 0xc) = (short)iVar10 + sVar1;
    *(short *)(iVar21 + 0xe) = (short)iVar13 + sVar2;
	
    DAT_1f800000 = iVar11;
    DAT_1f800004 = iVar14;
    DAT_1f800008 = iVar17;
    
	// === X Axis ===
	if (((iVar23 < -0x8000) && (-0x8000 < iVar11)) || ((-0x8000 < iVar23 && (iVar11 < -0x8000)))) {
      iVar13 = (-0x8000 - iVar23) * 0x1000;
      iVar10 = iVar11 - iVar23;
      iVar16 = iVar13 / iVar10;
      if (iVar10 == 0) {
        trap(0x1c00);
      }
      if ((iVar10 == -1) && (iVar13 == -0x80000000)) {
        trap(0x1800);
      }
      if (iVar16 < 0x1000) {
        DAT_1f800000 = -0x8000;
        DAT_1f800004 = iVar25 + (iVar16 * (iVar14 - iVar25) >> 0xc);
        DAT_1f800008 = iVar26 + (iVar16 * (iVar17 - iVar26) >> 0xc);
        iVar19 = iVar16;
      }
    }
	
	// === Y Axis ===
    if (((iVar25 < -0x8000) && (-0x8000 < iVar14)) || ((-0x8000 < iVar25 && (iVar14 < -0x8000)))) {
      iVar13 = (-0x8000 - iVar25) * 0x1000;
      iVar10 = iVar14 - iVar25;
      iVar16 = iVar13 / iVar10;
      if (iVar10 == 0) {
        trap(0x1c00);
      }
      if ((iVar10 == -1) && (iVar13 == -0x80000000)) {
        trap(0x1800);
      }
      if (iVar16 < iVar19) {
        DAT_1f800004 = -0x8000;
        DAT_1f800000 = iVar23 + (iVar16 * (iVar11 - iVar23) >> 0xc);
        DAT_1f800008 = iVar26 + (iVar16 * (iVar17 - iVar26) >> 0xc);
        iVar19 = iVar16;
      }
    }
	
	// === Z Axis ===
    if (((iVar26 < -0x8000) && (-0x8000 < iVar17)) || ((-0x8000 < iVar26 && (iVar17 < -0x8000)))) {
      iVar13 = (-0x8000 - iVar26) * 0x1000;
      iVar10 = iVar17 - iVar26;
      iVar16 = iVar13 / iVar10;
      if (iVar10 == 0) {
        trap(0x1c00);
      }
      if ((iVar10 == -1) && (iVar13 == -0x80000000)) {
        trap(0x1800);
      }
      if (iVar16 < iVar19) {
        DAT_1f800008 = -0x8000;
        DAT_1f800000 = iVar23 + (iVar16 * (iVar11 - iVar23) >> 0xc);
        DAT_1f800004 = iVar25 + (iVar16 * (iVar14 - iVar25) >> 0xc);
        iVar19 = iVar16;
      }
    }
	
	// === X Axis ===
    if (((iVar23 < 0x7fff) && (0x7fff < iVar11)) || ((0x7fff < iVar23 && (iVar11 < 0x7fff)))) {
      iVar13 = (0x7fff - iVar23) * 0x1000;
      iVar10 = iVar11 - iVar23;
      iVar16 = iVar13 / iVar10;
      if (iVar10 == 0) {
        trap(0x1c00);
      }
      if ((iVar10 == -1) && (iVar13 == -0x80000000)) {
        trap(0x1800);
      }
      if (iVar16 < iVar19) {
        DAT_1f800000 = 0x7fff;
        DAT_1f800004 = iVar25 + (iVar16 * (iVar14 - iVar25) >> 0xc);
        DAT_1f800008 = iVar26 + (iVar16 * (iVar17 - iVar26) >> 0xc);
        iVar19 = iVar16;
      }
    }
	
	// === Y Axis ===
    if (((iVar25 < 0x7fff) && (0x7fff < iVar14)) || ((0x7fff < iVar25 && (iVar14 < 0x7fff)))) {
      iVar13 = (0x7fff - iVar25) * 0x1000;
      iVar10 = iVar14 - iVar25;
      iVar16 = iVar13 / iVar10;
      if (iVar10 == 0) {
        trap(0x1c00);
      }
      if ((iVar10 == -1) && (iVar13 == -0x80000000)) {
        trap(0x1800);
      }
      if (iVar16 < iVar19) {
        DAT_1f800004 = 0x7fff;
        DAT_1f800000 = iVar23 + (iVar16 * (iVar11 - iVar23) >> 0xc);
        DAT_1f800008 = iVar26 + (iVar16 * (iVar17 - iVar26) >> 0xc);
        iVar19 = iVar16;
      }
    }
	
	// === Z Axis ===
    if (((iVar26 < 0x7fff) && (0x7fff < iVar17)) || ((0x7fff < iVar26 && (iVar17 < 0x7fff)))) {
      iVar10 = (0x7fff - iVar26) * 0x1000;
      iVar17 = iVar17 - iVar26;
      iVar13 = iVar10 / iVar17;
      if (iVar17 == 0) {
        trap(0x1c00);
      }
      if ((iVar17 == -1) && (iVar10 == -0x80000000)) {
        trap(0x1800);
      }
      if (iVar13 < iVar19) {
        DAT_1f800008 = 0x7fff;
        DAT_1f800000 = iVar23 + (iVar13 * (iVar11 - iVar23) >> 0xc);
        DAT_1f800004 = iVar25 + (iVar13 * (iVar14 - iVar25) >> 0xc);
      }
    }
	
    if (DAT_1f800000 < iVar28) {
      iVar28 = DAT_1f800000;
    }
    if (iVar4 < DAT_1f800000) {
      iVar4 = DAT_1f800000;
    }
    if (DAT_1f800004 < local_3c) {
      local_3c = DAT_1f800004;
    }
    if (iVar7 < DAT_1f800004) {
      iVar7 = DAT_1f800004;
    }
    if (DAT_1f800008 < local_38) {
      local_38 = DAT_1f800008;
    }
    if (iVar27 < DAT_1f800008) {
      iVar27 = DAT_1f800008;
    }
    
	// next loop index
	iVar20 = iVar20 + -1;
	
	// next corner to write
    iVar21 = iVar21 + -6;
	
  } while (-1 < iVar20);

  // 0xE8 to 0xF2
  param_1[0x74] = (short)iVar28;
  param_1[0x77] = (short)iVar4;
  param_1[0x78] = (short)iVar7;
  param_1[0x75] = (short)local_3c;
  param_1[0x79] = (short)iVar27;
  param_1[0x76] = (short)local_38;

  // cameraPos (x,y,z)
  DAT_1f800024._0_2_ = sVar1;
  DAT_1f800024._2_2_ = sVar2;
  DAT_1f800028._0_2_ = sVar3;

  // Changing stuff here is what caused EuroAli's
  // discovery for widescreen, so that polygons aren't
  // clipped outside of original 4:3 viewport

  // TileView_SetFrustumPlane (x4)
  
  // these are four corners, two corners per func call,
  // combined with camera position, is used to make a plane
/*
	1f80000c -0x100 0x255 0x66 -- corner (-x,+y,-z)
	1f800012 +0x100 0x255 0x66 -- corner (+x,+y,-z)
	1f800018 -0x100 0x0D5 0x78 -- corner (-x,-y,-z)
	1f80001e +0x100 0x0D5 0x78 -- corner (+x,-y,-z)
	1f800024 0x0000 0x1a4 0x1af -- cameraPos
*/

  // param_1 is short*, so double offsets

  // 0xA8
  uVar5 = FUN_80042e50(param_1 + 0x54,&DAT_1f80000c,&DAT_1f800024,0x1f800012);
  // 0xD0
  *(uint *)(param_1 + 0x68) = ~uVar5 & 7;

  // 0xB0
  uVar5 = FUN_80042e50(param_1 + 0x58,0x1f800012,&DAT_1f800024,0x1f80001e);
  // 0xD4
  *(uint *)(param_1 + 0x6a) = ~uVar5 & 7;

  // 0xB8
  uVar5 = FUN_80042e50(param_1 + 0x5c,0x1f80001e,&DAT_1f800024,&DAT_1f800018);
  // 0xD8
  *(uint *)(param_1 + 0x6c) = ~uVar5 & 7;

  // 0xC0
  uVar5 = FUN_80042e50(param_1 + 0x60,&DAT_1f800018,&DAT_1f800024,&DAT_1f80000c);
  // 0xDC
  *(uint *)(param_1 + 0x6e) = ~uVar5 & 7;

  setCopReg(2,0,0);
  setCopReg(2,0x800,0x1000);

  // llv0     cop2 $04A6012  v0 * light matrix
  copFunction(2,0x4a6012);

  uVar5 = getCopReg(2,0xc800);
  iVar4 = getCopReg(2,0xd000);
  iVar7 = getCopReg(2,0xd800);

  // 0xC8, 0xCA, 0xCC
  param_1[100] = -(short)uVar5;
  param_1[0x65] = -(short)iVar4;
  param_1[0x66] = -(short)iVar7;

  iVar9 = iVar24;
  if (iVar24 < 0) {
    iVar9 = iVar24 + 3;
  }

  // 0xCE
  param_1[0x67] =
       (short)((int)-(iVar23 * uVar5 + iVar25 * iVar4 + iVar26 * iVar7) >> 0xd) -
       (short)(iVar9 >> 2);

  uVar5 = uVar5 >> 0x1f;
  if (iVar4 < 0) {
    uVar5 = uVar5 | 2;
  }
  if (iVar7 < 0) {
    uVar5 = uVar5 | 4;
  }

  // 0xE0, 0xE4
  *(uint *)(param_1 + 0x70) = ~uVar5 & 7;
  *(uint *)(param_1 + 0x72) = uVar5;

  setCopReg(2,0,0);
  setCopReg(2,0x800,iVar24 / 2);

  // llv0     cop2 $04A6012  v0 * light matrix
  copFunction(2,0x4a6012);

  uVar12 = getCopReg(2,0xc800);
  uVar15 = getCopReg(2,0xd000);
  uVar18 = getCopReg(2,0xd800);
  param_1[6] = (short)uVar12 + sVar1;
  param_1[7] = (short)uVar15 + sVar2;
  param_1[8] = (short)uVar18 + sVar3;
  return;
}


// TileView_FadeOneWindow
void FUN_80043928(int param_1)

{
  undefined2 uVar1;
  undefined uVar2;
  short sVar3;
  int iVar4;
  void *p;

  // if tileView->fadeFromBlack_currentValue
  // is not 0x1000, which means there must be
  // some amount of fading
  if (*(short *)(param_1 + 0x12) != 0x1000)
  {
	// if we are fading to black
    if (*(short *)(param_1 + 0x12) < 0x1001)
	{
	  // backBuffer->primMem.curr
      p = *(void **)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80);

	  *(undefined *)((int)p + 3) = 7;
      *(undefined *)((int)p + 0xf) = 0x2a;

	  // fade to black
	  *(undefined4 *)((int)p + 4) = 0xe1000a40;

      *(undefined4 *)((int)p + 8) = 0;
      sVar3 = *(short *)(param_1 + 0x12);
      *(undefined2 *)((int)p + 0x10) = 0;
      *(undefined2 *)((int)p + 0x12) = 0;

	  // get strength of fade (0 to 0x1000)
      iVar4 = 0xfff - (int)sVar3;
    }
    else
	{
	  // backBuffer->primMem.curr
      p = *(void **)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80);

	  *(undefined *)((int)p + 3) = 7;
      *(undefined *)((int)p + 0xf) = 0x2a;

	  // fade to white
	  *(undefined4 *)((int)p + 4) = 0xe1000a20;

      *(undefined4 *)((int)p + 8) = 0;
      sVar3 = *(short *)(param_1 + 0x12);
      *(undefined2 *)((int)p + 0x10) = 0;
      *(undefined2 *)((int)p + 0x12) = 0;

	  // get strength of fade (0 to 0x1000)
      iVar4 = (int)sVar3 + -0x1000;
    }

	// strength of fade
    uVar2 = (undefined)(iVar4 >> 4);

	*(undefined *)((int)p + 0xe) = uVar2;
    *(undefined *)((int)p + 0xd) = uVar2;
    *(undefined *)((int)p + 0xc) = uVar2;
    uVar1 = *(undefined2 *)(param_1 + 0x20);
    *(undefined2 *)((int)p + 0x16) = 0;
    *(undefined2 *)((int)p + 0x18) = 0;
    *(undefined2 *)((int)p + 0x14) = uVar1;
    *(undefined2 *)((int)p + 0x1a) = *(undefined2 *)(param_1 + 0x22);
    *(undefined2 *)((int)p + 0x1c) = *(undefined2 *)(param_1 + 0x20);
    *(undefined2 *)((int)p + 0x1e) = *(undefined2 *)(param_1 + 0x22);
    AddPrim(*(void **)(param_1 + 0xf4),p);

	// backBuffer->primMem.curr
    // move pointer after writing polygons
    *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80) =
         *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80) + 0x20;
  }

  // alter the fade value by the fade velocity
  sVar3 = *(short *)(param_1 + 0x12) + *(short *)(param_1 + 0x16);

  // set new fade value (temporarily)
  *(short *)(param_1 + 0x12) = sVar3;

  // if fade velocity is negative
  if (*(short *)(param_1 + 0x16) < 1)
  {
	// if we go lower than the desired fade
    if (sVar3 < *(short *)(param_1 + 0x14))
	{
	  // set to desired fade
      *(undefined2 *)(param_1 + 0x12) = *(undefined2 *)(param_1 + 0x14);
    }
  }

  // if fade velocity is positive
  else
  {
	// if we go higher than the desired fade value
    if (*(short *)(param_1 + 0x14) < sVar3)
	{
	  // set to desired fade value
      *(undefined2 *)(param_1 + 0x12) = *(undefined2 *)(param_1 + 0x14);
    }
  }
  return;
}


// TileView_FadeAllWindows
void FUN_80043ab8(void)

{
  int iVar1;
  int iVar2;

  // loop counter
  iVar1 = 0;

  // if numPlyrCurrGame is not zero
  if (PTR_DAT_8008d2ac[0x1ca8] != '\0')
  {
	// offset of 8008d2ac for tileView buffers
    iVar2 = 0x168;

	// for(int iVar1 = 0; iVar1 < numPlyrCurrGame; iVar1++)
    do
	{
      // add fade quad for current camera

	  // TileView_FadeOneWindow
	  // pointer to tileView buffer
      FUN_80043928(PTR_DAT_8008d2ac + iVar2);

	  // increment loop counter
      iVar1 = iVar1 + 1;

	  // increment offset to next tileView buffer
      iVar2 = iVar2 + 0x110;

						// numPlyrCurrGame
    } while (iVar1 < (int)(uint)(byte)PTR_DAT_8008d2ac[0x1ca8]);
  }

  // TileView_FadeOneWindow
  // add quad for UI camera
  FUN_80043928(PTR_DAT_8008d2ac + 5000);
  return;
}


// TitleBeginTrack_MenuFuncPtr
void FUN_80043b30(undefined4 param_1)

{
  undefined *puVar1;
  uint uVar2;

  // If you're in Time Trial
  if ((*(uint *)PTR_DAT_8008d2ac & 0x20000) != 0)
  {
	// Set P3 to N Tropy
    DAT_80086e88 = 0xc;

	// Set P4 to N Oxide
    DAT_80086e8a = 0xf;
  }

  // If you're in Adventure Mode
  if ((*(uint *)PTR_DAT_8008d2ac & 0x80000) != 0) {

	// Change mode to Adventure Arena
    *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac | 0x100000;
  }

  puVar1 = PTR_DAT_8008d2ac;

  // If you're not in Battle Mode
  if ((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0)
  {
    *(undefined4 *)(PTR_DAT_8008d2ac + 0x1d84) = 0x2a300;

	// Turn off 0x10000: Time limit (battle)
	// Turn off 0x4000: Point limit (battle)
	// Turn off 0x8000 Life limit (battle)
    uVar2 = *(uint *)PTR_DAT_8008d2ac;
    *(uint *)puVar1 = uVar2 & 0xfffe3fff;
  }

  // Load LEV in Track Selection
  FUN_8003cfc0((int)*(short *)(PTR_DAT_8008d2ac + 0x1eb0));

  // make MenuBox invisible
  FUN_800469c8(param_1);
  return;
}


// TitleBeginTrack_Get_MenuBox
undefined * FUN_80043c04(void)

{
  return &DAT_80085a94;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// Restore a backup of game options,
// this is stored between GameProgress and AdventureProgress
void FUN_80043c10(void)

{
  int iVar1;

  if (DAT_8008d8f0 == 0) {
    DAT_8008d8f0 = 1;
    iVar1 = 0;

	// loop 3 times (fx, music, voice)
	do {
      howl_VolumeSet((int)(short)iVar1,(uint)(byte)(&DAT_8008fb7c)[(int)(short)iVar1 * 2]);
      iVar1 = iVar1 + 1;
      DAT_800841fc = DAT_8008fb82;
      _DAT_80084200 = DAT_8008fb86;
      DAT_80084204 = DAT_8008fb8a;
      DAT_80084208 = DAT_8008fb8e;
      DAT_8008420c = DAT_8008fb92;
      DAT_80084210 = DAT_8008fb96;
    } while (iVar1 * 0x10000 >> 0x10 < 3);

    *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac | DAT_8008fb9c & 0xf00;

	// howl_ModeSet
	FUN_8002b1fc((uint)DAT_8008fba0 & 1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// make a backup of game options,
// this is stored between GameProgress and AdventureProgress
void FUN_80043d24(void)

{
  ushort uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;

  // loop counter
  iVar4 = 0;

  // pointer counter
  iVar3 = 0;

  do
  {
	// get value for each type of volume and clamp to 0x100
    uVar1 = howl_VolumeGet(iVar3 >> 0x10);

	// store a backup of volume
	*(ushort *)(&DAT_8008fb7c + (iVar3 >> 0x10) * 2) = uVar1 & 0xff;

	// loop counter
    iVar4 = iVar4 + 1;

	// pointer counter
    iVar3 = iVar4 * 0x10000;

  } while (iVar4 * 0x10000 >> 0x10 < 3);

  DAT_8008fb82 = DAT_800841fc;
  DAT_8008fb86 = _DAT_80084200;
  DAT_8008fb8a = DAT_80084204;
  DAT_8008fb8e = DAT_80084208;
  DAT_8008fb92 = DAT_8008420c;
  DAT_8008fb96 = DAT_80084210;
  DAT_8008fb9c = *(uint *)PTR_DAT_8008d2ac & 0xf00;

  // howl_ModeGet
  uVar2 = FUN_8002b1f0();

  // store a saftery-copy of mode?
  DAT_8008fba0 = (ushort)((uVar2 & 0xff) != 0);
  return;
}


// TitleFlag_MoveModels
// param_1 - frame index
// param_2 - numFrames in transition
int FUN_80043e34(int param_1,int param_2)
{
  // need a better prefix than TitleFlag,
  // all this does is move the intro logo models
  // from the center of the screen, to the right

  // also used for transitioning driver models
  // on and off the screen in character selection

  int iVar1;
  int iVar2;

  // 0x0000 - start of transition
  iVar1 = 0;
  if (
		// index >= 0
		(-1 < param_1) &&

		(
			// 0x1000 - end of transition
			iVar1 = 0x1000,

			// frameIndex is between start and ennd
			param_1 <= param_2
		)
	 )
  {
	// iVar1 = param_2 / 2,
	// stupid over-complicated way of cutting in half
    iVar1 = (param_2 - (param_2 >> 0x1f)) * 0x8000 >> 0x10;

	// if less than half done
    if (param_1 < iVar1)
	{
	  // (half - index) * 0x400
      iVar2 = (iVar1 - param_1) * 0x400;

      if (iVar1 == 0) {
        trap(0x1c00);
      }
      if ((iVar1 == -1) && (iVar2 == -0x80000000)) {
        trap(0x1800);
      }

	  // Sine(angle)
	  iVar1 = FUN_8003d184(iVar2 / iVar1);

	  // 50% - sin(angle/2)
      iVar1 = 0x800 - iVar1 / 2;
    }

	// if more than half done
    else
	{
	  // (index - half) * 0x400
      iVar2 = (param_1 - iVar1) * 0x400;

      if (iVar1 == 0) {
        trap(0x1c00);
      }
      if ((iVar1 == -1) && (iVar2 == -0x80000000)) {
        trap(0x1800);
      }

	  // Sine(angle)
	  iVar1 = FUN_8003d184(iVar2 / iVar1);

	  // sin(angle/2) + 50%
      iVar1 = iVar1 / 2 + 0x800;
    }
  }
  return iVar1;
}

// TitleFlag_IsFullyOnScreen
uint FUN_80043f1c(void)

{

  // TitleFlag_Position
  // return true if flag is fully on screen
  // return false if flag is not fully on screen
  return (uint)(DAT_8008d444 == 0);
}


// TitleFlag_IsFullyOffScreen
uint FUN_80043f28(void)

{

  // TitleFlag_Position
  // return false, "not true", if flag is < 5000, partially on-screen
  // return true, "not false", if flag is >= 5000, fully off-screen
  return (uint)((ushort)(DAT_8008d444 + 4999U) < 9999) ^ 1;
}


// TitleFlag_IsTransitioning
uint FUN_80043f44(void)

{
  uint uVar1;

  // by default, assume false
  uVar1 = 0;

  // TitleFlag_Position
  // if checkered flag is not fully on-screen and not fully off-screen
  if (((DAT_8008d444 != 0) && (DAT_8008d444 != -5000)) && (DAT_8008d444 != 5000))
  {
	// this is true if the loading screen is being drawn, false if it is not
    uVar1 = (uint)((*(uint *)(PTR_DAT_8008d2ac + 0x256c) & 0x1000) != 0);
  }
  return uVar1;
}



// TitleFlag_SetDrawOrder
void FUN_80043f8c(int param_1)

{
  if (param_1 != 0) {

    // TitleFlag_DrawOrder = 1
    DAT_8008d44c = 1;
    return;
  }

  // TitleFlag_DrawOrder = -1
  DAT_8008d44c = 0xffff;
  return;
}


// TitleFlag_BeginTransition
void FUN_80043fb0(int param_1)

{
  // Begin Transition on-screen
  if (param_1 == 1) {

    // TitleFlag_LoadingTextAnimFrame = -1
    DAT_8008d450 = 0xffffffff;

    // TitleFlag_Position = 5000
    DAT_8008d444 = 5000;

    // TitleFlag_AnimationType = 0
    DAT_8008d440 = 0;
  }

  // Begin Transition off-screen
  else {
    if (param_1 == 2) {
      FUN_80043f8c(0);

      // TitleFlag_Position = 0
      DAT_8008d444 = 0;

      // TitleFlag_AnimationType = 2
      DAT_8008d440 = param_1;
    }
  }

  // enable loading screen's checkered flag
  *(uint *)(PTR_DAT_8008d2ac + 0x256c) = *(uint *)(PTR_DAT_8008d2ac + 0x256c) | 0x1000;
  return;
}


// TitleFlag_SetFullyOnScreen
void FUN_8004402c(void)

{
  // flag is now fully on-screen
  DAT_8008d444 = 0;

  // TitleFlag_AnimationType = 0
  DAT_8008d440 = 0;

  // TitleFlag_LoadingTextAnimFrame = -1
  DAT_8008d450 = 0xffffffff;

  // enable loading screen's checkered flag
  *(uint *)(PTR_DAT_8008d2ac + 0x256c) = *(uint *)(PTR_DAT_8008d2ac + 0x256c) | 0x1000;
  return;
}


// TitleFlag_SetFullyOffScreen
void FUN_80044058(void)

{
  // TitleFlag_LoadingTextAnimFrame = -1
  DAT_8008d450 = 0xffffffff;

  // TitleFlag_Position
  // flag is now fully off-screen
  DAT_8008d444 = 5000;

  // TitleFlag_AnimationType = 0
  DAT_8008d440 = 0;

  // disable loading screen's checkered flag
  *(uint *)(PTR_DAT_8008d2ac + 0x256c) = *(uint *)(PTR_DAT_8008d2ac + 0x256c) & 0xffffefff;
  return;
}

// TitleFlag_SetCanDraw
void FUN_80044088(undefined2 param_1)

{
  DAT_8008d448 = param_1;

  return;
}


// TitleFlag_GetCanDraw
int FUN_80044094(void)

{
  return (int)DAT_8008d448;
}


// TitleFlag_GetOT
int FUN_800440a0(void)
{
  // In Naughty Dog's code, this could have
  // been split in 2 functions, but compiler
  // optimized it into one, or maybe ND just
  // threw it into one anyway

  short sVar1;
  int iVar2;

  if (DAT_8008d44a == 0) {
    DAT_8008d44a = 1;
  }

  // if TitleFlag_AnimationType != 1
  if (DAT_8008d440 != 1) {

    // if TitleFlag_AnimationType == 0
    if (DAT_8008d440 == 0) {

      // if TitleFlag_Position < 0
      if ((short)DAT_8008d444 < 0) {

        // TitleFlag_Position = 5000
        DAT_8008d444 = 5000;
      }
      DAT_8008d446 = 300;

      // iVar2 = (TitleFlag_Position << 0x10) >> 0x10
      iVar2 = (int)((uint)DAT_8008d444 << 0x10) >> 0x10;
      if (iVar2 < 1) {

        // TitleFlag_Position = 0
        DAT_8008d444 = 0;

        // if TitleFlag_DrawOrder != 1
        if (DAT_8008d44c != 1) {

          // if TitleFlag_DrawOrder != -1
          if (DAT_8008d44c != -1) {

            // TitleFlag_Position = 0
            DAT_8008d444 = 0;
            DAT_8008d446 = 300;

			// pointer to TileView[0]->OTMem (25c-168=0xf4)
			// last primitives drawn, front of sorting order
            return *(int *)(PTR_DAT_8008d2ac + 0x25c) + 0xffc;
          }

          // TitleFlag_DrawOrder = 0
          DAT_8008d44c = 0;
          goto LAB_80044268;
        }
      }
      else
	  {
		// if position is less than 8
        if (iVar2 < 8)
		{
		  // drop to zero

          // TitleFlag_Position = 0
          DAT_8008d444 = 0;
        }

		// if position is large
        else
		{
		  // decrease until position is near zero

		  // Take TitleFlag_Position, remove top 2 bytes, divide by 8		// elapsed milliseconds per frame, ~32
          iVar2 = ((int)((uint)DAT_8008d444 << 0x10) >> 0x13) * *(int *)(PTR_DAT_8008d2ac + 0x1d04)
                  >> 5;
          sVar1 = -(short)iVar2;
          if (iVar2 < 1) {
            sVar1 = -1;
          }

          // TitleFlag_Position += sVar1
          DAT_8008d444 = DAT_8008d444 + sVar1;
        }
      }
      DAT_8008d446 = 300;


	  // OTMem depending on swapchain index
	  // first primitives drawn, back of draw sorting
      return *(undefined4 *)(PTR_DAT_8008d2ac + *(int *)(PTR_DAT_8008d2ac + 0xc) * 4 + 0x18c8);
    }

    // if TitleFlag_AnimationType == 2
    if (DAT_8008d440 == 2)
	{
      if ((short)DAT_8008d446 < 1000)
	  {
		// increase until 1000
										// elapsed milliseconds per frame, ~32
        DAT_8008d446 = DAT_8008d446 + (short)(*(int *)(PTR_DAT_8008d2ac + 0x1d04) * 10 >> 5);
      }

      // if TitleFlag_Position < -4999
      if ((short)DAT_8008d444 < -4999) {

        // TitleFlag_Position = 5000
        DAT_8008d444 = 5000;

        // TitleFlag_AnimationType = 0
        DAT_8008d440 = 0;

		// disable loading screen
        *(uint *)(PTR_DAT_8008d2ac + 0x256c) = *(uint *)(PTR_DAT_8008d2ac + 0x256c) & 0xffffefff;
      }

	  // If not -5000 yet
      else
	  {
		// decrease until -5000

        // TitleFlag_Position -= ???
        DAT_8008d444 = DAT_8008d444 -
                       (short)(((int)((uint)DAT_8008d446 << 0x10) >> 0x12) *

								// elapsed milliseconds per frame, ~32
                               *(int *)(PTR_DAT_8008d2ac + 0x1d04) >> 5);
      }
    }
  }
LAB_80044268:
  // OTMem depending on swapchain index
  // first primitives drawn, back of draw sorting
  return *(undefined4 *)(PTR_DAT_8008d2ac + *(int *)(PTR_DAT_8008d2ac + 0xc) * 4 + 0x18c8);
}


// TitleFlag_ResetTextAnim
void FUN_80044290(void)

{

  // TitleFlag_LoadingTextAnimFrame = -1
  DAT_8008d450 = 0xffffffff;

  return;
}


// TitleFlag_DrawLoadingString
void FUN_800442a0(void)

{
  undefined *puVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  undefined4 uVar5;
  int iVar6;
  byte *pbVar7;
  byte *pbVar8;
  int iVar9;
  int iVar10;
  undefined4 uVar11;
  byte local_30;
  byte local_2f;

  iVar2 = DAT_8008d878;

  // pointer to OT mem
  uVar11 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c);

  // pointer to OT mem
  *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c) =
       *(undefined4 *)(PTR_DAT_8008d2ac + *(int *)(PTR_DAT_8008d2ac + 0xc) * 4 + 0x18c8);

  // iVar2 + 0x8c4
  // LOADING...
  pbVar7 = *(byte **)(iVar2 + 0x8c4);

  // get length of "LOADING..." string
  iVar2 = strlen();

  // DecalFont_GetLineWidth
  iVar3 = FUN_800224d0(pbVar7,1);

  // loop counter
  iVar6 = 0;

  // if game is not loading
  if (DAT_8008d0f8 == -1) {
    if (-1000 < (int)DAT_8008d454) {
      DAT_8008d454 = DAT_8008d454 - 0x28;
    }
  }
  else {
    DAT_8008d454 = 0;
  }
  iVar10 = (DAT_8008d454 & 0xffff) - (((iVar3 << 0x10) >> 0x10) - ((iVar3 << 0x10) >> 0x1f) >> 1);

  // iVar3 = TitleFlag_LoadingTextAnimFrame
  iVar3 = DAT_8008d450;

  if (0 < iVar2) {

    // iVar9 = TitleFlag_LoadingTextAnimFrame * -0x3C + 0x23C
    iVar9 = DAT_8008d450 * -0x3c + 0x23c;

	// for iVar6 = 0; iVar6 < strlen("LOADING..."); iVar6++)
	do {
      if (iVar3 < 0) {
LAB_800443c4:

		// draw text off screen
        iVar4 = 0x23c;
      }
      else {
        iVar4 = iVar9;
        if (
				// if frame > 4,
				// if text starts moving on-screen?
				(4 < iVar3) &&
				(
					// draw letter at midpoint of screen
					iVar4 = 0x100,

					// if frame > 0x4a,
					// if text starts moving off-screen?
					0x4a < iVar3
				)
			)
		{
		  // if frame > 0x4f,
		  // if letter is fully off-screen
          if (0x4f < iVar3) goto LAB_800443c4;

		  // letter is moving off-screen
		  iVar4 = (0x4b - iVar3) * 0x3c + 0x100;
        }
      }
      local_30 = *pbVar7;
      pbVar8 = pbVar7 + 1;
      uVar5 = 1;
      if (local_30 < 4) {
        local_2f = *pbVar8;
        pbVar8 = pbVar7 + 2;

		// increment loop counter
        iVar6 = iVar6 + 1;

        uVar5 = 2;
      }
      if ((short)iVar4 != 0x23c)
	  {
		// DecalFont_DrawLineStrlen
        FUN_800224fc(&local_30,uVar5,(iVar10 + iVar4) * 0x10000 >> 0x10,0x6c,1,0);
      }

	  // DecalFont_GetLineWidthStrlen
      iVar4 = FUN_800223f4(&local_30,uVar5,1);

      iVar10 = iVar10 + iVar4;
      iVar9 = iVar9 + 0xf0;

	  // increment loop counter
      iVar6 = iVar6 + 1;

	  // treat all letters with 4 frame difference
      iVar3 = iVar3 + -4;

      pbVar7 = pbVar8;
    } while (iVar6 < iVar2);
  }
  puVar1 = PTR_DAT_8008d2ac;

  // pointer to OT mem
  *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c) = uVar11;

  if (iVar3 < 0x50)
  {
    iVar2 = *(int *)(puVar1 + 0x1d04) >> 5;

	if (iVar2 < 1) {
      iVar2 = 1;
    }

    // TitleFlag_LoadingTextAnimFrame += iVar2
    DAT_8008d450 = DAT_8008d450 + iVar2;
  }

  else {

    // TitleFlag_LoadingTextAnimFrame = -1
    DAT_8008d450 = -1;
    if (DAT_8008d0f8 - 6U < 2) {

      // TitleFlag_LoadingTextAnimFrame = 0
      DAT_8008d450 = 0;
    }
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

// TitleFlag_DrawSelf
void FUN_800444e8(void)

{
  bool bVar1;
  short sVar2;
  uint *puVar3;
  undefined uVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  SVECTOR *pSVar9;
  int iVar10;
  uint *puVar11;
  uint uVar12;
  int iVar13;
  uint uVar14;
  SVECTOR *r0;
  int iVar15;
  uint uVar16;
  uint uVar17;
  uint *puVar18;
  long *r0_00;
  uint *puVar19;
  undefined *puVar20;
  uint *puVar21;
  int iVar22;
  uint uVar23;
  undefined *puVar24;
  undefined *puVar25;
  int iVar26;
  undefined auStack136 [96];
  
  puVar24 = &DAT_8008cf6c;
  puVar25 = auStack136;
  
  // if TitleFlag_CanDraw == false
  if (DAT_8008d448 == 0) 
  {
	// don't draw
    return;
  }
  
  // if TitleFlag_LoadingTextAnimFrame < 0
  if (DAT_8008d450 < 0) 
  {
	// if loading stage is 6 or 7,
	// during the level loading
    if ((5 < DAT_8008d0f8) && (DAT_8008d0f8 < 8)) {
		
	  // TitleFlag_LoadingTextAnimFrame = 0
      DAT_8008d450 = 0;
    }
	
	// if TitleFlag_LoadingTextAnimFrame < 0 goto ???
    if (DAT_8008d450 < 0) goto LAB_80044568;
  }
  
  // TitleFlag_DrawLoadingString
  FUN_800442a0();
  
LAB_80044568:
  DAT_8009d45c = DAT_8008d0f8;
  
  // get ptr OTMem
  puVar3 = (uint *)FUN_800440a0();
  
  gte_SetRotMatrix((MATRIX *)0x80085ac0);
  gte_SetTransMatrix((MATRIX *)0x80085ac0);
  gte_SetGeomOffset(0x100,0x78);
  gte_ldH(0x100);
  
  // elapsed milliseconds per frame, ~32
  iVar26 = DAT_80085aec * *(int *)(PTR_DAT_8008d2ac + 0x1d04);
  
  puVar18 = (uint *)0x0;
  r0_00 = &DAT_1f800000;
  uVar23 = 1;
  
  // some kind of elapsed time in TitleFlag,
  // 8008d458
  uVar16 = *(int *)(puVar24 + 0x4ec) >> 5;
  *(uint *)(puVar25 + 0x4c) = uVar16;

  DAT_80085af0 = DAT_80085af0 + iVar26;
  uVar14 = (int)DAT_80085af0 >> 5;
  
  // if more than 360 degrees (0xfff)
  if (0xfff < uVar14) 
  {
    DAT_80085af0 = DAT_80085af0 & 0x1ffff;
    uVar14 = (int)DAT_80085af0 >> 5;
    DAT_80085ae0 = DAT_80085ae0 + 0x200;
	
	// approximate trigonometry
    iVar26 = *(int *)(&DAT_800845a0 + (DAT_80085ae0 & 0x3ff) * 4);
	
    if ((DAT_80085ae0 & 0x400) == 0) {
      iVar26 = iVar26 << 0x10;
    }
    iVar26 = iVar26 >> 0x10;
    if ((DAT_80085ae0 & 0x800) != 0) {
      iVar26 = -iVar26;
    }
    
	DAT_80085ae4 = ((iVar26 + 0xfff) * 0x20 >> 0xd) + 0x96;
    DAT_80085ae8 = DAT_80085ae8 + 200;
    
	// approximate trigonometry
	iVar26 = *(int *)(&DAT_800845a0 + (DAT_80085ae8 & 0x3ff) * 4);
	
    if ((DAT_80085ae8 & 0x400) == 0) {
      iVar26 = iVar26 << 0x10;
    }
    iVar26 = iVar26 >> 0x10;
    if ((DAT_80085ae8 & 0x800) != 0) {
      iVar26 = -iVar26;
    }
    DAT_80085aec = ((iVar26 + 0xfff) * 0x40 >> 0xd) + 0xb4;
  }
  
  // approximate trigonometry
  iVar26 = *(int *)(&DAT_800845a0 + (uVar14 & 0x3ff) * 4);
  
  if ((uVar14 & 0x400) == 0) {
    iVar26 = iVar26 << 0x10;
  }
  iVar26 = iVar26 >> 0x10;
  if ((uVar14 & 0x800) != 0) {
    iVar26 = -iVar26;
  }
  uVar14 = uVar14 + 0xc80;
  
  // approximate trigonometry
  iVar5 = *(int *)(&DAT_800845a0 + (uVar14 & 0x3ff) * 4);
  
  if ((uVar14 & 0x400) == 0) {
    iVar5 = iVar5 << 0x10;
  }
  iVar5 = iVar5 >> 0x10;
  if ((uVar14 & 0x800) != 0) {
    iVar5 = -iVar5;
  }
  
  // loop counter
  iVar22 = 0;
  
  puVar20 = &DAT_800845a0;
  r0 = (SVECTOR *)(puVar25 + 0x10);
  *(int *)(puVar25 + 0x48) = iVar5 + 0xfff;
  iVar26 = (iVar26 + 0xfff) * DAT_80085ae4;
  *(undefined2 *)(puVar25 + 0x12) = 0xfc72;
  
  // 8008d444
  // TitleFlag_Position
  sVar2 = *(short *)(puVar24 + 0x4d8);
  
  *(undefined2 *)(puVar25 + 0x1a) = 0xfcd0;
  *(undefined2 *)(puVar25 + 0x22) = 0xfd2e;
  
  // sVar3 = -0xBBE - TitleFlag_Position
  sVar2 = -0xbbe - sVar2;
  
  // flag position
  *(short *)(puVar25 + 0x10) = sVar2;
  *(short *)(puVar25 + 0x18) = sVar2;
  *(short *)(puVar25 + 0x20) = sVar2;
  
  iVar26 = (iVar26 >> 0xd) + 0x280;
  
  // for iVar22 = 0; iVar22 < 10; iVar22++
  do 
  {
	// loop counter
    iVar5 = 0;
	
    pSVar9 = r0;
	
	// for iVar5 = 0; iVar5 < 3; iVar5++
    do {
      iVar6 = *(int *)(puVar20 + (uVar16 & 0x3ff) * 4);
      if ((uVar16 & 0x400) == 0) {
        iVar6 = iVar6 << 0x10;
      }
      iVar6 = iVar6 >> 0x10;
      if ((uVar16 & 0x800) != 0) {
        iVar6 = -iVar6;
      }
      pSVar9->vz = (short)iVar26 + (short)((iVar6 + 0xfff) * 0x20 >> 0xd);
      uVar16 = uVar16 + 300;
      
	  // increment loop counter
	  iVar5 = iVar5 + 1;
	  
      pSVar9 = pSVar9 + 1;
    } while (iVar5 < 3);
	
    gte_ldv3(r0,(SVECTOR *)(puVar25 + 0x18),(SVECTOR *)(puVar25 + 0x20));
    gte_rtpt();
	
    *(short *)(puVar25 + 0x12) = *(short *)(puVar25 + 0x12) + 0x11a;
    *(short *)(puVar25 + 0x22) = *(short *)(puVar25 + 0x22) + 0x11a;
    *(short *)(puVar25 + 0x1a) = *(short *)(puVar25 + 0x1a) + 0x11a;
	
    gte_stsxy3(r0_00,r0_00 + 1,r0_00 + 2);
	
	// increment loop counter
    iVar22 = iVar22 + 1;
	
    r0_00 = r0_00 + 3;
	
  } while (iVar22 < 10);
  
  iVar5 = 1;
  puVar20 = &DAT_800845a0;
  uVar14 = 0x80008000;
  iVar22 = *(int *)(puVar25 + 0x48);
  *(undefined **)(puVar25 + 0x50) = puVar25 + 0x48;
  *(undefined **)(puVar25 + 0x5c) = puVar25 + 0x10;
  
  // screen dimensions
  iVar26 = 0xd80200;
  
  *(uint *)(puVar25 + 0x28) = DAT_80085ae0;
  *(int *)(puVar25 + 0x2c) = DAT_80085ae4;
  *(uint *)(puVar25 + 0x30) = DAT_80085ae8; // angle of wave effect
  *(int *)(puVar25 + 0x34) = DAT_80085aec; // set zero makes all light dark
  *(uint *)(puVar25 + 0x38) = DAT_80085af0; // set zero makes all light bright
  
  // vertical strips
  do 
  {
    puVar19 = (uint *)(uVar23 * 0x78 + 0x1f7ffffc);
    uVar23 = uVar23 ^ 1;
    puVar21 = (uint *)(uVar23 * 0x78 + 0x1f800000);
    uVar17 = *(int *)(puVar25 + 0x4c) + 0x100;
    uVar16 = *(int *)(puVar25 + 0x38) + *(int *)(puVar25 + 0x34) * 0x40;
    uVar12 = (int)uVar16 >> 5;
    *(uint *)(puVar25 + 0x4c) = uVar17;
    *(uint *)(puVar25 + 0x38) = uVar16;
	
    if (0xfff < uVar12) 
	{
      uVar12 = (int)(uVar16 & 0x1ffff) >> 5;
      *(uint *)(puVar25 + 0x38) = uVar16 & 0x1ffff;
	  
	  // increment 0x200
      uVar16 = *(int *)(puVar25 + 0x28) + 0x200;
      *(uint *)(puVar25 + 0x28) = uVar16;
	  
	  // approximate trigonometry
      iVar6 = *(int *)(puVar20 + (uVar16 & 0x3ff) * 4);
      
	  if ((uVar16 & 0x400) == 0) {
        iVar6 = iVar6 << 0x10;
      }
      iVar6 = iVar6 >> 0x10;
      if ((uVar16 & 0x800) != 0) {
        iVar6 = -iVar6;
      }
      *(int *)(puVar25 + 0x2c) = ((iVar6 + 0xfff) * 0x20 >> 0xd) + 0x96;
      uVar16 = *(int *)(puVar25 + 0x30) + 200;
      *(uint *)(puVar25 + 0x30) = uVar16;
	  
	  // approximate trigonometry
      iVar6 = *(int *)(puVar20 + (uVar16 & 0x3ff) * 4);
      
	  if ((uVar16 & 0x400) == 0) {
        iVar6 = iVar6 << 0x10;
      }
      iVar6 = iVar6 >> 0x10;
      if ((uVar16 & 0x800) != 0) {
        iVar6 = -iVar6;
      }
      *(int *)(puVar25 + 0x34) = ((iVar6 + 0xfff) * 0x40 >> 0xd) + 0xb4;
    }
	
	// approximate trigonometry
    iVar6 = *(int *)(puVar20 + (uVar12 & 0x3ff) * 4);
	
    if ((uVar12 & 0x400) == 0) {
      iVar6 = iVar6 << 0x10;
    }
    iVar6 = iVar6 >> 0x10;
    if ((uVar12 & 0x800) != 0) {
      iVar6 = -iVar6;
    }
    uVar12 = uVar12 + 0xc80;
	
	// approximate trigonometry
    iVar7 = *(int *)(puVar20 + (uVar12 & 0x3ff) * 4);
	
    if ((uVar12 & 0x400) == 0) {
      iVar7 = iVar7 << 0x10;
    }
    iVar7 = iVar7 >> 0x10;
    if ((uVar12 & 0x800) != 0) {
      iVar7 = -iVar7;
    }
	
	// loop counter
    iVar13 = 0;
	
    iVar15 = *(int *)(puVar25 + 0x5c);
    **(int **)(puVar25 + 0x50) = iVar7 + 0xfff;
    *(undefined2 *)(puVar25 + 0x12) = 0xfc72;
    *(undefined2 *)(puVar25 + 0x1a) = 0xfcd0;
    *(undefined2 *)(puVar25 + 0x22) = 0xfd2e;
	
	// move to next position to draw
    *(short *)(puVar25 + 0x10) = *(short *)(puVar25 + 0x10) + 100;
    *(short *)(puVar25 + 0x18) = *(short *)(puVar25 + 0x18) + 100;
    *(short *)(puVar25 + 0x20) = *(short *)(puVar25 + 0x20) + 100;
    
	iVar6 = ((iVar6 + 0xfff) * *(int *)(puVar25 + 0x2c) >> 0xd) + 0x280;
	
	// for iVar13 = 0; iVar13 < 3; iVar3++
    do 
	{
	  // approximate trigonometry
      iVar7 = *(int *)(puVar20 + (uVar17 & 0x3ff) * 4);
	  
      if ((uVar17 & 0x400) == 0) {
        iVar7 = iVar7 << 0x10;
      }
      iVar7 = iVar7 >> 0x10;
      if ((uVar17 & 0x800) != 0) {
        iVar7 = -iVar7;
      }
      *(short *)(iVar15 + 4) = (short)iVar6 + (short)((iVar7 + 0xfff) * 0x20 >> 0xd);
      uVar17 = uVar17 + 300;
	  
	  // increment loop counter
      iVar13 = iVar13 + 1;
	  
      iVar15 = iVar15 + 8;
    } while (iVar13 < 3);
    
	gte_ldv3(*(SVECTOR **)(puVar25 + 0x5c),(SVECTOR *)(puVar25 + 0x18),(SVECTOR *)(puVar25 + 0x20));
    gte_rtpt();
	
    iVar13 = 0;
    iVar7 = 1;
	
	// horizontal strips
    do 
	{
      if (iVar7 < 0xb) 
	  {
        
		gte_stsxy3((long *)(puVar19 + 1),(long *)(puVar19 + 2),(long *)(puVar19 + 3));
        
		iVar15 = 0;
        
		if (iVar7 < 10) {
          iVar10 = *(int *)(puVar25 + 0x5c);
		  
		  // for iVar15 = 0; iVar15 < 3; iVar15++
          do 
		  {
			// approximate trigonometry
            iVar8 = *(int *)(puVar20 + (uVar17 & 0x3ff) * 4);
			
            if ((uVar17 & 0x400) == 0) {
              iVar8 = iVar8 << 0x10;
            }
            iVar8 = iVar8 >> 0x10;
            if ((uVar17 & 0x800) != 0) {
              iVar8 = -iVar8;
            }
            *(short *)(iVar10 + 4) = (short)iVar6 + (short)((iVar8 + 0xfff) * 0x20 >> 0xd);
            uVar17 = uVar17 + 300;
			
			// increment loop counter
            iVar15 = iVar15 + 1;
			
            iVar10 = iVar10 + 8;
          } while (iVar15 < 3);
          
		  *(short *)(puVar25 + 0x12) = *(short *)(puVar25 + 0x12) + 0x11a;
          *(short *)(puVar25 + 0x22) = *(short *)(puVar25 + 0x22) + 0x11a;
          *(short *)(puVar25 + 0x1a) = *(short *)(puVar25 + 0x1a) + 0x11a;
          gte_ldv3(*(SVECTOR **)(puVar25 + 0x5c),(SVECTOR *)(puVar25 + 0x18),
                   (SVECTOR *)(puVar25 + 0x20));
          gte_rtpt();
        }
      }
      if (iVar13 == 0) {
        puVar19 = puVar19 + 1;
      }
      uVar16 = (uint)(iVar13 == 0);
	  
	  // color of black tile
      *(int *)(puVar25 + 0x58) = iVar22 * 0x69 + (0x2000 - iVar22) * 0xa0 >> 0xd;
      
	  // loop 3 times
	  do 
	  {
        if (((*puVar21 & puVar21[1] & uVar14 & uVar14 & *puVar19 & uVar14 & puVar19[1]) == 0) &&
           ((iVar26 - *puVar21 & iVar26 - puVar21[1] & uVar14 & uVar14 & iVar26 - *puVar19 & uVar14
            & iVar26 - puVar19[1]) == 0)) 
		{
		  // gGT->backBuffer
          iVar15 = *(int *)(PTR_DAT_8008d2ac + 0x10);
		  
		  // gGT->backBuffer.primMem.curr
          puVar11 = *(uint **)(iVar15 + 0x80);
		  
		  // if room is remaining
          if (puVar11 <= *(uint **)(iVar15 + 0x84)) 
		  {
			// POLY_G4 ???
			// increment primMem.curr by 0x24 bytes
            *(uint **)(iVar15 + 0x80) = puVar11 + 9;
            puVar18 = puVar11;
          }
          if (puVar18 == (uint *)0x0) {
            return;
          }
          
		  // white tile
		  if (((iVar5 >> 2) + (iVar13 >> 2) & 1U) == 0) 
		  {
			// RGB 1 and 3
            puVar25[0x40] = (char)(iVar22 * 0x82 + (0x2000 - iVar22) * 0xff >> 0xd);
			
			// RGB 0 and 2
            uVar4 = (undefined)(*(int *)(puVar25 + 0x48) * -0x7d + 0x1fe000 >> 0xd);
          }
		  
		  // black tile
          else 
		  {
			// RGB 1 and 3
            uVar4 = (undefined)(*(int *)(puVar25 + 0x48) * -0x37 + 0x140000 >> 0xd);
			
			// RGB 0 and 2
			// color black = iVar22 * 0x69 + (0x2000 - iVar22) * 0xa0 >> 0xd;
            puVar25[0x40] = puVar25[0x58];
          }
		  
		  // RGB 0 and 2
          puVar25[0x41] = uVar4;
		  
		  // x0, y0
          puVar18[2] = *puVar21;
          
		  // x2, y2
		  puVar18[6] = puVar21[1];
		  
		  // x1, y1
          puVar18[4] = *puVar19;
		  
		  // x3, y3
          puVar18[8] = puVar19[1];
		  
		  // rgb0 and rgb2
          uVar12 = (uint)(byte)puVar25[0x40];
          uVar12 = uVar12 | uVar12 << 0x10 | uVar12 << 8;
          puVar18[1] = uVar12;
          puVar18[5] = uVar12;
		  
		  // rgb1 and rgb3
          uVar12 = (uint)(byte)puVar25[0x41];
          
		  // part of tag?
		  *(undefined *)((int)puVar18 + 3) = 8;
		  
		  // primID
          *(undefined *)((int)puVar18 + 7) = 0x38;
		  
		  // rgb1 and rgb3
          uVar12 = uVar12 | uVar12 << 0x10 | uVar12 << 8;
          puVar18[3] = uVar12;
		  puVar18[7] = uVar12;
		  
		  // tag
          *puVar18 = *puVar18 & 0xff000000 | *puVar3 & 0xffffff;
          *puVar3 = *puVar3 & 0xff000000 | (uint)puVar18 & 0xffffff;
        }
        puVar21 = puVar21 + 1;
        puVar19 = puVar19 + 1;
        uVar16 = uVar16 + 1;
        iVar13 = iVar13 + 1;
      } while ((int)uVar16 < 3);
	  
	  // count horizontal strips,
	  // stop at 10
      bVar1 = iVar7 < 10;
      iVar7 = iVar7 + 1;
	  
    } while (bVar1);
    
	iVar22 = *(int *)(puVar25 + 0x48);
	
	// count vertical strips
    iVar5 = iVar5 + 1;
    
	// stop vertical strips at 0x23 (35)
	if (0x22 < iVar5) 
	{	
		// 8008d458
		// some kind of elapsed time in TitleFlag
      *(int *)(puVar24 + 0x4ec) =
           *(int *)(puVar24 + 0x4ec) + *(int *)(PTR_DAT_8008d2ac + 0x1d04) * 100;
      return;
    }
	
  } while( true );
}


// MenuBox_DrawPolyGT4
void FUN_80044ef8(int param_1)

{
  // safety check for nullptr
  if (param_1 != 0)
  {
	// DecalHUD_DrawPolyGT4
    FUN_80023054();
  }

  return;
}


// MenuBox_DrawOuterRect_Edge
void FUN_80044f90(undefined4 param_1,undefined4 param_2,uint param_3,undefined4 param_4)
{
  if ((param_3 & 0x20) == 0)
  {
	// solid border

	// CTR_Box_DrawSolidBox
    FUN_80021894(
					param_1,
					param_2,
					param_4,

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);
  }
  else
  {
	// transparent border

	// CTR_Box_DrawClearBox
    FUN_8002177c(
					param_1,
					param_2,
					1,
					param_4,

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);
  }
  return;
}


// Make time string
undefined * FUN_80044ff8(int param_1)

{
  // param_1 keeps track of time in milliseconds

  // Here's how it works:
  // 32 is added to param_1 every frame,
  // 30 fps, so param_1 gets 960 added every second,
  // 60 seconds per minute, so param_1 gets 57600
  // added per minute, which is 0xe100 in hex

  // 32 is the number of milliseconds passed since
  // last frame, which is calculated here:
  // PTR_DAT_8008d2ac + 0x1d04

  // build a string
  sprintf(

		// where string will be stored
		&DAT_80099264,

		// Format
	    // Minute:Seconds:Milliseconds
		"%ld:%ld%ld:%ld%ld",

		// minutes
		param_1 / 0xe100,

		// seconds / 10
        param_1 / 0x2580 + (param_1 / 0xe100) * -6,

		// seconds
		param_1 / 0x3c0 + (param_1 / 0x2580) * -10,

		// milliseconds / 10
        ((param_1 / 6 + (param_1 >> 0x1f) >> 4) - (param_1 >> 0x1f)) + (param_1 / 0x3c0) * -10,

		// milliseconds
        ((param_1 * 100) / 0x3c0) % 10);

  // return the string
  return &DAT_80099264;
}


// MenuBox_DrawRwdBlueRect_Subset
void FUN_80045134(uint *param_1,uint *param_2,uint *param_3,int param_4)

{
  uint *puVar1;
  uint *puVar2;

  puVar1 = *(uint **)(param_4 + 0xc);
  puVar2 = (uint *)0x0;
  if (puVar1 <= *(uint **)(param_4 + 0x10)) {
    *(uint **)(param_4 + 0xc) = puVar1 + 9;
    puVar2 = puVar1;
  }
  if (puVar2 != (uint *)0x0) {
    puVar2[1] = *param_2 & 0xffffff | 0x38000000;
    puVar2[3] = param_2[1] & 0xffffff;
    puVar2[5] = param_2[2] & 0xffffff;
    puVar2[7] = param_2[3] & 0xffffff;
    puVar2[2] = *param_1;
    puVar2[4] = (int)(short)*(ushort *)param_1 + (int)(short)*(ushort *)(param_1 + 1) & 0xffffU |
                (int)(short)*(ushort *)((int)param_1 + 2) << 0x10;
    puVar2[6] = (uint)*(ushort *)param_1 |
                ((int)(short)*(ushort *)((int)param_1 + 2) +
                (int)(short)*(ushort *)((int)param_1 + 6)) * 0x10000;
    puVar2[8] = (int)(short)*(ushort *)param_1 + (int)(short)*(ushort *)(param_1 + 1) & 0xffffU |
                ((int)(short)*(ushort *)((int)param_1 + 2) +
                (int)(short)*(ushort *)((int)param_1 + 6)) * 0x10000;
    *puVar2 = *param_3 & 0xffffff | 0x8000000;
    *param_3 = (uint)puVar2 & 0xffffff;
  }
  return;
}


// MenuBox_DrawRwdBlueRect
// RaceWheelConfig + ArcadeDriverSelect
void FUN_80045254(undefined2 *param_1,int param_2,undefined4 param_3,undefined4 param_4)

{
  int iVar1;
  undefined4 *puVar2;
  int iVar3;
  undefined2 local_38;
  short local_36;
  undefined2 local_34;
  short local_32;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;

  local_38 = *param_1;
  local_34 = param_1[2];
  iVar3 = 0;
  if (*(char *)(param_2 + 3) != 'd') {
    iVar1 = 0;
    do {
      puVar2 = (undefined4 *)((iVar1 >> 0xe) + param_2);
      local_30 = *puVar2;
      local_28 = puVar2[1];
      local_36 = param_1[1] +
                 (short)((int)((uint)*(byte *)((int)puVar2 + 3) * (int)(short)param_1[3]) / 100);
      local_32 = ((param_1[1] +
                  (short)((int)((uint)*(byte *)((int)puVar2 + 7) * (int)(short)param_1[3]) / 100)) -
                 local_36) + 1;
      local_2c = local_30;
      local_24 = local_28;

	  // MenuBox_DrawRwdBlueRect_Subset
      FUN_80045134(&local_38,&local_30,param_3,param_4);

      iVar3 = iVar3 + 1;
      iVar1 = iVar3 * 0x10000;
    } while (*(char *)((iVar3 * 0x10000 >> 0xe) + param_2 + 3) != 'd');
  }
  return;
}


// MenuBox_DrawRwdTriangle
// (square gorard icon, not actual triangle)
void FUN_800453e8(undefined2 *param_1,undefined *param_2,void *param_3,int param_4)

{
  void *p;
  void *pvVar1;

  pvVar1 = *(void **)(param_4 + 0xc);
  p = (void *)0x0;
  if (pvVar1 <= *(void **)(param_4 + 0x10)) {
    *(int *)(param_4 + 0xc) = (int)pvVar1 + 0x24;
    p = pvVar1;
  }
  if (p != (void *)0x0) {
    
	// psyq macro setPolyG4
	*(undefined *)((int)p + 3) = 8;
    *(undefined *)((int)p + 7) = 0x38;
	
	// RGB
    *(undefined *)((int)p + 4) = *param_2;
    *(undefined *)((int)p + 5) = param_2[1];
    *(undefined *)((int)p + 6) = param_2[2];
	
	// rest of the primitive (four xy, four uv)
    *(undefined *)((int)p + 0xc) = param_2[4];
    *(undefined *)((int)p + 0xd) = param_2[5];
    *(undefined *)((int)p + 0xe) = param_2[6];
    *(undefined *)((int)p + 0x14) = *param_2;
    *(undefined *)((int)p + 0x15) = param_2[1];
    *(undefined *)((int)p + 0x16) = param_2[2];
    *(undefined *)((int)p + 0x1c) = param_2[8];
    *(undefined *)((int)p + 0x1d) = param_2[9];
    *(undefined *)((int)p + 0x1e) = param_2[10];
    *(undefined2 *)((int)p + 8) = *param_1;
    *(short *)((int)p + 10) = param_1[1] + -1;
    *(undefined2 *)((int)p + 0x10) = param_1[2];
    *(undefined2 *)((int)p + 0x12) = param_1[3];
    *(undefined2 *)((int)p + 0x18) = *param_1;
    *(undefined2 *)((int)p + 0x1a) = param_1[1];
    *(undefined2 *)((int)p + 0x20) = param_1[4];
    *(undefined2 *)((int)p + 0x22) = param_1[5];
	
    AddPrim(param_3,p);
  }
  return;
}


// Draw a 2D box made of four rectangles
// param1 is a pointer RECT
// param2 is x offset from edge
// param3 is y offset from edge
// MenuBox_DrawOuterRect_LowLevel
void FUN_80045534(short *param_1,short param_2,ushort param_3,undefined4 param_4,short param_5,
                 undefined4 param_6)

{
  int iVar1;
  short local_28;
  short local_26;
  short local_24;
  ushort local_22;

  // startX
  local_28 = *param_1;

  iVar1 = (int)param_5;

  // startY
  local_26 = param_1[1];

  // sizeX
  local_24 = param_1[2];

  // y offset from edge
  local_22 = param_3;

  // Draw rectangle 1
  // MenuBox_DrawOuterRect_Edge
  FUN_80044f90(&local_28,param_4,iVar1,param_6);

  // 					sizeY - y offset from edge
  local_26 = local_26 + (param_1[3] - param_3);

  // Draw rectangle 2
  // MenuBox_DrawOuterRect_Edge
  FUN_80044f90(&local_28,param_4,iVar1,param_6);

  // startY + y offset from edge
  local_26 = param_1[1] + param_3;

  local_22 = param_1[3] - (short)((int)((uint)param_3 << 0x10) >> 0xf);

  // x offset from edge
  local_24 = param_2;

  // Draw rectangle 3
  // MenuBox_DrawOuterRect_Edge
  FUN_80044f90(&local_28,param_4,iVar1,param_6);

  //					sizeX - x offset frome edge
  local_28 = local_28 + (param_1[2] - param_2);

  // Draw rectangle 4
  // MenuBox_DrawOuterRect_Edge
  FUN_80044f90(&local_28,param_4,iVar1,param_6);
  return;
}


// Draw a 2D box made of four rectangles
// MenuBox_DrawOuterRect_HighLevel
// for colored boxes in battle mode
void FUN_80045650(undefined4 param_1,undefined4 param_2,short param_3,undefined4 param_4)

{
  // Draw a 2D box made of four rectangles
  // MenuBox_DrawOuterRect_LowLevel
  FUN_80045534(param_1,3,2,param_2,(int)param_3,param_4);
  return;
}


// Only used for drawing player comments
void FUN_8004568c(undefined4 param_1,short param_2,int param_3,uint param_4,short param_5,
                 short param_6,short param_7)

{
  int iVar1;
  short local_28;
  undefined2 local_26;
  undefined2 local_24;
  undefined2 local_22;

  if ((param_4 & 0xffff) == 0)
  {
	// DecalFont_GetLineWidth
    iVar1 = FUN_800224d0(param_1,(int)param_5);
    param_4 = iVar1 + 0xc;
  }

  // posX
  local_28 = param_2;

  // if text is not centered
  if (((int)param_6 & 0x8000U) != 0)
  {
	// posX with text un-centered
    local_28 = param_2 - (short)(((int)(param_4 << 0x10) >> 0x10) - ((int)(param_4 << 0x10) >> 0x1f)
                                >> 1);
  }

  iVar1 = (int)param_5 * 2;

  // sizeX
  local_24 = (undefined2)param_4;

  // posY
  local_26 = (undefined2)param_3;

  // sizeY
  local_22 = *(undefined2 *)(&DAT_80085af4 + iVar1);

  // Draw string
  FUN_80022878(param_1,(int)param_2,
               (int)((param_3 + (uint)*(ushort *)(&DAT_80085afc + iVar1)) * 0x10000) >> 0x10,
               (int)param_5,(int)param_6);

  // Draw 2D Menu rectangle background
  FUN_800457b0(&local_28,(int)param_7,*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0));
  return;
}



// WARNING: Could not reconcile some variable overlaps

// Draw 2D Menu rectangle background
// param1 is a pointer to RECT (x,y,w,h)
// param2 is type of tileView
	// 0: transparent, like main menu
	// 1: Black, like "gamepad unplugged"
void FUN_800457b0(undefined4 *param_1,ushort param_2,undefined4 param_3)

{
  undefined4 *puVar1;
  undefined *puVar2;
  undefined4 uVar3;
  short sVar4;
  short sVar5;
  undefined4 local_20;
  undefined4 local_1c;

  puVar1 = &DAT_8008d438;
  if ((param_2 & 0x10) != 0) {
    puVar1 = (undefined4 *)&DAT_8008d43c;
  }

  if ((param_2 & 2) == 0)
  {
	// MenuBox_DrawOuterRect_HighLevel (transparent)
    FUN_80045650(param_1,puVar1,(int)(short)(param_2 | 0x20),param_3);
  }

  if ((param_2 & 8) == 0) {
    local_20 = *param_1;
    local_1c = param_1[1];
    if ((param_2 & 2) == 0) {
      local_20._2_2_ = (short)((uint)local_20 >> 0x10);
      local_20 = CONCAT22(local_20._2_2_ + 2,(short)local_20 + 3);
      local_1c._2_2_ = (short)((uint)local_1c >> 0x10);
      local_1c = CONCAT22(local_1c._2_2_ + -4,(short)local_1c + -6);
    }
    if ((param_2 & 1) == 0) {
      uVar3 = 2;
      if ((param_2 & 0x100) == 0) {
        puVar2 = &DAT_8008d468;
        uVar3 = 0;
      }
      else {
        puVar2 = &DAT_8008d464;
      }

	  // CTR_Box_DrawClearBox
      FUN_8002177c(
					&local_20,
					puVar2,
					uVar3,
					param_3,

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);
    }
    else
	{
	  // draw a rectangle
	  // CTR_Box_DrawSolidBox
      FUN_80021894(
					&local_20,
					&DAT_8008d460,
					param_3,

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);
    }
  }
  if ((param_2 & 4) == 0) {
    sVar4 = 0xc;
    if ((param_2 & 0x80) != 0) {
      sVar4 = 4;
    }
    sVar5 = 6;
    if ((param_2 & 0x40) != 0) {
      sVar5 = 2;
    }
    local_20 = CONCAT22(*(short *)((int)param_1 + 2) + sVar5,
                        *(short *)param_1 + *(short *)(param_1 + 1));
    local_1c = CONCAT22(*(short *)((int)param_1 + 6),sVar4);

	// CTR_Box_DrawClearBox
    FUN_8002177c(
					&local_20,
					&DAT_8008d460,
					0,
					param_3,

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

	local_20 = CONCAT22(*(short *)((int)param_1 + 2) + *(short *)((int)param_1 + 6),
                        *(short *)param_1 + sVar4);

    local_1c = CONCAT22(sVar5,*(short *)(param_1 + 1) - sVar4);

	// CTR_Box_DrawClearBox
    FUN_8002177c(
					&local_20,
					&DAT_8008d460,
					0,
					param_3,

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);
  }
  return;
}


// Draw MenuBox background
void FUN_800459ec(short *param_1,short *param_2)

{
  undefined4 *puVar1;
  short local_18;
  short local_16;
  short local_14;
  undefined2 local_12;

  if (
		// if title text exists
		(-1 < *param_1) &&

		((*(uint *)(param_1 + 4) & 4) == 0)
	 )
  {
    puVar1 = &DAT_8008d438;
    if ((param_1[10] & 0x10U) != 0) {
      puVar1 = (undefined4 *)&DAT_8008d43c;
    }
    local_18 = *param_2 + 3;
    local_16 = param_2[1] + 6;
    if ((*(uint *)(param_1 + 4) & 0x80) == 0) {
      local_16 = param_2[1] + 9 + DAT_8008236a;
    }
    else {
      if ((*(uint *)(param_1 + 4) & 0x4000) == 0)
	  {
		// pixel-height of title menu rows
        local_16 = local_16 + DAT_8008236c;
      }
      else
	  {
		// pixel-height of non-title menu rows
        local_16 = local_16 + DAT_8008236a;
      }
    }
    local_12 = 2;
    local_14 = param_2[2] + -6;

	// MenuBox_DrawOuterRect_Edge (transparent)
    FUN_80044f90(&local_18,puVar1,(int)(short)(param_1[10] | 0x20),
                 *(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0));
  }

  // Draw 2D Menu rectangle background
  FUN_800457b0(param_2,(int)param_1[10],*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0));
  return;
}


// Get MenuBox Height
// param_1 MenuBox
// param_2 return value
// param_3 bool check submenus
void FUN_80045b1c(short *param_1,short *param_2,short param_3)

{
  short sVar1;
  short sVar2;
  short *psVar3;

  // height of small text
  sVar1 = DAT_8008236c;

  // if tiny text is disabled
  if ((*(uint *)(param_1 + 4) & 0x80) == 0)
  {
	// height of large text
    sVar1 = DAT_8008236a + 3;
  }

  // if not showing only highlighted row
  if ((*(uint *)(param_1 + 4) & 0x40) == 0) 
  {
	// if not drawing only title bar
    if ((*(uint *)(param_1 + 4) & 4) == 0) 
	{
	  // MenuRow array
	  psVar3 = *(short **)(param_1 + 6);

	  // deref to get string
	  sVar2 = *psVar3;

	  // loop through all valid rows
	  while (sVar2 != -1)
	  {
		// go to next row
        psVar3 = psVar3 + 3;

		// increment menubox height by row height
        *param_2 = *param_2 + sVar1;

		// get next string
		sVar2 = *psVar3;
      }
      goto LAB_80045bd0;
    }
	
	// if only showing title bar
	// height = height + lineHeight - 6
    sVar2 = *param_2 + -6;
  }
  
  // if only showing highlighted row
  else 
  {
	// height = height + lineHeight
    sVar2 = *param_2;
  }
  
  *param_2 = sVar1 + sVar2;

LAB_80045bd0:

  // if title text exists
  if (-1 < *param_1)
  {
    if ((*(uint *)(param_1 + 4) & 0x4000) == 0) {
      sVar2 = *param_2 + 6;
    }
    else {
      sVar1 = *param_2 + 9;
      sVar2 = DAT_8008236a;
    }

	// increment menubox height by text height
    *param_2 = sVar2 + sVar1;
  }

  if (
		// if submenu should be checked
		(param_3 != 0) &&

		// if submenu will be drawn
		((*(uint *)(param_1 + 4) & 0x10) != 0)
	 )
  {
	// recursively check height from submenus
    FUN_80045b1c(*(undefined4 *)(param_1 + 0x12),param_2,1);
  }
  return;
}

// get width of menubox
// param_1 MenuBox
// param_2 return value
// param_3 bool check submenus
void FUN_80045c50(short *param_1,short *param_2,short param_3)

{
  ushort uVar1;
  int iVar2;
  undefined4 uVar3;
  ushort *puVar4;
  undefined4 uVar5;

  // if large text
  uVar5 = 1;

  // if menu should have tiny text
  if ((*(uint *)(param_1 + 4) & 0x80) != 0) {
    uVar5 = 2;
  }

  // Menu Rows
  puVar4 = *(ushort **)(param_1 + 6);

  // deref row, to get string index
  uVar1 = *puVar4;

  // if string is valid
  if (*puVar4 != 0xffff)
  {
	// loop through all rows
    do
	{
	  // DecalFont_GetLineWidth
      iVar2 = FUN_800224d0(*(undefined4 *)(((uint)uVar1 & 0x7fff) * 4 + DAT_8008d878),
                           (int)(short)uVar5);

	  // if menuBox width is less than width of this string
	  if ((int)*param_2 < (iVar2 + 1) * 0x10000 >> 0x10)
	  {
		// set new width of menuBox
        *param_2 = (short)(iVar2 + 1);
      }

	  // next row
	  puVar4 = puVar4 + 3;

	  // next string
	  uVar1 = *puVar4;

    } while (*puVar4 != 0xffff);
  }

  // if MenuBox title has a string
  if (-1 < (int)*param_1)
  {
    uVar3 = 1;
    if ((*(uint *)(param_1 + 4) & 0x4000) == 0) {
      uVar3 = uVar5;
    }

	// DecalFont_GetLineWidth
    iVar2 = FUN_800224d0(*(undefined4 *)((int)*param_1 * 4 + DAT_8008d878),uVar3);

	// if menuBox width is less than width of this string
	if ((int)*param_2 < (iVar2 + 1) * 0x10000 >> 0x10)
	{
	  // set new width of menuBox
      *param_2 = (short)(iVar2 + 1);
    }
  }

  if (
		// if submenus should be checked
		(param_3 != 0) &&

		// if submenu will be drawn
		((*(uint *)(param_1 + 4) & 0x10) != 0))
  {
	// recursively check submenus for width
    FUN_80045c50(*(undefined4 *)(param_1 + 0x12),param_2,1);
  }
  return;
}


// draw entire menubox
// param_1 - ptrMenuBox
// param_4 - menuBox width
void FUN_80045db0(short *param_1,int param_2,short param_3,ushort param_4)

{
  ushort uVar1;
  uint uVar2;
  int iVar3;
  undefined4 uVar4;
  int iVar5;
  undefined4 *puVar6;
  short sVar7;
  ushort uVar8;
  short sVar9;
  ushort *puVar10;
  short sVar11;
  short sVar12;
  ushort uVar13;
  uint local_78;
  short local_70;
  short local_6e;
  ushort local_6c;
  short local_6a;
  short local_68;
  short local_66;
  short local_64;
  short local_62;
  short local_60;
  short local_5e [3];
  short local_58;
  short local_50;
  short local_48;
  short local_40;
  short local_38;
  int local_30;
  int local_2c;

  // default text color (orange)
  local_78 = 0;

  local_40 = 0;
  local_38 = 0;

  // if MenuBox should be drawn green
  // for save/load screen
  if ((param_1[10] & 0x10U) != 0)
  {
	// make text color green
    local_78 = 0x1d;
  }
  uVar13 = (ushort)local_78;
  local_58 = param_3;

  // setting flag 0x60000 disables input in pause menu,
  // so how does this "if" make sense?
  if ((*(uint *)(param_1 + 4) & 0x60000) == 0x60000)
  {
    param_1[0xf] = 2;

	// short "+8" is really + 0x10,
	// if funcPtr exists, execute it
	if (*(code **)(param_1 + 8) != (code *)0x0) {
      (**(code **)(param_1 + 8))(param_1);
    }
  }
  sVar11 = 2;

  // if large text in rows
  if ((*(uint *)(param_1 + 4) & 0x80) == 0) {
    sVar11 = 1;
    local_50 = 2;

	// row height + 3
    local_62 = DAT_8008236a + 3;
  }

  // & 80 == 1
  // if tiny text in rows
  else {
    local_50 = 0;

	// row height
    local_62 = DAT_8008236c;

	// if tiny text in title
    if ((*(uint *)(param_1 + 4) & 0x4000) == 0) {

	  // row height
	  local_48 = DAT_8008236c;

      goto LAB_80045e94;
    }
  }

  // if large text in title
  // row height + 3
  local_48 = DAT_8008236a + 3;

LAB_80045e94:
  local_60 = 0;
  param_1[0xb] = param_1[1];
  param_1[0xc] = param_1[2];

  // get height of menubox
  FUN_80045b1c(param_1,&local_60,0);

  uVar2 = *(uint *)(param_1 + 4);

  // set menuBox width
  param_1[0x10] = param_4;

  *(uint *)(param_1 + 4) = uVar2 & 0xfffffff7;

  // set menuBox height
  param_1[0x11] = local_60;

  if ((uVar2 & 2) != 0) {
    local_5e[0] = 0;
    FUN_80045b1c(param_1,local_5e,1);
    local_38 = (short)((uint)(-(int)local_5e[0] - (-(int)local_5e[0] >> 0x1f)) >> 1);
  }
  uVar2 = *(uint *)(param_1 + 4);
  if ((uVar2 & 1) != 0) {
    local_40 = (short)((uint)(-(int)(short)param_4 - (-(int)(short)param_4 >> 0x1f)) >> 1);
  }
  sVar12 = 0;

  // short +6 is really +C,
  // MenuRow array, deref to get string index
  puVar10 = *(ushort **)(param_1 + 6);

  // dereference short, then cast short to int,
  // get string index of the MenuBox title
  iVar3 = (int)*param_1;

  sVar9 = local_50 + local_38 + local_58 + param_1[0xc];

  if (
		// if title is not 0xFFFF
		(-1 < iVar3) &&

		((uVar2 & 4) == 0)
	 )
  {
    sVar7 = 1;
    if ((uVar2 & 0x4000) == 0) {
      sVar7 = sVar11;
    }
    if ((uVar2 & 0x200) == 0) {
      iVar5 = param_2 + (uint)(ushort)param_1[0xb];
      uVar8 = uVar13;
      if ((uVar2 & 1) != 0) {
        uVar8 = uVar13 | 0x8000;
      }
      local_78 = SEXT24((short)uVar8);

	  // get string from LNG
      uVar4 = *(undefined4 *)(iVar3 * 4 + DAT_8008d878);
    }
    else
	{
      local_78 = local_78 | 0xffff8000;

	  // get string from LNG
      uVar4 = *(undefined4 *)(iVar3 * 4 + DAT_8008d878);

	  iVar5 = param_2 + (uint)(ushort)param_1[0xb] +
              (((int)((uint)param_4 << 0x10) >> 0x10) - ((int)((uint)param_4 << 0x10) >> 0x1f) >> 1)
      ;
    }

	// draw title string
    FUN_80022878(uVar4,iVar5 * 0x10000 >> 0x10,(int)sVar9,(int)sVar7,local_78);

	sVar9 = local_48 + sVar9 + 6;
  }

  // if row string is not 0xFFFF
  if (*puVar10 != 0xffff)
  {
    local_30 = (((int)((uint)param_4 << 0x10) >> 0x10) - ((int)((uint)param_4 << 0x10) >> 0x1f) >> 1
               ) + 1;
    local_2c = (int)sVar11;

	// loop through all menu rows
	do
	{
      local_78 = *(uint *)(param_1 + 4);

	  if (
			// flags are disabled
			((local_78 & 0x44) == 0) ||

			// if this row is the highlighted row
			(sVar12 == param_1[0xd])
		 )
	  {
		// dereference row to get string
        uVar8 = *puVar10;

		// color of "locked" text (gray)
        uVar1 = 0x17;

		// if row is not "locked"
		if ((uVar8 & 0x8000) == 0)
		{
		  // change color to unlocked
          uVar1 = uVar13;
        }

		// if string is valid
		if ((uVar8 & 0x7fff) != 0)
		{

		  if ((local_78 & 0x200) == 0)
		  {
            iVar3 = param_2 + (uint)(ushort)param_1[0xb] + 1;

			if ((local_78 & 1) != 0)
			{
			  // center text
              uVar1 = uVar1 | 0x8000;
            }

			// get pointer to string, from index
            uVar4 = *(undefined4 *)(((uint)uVar8 & 0x7fff) * 4 + DAT_8008d878);

			iVar5 = local_2c;
          }
          else
		  {
			// center text
            uVar1 = uVar1 | 0x8000;

            iVar3 = param_2 + (uint)(ushort)param_1[0xb] + local_30;

			// get pointer to string, from index
			uVar4 = *(undefined4 *)(((uint)uVar8 & 0x7fff) * 4 + DAT_8008d878);

            iVar5 = (int)sVar11;
          }

		  // Draw string
          FUN_80022878(uVar4,iVar3 * 0x10000 >> 0x10,(int)sVar9,iVar5,(int)(short)uVar1);
        }
        sVar9 = sVar9 + local_62;
      }

	  // skip 6 bytes to next row
      puVar10 = puVar10 + 3;

	  // keep count of row
      sVar12 = sVar12 + 1;

	// as long as another row is valid
	} while (*puVar10 != 0xffff);
  }

  if ((*(uint *)(param_1 + 4) & 0x104) == 0) {
    local_70 = local_40 + (short)param_2 + param_1[0xb];
    local_6e = local_58 + param_1[0xc] + local_38;
    if ((*(uint *)(param_1 + 4) & 0x40) == 0) {
      local_6e = local_6e + param_1[0xd] * local_62 + local_50 + -1;
    }
    else {
      local_6e = local_6e + local_50 + -1;
    }
    if ((*(uint *)(param_1 + 4) & 0x80) == 0) {
      local_6a = -3;
    }
    else {
      local_6a = 1;
    }
    local_6a = local_62 + local_6a;
    if (-1 < *param_1) {
      local_6e = local_48 + local_6e + 6;
    }

	// if normal,
	// draw menu row highlight
	puVar6 = &DAT_8008d94c;

	// if draw green save/load
    if ((param_1[10] & 0x10U) != 0)
	{
	  // draw green menu row highlight
      puVar6 = &DAT_8008d948;
    }

    local_6c = param_4;

	// CTR_Box_DrawClearBox
    FUN_8002177c(&local_70,puVar6,1,

					*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0),

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);
  }

  // if a submenu is being drawn in a hierarchy structure
  if ((*(uint *)(param_1 + 4) & 0x10) != 0)
  {
	// recursively call this function,
	// draw the next menu within this menu
    FUN_80045db0(
				 // offset 0x24, pointer to next menu
				 *(undefined4 *)(param_1 + 0x12),

                 (int)((param_2 + (uint)(ushort)param_1[0xb]) * 0x10000) >> 0x10,
                 (int)(short)(local_38 + local_58 + param_1[0xc] + local_62 + 0xc),

				 // same width in parent and child
                 (int)(short)param_4);
  }
  if ((*(uint *)(param_1 + 4) & 4) == 0) {
    sVar11 = param_1[0xb];
    sVar9 = param_1[0xc];
    local_62 = (local_60 + 8) - (ushort)(*(byte *)(param_1 + 4) >> 7);
  }
  else {
    sVar11 = param_1[0xb];
    sVar9 = param_1[0xc];
    local_62 = local_62 + 8;
  }
  local_64 = param_4 + 0xc;
  local_66 = local_38 + local_58 + sVar9 + -4;
  local_68 = local_40 + (short)param_2 + sVar11 + -6;

  // draw background of menubox
  FUN_800459ec(param_1,&local_68);
  return;
}


// MenuBox_ClearInput
void FUN_80046404(void)

{
  int iVar1;
  int iVar2;

  iVar2 = 0;

  // Reset button input
  DAT_8008d950 = 0;
  DAT_8008d974 = 0;

  // for iVar2 = 0; iVar2 < 4; iVar2++
  do
  {
    iVar1 = iVar2 << 0x10;

	// increment loop counter
	iVar2 = iVar2 + 1;

	iVar1 = iVar1 >> 0xe;

	// clear all gamepad input for all players
    *(undefined4 *)((int)&DAT_8009a990 + iVar1) = 0;
    *(undefined4 *)((int)&DAT_8009a964 + iVar1) = 0;

  } while (iVar2 * 0x10000 >> 0x10 < 4);

  return;
}


// MenuBox_CollectInput
void FUN_80046458(void)

{
  undefined *puVar1;
  uint uVar2;
  int iVar3;
  int iVar4;

  // pointer to gamepad input for all players
  puVar1 = PTR_DAT_8008d2b0;

  // Reset button input
  DAT_8008d950 = 0;
  DAT_8008d974 = 0;

  if ((DAT_8008d954 == 0) || (uVar2 = 4, (*(uint *)(DAT_8008d954 + 8) & 0x8000) == 0))
  {
	// uvar2 = number of players
    uVar2 = (uint)(byte)PTR_DAT_8008d2ac[0x1ca9];
  }

  // loop counter
  iVar4 = 0;

  // if number of players is not zero
  if (uVar2 != 0)
  {
    iVar3 = 0;

	// for iVar4 = 0; iVar4 < numPlyrNextGame; iVar4++
	do
	{
	  // increment pointer counter
      iVar4 = iVar4 + 1;
      iVar3 = iVar3 >> 0x10;

	  // save input each gamepad into variables that can be re-used

	  // Detect buttons "tapped" which only show on the first frame they are pressed
      (&DAT_8009a990)[iVar3] = *(uint *)(puVar1 + iVar3 * 0x50 + 0x14);

	  // Detect buttons "held" which show from when they are pressed, until released
      (&DAT_8009a964)[iVar3] = *(uint *)(puVar1 + iVar3 * 0x50 + 0x10);

	  // Set button input for menus. This combines input from multiple players,
	  // and is used in menus. That's why all 4 players can fight in menus

	  // Tapped buttons from any player
      DAT_8008d950 = DAT_8008d950 | (&DAT_8009a990)[iVar3];

	  // Held buttons from any player
      DAT_8008d974 = DAT_8008d974 | (&DAT_8009a964)[iVar3];

	  // distance between each player's button managment addresses
	  iVar3 = iVar4 * 0x10000;

    } while (iVar4 * 0x10000 >> 0x10 < (int)uVar2);
  }
  return;
}


// MenuBox_ProcessInput
int FUN_80046534(int param_1)

{
  // When navigating main menu, the pointer in the value
  // of param_1 changes any time you press X or Triangle,
  // to change the submenu. DAT_8008d954 holds a copy

  // ptr + 0x1a: which row is highlighted
  // param_1 + 0x24: Pointer to next submenu (will be 0 at bottom sublevel)
  // param_1 + 0x28: Pointer to prev submenu (will be 0 at top of level of main menu)

  short sVar1;
  uint uVar2;
  ushort uVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  short sVar7;

  FUN_8006c684(&DAT_8008d668);
  sVar7 = 0;
  sVar1 = 0;

  if (((*(uint *)(param_1 + 8) & 4) == 0) && ((*(uint *)(param_1 + 8) & 0x60000) != 0x60000))
  {
	// save the row you are hovering over
    uVar3 = *(ushort *)(param_1 + 0x1a);

	// save it again
    uVar4 = (uint)uVar3;

	// At any time, the address (pointer + offset) that holds
	// the value of the row you are highlighting is
	// 8d954 + 0x1a

	// pointer to row selected
    iVar6 = *(int *)(param_1 + 0xc) + (int)*(short *)(param_1 + 0x1a) * 6;

    if (
			// If the submenu you're in has changed
			(DAT_8008d954 != param_1) &&

			(
				// save the current submenu address
				DAT_8008d954 = param_1,

				(*(uint *)(param_1 + 8) & 0x10000) == 0
			)
		)
	{
	  // clear gamepad input (for menus)
      FUN_80046404();
    }

	// Get button input
    uVar2 = DAT_8008d950;

    if ((*(uint *)(param_1 + 8) & 0x8000) == 0) {

		// gamepad input of P1
		uVar2 = DAT_8009a990;
    }

	// If you dont press L1 or R1
	if ((DAT_8009a964 & 0xc00) == 0) {
      sVar1 = sVar7;

	  // If you press D-Pad, Cross, Square, Triangle, Circle
      if ((uVar2 & 0x4007f) != 0)
	  {
		// If you dont press Up
        if ((uVar2 & 1) == 0)
		{
		  // If you dont press Down
          if ((uVar2 & 2) == 0)
		  {
			// If you dont press Left
            if ((uVar2 & 4) == 0)
			{
			  // if you press nothing,
			  // keep old row
              uVar5 = uVar4;

			  // If you press Right
			  if ((uVar2 & 8) != 0)
			  {
                uVar5 = (uint)*(byte *)(iVar6 + 5);
              }
            }

			// If you press Left
            else {
              uVar5 = (uint)*(byte *)(iVar6 + 4);
            }
          }

		  // If you press Down
          else {
            uVar5 = (uint)*(byte *)(iVar6 + 3);
          }
        }

		// If you press Up
        else {
          uVar5 = (uint)*(byte *)(iVar6 + 2);
        }

		// copy new row
        uVar3 = (ushort)uVar5;

        if (
				// if row has changed
				(uVar4 << 0x10 != uVar5 << 0x10) &&

				// if cursor moving sound is not muted
				((*(uint *)(param_1 + 8) & 0x800000) == 0)
			)
		{
		  // OtherFX_Play that moves cursor
          FUN_80028468(0,1);
        }

		// If you dont press Cross or Circle
        if ((uVar2 & 0x50) == 0)
		{
          if ((
				(*(uint *)(param_1 + 8) & 0x100000) == 0) &&

				// If you press Triangle or Square
				((uVar2 & 0x40020) != 0)
			)
		  {
            if ((*(uint *)(param_1 + 8) & 0x800000) == 0)
			{
			  // OtherFX_Play for "go back"
              FUN_80028468(2,1);
            }
            sVar1 = -1;

			// you are not at the top level of main menu
            *(undefined2 *)(param_1 + 0x1e) = 0;

			// set the current selected row
            *(undefined2 *)(param_1 + 0x1a) = 0xffff;

			// if funcPtr exists
            if (*(int *)(param_1 + 0x10) != 0)
			{
			  // clear gamepad input (for menus)
              FUN_80046404();

			  // call the function this menu has,
			  // pass itself as a parameter. Maybe
			  // this means "Draw itself"
              (**(code **)(param_1 + 0x10))(param_1);
            }

			// set the current selected row
            *(ushort *)(param_1 + 0x1a) = uVar3;
          }
        }

		// If you press Cross or Circle
		else
		{
		  // breakpoint at 800466c4, try to enter 4P menu,
		  // then set r2 to zero, resume, and you enter

		  // if you can enter this submenu

		  // menuBox->rows[menuBox->rowSelected] & LOCKED == false
          if (((int)*(short *)((int)*(short *)(param_1 + 0x1a) * 6 + *(int *)(param_1 + 0xc)) &
              0x8000U) == 0)
		  {
            if ((*(uint *)(param_1 + 8) & 0x800000) == 0)
			{
			  // OtherFX_Play for "enter"
              FUN_80028468(1,1);
            }

			// you are not on the top of the main menu
            *(undefined2 *)(param_1 + 0x1e) = 0;

			// set the current selected row
            *(ushort *)(param_1 + 0x1a) = uVar3;

            sVar1 = 1;

			// if you have not reached the bottom of the submenu
            if (*(int *)(param_1 + 0x10) != 0)
			{
			  // clear gamepad input (for menus)
              FUN_80046404();

			  // call the function this menu has,
			  // pass itself as a parameter. Maybe
			  // this means "Draw itself"
              (**(code **)(param_1 + 0x10))(param_1);
            }
          }

		  // if you cant enter this submenu,
		  // like 4P VS with 2 gamepads
          else
		  {
            if ((*(uint *)(param_1 + 8) & 0x800000) == 0)
			{
			  // OtherFX_Play "womp" sound
              FUN_80028468(5,1);
            }
          }
        }

		// clear gamepad input (for menus)
        FUN_80046404();
      }

	  // set the current selected row
      *(ushort *)(param_1 + 0x1a) = uVar3;
    }
  }

  // if you are not at the bottom level of
  // the submenu, go to the next level
  if ((*(uint *)(param_1 + 8) & 0x10) != 0)
  {
	// param_1 + 0x24: Pointer to next submenu
	// param_1 + 0x28: Pointer to prev submenu

	// Store the address of the next submenu's previous submenu, to this submenu
    *(int *)(*(int *)(param_1 + 0x24) + 0x28) = param_1;

	// Call this function again, going to the next submenu
    sVar1 = FUN_80046534(*(undefined4 *)(param_1 + 0x24));
  }

  // If you've reached the end of the submenu, return
  return (int)sVar1;
}

// MenuBox_ProcessState
// birth, life, and death of MenuBox
void FUN_8004680c(void)

{
  code **ppcVar1;
  uint uVar2;
  int iVar3;
  short local_10 [4];

  // get ptrDesiredMenuBox
  iVar3 = DAT_8008d924;

  // This is a timer feature so that you
  // can give "amount of life" to a menu,
  // but this variable is never used so
  // it serves no purpose
  if (DAT_8008d90c != 0) {
    DAT_8008d90c = DAT_8008d90c + -1;
  }

  // if you want to change the MenuBox
  if (DAT_8008d924 != 0)
  {
    uVar2 = *(uint *)(DAT_8008d924 + 8);

	// change ActiveMenuBox to DesiredMenuBox
	DAT_8008d908 = DAT_8008d924;

	// erase DesiredMenuBox
    DAT_8008d924 = 0;

    *(uint *)(iVar3 + 8) = uVar2 & 0xffffefff;
    while ((uVar2 & 0x10) != 0) {
      iVar3 = *(int *)(iVar3 + 0x24);
      uVar2 = *(uint *)(iVar3 + 8);
    }
    *(uint *)(iVar3 + 8) = *(uint *)(iVar3 + 8) & 0xfffffffb;
  }


  if ((*(uint *)(DAT_8008d908 + 8) & 0x420) != 0) {

	// Get function pointer that MenuBox executes each frame
	ppcVar1 = (code **)(DAT_8008d908 + 0x10);

	// you are at the top level of main menu and can't go back
    *(undefined2 *)(DAT_8008d908 + 0x1e) = 1;

	// execute MenuBox function
    (**ppcVar1)();
  }

  if ((*(uint *)(DAT_8008d908 + 8) & 0x20) == 0)
  {
	// MenuBox_ProcessInput
    FUN_80046534();

    if ((*(uint *)(DAT_8008d908 + 8) & 0x2000) == 0)
	{
	  // set width to zero
      local_10[0] = 0;

	  // get width of menubox
	  FUN_80045c50(DAT_8008d908,local_10,1);

	  // draw menubox
      FUN_80045db0(DAT_8008d908,0,0,(int)local_10[0]);
    }
  }

  if ((*(uint *)(DAT_8008d908 + 8) & 0x800) == 0)
  {
	// TitleFlag_GetCanDraw
    iVar3 = FUN_80044094();

	// if the value is zero
    if (iVar3 == 0)
	{
	  // TitleFlag_SetCanDraw(true)
      FUN_80044088(1);
    }

	// enable 3d cars on track? pause the game?
    *(uint *)(PTR_DAT_8008d2ac + 0x256c) = *(uint *)(PTR_DAT_8008d2ac + 0x256c) | 0x20;
  }

  // If the menu is invisible, which is only if you
  // left the menu, and no longer need the menu,
  if ((*(uint *)(DAT_8008d908 + 8) & 0x1000) != 0)
  {
	// set ActiveMenuBox to nullptr
    DAT_8008d908 = 0;
  }
  return;
}


// MenuBox_Show
void FUN_80046990(int param_1)

{
  // clear gamepad input (for menus)
  FUN_80046404();

  // save the pointer to the menu buffer
  // that is stored at bottom of 221 dll
  DAT_8008d908 = param_1;

  // Remove 0x1000 flag, making sure the menu is visible,
  // this is called in DLL 221 to keep the menu visible
  *(uint *)(param_1 + 8) = *(uint *)(param_1 + 8) & 0xffffefff;
  return;
}


// MenuBox_Hide
void FUN_800469c8(int param_1)

{
  // Enable 0x1000 flag to make menu invisible, this is used
  // when the menu is diabled in 221 dll after making a choice
  *(uint *)(param_1 + 8) = *(uint *)(param_1 + 8) | 0x1000;
  return;
}

// MenuBox_BoolHidden
uint FUN_800469dc(int param_1)

{
  return *(uint *)(param_1 + 8) >> 0xc & 1;
}

// GhostData_NumGhostsForLEV
int FUN_800469f0(short param_1)

{
  short sVar1;
  int iVar2;
  short sVar3;

  sVar3 = 0;
  iVar2 = 0;
  sVar1 = 0;

  // if ghost profiles are present
  if (0 < DAT_8009aa5c)
  {
	// loop through ghost profiles
    do {
      sVar3 = sVar1;
      sVar1 = (short)iVar2;
      iVar2 = iVar2 + 1;

	  // Check trackID of each profile
      if ((&DAT_8009aa88)[sVar1 * 0x1a] == param_1) {
        sVar3 = sVar3 + 1;
      }
      sVar1 = sVar3;
    } while (iVar2 * 0x10000 >> 0x10 < (int)DAT_8009aa5c);
  }
  return (int)sVar3;
}


void FUN_80046a74(void)

{
  DAT_8009aa30 = DAT_8009aa30 & 0xfffffff7 | 6;
  return;
}



uint FUN_80046a90(short param_1)

{
  uint uVar1;

  if ((param_1 == 8) && ((DAT_8009aa30 & 6) != 0)) {
    return 1;
  }
  uVar1 = 0;
  if ((((DAT_8009aa30 & 6) == 0) && (DAT_8009aa3e == DAT_8009aa42)) &&
     (DAT_8009aa40 == DAT_8009aa44)) {
    uVar1 = (uint)(DAT_8009aa34 == param_1);
  }
  return uVar1;
}



void FUN_80046b1c(undefined2 param_1,undefined2 param_2,undefined4 param_3,undefined4 param_4,
                 undefined4 param_5,undefined2 param_6)

{
  // param2 is 1 for SLOTS
  // param2 is 3 for ghost data

  DAT_8009aa30 = DAT_8009aa30 & 0xfffffff7;

  DAT_8009aa3a = param_2;

  // slotIndex
  DAT_8009aa3c = param_1;

  DAT_8009aa42 = param_2;

  // param1 always zero?
  DAT_8009aa44 = param_1;

  // Name of the save
  DAT_8009aa48 = param_3;

  DAT_8009aa4c = param_4;

  // if reading, copy data to this address
  DAT_8009aa50 = param_5;

  // if reading, copy data of this size
  DAT_8009aa54 = param_6;
  return;
}


// GhostData_Encode
uint FUN_80046b60(int param_1)
{
  // only called from GhostData_SaveProfile

  uint uVar1;
  short sVar2;

  sVar2 = (short)param_1;
  if (sVar2 < 10) {
    return param_1 + 0x30U & 0xff;
  }
  if (sVar2 < 0x24) {
    return param_1 + 0x37U & 0xff;
  }
  if (sVar2 < 0x3e) {
    uVar1 = param_1 + 0x3dU & 0xff;
  }
  else {
    uVar1 = 0x2d;
    if (sVar2 != 0x3e) {
      return 0x5f;
    }
  }
  return uVar1;
}


// GhostData_Decode
int FUN_80046bc0(byte param_1)
{
  // only called from GhostData_LoadProfile

  if (param_1 == 0x2d) {
    return 0x3e;
  }
  if (param_1 == 0x5f) {
    return 0x3f;
  }
  if (param_1 < 0x3a) {
    return (uint)param_1 - 0x30;
  }
  if (0x5a < param_1) {
    return (int)(((uint)param_1 + 0xffc3) * 0x10000) >> 0x10;
  }
  return (int)(((uint)param_1 + 0xffc9) * 0x10000) >> 0x10;
}


// WARNING: Removing unreachable block (ram,0x80046e88)
// WARNING: Removing unreachable block (ram,0x80046ed4)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// GhostData_SaveProfile
void FUN_80046c30(
	uint param_1,	// index to save (or load) to
	ushort param_2, // character ID array
	ushort param_3, // Level ID Array
	int param_4,	// amount of time
	undefined4 *param_5) // string typed from OSK

{
  bool bVar1;
  undefined4 *puVar2;
  undefined uVar3;
  byte bVar4;
  int iVar5;
  char *pcVar6;
  undefined4 *puVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  int iVar14;
  undefined4 *puVar15;
  undefined4 *puVar16;
  char local_138 [128];
  undefined4 local_b8 [32];
  ushort local_38;
  uint local_30;

  local_30 = SEXT24((short)param_2);
  local_38 = param_2;
  do {
    bVar1 = true;

	// if time is more than 9:59:99
    if (0x8c9ff < param_4)
	{
	  // set time to 9:59:99
      param_4 = 0x8c9ff;
    }

    uVar11 = local_30 | (int)((uint)param_3 << 0x10) >> 0xc;
    uVar12 = uVar11 | param_4 << 9;
    uVar13 = uVar12 | param_1 << 0x1d;

	// GhostData_Encode
    uVar3 = FUN_80046b60(uVar11 & 0x3f);

    _DAT_80085a3c = CONCAT11(uVar3,DAT_80085a3c);
    _DAT_80085a3c = _DAT_80085a3c & 0xffff0000 | (uint)_DAT_80085a3c;

	// GhostData_Encode
    uVar3 = FUN_80046b60((uVar12 & 0xfc0) >> 6);

    _DAT_80085a3c = CONCAT12(uVar3,_DAT_80085a3c);
    _DAT_80085a3c = _DAT_80085a3c & 0xff000000 | (uint)_DAT_80085a3c;

	// GhostData_Encode
    bVar4 = FUN_80046b60((uVar12 & 0x3f000) >> 0xc);

    _DAT_80085a3c = _DAT_80085a3c & 0xffffff | (uint)bVar4 << 0x18;
    bVar4 = FUN_80046b60((uVar12 & 0xfc0000) >> 0x12);
    _DAT_80085a40 = _DAT_80085a40 & 0xffffff00 | (uint)bVar4;

	// GhostData_Encode
    uVar3 = FUN_80046b60(uVar13 >> 0x18 & 0x3f);

    _DAT_80085a40 = CONCAT11(uVar3,DAT_80085a40);
    _DAT_80085a40 = _DAT_80085a40 & 0xffff0000 | (uint)_DAT_80085a40;

	// GhostData_Encode
    uVar3 = FUN_80046b60(uVar13 >> 0x1e);

	// loop counter
    iVar14 = 0;

	_DAT_80085a40 = (uint)CONCAT12(uVar3,_DAT_80085a40);

	// If there is ghost data to load
    if (0 < DAT_8009aa5c)
	{
	  // for iVar14 = 0; iVar14 < numGhosts; iVar14++
      do {
        iVar5 = strcmp();

		// increment loop counter
        iVar14 = iVar14 + 1;

        if (iVar5 == 0) {
          bVar1 = false;
          break;
        }
      } while (iVar14 * 0x10000 >> 0x10 < (int)DAT_8009aa5c);
    }
    param_1 = param_1 + 1 & 7;
    if (bVar1)
	{
      local_138[0] = '\0';

	  // length of string
	  iVar14 = strlen();

	  // param_3 = levelID
      strcat(

		// append end of string
		local_138 + iVar14,

		// lngStrings[MetaDataLEV[id].name_LNG]
        *(char **)((int)*(short *)(&DAT_80083a88 + (int)(short)param_3 * 0x18) * 4 +
				DAT_8008d878)
	  );

	  // ":"
      strcat(local_138,&DAT_8008d46c);

	  // length of string
      iVar14 = strlen();

	  // local_38 = 80086E84
      strcat(

		// append end of string
		local_138 + iVar14,

		// lngStrings[MetaDataCharacters[id].name_LNG_long]
		*(char **)((int)*(short *)(&DAT_80086d8a + ((int)((uint)local_38 << 0x10) >> 0xc)) * 4
                + DAT_8008d878)
	  );

	  // ":"
	  strcat(local_138,&DAT_8008d46c);

	  // make a string with amount of time
	  // param_4 is the number of milliseconds in the race (or lap)
      pcVar6 = (char *)FUN_80044ff8(param_4);

	  // append end of string
      strcat(local_138,pcVar6);

	  // CTR_ScrambleGhostString (why?)
	  FUN_80022234(local_b8,local_138);

      puVar2 = &DAT_800992a4;
      puVar16 = local_b8;
      do {
        puVar15 = puVar16;
        puVar7 = puVar2;
        uVar9 = puVar15[1];
        uVar8 = puVar15[2];
        uVar10 = puVar15[3];
        *puVar7 = *puVar15;
        puVar7[1] = uVar9;
        puVar7[2] = uVar8;
        puVar7[3] = uVar10;
        puVar16 = puVar15 + 4;
        puVar2 = puVar7 + 4;
      } while (puVar16 != local_b8 + 0xc);
      uVar10 = puVar15[5];
      uVar8 = puVar15[6];
      uVar3 = *(undefined *)(puVar15 + 7);
      puVar7[4] = *puVar16;
      puVar7[5] = uVar10;
      puVar7[6] = uVar8;
      *(undefined *)(puVar7 + 7) = uVar3;
      *(undefined *)((int)puVar7 + 0x1d) = *(undefined *)((int)puVar15 + 0x1d);
                    // WARNING: Read-only address (ram,0x8009abe5) is written
                    // WARNING: Read-only address (ram,0x8009abe9) is written

	  // copy string into ghostProfile_current
	  DAT_8009abcc = DAT_80085a30;
      DAT_8009abd0 = DAT_80085a34;
      DAT_8009abd4 = DAT_80085a38;
      DAT_8009abd8 = _DAT_80085a3c;
      DAT_8009abdc = _DAT_80085a40;

	  // 80085a44
	  // BASCUS-94426G*
      DAT_8009abe0._0_1_ = s_BASCUS_94426G__80085a44[0];

	  // OSK name
      ram0x8009abe1 = *param_5;
      ram0x8009abe5 = param_5[1];
      ram0x8009abe9 = param_5[2];
      DAT_8009abed = param_5[3];
      DAT_8009abf1 = *(undefined *)(param_5 + 4);

      DAT_8009abf2 = 1;

	  // trackID
      DAT_8009abf4 = param_3;

	  // characterID
      DAT_8009abf6 = local_38;

      DAT_8009abf8 = (short)param_1;
      DAT_8009abfc = param_4;
      return;
    }
  } while( true );
}


// GhostData_LoadProfile
void FUN_80047034(undefined4 *param_1,undefined4 *param_2)

{
  undefined uVar1;
  ushort uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  uint uVar11;
  uint uVar12;

  // GhostData_Decode
  uVar2 = FUN_80046bc0((uint)*(byte *)((int)param_2 + 0xd));
  iVar3 = FUN_80046bc0((uint)*(byte *)((int)param_2 + 0xe));
  iVar4 = FUN_80046bc0((uint)*(byte *)((int)param_2 + 0xf));
  iVar5 = FUN_80046bc0((uint)*(byte *)((int)param_2 + 0x10));
  iVar6 = FUN_80046bc0((uint)*(byte *)((int)param_2 + 0x11));
  iVar7 = FUN_80046bc0((uint)*(byte *)((int)param_2 + 0x12));

  uVar11 = (int)(short)uVar2 | (iVar3 << 0x10) >> 10;
  uVar12 = uVar11 | (iVar4 << 0x10) >> 4 | iVar5 << 0x12 | iVar6 << 0x18;
  *(ushort *)((int)param_1 + 0x2a) = uVar2 & 0xf;
  *(short *)(param_1 + 10) = (short)((uVar11 & 0x1f0) >> 4);
  param_1[0xc] = (uVar12 & 0x1ffffe00) >> 9;
  *(ushort *)(param_1 + 0xb) =
       ((ushort)(uVar12 >> 0x10) | (ushort)((uint)(iVar7 << 0x1e) >> 0x10)) >> 0xd;
  *(undefined *)((int)param_1 + 0x26) = 0;
  uVar8 = param_2[1];
  uVar9 = param_2[2];
  uVar10 = param_2[3];
  *param_1 = *param_2;
  param_1[1] = uVar8;
  param_1[2] = uVar9;
  param_1[3] = uVar10;
  uVar1 = *(undefined *)(param_2 + 5);
  param_1[4] = param_2[4];
  *(undefined *)(param_1 + 5) = uVar1;
  *(undefined *)((int)param_1 + 0x29) = 0;
  return;
}


// LoadSave_StartMemcardAction
// 2 = null
// 3 = save main CTR save file (adv, high score, etc)
// 5 = load ghost profile
// 6 = save ghost files
// 7 = load main ctr save file (adv, high score, etc)
void FUN_80047198(undefined2 param_1)

{
  DAT_8008d478 = param_1;
  DAT_8008d964 = 0;
  DAT_8008d984 = 0;
  return;
}


// LoadSave_StopMemcardAction
void FUN_800471ac(void)

{
  // memcard action = null
  DAT_8008d478 = 2;
  
  DAT_8008d964 = 1;
  return;
}



void FUN_800471c4(undefined2 param_1)

{
  DAT_8008d47a = param_1;
  FUN_80046a74();
  return;
}



void FUN_800471e8(void)

{
  // if data has not been wiped to "default state"
  // before reading memcard, then wipe it now
  if (DAT_8008d968 == 0)
  {
	// 8008d474 is ptr to memcard data
	// GAMEPROG_InitFullMemcard
    FUN_80026c24(PTR_DAT_8008d474);

	// dont do this a second time
    DAT_8008d968 = 1;
  }

  DAT_8008d928 = 0;
  DAT_8008d95c = 1;
  return;
}


// GhostData_ResetNumGhosts
void FUN_80047224(void)

{
  // By default, there are zero ghosts available to load
  DAT_8009aa5c = 0;
  return;
}


// LoadFromCard_GameProgressAndOptions
void FUN_80047230(void)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 *puVar8;

  DAT_8008d95c = 1;
  DAT_8008d928 = 1;
  DAT_8008d96c = 0xffff;

  // GAMEPROG_SyncGameAndCard
  // params are: memcardPtr, ram ptr
  // not "save", more like "sync" memcard and ram
  FUN_80026d7c(PTR_DAT_8008d474 + 0x144,&DAT_8008e6e8);

  // pointer to memcard GameProgress and partially GameOptions
  puVar2 = (undefined4 *)(PTR_DAT_8008d474 + 0x15f4);
  puVar4 = (undefined4 *)(PTR_DAT_8008d474 + 0x144);

  // GameProgress struct
  puVar1 = &DAT_8008e6e8;

  // Copy to memory card
  do {
    puVar8 = puVar1;
    puVar3 = puVar4;
    uVar5 = puVar3[1];
    uVar6 = puVar3[2];
    uVar7 = puVar3[3];
    *puVar8 = *puVar3;
    puVar8[1] = uVar5;
    puVar8[2] = uVar6;
    puVar8[3] = uVar7;
    puVar4 = puVar3 + 4;
    puVar1 = puVar8 + 4;
  } while (puVar4 != puVar2);

  uVar5 = puVar3[5];
  uVar6 = puVar3[6];
  puVar8[4] = *puVar4;
  puVar8[5] = uVar5;
  puVar8[6] = uVar6;

  // load game options from memcard
  FUN_80043c10();
  return;
}



void FUN_800472d0(void)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  undefined4 local_1c;
  undefined4 *puVar4;
  undefined4 uVar5;
  char *pcVar6;
  undefined4 *puVar7;
  undefined4 uVar8;
  undefined *local_20;

  bVar1 = false;
  switch(DAT_8008d47a) {
  case 0:
    bVar1 = true;
    
	// memcard action = null
	DAT_8008d478 = 2;
	
    DAT_8008d984 = 1;
    break;
  case 1:
  
	// if not loading profile
    if (DAT_8008d478 != 7) 
	{
	  // memcard action = null
      DAT_8008d478 = 2;
      goto LAB_800475b4;
    }
	
	// if DAT_8008d478 == 7, continue here...
	
	// memcard action = null
    DAT_8008d478 = 2;
	
    FUN_800471c4();
    uVar5 = 4;

	// 800859e4
	// BASCUS-94426-SLOTS
    pcVar6 = s_BASCUS_94426_SLOTS_800859e4;

	puVar7 = (undefined4 *)0x0;
    local_20 = (undefined *)0x0;
    local_1c = 0;
LAB_80047544:
    FUN_80046b1c(0,uVar5,pcVar6,puVar7,local_20,local_1c);
    DAT_8008d984 = 0;
    break;
  case 5:
  case 6:
    bVar1 = true;
    break;
  case 7:
  case 8:
  case 9:

	// if loading ghost profile
	if (DAT_8008d478 == 5)
	{
      FUN_800471c4(4);

	  // ghost profile (save or load?)
	  FUN_80046b1c(0,3,&DAT_8009aa60 + (int)DAT_8009aa5a * 0x34,0,DAT_8008d754,0x3e00);
    }
    else {
      if (DAT_8008d478 < 6) 
	  {
		// if saving main CTR save file
        if (DAT_8008d478 == 3) 
		{
		  // memcard action = null
          DAT_8008d478 = 2;
          
		  FUN_800471c4(3);

		  // 800859e4
		  // BASCUS-94426-SLOTS
          pcVar6 = s_BASCUS_94426_SLOTS_800859e4;

		  puVar7 = (undefined4 *)&DAT_800859f8;

		  // size of memory card buffer
          local_1c = 0x1680;

		  // 8008d470 -> 800992E4, holds all memory card bytes
          local_20 = PTR_DAT_8008d470;
LAB_8004753c:
          uVar5 = 2;
          goto LAB_80047544;
        }
      }
      else {
        
		// if saving ghost profile
		if (DAT_8008d478 == 6) 
		{
          if (-1 < (int)DAT_8009aa56)
		  {
			// Get offset in array based on index,
			// the string of each profile is 0x34 bytes apart
            iVar2 = (int)DAT_8009aa56 * 0x34;

			// This happens as soon as you start saving ghost,
			// and "Saving..." appears on the screen

			// Generate 0x14-character string for profile name
			// BASCUS-94426GT xxxxx
			DAT_80099284 = *(undefined4 *)(&DAT_8009aa60 + iVar2);
            DAT_80099288 = *(undefined4 *)(&DAT_8009aa64 + iVar2);
            DAT_8009928c = *(undefined4 *)(&DAT_8009aa68 + iVar2);
            DAT_80099290 = *(undefined4 *)(&DAT_8009aa6c + iVar2);
            DAT_80099294 = *(undefined4 *)(&DAT_8009aa70 + iVar2);
            DAT_80099298 = (&DAT_8009aa74)[iVar2];

			FUN_800471c4(3);

			// Name of Ghost profile to save to
            FUN_80046b1c(0,5,&DAT_80099284,0,0,0);

            DAT_8008d984 = 0;
            iVar2 = ((int)DAT_8009aa5c + -1) - (int)DAT_8009aa56;
            if (iVar2 != 0)
			{
			  // Get byte index, given array index
              iVar3 = (int)DAT_8009aa56 * 0x34;

			  // copy the string
              memmove(&DAT_8009aa60 + iVar3,&DAT_8009aa94 + iVar3,iVar2 * 0x34);
            }

			// decrease number of ghost profiles
            DAT_8009aa5c = DAT_8009aa5c + -1;
            break;
          }
          FUN_800471c4(3);
          pcVar6 = (char *)&DAT_80085a30;
          puVar7 = &DAT_800992a4;

		  // size of two memcard slots
          local_1c = 0x3e00;

		  // address of ghost recording buffer
          local_20 = DAT_8008fbf4;

          goto LAB_8004753c;
        }
      }
    }
LAB_800475b4:
    bVar1 = true;
    DAT_8008d984 = 1;
  }
  
  // if NEWCARD detected
  iVar2 = FUN_80046a90(3);
  if (iVar2 != 0) {
    FUN_800471e8();

	// GhostData_ResetNumGhosts
    FUN_80047224();

    goto LAB_80047a08;
  }
  
  iVar2 = FUN_80046a90(0);
  if (iVar2 == 0) {
    iVar2 = FUN_80046a90(1);
    local_1c = 6;
    if (iVar2 == 0) {
      
	  // if TIMEOUT (no card) detected
	  iVar2 = FUN_80046a90(2);
      
	  // no TIMEOUT
	  if (iVar2 == 0) 
	  {
        iVar2 = FUN_80046a90(5);
        if (iVar2 == 0) 
		{
          iVar2 = FUN_80046a90(4);
          if (iVar2 != 0) 
		  {
LAB_800479bc:
            
			// wrapper for resetting GameProg
			FUN_800471e8();
			
            DAT_8008d95c = 0;
            
			// reset gameProg (again?)
			DAT_8008d968 = 0;
			
            FUN_800471c4(4);
            uVar5 = 3;

			// 800859e4
			// BASCUS-94426-SLOTS
            pcVar6 = s_BASCUS_94426_SLOTS_800859e4;

			puVar7 = (undefined4 *)0x0;

			// size of memory card buffer
            local_1c = 0x1680;

			// 8008d470 -> 800992E4, holds all memory card bytes
            local_20 = PTR_DAT_8008d470;
LAB_800479f4:
            bVar1 = false;
            FUN_80046b1c(0,uVar5,pcVar6,puVar7,local_20,local_1c);
            DAT_8008d984 = 0;
            goto LAB_80047a08;
          }
		  
          iVar2 = FUN_80046a90(6);
          if (iVar2 != 0)
		  {
			// GhostData_ResetNumGhosts
            FUN_80047224();

            FUN_800471e8();
            local_1c = 1;
            goto LAB_800476b4;
          }
          
		  iVar2 = FUN_80046a90(7);
          if (iVar2 == 0) goto LAB_80047a08;
          
		  DAT_8008d984 = 1;
          
		  if (DAT_8008d47a == 3) 
		  {
			// if saving ghost profile
            if (DAT_8008d478 == 6) {
              if (-1 < DAT_8009aa56) {
                DAT_8009aa56 = -1;
                FUN_800471c4(3);
                uVar5 = 2;
                pcVar6 = (char *)&DAT_80085a30;
                puVar7 = &DAT_800992a4;

				// max size of ghost recording buffer
				local_1c = 0x3e00;

				// address of ghost recording buffer
                local_20 = DAT_8008fbf4;

                goto LAB_800479f4;
              }

              iVar2 = ((int)DAT_8009aa5c + -1) - (int)DAT_8009aa58;

			  if (iVar2 != 0)
			  {
				// get ghost profile
                iVar3 = (int)DAT_8009aa58 * 0x34;

				// copy from profile array to current profile
                memmove(&DAT_8009aa94 + iVar3,&DAT_8009aa60 + iVar3,iVar2 * 0x34);
              }

              puVar4 = &DAT_8009abcc;
              puVar7 = (undefined4 *)(&DAT_8009aa60 + (int)DAT_8009aa58 * 0x34);

			  // increment number of ghost profiles
              DAT_8009aa5c = DAT_8009aa5c + 1;

              do {
                local_1c = puVar4[1];
                uVar5 = puVar4[2];
                uVar8 = puVar4[3];
                *puVar7 = *puVar4;
                puVar7[1] = local_1c;
                puVar7[2] = uVar5;
                puVar7[3] = uVar8;
                puVar4 = puVar4 + 4;
                puVar7 = puVar7 + 4;
              } while (puVar4 != &DAT_8009abfc);
              *puVar7 = DAT_8009abfc;
            }
            DAT_8008d964 = 1;
            local_1c = 8;
            
			// memcard action = null
			DAT_8008d478 = 2;
			
            goto LAB_80047984;
          }
          if (DAT_8008d47a < 4) {
            if (DAT_8008d47a == 2)
			{
			  // GhostData_ResetNumGhosts
              FUN_80047224();

			  FUN_800471e8();
              DAT_8008d928 = 1;
              if (-1 < DAT_8008d978)
			  {
				// if chose load or save (0 or 1)
                if (DAT_8008d978 < 2)
				{
				  // 8008d474 is ptr to memcard data
				  // GAMEPROG_InitFullMemcard
                  FUN_80026c24(PTR_DAT_8008d474);

                  FUN_800471c4(8);

				  // 800859e4
				  // BASCUS-94426-SLOTS
                  FUN_80046b1c(0,1,s_BASCUS_94426_SLOTS_800859e4,0,0,0);

				  bVar1 = false;
                }
                else {

				  // if you are deleting data
                  if (DAT_8008d978 == 2) {
                    DAT_8008d984 = 1;
                  }
                }
              }
            }
            goto LAB_80047a08;
          }
          if (DAT_8008d47a != 4) {
            if (DAT_8008d47a != 5) goto LAB_80047a08;

			// GhostData_ResetNumGhosts
            FUN_80047224();

			goto LAB_800479bc;
          }
		  
		  // if loading ghost profile
          if (DAT_8008d478 == 5)
		  {
			// you want to show a ghost during a race
            DAT_8008d958 = 1;

			DAT_8008d964 = 1;
            local_1c = 8;
          }
          else
		  {
			// If memory card save has correct version number
            if (*(int *)PTR_DAT_8008d474 == 0x1600ffee)
			{
			  // the save is not outdated
              DAT_8008d944 = 0;

			  // LoadFromCard_GameProgressAndOptions
              FUN_80047230();

              local_1c = 8;
            }
            else
			{
			  // the save is outdated
              DAT_8008d944 = 1;

              FUN_800471e8();
              local_1c = 9;
            }
          }
          FUN_800471c4(local_1c);
		  
		  // memcard action = null
          DAT_8008d478 = 2;
        }
        else
		{
		  // the save is not outdated
          DAT_8008d944 = 0;
          FUN_800471e8();
          DAT_8008d984 = 1;
          local_1c = 9;
          if ((DAT_8008d978 != 0) && ((DAT_8008d978 < 0 || (local_1c = 8, 2 < DAT_8008d978))))
          goto LAB_80047a08;
LAB_80047984:
          DAT_8008d984 = 1;
          FUN_800471c4(local_1c);
        }

		// 800859e4
		// BASCUS-94426-SLOTS
        FUN_80046b1c(0,1,s_BASCUS_94426_SLOTS_800859e4,0,0,0);

		bVar1 = false;
        goto LAB_80047a08;
      }
	  
	  // TIMEOUT (no card)
      FUN_800471e8();
      local_1c = 7;
    }
  }
  else {
    FUN_800471e8();

	// GhostData_ResetNumGhosts
    FUN_80047224();

	local_1c = 0;
  }
LAB_800476b4:
  FUN_800471c4(local_1c);

  // 800859e4
  // BASCUS-94426-SLOTS
  FUN_80046b1c(0,1,s_BASCUS_94426_SLOTS_800859e4,0,0,0);

  DAT_8008d984 = 1;
  bVar1 = false;
LAB_80047a08:
  if ((bVar1) && (iVar2 = FUN_80046a90(8), iVar2 == 0))
  {
	// 800859e4
	// BASCUS-94426-SLOTS
    FUN_80046b1c(0,1,s_BASCUS_94426_SLOTS_800859e4,0,0,0);
  }
  return;
}



void FUN_80047a58(void)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  int iVar4;

  iVar4 = -1;
  if ((DAT_8009aa30 & 1) == 0) {
    if (DAT_8009aa36 != 0) {
      iVar4 = FUN_8003ddac();
      DAT_8009aa3e = DAT_8009aa36;
      DAT_8009aa40 = DAT_8009aa38;
    }
  }
  else {
    DAT_8009aa3e = DAT_8009aa36;
    DAT_8009aa40 = DAT_8009aa38;
    uVar1 = DAT_8009aa30 & 0xfffffffe;
    if ((DAT_8009aa30 & 2) == 0) {
      uVar1 = DAT_8009aa30 & 0xfffffffa;
    }
    DAT_8009aa30 = uVar1;

    switch(DAT_8009aa36)
	{
    case 1:
	  // MEMCARD_GetInfo
      iVar4 = FUN_8003e238((int)DAT_8009aa38);
      break;
    case 2:
	  // MEMCARD_Save
      iVar4 = FUN_8003e344((int)DAT_8009aa38,DAT_8009aa48,DAT_8009aa4c,DAT_8009aa50,
                           (int)DAT_8009aa54,0);
      break;
    case 3:
	  // MEMCARD_Load
      iVar4 = FUN_8003e29c((int)DAT_8009aa38,DAT_8009aa48,DAT_8009aa50,(int)DAT_8009aa54,0);
      break;

    case 4:
      // MEMCARD_Format
	  iVar4 = FUN_8003e51c((int)DAT_8009aa38);
      break;

    case 5:
	  // MEMCARD_EraseFile (unused)
      iVar4 = FUN_8003e6d4((int)DAT_8009aa38,DAT_8009aa48);
    }
  }
  iVar2 = iVar4 << 0x10;

  if (
		(DAT_8009aa36 == 1) &&
		(
			iVar3 = iVar2 >> 0x10,
			iVar2 = iVar4 << 0x10,
			iVar3 == 3
		)
	  )
  {
    iVar4 = 0;

	// Set number of ghost profiles to zero
    DAT_8009aa5c = 0;

	// 80085a44
	// BASCUS-94426G*
	// MEMCARD_FindFirstGhost
    iVar3 = FUN_8003e600((int)DAT_8009aa38,s_BASCUS_94426G__80085a44);

	iVar2 = 0;

	// loop until you have gone through all memory card saves
    while (iVar3 != 0)
	{
	  // If there are less than 7 ghosts loaded
      if (iVar2 >> 0x10 < 7)
	  {
		// GhostData_LoadProfile
        FUN_80047034(&DAT_8009aa60 + (iVar2 >> 0x10) * 0x34);

		// increment ghost counter
        DAT_8009aa5c = DAT_8009aa5c + 1;
      }

	  // increment number of ghosts loaded
      iVar4 = iVar4 + 1;

	  // MEMCARD_FindNextGhost
      iVar3 = FUN_8003e678();

	  // bitshifted version of numGhosts
      iVar2 = iVar4 * 0x10000;
    }

	// slotIndex, and saveName
	FUN_8003e59c((int)DAT_8009aa38,DAT_8009aa48);

    DAT_8009aa30 = DAT_8009aa30 | 8;

	// slotIndex, and saveName
    iVar2 = FUN_8003e59c((int)DAT_8009aa38,DAT_8009aa48);

	iVar2 = iVar2 << 0x10;
  }
  switch(iVar2 >> 0x10) {
  
  // from MEMCARD_GetNextSlot1Event == IOE (processing done)
  case 0:
    DAT_8009aa34 = 7;
    if ((DAT_8009aa36 == 1) && (DAT_8009aa34 = 4, (DAT_8009aa30 & 8) == 0)) {
      DAT_8009aa34 = 7;
    }
    break;
  
  // from MEMCARD_GetInfo, 
  // from MEMCARD_Save if seek() fails or write() fails
  // from MEMCARD_Load if seek() fails or read() fails
  // from MEMCARD_GetNextSlot1Event fail (ERROR, bad card)
  case 1:
    DAT_8009aa34 = 2;
    break;
	
  // from MEMCARD_GetNextSlot1Event fail (TIMEOUT, no card)
  case 2:
    DAT_8009aa34 = 0;
    DAT_8009aa36 = 0;
    goto switchD_80047c84_caseD_8;
  
  // from MEMCARD_GetNextSlot1Event fail (NEWCARD)
  case 3:
    DAT_8009aa34 = 3;
    if (DAT_8009aa36 == 4) {
      DAT_8009aa34 = 7;
    }
    break;
  
  // from MEMCARD_Save if open() fails
  case 4:
    DAT_8009aa34 = 1;
    break;
  
  // from FUN_8003ddac
  case 5:
    DAT_8009aa34 = 6;
    break;
  
  // from MEMCARD_Load if open() fails
  case 6:
    DAT_8009aa34 = 5;
    break;
  
  // from MEMCARD_GetInfo, 
  // from MEMCARD_Save if write() works
  // from MEMCARD_Load if read() works
  case 7:
    DAT_8009aa34 = 8;
	
  default:
    goto switchD_80047c84_caseD_8;
  }
  
  DAT_8009aa36 = 0;
  
switchD_80047c84_caseD_8:
  
  if ((DAT_8009aa36 == 0) && (DAT_8009aa3a != 0)) {
    DAT_8009aa36 = DAT_8009aa3a;
    DAT_8009aa3a = 0;

	// slotIndex
	DAT_8009aa38 = DAT_8009aa3c;

    DAT_8009aa30 = DAT_8009aa30 & 0xfffffffd | 1;
  }
  return;
}

// spammed in main menu, adv arena, and end-of-race
// supposedly triggers memcard routines. if noped, game hangs at CHECKING... screen
// the 2 functions are only called here.
void FUN_80047d64(void)
{
  // if PauseAllThreads is diabled
  if ((*(uint *)PTR_DAT_8008d2ac & 0x10) == 0)
  {
    FUN_80047a58();

	// Handles BASCUS-94426-SLOTS file for
	// Adventure saves and time trial scores
    FUN_800472d0();
  }
  return;
}

// LoadSave_LoadProfileFromHub_MenuBoxFuncPtr
void FUN_80047da8(undefined4 param_1)

{
  undefined *puVar1;

  // main structure of game
  puVar1 = PTR_DAT_8008d2ac;

  // set level ID to main menu
  *(undefined4 *)(PTR_DAT_8008d2ac + 0x1a10) = 0x27;

  // change character ID to icon ID
  DAT_80086e84 = DAT_8008fbce;

  // Load AdvHub LEV depending on new profile
  FUN_8003cfc0((int)*(short *)(puVar1 + 0x1eb0));

  // make MenuBox invisible
  FUN_800469c8(param_1);
  return;
}


// LoadSave_ThTick
void FUN_80047dfc(int param_1)

{
  int iVar1;
  int iVar2;
  int *piVar3;
  int *piVar4;
  ushort uVar5;
  undefined2 local_28;
  undefined2 local_26;
  undefined2 local_24;

  uVar5 = 0;
  piVar4 = *(int **)(*(int *)(param_1 + 0x30) + 4);
  piVar3 = piVar4 + 1;

  // loop through 12 instances,
  // 3 per profile, 4 profiles
  do {
    iVar2 = (int)(short)uVar5;
    iVar1 = (iVar2 % 3) * 0x10000 >> 0x10;
    *(short *)((int)piVar3 + 2) = *(short *)((int)piVar3 + 2) + (&DAT_8008d47c)[iVar1];

	 // convert 3 rotation shorts into rotation matrix
    FUN_8006c2a4(*piVar4 + 0x30,piVar3);

    if (iVar1 != 1)
	{
	  // from MetaDataSaveLoad
      local_28 = (&DAT_80085c68)[iVar2 * 7];
      local_26 = (&DAT_80085c6a)[iVar2 * 7];
      local_24 = (&DAT_80085c6c)[iVar2 * 7];

	  // Vector_SpecLightSpin3D
      FUN_8005741c(*piVar4,piVar3,&local_28);
    }

    uVar5 = uVar5 + 1;
    piVar3 = piVar3 + 3;
    piVar4 = piVar4 + 3;
  } while (uVar5 < 0xc);
  return;
}


// LoadSave_PrintInteger
void FUN_80047f20(undefined4 param_1,short param_2,short param_3,short param_4,short param_5)

{
  // format of sprintf
  char *fmt;

  // char array for generated sprintf message
  char acStack80 [64];

  if (param_4 == 1)
  {
	// %02ld
    fmt = s__02ld_8008d484;
  }
  else
  {
	// %ld
    fmt = &DAT_8008d48c;
  }

  // convert param_1 to string
  sprintf(acStack80,fmt,param_1);

  // Draw string
  FUN_80022878(acStack80,(int)param_2,(int)param_3,1,(int)param_5);
  return;
}


// LoadSave_UI_ConvertX
int FUN_80047fb8(int param_1,int param_2)

{
  param_2 = (param_1 + -0x100) * param_2;
  if (param_2 < 0) {
    param_2 = param_2 + 0xff;
  }
  return param_2 >> 8;
}


// LoadSave_UI_ConvertY
int FUN_80047fd8(int param_1,int param_2)

{
  param_2 = (param_1 + -0x6c) * param_2;
  if (param_2 < 0) {
    param_2 = param_2 + 0xff;
  }
  return param_2 >> 8;
}


// LoadSave_DrawAdvProfile
void FUN_80047ff8(int param_1,int param_2,int param_3,short param_4,short param_5,ushort param_6)

{
  int iVar1;
  undefined4 *puVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  int iVar7;
  uint uVar8;
  int iVar9;
  undefined4 uVar10;
  undefined4 local_58;
  short local_50;
  short local_4e;
  undefined2 local_4c;
  undefined2 local_4a;
  short local_48;
  short local_46;
  undefined2 local_44;
  undefined2 local_42;
  short local_40;
  ushort local_38;
  ushort local_30;

  local_30 = param_6;
  if ((param_6 & 0x10) == 0) {
    uVar8 = 0;
    uVar3 = 3;
    uVar6 = 1;
    uVar10 = 4;
  }
  else {
    uVar8 = 0x1d;
    uVar3 = 0x1e;
    uVar6 = 0x1d;
    uVar10 = 0x1d;
  }
  local_38 = param_5 * 3;
  local_40 = param_4;
  
  // GAMEPROG_AdvPercent
  FUN_800265c0(param_1);
  
  local_4e = (short)param_3;
  local_50 = (short)param_2;

  // If Adventure Profile is empty
  if (*(short *)(param_1 + 0x2a) < 0)
  {
	// DAT_8008d878 + 0x2d4
	// EMPTY
    FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x2d4),(param_2 + 0x6c) * 0x10000 >> 0x10,
                 (param_3 + 0x17) * 0x10000 >> 0x10,1,uVar3 | 0xffff8000);
  }

  // If Adventure Profile is not empty
  else {
    iVar1 = (int)local_50;
    if ((local_30 & 0x10) == 0)
	{
	  // grey
      local_58 = DAT_8008d490;
    }
    else
	{
	  // black
      local_58 = DAT_8008d494;
    }

    iVar9 = (int)local_4e;

	// Character Icon
	// MenuBox_DrawPolyGT4
    FUN_80044ef8(*(undefined4 *)
                  (PTR_DAT_8008d2ac +
                  (int)*(short *)(&DAT_80086d8c + (int)*(short *)(param_1 + 0x2a) * 0x10) * 4 +
                  0x1eec),iVar1 + 10,iVar9 + 6,

				  // pointer to PrimMem struct
				  *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

				 // pointer to OT mem
				  *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				  local_58,local_58,local_58,local_58,1,
                  0x1000);

	// Draw String
	FUN_80022878(param_1 + 0x18,(param_2 + 0x6c) * 0x10000 >> 0x10,
                 (param_3 + 0x29) * 0x10000 >> 0x10,1,uVar6 | 0xffff8000);

	// X position to draw
    iVar4 = (param_2 + 0x6a) * 0x10000 >> 0x10;

	// Y position to draw
    iVar7 = (param_3 + 0x17) * 0x10000 >> 0x10;

	// Color to draw
    uVar8 = uVar8 | 0x4000;

	// (PTR_DAT_8008d2ac + 0x1e54) is percentage of completion (0 - 101)
	// Convert to a string and draw
    FUN_80047f20(*(undefined4 *)(PTR_DAT_8008d2ac + 0x1e54),iVar4,iVar7,0,uVar8);

	// Y position to draw
    iVar5 = (param_3 + 5) * 0x10000 >> 0x10;

	// (PTR_DAT_8008d2ac + 0x1e30) is the number of trophies
	// Convert to a string and draw
    FUN_80047f20(*(undefined4 *)(PTR_DAT_8008d2ac + 0x1e30),iVar4,iVar5,0,uVar8);

	// X position to draw
    iVar4 = (param_2 + 0xb5) * 0x10000 >> 0x10;

	// (PTR_DAT_8008d2ac + 0x1e38) is the number of keys
	// Convert to a string and draw
    FUN_80047f20(*(undefined4 *)(PTR_DAT_8008d2ac + 0x1e38),iVar4,iVar5,0,uVar8);

	// (PTR_DAT_8008d2ac + 0x1e34) is the number of relics
	// Convert to a string and draw
    FUN_80047f20(*(undefined4 *)(PTR_DAT_8008d2ac + 0x1e34),iVar4,iVar7,0,uVar8);

	// Draw Name of profile
    FUN_80022878(&DAT_8008d498,(param_2 + 0x70) * 0x10000 >> 0x10,iVar7,1,uVar10);

	// convert x
    uVar10 = FUN_80047fb8(iVar1 + 0xc3,0x100);
    iVar5 = (int)(short)local_38 * 0xc;
    *(undefined4 *)(*(int *)(iVar5 + *(int *)(DAT_8008d8f4 + 4)) + 0x44) = uVar10;

	// convert y
	uVar10 = FUN_80047fd8(iVar9 + 0x1f,0x100);
    iVar4 = DAT_8008d8f4;
    *(undefined4 *)(*(int *)(iVar5 + *(int *)(DAT_8008d8f4 + 4)) + 0x48) = uVar10;
    *(undefined4 *)(*(int *)(iVar5 + *(int *)(iVar4 + 4)) + 0x4c) = 0x100;
    iVar4 = *(int *)(iVar5 + *(int *)(iVar4 + 4));

	// make visible
    *(uint *)(iVar4 + 0x28) = *(uint *)(iVar4 + 0x28) & 0xffffff7f;

	// convert x
	uVar10 = FUN_80047fb8(iVar1 + 0x78,0x100);
    uVar3 = (uint)local_38;
    iVar5 = ((int)((uVar3 + 1) * 0x10000) >> 0x10) * 0xc;
    *(undefined4 *)(*(int *)(iVar5 + *(int *)(DAT_8008d8f4 + 4)) + 0x44) = uVar10;

	// convert y
	uVar10 = FUN_80047fd8(iVar9 + 0xd,0x100);
    iVar4 = DAT_8008d8f4;
    *(undefined4 *)(*(int *)(iVar5 + *(int *)(DAT_8008d8f4 + 4)) + 0x48) = uVar10;
    *(undefined4 *)(*(int *)(iVar5 + *(int *)(iVar4 + 4)) + 0x4c) = 0x100;
    iVar4 = *(int *)(iVar5 + *(int *)(iVar4 + 4));

	// make visible
    *(uint *)(iVar4 + 0x28) = *(uint *)(iVar4 + 0x28) & 0xffffff7f;

	// convert x
    uVar10 = FUN_80047fb8(iVar1 + 0xc3,0x100);
    iVar4 = ((int)((uVar3 + 2) * 0x10000) >> 0x10) * 0xc;
    *(undefined4 *)(*(int *)(iVar4 + *(int *)(DAT_8008d8f4 + 4)) + 0x44) = uVar10;

	// convert y
	uVar10 = FUN_80047fd8(iVar9 + 0xd,0x100);
    iVar1 = DAT_8008d8f4;
    *(undefined4 *)(*(int *)(iVar4 + *(int *)(DAT_8008d8f4 + 4)) + 0x48) = uVar10;
    *(undefined4 *)(*(int *)(iVar4 + *(int *)(iVar1 + 4)) + 0x4c) = 0x100;
    iVar1 = *(int *)(iVar4 + *(int *)(iVar1 + 4));

	// make visible
    *(uint *)(iVar1 + 0x28) = *(uint *)(iVar1 + 0x28) & 0xffffff7f;
  }
  local_4c = 0xdc;
  local_4a = 0x3d;
  if (local_40 != 0)
  {
	// highlight
    puVar2 = &DAT_8008d94c;

	// if green load/save
    if ((local_30 & 0x10) != 0)
	{
	  // highlight
      puVar2 = &DAT_8008d948;
    }

    local_48 = local_50 + 6;
    local_46 = local_4e + 4;
    local_44 = 0xd0;
    local_42 = 0x35;

	// CTR_Box_DrawClearBox
    FUN_8002177c(&local_48,puVar2,1,

					*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0) + 0xc,

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);
  }

  // Draw 2D Menu rectangle background
  FUN_800457b0(&local_50,(int)(short)local_30,
               *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0) + 0xc);
  return;
}


// LoadSave_GetTrackID
void FUN_800485a8(void)

{
  DAT_80085b76 = 1;

  // level ID
  DAT_8008fbd2 = *(undefined2 *)(PTR_DAT_8008d2ac + 0x1a10);

  return;
}


// LoadSave_Init
void FUN_800485cc(uint param_1)
{
  bool bVar1;
  byte bVar2;
  undefined2 uVar3;
  undefined *puVar4;
  int iVar5;
  uint uVar6;
  int iVar7;
  int iVar8;
  byte *pbVar9;
  int *piVar10;
  int *piVar11;
  ushort uVar12;
  short *psVar13;

  // if loadsave object does not exist
  if (DAT_8008d8f4 == (int *)0x0)
  {
	// THREAD_BirthWithObject
	// 0x8 = size
	// 0 = no relation to param4
	// 0x300 flag = SmallStackPool
	// 0xd = "other" thread bucket
    iVar5 = FUN_8004205c(0x8030d,FUN_80047dfc,"LoadSave",0);

	// Get the object attached to the thread
	// store object globally
    DAT_8008d8f4 = *(int **)(iVar5 + 0x30);

    DAT_8008d8f4[1] = -0x7ff65660; // 0x8009A9A0
    memset(&DAT_8009a9a0,0,0x90);

	// check if creation failed
    bVar1 = DAT_8008d8f4 == (int *)0x0;

	// store thread in object
    *DAT_8008d8f4 = iVar5;

	// if creation failed
    if (bVar1) {
      return;
    }
  }

  // Instances MetaData
  psVar13 = &DAT_80085c64;

  uVar12 = 0;
  piVar10 = (int *)DAT_8008d8f4[1];
  pbVar9 = &DAT_80085c70;
  piVar11 = piVar10 + 2;
  do {
    if (*piVar10 == 0) {
      if (*(int *)(PTR_DAT_8008d2ac + (int)*psVar13 * 4 + 0x2160) != 0)
	  {
		// INSTANCE_Birth3D -- ptrModel, name, thread
        iVar5 = FUN_8003086c(*(int *)(PTR_DAT_8008d2ac + (int)*psVar13 * 4 + 0x2160),"loadsave",
                             *DAT_8008d8f4);
        *piVar10 = iVar5;
		
		// if instance exists
        if (iVar5 != 0) 
		{
		  // flags
          uVar6 = *(uint *)(iVar5 + 0x28);
          *(uint *)(iVar5 + 0x28) = uVar6 | 0x480;
          if (((int)(short)uVar12 % 3) * 0x10000 >> 0x10 != 1) {
            *(uint *)(iVar5 + 0x28) = uVar6 | 0x20480;
          }
          puVar4 = PTR_DAT_8008d2ac;

		  // instance -> InstDrawPerPlayer[0].tileView = TileView_UI
          *(undefined **)(iVar5 + 0x74) = PTR_DAT_8008d2ac + 5000;

		  iVar8 = 1;

		  // if more than 1 screen
          if (1 < (byte)puVar4[0x1ca8])
		  {
            iVar7 = 0x10000;
			
			// every InstDrawPerPlayer (except for first)
            do 
			{
			  // loop index
              iVar8 = iVar8 + 1;
			  
			  // erase tileView
              *(undefined4 *)(iVar5 + (iVar7 >> 0x10) * 0x88 + 0x74) = 0;
			  
              iVar7 = iVar8 * 0x10000;
            } while (iVar8 * 0x10000 >> 0x10 < (int)(uint)(byte)puVar4[0x1ca8]);
          }

          if ((param_1 & 0x10) == 0) {
            bVar2 = *pbVar9;
            uVar6 = (uint)pbVar9[-2] << 0x14 | (uint)pbVar9[-1] << 0xc;
          }
          else {
            uVar6 = (uint)(pbVar9[-2] >> 1) << 0x14 | (uint)pbVar9[-1] << 0xc;
            bVar2 = *pbVar9 >> 1;
          }
          *(uint *)(iVar5 + 0x24) = uVar6 | (uint)bVar2 << 4;
          uVar3 = (&DAT_80085c66)[(int)(short)uVar12 * 7];

		  // scale (x, y, z)
		  *(undefined2 *)(iVar5 + 0x20) = uVar3;
          *(undefined2 *)(iVar5 + 0x1e) = uVar3;
          *(undefined2 *)(iVar5 + 0x1c) = uVar3;

          *(undefined2 *)((int)piVar11 + -2) = 0;
          *(undefined2 *)(piVar11 + -1) = 0;
          *(undefined2 *)piVar11 =
               *(undefined2 *)((int)&DAT_80085d0c + (((int)(short)uVar12 % 3) * 0x10000 >> 0xf));

		  // set rotation (5 direction vectors)
		  *(undefined4 *)(iVar5 + 0x30) = 0x1000;
          *(undefined4 *)(iVar5 + 0x34) = 0;
          *(undefined4 *)(iVar5 + 0x38) = 0x1000;
          *(undefined4 *)(iVar5 + 0x3c) = 0;
          *(undefined2 *)(iVar5 + 0x40) = 0x1000;
        }
      }
      if (*piVar10 != 0) goto LAB_80048878;
    }
    else {
LAB_80048878:

	  // make invisible
      *(uint *)(*piVar10 + 0x28) = *(uint *)(*piVar10 + 0x28) | 0x80;
    }
    uVar12 = uVar12 + 1;
    piVar11 = piVar11 + 3;
    piVar10 = piVar10 + 3;
    pbVar9 = pbVar9 + 0xe;
    psVar13 = psVar13 + 7;
    if (0xb < uVar12) {
      return;
    }
  } while( true );
}


// LoadSave_Destroy
void FUN_800488e0(void)

{
  int iVar1;
  ushort uVar2;
  int *piVar3;

  // if loadsave object exists
  if (DAT_8008d8f4 != (int *)0x0) {
    piVar3 = (int *)DAT_8008d8f4[1];

	// loop iteration counter
    uVar2 = 0;

	// destroy 12 instances, for LoadSave's
	// 4x trophy, 4x relic, and 4x key

	// for uVar2 = 0; uVar2 < 0xc; uVar2++
	do
	{
      if (*piVar3 != 0)
	  {
		// INSTANCE_Death
        FUN_80030aa8();
      }

	  // increment loop counter
      uVar2 = uVar2 + 1;
      piVar3 = piVar3 + 3;

    } while (uVar2 < 0xc);

	// get pointer to thread, from object
    iVar1 = *DAT_8008d8f4;

	// erase pointer to object
    DAT_8008d8f4 = (int *)0x0;

	// 0x800 = this thread needs to be deleted
    *(uint *)(iVar1 + 0x1c) = *(uint *)(iVar1 + 0x1c) | 0x800;
  }
  return;
}

// "OneProfile" means you see one profile on screen,
// and four options (load/save/delete/exit)

// LoadSave_OneProfile_MenuBoxFuncPtr
void FUN_80048960(int param_1)

{
  short sVar1;

  // if have not chosen any option
  // if you see current profile, and load/save/delete/exit rows
  if (*(short *)(param_1 + 0x1e) != 0)
  {
	// LoadSave_Init
    FUN_800485cc((int)*(short *)(param_1 + 0x14));

	// 0x8fba4 is where the adventure profile (currently loaded) begins

	// Draw Adventure Profile
    FUN_80047ff8(&DAT_8008fba4,0x92,0x32,0,0,0x10);

	// exit the function
    return;
  }

  // only here if you chose one of the rows (save/load/delete/exit)

  // get value of row selected
  sVar1 = *(short *)(param_1 + 0x1a);

  // no submenu can have more than 3 rows

  // if submenu row is less than 3
  if (sVar1 < 3) {

	// if row is more or equal to zero
    if (-1 < sVar1)
	{
	  // Set Load/Save to "Green" mode,
	  // remembering the last selected row
      FUN_80048e2c((int)(short)(*(ushort *)(param_1 + 0x1a) | 0x20));

	  // Set MenuBox to a menu box
	  // that draws four adv profiles
	  DAT_8008d924 = &DAT_80085b88;

	  return;
    }

	// if row is invalid, return
    if (sVar1 != -1) {
      return;
    }
  }

  // if row is not 3, invalid row
  else {
    if (sVar1 != 3) {
      return;
    }
  }

  // does that mean row = 3 (4th row) is valid??

  // make MenuBox invisible
  FUN_800469c8(param_1);

  // LoadSave_Destroy
  FUN_800488e0();

  return;
}


// Draw Profile
void FUN_80048a30(int param_1,short param_2,short param_3,short param_4,undefined4 param_5,
                 ushort param_6,short param_7,short param_8)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 *puVar3;
  short local_38;
  short local_36;
  undefined2 local_34;
  undefined2 local_32;
  short local_30;
  short local_2e;
  undefined2 local_2c;
  undefined2 local_2a;

  local_34 = 200;
  local_32 = 0x29;
  local_30 = param_2 + 6;
  local_2e = param_3 + 3;
  local_2c = 0xbc;
  local_2a = 0x23;
  local_38 = param_2;
  local_36 = param_3;

  if (param_8 != 0)
  {
	// DAT_8008d878 + 0x1b4
	// NOT AVAILABLE
    FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x1b4),(int)(short)(param_2 + 100),
                 (int)(short)(param_3 + 0x11),2,0xffff8016);

	// CTR_Box_DrawClearBox
    FUN_8002177c(&local_30,&DAT_8008d49c,2,

					*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0),

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);
  }

  // If there is no ghost data
  if (param_1 == 0)
  {
    // If you are saving a ghost
	if (param_7 == 0)
	{
	  // DAT_8008d878 + 0x2d4
	  // EMPTY
      uVar1 = *(undefined4 *)(DAT_8008d878 + 0x2d4);
    }

	// If you are loading a ghost
	else
	{
	  // DAT_8008d878 + 0x1b0
	  // NO GHOST
      uVar1 = *(undefined4 *)(DAT_8008d878 + 0x1b0);
    }
    uVar2 = 0xffff8001;
    if (param_7 == 0) {
      uVar2 = 0xffff8003;
    }
    FUN_80022878(uVar1,(int)(short)(param_2 + 100),(int)(short)(param_3 + 0x11),2,uVar2);
  }

  // If Ghost data is valid
  else
  {
	// Draw name of player that saved the ghost (from OSK screen)
    FUN_80022878(*(undefined4 *)
                  ((int)*(short *)(&DAT_80083a88 + (int)*(short *)(param_1 + 0x28) * 0x18) * 4 +
                  DAT_8008d878),(int)(short)(param_2 + 100),(int)(short)(param_3 + 0x1e),2,
                 0xffff801d);

	// make a string with amount of time
    uVar1 = FUN_80044ff8(*(undefined4 *)(param_1 + 0x30));

	// Draw String
    FUN_80022878(uVar1,(int)(short)(param_2 + 0x78),(int)(short)(param_3 + 10),1,0xffff8001);

	// character icon
	// MenuBox_DrawPolyGT4
    FUN_80044ef8(*(undefined4 *)
                  (PTR_DAT_8008d2ac +
                  (int)*(short *)(&DAT_80086d8c + (int)*(short *)(param_1 + 0x2a) * 0x10) * 4 +
                  0x1eec),(int)param_2 + 8,(int)param_3 + 5,

				  // pointer to PrimMem struct
				  *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

				  // pointer to OT mem
				  *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				  DAT_8008d4a0,DAT_8008d4a0,DAT_8008d4a0,
                 DAT_8008d4a0,1,0x1000);
  }

  if (param_4 != 0)
  {
	// normal highlight
    puVar3 = &DAT_8008d94c;

	// if load/save screen
	if ((param_6 & 0x10) != 0)
	{
	  // green highlight
      puVar3 = &DAT_8008d948;
    }

	// CTR_Box_DrawClearBox
    FUN_8002177c(&local_30,puVar3,1,

					*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0),

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);
  }

  // Draw 2D Menu rectangle background
  FUN_800457b0(&local_38,(int)(short)param_6,
               *(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0));
  return;
}


// LoadSave_MuteCursors
void FUN_80048da0(void)

{
  // offset 8 of MenuBox_DrawSelfFourAdvProfiles
  DAT_80085b90 = DAT_80085b90 | 0x800000;

  // offset 8 of menuBox_GhostSelection
  DAT_80085bbc = DAT_80085bbc | 0x800000;

  // offset 8 of menuBox_warning
  DAT_80085be8 = DAT_80085be8 | 0x800000;
  return;
}


// LoadSave_UnMuteCursors
void FUN_80048de4(void)

{
  // offset 8 of MenuBox_DrawSelfFourAdvProfiles
  DAT_80085b90 = DAT_80085b90 & 0xff7fffff;

  // offset 8 of menuBox_GhostSelection
  DAT_80085bbc = DAT_80085bbc & 0xff7fffff;

  // offset 8 of menuBox_warning
  DAT_80085be8 = DAT_80085be8 & 0xff7fffff;
  return;
}


// LoadSave_ToggleMode
void FUN_80048e2c(undefined4 param_1)

{
  // remember last row selected
  DAT_8008d978 = (ushort)param_1 & 0xf;

  // 0x00 - AdvNew (garage) mode
  // 0x10 - AdvLoad (main menu) mode
  // 0x20 - Green mode
  // 0x30 - Ghost mode
  // 0x40 - SlotSelected (exiting) mode
  DAT_8008d8f8 = (ushort)param_1 & 0xf0;

  DAT_8008d8fc = 0;
  DAT_8008d8fe = 0;
  DAT_8008d900 = 0;
  DAT_8008d902 = 0;
  DAT_8008d904 = 0;

  // LoadSave_UnMuteCursors
  FUN_80048de4();

  DAT_80085b9c = DAT_80085b9c & 0xffef;
  DAT_80085d44 = DAT_80085d44 & 0xffef;
  if (DAT_8008d8f8 == 0x20) {
    DAT_80085b9c = DAT_80085b9c | 0x10;
    DAT_80085d44 = DAT_80085d44 | 0x10;
  }

  // LoadSave_Init
  FUN_800485cc((int)(short)DAT_80085b9c);

  DAT_80085ba2 = DAT_8008d73c;
  DAT_8008d8fa = 0;
  return;
}


// LoadSave_InitAndDestroy
void FUN_80048edc(void)

{
  // LoadSave_Init
  FUN_800485cc((int)DAT_80085b9c);

  // LoadSave_Destroy
  FUN_800488e0();
  return;
}


// LoadSave_InputLogic
uint FUN_80048f0c(int param_1,short param_2,uint param_3)

{
  bool bVar1;
  ushort uVar2;
  ushort uVar3;
  short sVar4;
  uint uVar5;

  uVar5 = 0;

  // If you press D-Pad, Cross, Square, Triangle, Circle
  if ((DAT_8009a990 & 0x4007f) != 0)
  {
    if ((param_3 & 1) == 0)
	{
	  // get which row is selected
      uVar2 = *(ushort *)(param_1 + 0x1a);

      uVar3 = uVar2 - 2;

      if (
			(
				// If you press Up
				((DAT_8009a990 & 1) != 0) ||
				(
					uVar3 = uVar2 + 2,

					// If you press Down
					(DAT_8009a990 & 2) != 0
				)
			) ||
			(
				uVar3 = uVar2 ^ 1,

				// If you press Left or Right
				(DAT_8009a990 & 0xc) != 0
			)
		  )
	  {
        *(ushort *)(param_1 + 0x1a) = uVar3;
      }

	  // get row selected
      sVar4 = *(short *)(param_1 + 0x1a);

	  // if row is less than zero
	  if (sVar4 < 0)
	  {
		// make the new value zero
        *(undefined2 *)(param_1 + 0x1a) = 0;

		// refresh
        sVar4 = *(short *)(param_1 + 0x1a);
      }

	  // maybe?
	  // alter row selected, if there is no empty slot
      if (param_2 <= sVar4) {
        *(short *)(param_1 + 0x1a) = param_2 + -1;
      }


      if (*(ushort *)(param_1 + 0x1a) != uVar2)
	  {
		// OtherFX_Play
        FUN_80028468(0,1);
      }

      if (
			// If you do not press Cross or Circle
			((DAT_8009a990 & 0x50) == 0) ||
			(
				(
					param_2 == 0 &&

					// if you are not saving data
					(DAT_8008d978 != 1)
				)
			)
		 )
	  {
		// If you press Triangle or Square
        if ((DAT_8009a990 & 0x40020) != 0)
		{
		  // OtherFX_Play
          FUN_80028468(2,1);

          uVar5 = 1;

		  // row selected is -1, so we know to reinitialize
		  // the menu when we return to it next time
          *(undefined2 *)(param_1 + 0x1a) = 0xffff;
        }
      }

	  // If you do not press Cross or Circle
      else
	  {
		// OtherFX_Play
        FUN_80028468(1,1);

        uVar5 = 1;

        if (DAT_8008d47a == 1)
		{
		  // back to the first row
          *(undefined2 *)(param_1 + 0x1a) = 0;
        }
      }
    }

	// param_3 & 1
    else
	{
	  // If you press Triangle or Square
      bVar1 = (DAT_8009a990 & 0x40020) != 0;

	  // Triangle or Square
      if (bVar1)
	  {
		// OtherFX_Play
        FUN_80028468(2,1);

		// row selected is -1, so we know to reinitialize
		// the menu when we return to it next time
		*(undefined2 *)(param_1 + 0x1a) = 0xffff;
      }

      uVar5 = (uint)bVar1;

      if (
			((param_3 & 2) != 0) &&

			// If you press Cross or Circle
			((DAT_8009a990 & 0x50) != 0)
		 )
	  {
		// OtherFX_Play
        FUN_80028468(1,1);

        uVar5 = 1;
      }
    }

	// clear gamepad input (for menus)
    FUN_80046404();
  }
  return uVar5;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// Used to draw four Adventure Profiles
// Load, Save, Delete, etc, also used to
// draw Ghost Profiles in Time Trial

// LoadSave_AllProfiles_MenuBoxFuncPtr
void FUN_800490c4(int param_1)

{
  bool bVar1;
  bool bVar2;
  undefined *puVar3;
  undefined uVar4;
  short sVar5;
  undefined4 *puVar6;
  undefined4 *puVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  undefined4 *puVar11;
  int iVar12;
  undefined4 *puVar13;
  ushort uVar14;
  undefined4 uVar15;
  undefined4 uVar16;
  undefined4 uVar17;
  uint uVar18;
  ushort uVar19;
  undefined *puVar20;
  uint uVar21;
  short sVar22;
  int iVar23;
  uint uVar24;
  short local_58;
  short local_56 [3];
  ushort local_50;
  ushort local_48;
  short local_40;
  ushort local_38;
  ushort local_30;

  local_50 = 0;
  if ((*(ushort *)(param_1 + 0x14) & 0x10) != 0) {
    local_50 = 0x1d;
  }
  uVar24 = 0;

  // DAT_8009aa5c = number of ghosts saved
  local_48 = DAT_8009aa5c;

  bVar2 = false;
  local_40 = 0;
  if (DAT_8008d47a == 0) {
    DAT_8008d900 = 0;
  }
  if (DAT_8008d47a < 2) {
    DAT_8008d8fa = 0;
  }

  // LoadSave_UnMuteCursors
  FUN_80048de4();

  if (((DAT_8008d8fc != 0) || (DAT_8008d8fe != 0)) || (DAT_8008d8fa != 0))
  {
    // LoadSave_MuteCursors
	FUN_80048da0();
  }

  if (DAT_8008d900 != 0)
  {
	// If you press D-pad or Cross, Square, Triangle, Circle
    if ((DAT_8009a990 & 0x4007f) != 0) {

	  // If you dont press Up
      if ((DAT_8009a990 & 1) == 0) {

		// If you dont press Down
        if ((DAT_8009a990 & 2) == 0) {

		  // If you press Cross, Square, Triangle, Circle
          if ((DAT_8009a990 & 0x40070) != 0) {

			// If you dont press Cross or Circle
			// If you press Triangle or Square
            if ((DAT_8009a990 & 0x50) == 0)
			{
			  // OtherFX_Play
              FUN_80028468(2,1);
            }

			// If you press Cross or Circle
            else
			{
			  // OtherFX_Play
              FUN_80028468(1,1);

              if (DAT_80085d4a == 0) {
                bVar2 = true;
              }
            }
            DAT_8008d900 = 0;
          }
        }

		// If you press Down
		else {
          if (DAT_80085d4a < 1)
		  {
			// OtherFX_Play
            FUN_80028468(0,1);

            DAT_80085d4a = DAT_80085d4a + 1;
          }
        }
      }

	  // If you press Up
	  else
	  {
		// If there is room to move up
        if (0 < DAT_80085d4a)
		{
		  // OtherFX_Play
          FUN_80028468(0,1);

		  // Move up
          DAT_80085d4a = DAT_80085d4a + -1;
        }
      }

	  // clear gamepad input (for menus)
      FUN_80046404();

	  DAT_80085d76 = DAT_80085d4a;
    }
    goto LAB_800499e4;
  }

  // If this is "Choose a Ghost" screen in Time Trial
  if (DAT_8008d8f8 == 0x30)
  {
	// If you are saving
    if (DAT_8008d978 == 1)
	{
	  // if enough room remains on memory card to save ghost
      uVar24 = (uint)((int)DAT_8008d8ac < 0x3e00) ^ 1;

	  // bool is enough room left
	  local_40 = (short)uVar24;

	  // DAT_8009aa5c = number of ghosts saved
      uVar24 = DAT_8009aa5c + uVar24;

	  // DAT_8009aa5c = number of ghosts saved
      local_48 = DAT_8009aa5c;

	  // if attempted to save more than 7 ghosts
      if (7 < (int)(uVar24 * 0x10000) >> 0x10)
	  {
		// assume only 7 are saved
        uVar24 = 7;

		// can't save another
        local_40 = 0;
      }
    }

	// if you are loading
    else {
      local_40 = 1;

	  // number of ghsots saved, plus 1,
	  // which should be the first "empty" slot
      uVar24 = (uint)local_48 + 1;
    }

	// if your row selected is negative
    if (*(short *)(param_1 + 0x1a) < 0)
	{
	  // reset to zero
      *(undefined2 *)(param_1 + 0x1a) = 0;
    }

	// compare against the row selected
    if ((short)uVar24 <= *(short *)(param_1 + 0x1a)) {
      *(short *)(param_1 + 0x1a) = (short)uVar24 + -1;
    }
  }

  if (DAT_8008d8fa != 0) goto LAB_800499e4;
  iVar10 = 0;
  if ((DAT_8008d8f8 == 0x30) && (DAT_8008d900 == 0)) {
    iVar10 = (int)(short)uVar24;
    iVar23 = 0;
LAB_800495a0:

	// LoadSave_InputLogic
    iVar10 = FUN_80048f0c(param_1,iVar10,iVar23);
LAB_800495ac:
    iVar10 = iVar10 << 0x10;
  }
  else {
    if (DAT_8008d8f8 != 0x40) {
      uVar14 = 0;
      if (
			(DAT_8008d47a < 2) ||
			(
				(
					// if memcard has no room
					(DAT_8008d8ac < 0x1680 && (DAT_8008d928 == 0))

					&& (DAT_8008d978 == 1)
				)
			)
		  )
	  {
        uVar14 = 1;
      }
      if (DAT_8008d47a < 2) {
        uVar14 = uVar14 | 2;
      }
      iVar10 = 4;
      iVar23 = (int)(short)uVar14;
      goto LAB_800495a0;
    }
    if (DAT_8008d47a == 0) {

	  // If you press Cross or Circle
      if ((DAT_8009a990 & 0x50) != 0)
	  {
		// OtherFX_Play
        FUN_80028468(1,1);

        if (DAT_8008d918 == 0)
		{
		  // MainGameEnd_SoloRaceSaveHighScore
          FUN_8003a2b4();
        }

		// clear gamepad input (for menus)
        FUN_80046404();

        DAT_8008d8fa = 1;
        DAT_8008d8fc = 1;
        iVar10 = 0;
        goto LAB_800495b0;
      }
      goto LAB_800495ac;
    }
    if (DAT_8008d47a == 1) {
      iVar10 = 0;

	  // If you press Circle
      if ((DAT_8009a990 & 0x40) != 0)
	  {
		// clear gamepad input (for menus)
        FUN_80046404();

		// OtherFX_Play
		FUN_80028468(1,1);

		// load main ctr memcard file (adv, high score, etc)
        FUN_80047198(7);
		
        iVar10 = 0;
      }
    }
    else {
      if (
			(
				(
					// if enough room is on memcard to save
					(0x167f < DAT_8008d8ac) ||

					(DAT_8008d928 != 0)
				) ||

				(
					iVar10 = 0,

					// if you are not saving data
					DAT_8008d978 != 1
				)
			) &&
			(
				(
					DAT_8008d95c != 0 ||
					(iVar10 = 0, DAT_8008d928 != 0)
				)
			)
		)
	{
        if (DAT_8008d918 == 0)
		{
		  // MainGameEnd_SoloRaceSaveHighScore
          FUN_8003a2b4();
        }

		// save game options
		FUN_80043d24();

		// GAMEPROG_SaveCupProgress
		FUN_80026cf4();

		// GAMEPROG_SyncGameAndCard
		// params are: memcardPtr, ram ptr
		// not "save", more like "sync" memcard and ram
        FUN_80026d7c(PTR_DAT_8008d474 + 0x144,&DAT_8008e6e8);

		// pointer to memcard GameProgress
        puVar7 = (undefined4 *)(PTR_DAT_8008d474 + 0x144);

        puVar13 = &DAT_8008e6e8;
        do {
          puVar11 = puVar13;
          puVar6 = puVar7;
          uVar15 = puVar11[1];
          uVar16 = puVar11[2];
          uVar17 = puVar11[3];
          *puVar6 = *puVar11;
          puVar6[1] = uVar15;
          puVar6[2] = uVar16;
          puVar6[3] = uVar17;
          puVar7 = puVar6 + 4;
          puVar13 = puVar11 + 4;
        } while (puVar11 + 4 != (undefined4 *)((int)&DAT_8008fb96 + 2));
        uVar15 = puVar11[5];
        uVar16 = puVar11[6];
        puVar6[4] = ram0x8008fb98;
        puVar6[5] = uVar15;
        puVar6[6] = uVar16;

		// MEMCARD_SetIcon to CrashHead
        FUN_8003d4e4(0);

		// save main CTR save file (3 = main file)
		FUN_80047198(3);
		
        DAT_8008d928 = 1;
        DAT_8008d8fa = 1;
        iVar10 = 0;
      }
    }
  }
LAB_800495b0:
  if (iVar10 == 0) goto LAB_800499e4;
  bVar1 = true;
  if (*(short *)(param_1 + 0x1a) == -1) {
    DAT_8008d8fa = 1;
    DAT_8008d8fc = 1;
    goto LAB_800499e4;
  }
  if (DAT_8008d47a == 0) {
    bVar1 = false;

	// if you are saving data
    if (DAT_8008d978 == 1) {
      DAT_8008d8fa = DAT_8008d978;
      DAT_8008d8fe = DAT_8008d978;
      goto LAB_80049624;
    }

	// if you are not loading data
    if (DAT_8008d978 != 0) goto LAB_80049624;

	// if you are handling time trial ghosts
    if (DAT_8008d8f8 == 0x30) {
      bVar1 = true;
      goto LAB_80049624;
    }

LAB_80049634:
    if (
			(
				(DAT_8008d47a != 1) &&

				// if not enough room on memcard
				(DAT_8008d8ac < 0x1680)
			) &&
			((DAT_8008d928 == 0 && (DAT_8008d978 == 1)))
		)
	{
      bVar1 = false;
    }
  }
  else {
LAB_80049624:
    if (DAT_8008d8f8 != 0x30) goto LAB_80049634;
  }
  if (!bVar1) goto LAB_800499e4;
  if (DAT_8008d47a == 1) 
  {
	// load main ctr file (adv, high scores, etc)
    FUN_80047198(7);
    
	goto LAB_800499e4;
  }
  if ((DAT_8008d95c == 0) && (DAT_8008d928 == 0)) goto LAB_800499e4;

  // if you are saving data
  if (DAT_8008d978 == 1)
  {
	// if you are handling time trial data
    if (DAT_8008d8f8 == 0x30)
	{
	  // if lap row is less than number of ghosts
      if (*(short *)(param_1 + 0x1a) < (short)DAT_8009aa5c) {
        DAT_80085d4a = 1;
        DAT_8008d900 = 1;
        DAT_80085d76 = 1;
        DAT_8009aa56 = *(short *)(param_1 + 0x1a);
        goto LAB_800499e4;
      }
    }

	// if you are handling adventure data
    else {
      if ((DAT_8008d902 == 0) && (DAT_8008d47a == 7)) {
        DAT_8008d902 = 1;
        goto LAB_800499e4;
      }

	  // 8008d474 is ptr to memcard data
      if ((-1 < *(short *)(PTR_DAT_8008d474 + (int)*(short *)(param_1 + 0x1a) * 0x50 + 0x2e)) &&
         ((int)*(short *)(param_1 + 0x1a) != (int)DAT_8008d96c)) {
        DAT_80085d4a = 1;
        DAT_80085d76 = 1;
        DAT_8008d900 = 1;
        goto LAB_800499e4;
      }
    }
    bVar2 = true;
    goto LAB_800499e4;
  }

  // If 0 or 1 (load, save)
  if (DAT_8008d978 < 2)
  {
	// if you are not loading data
    if (DAT_8008d978 != 0) goto LAB_800499e4;

	// If you are handling time trial ghosts
    if (DAT_8008d8f8 == 0x30) {
      if ((int)(short)uVar24 + -1 <= (int)*(short *)(param_1 + 0x1a)) {
        DAT_8008d8fa = 1;
        DAT_8008d8fe = 1;
        memset(DAT_8008d754,0,0x28);
        goto LAB_800499e4;
      }

	  // if track of ghost profile matches the track selected
      if ((int)*(short *)(&DAT_8009aa88 + (int)*(short *)(param_1 + 0x1a) * 0x34) ==

			// Level in Track Selection
          *(int *)(PTR_DAT_8008d2ac + 0x1eb0))
	  {
		// set selected ghost profile index
        DAT_8009aa5a = *(undefined2 *)(param_1 + 0x1a);

		// load ghost profile
        FUN_80047198(5);
		
        goto LAB_800499e0;
      }
    }

	// if you are handling adventure data
	else {
      if (DAT_8008d47a == 7) {
        DAT_8008d8fa = 1;
        DAT_8008d8fc = 1;
        goto LAB_800499e4;
      }

	  // 8008d474 is ptr to memcard data
      if (-1 < *(short *)(PTR_DAT_8008d474 + (int)*(short *)(param_1 + 0x1a) * 0x50 + 0x2e))
	  {
		// GAMEPROG_SyncGameAndCard
		// params are: memcardPtr, ram ptr
		// not "save", more like "sync" memcard and ram
        FUN_80026d7c(PTR_DAT_8008d474 + 0x144,&DAT_8008e6e8);

		// 0x8fba4 is where the adventure profile (currently loaded) begins
        puVar13 = &DAT_8008fba4;

		// 8008d474 is ptr to memcard data
		puVar20 = PTR_DAT_8008d474 + (int)*(short *)(param_1 + 0x1a) * 0x50;
        puVar7 = (undefined4 *)(puVar20 + 4);
        do {
          uVar15 = puVar7[1];
          uVar16 = puVar7[2];
          uVar17 = puVar7[3];
          *puVar13 = *puVar7;
          puVar13[1] = uVar15;
          puVar13[2] = uVar16;
          puVar13[3] = uVar17;
          uVar17 = DAT_8008fbc8;
          uVar16 = DAT_8008fbc4;
          uVar15 = DAT_8008fbc0;
          puVar3 = PTR_DAT_8008d2ac;
          puVar7 = puVar7 + 4;
          puVar13 = puVar13 + 4;
        } while (puVar7 != (undefined4 *)(puVar20 + 0x54));

		// DAT_8008fbce is the Icon ID of the character you want
		// for the adventure mode character

		// Set P1 Character ID to Adventure Icon ID
        DAT_80086e84 = DAT_8008fbce;

		// related to name at OSK screen
        *(undefined4 *)(PTR_DAT_8008d2ac + 0x1d54) = DAT_8008fbbc;
        *(undefined4 *)(puVar3 + 0x1d58) = uVar15;
        *(undefined4 *)(puVar3 + 0x1d5c) = uVar16;
        *(undefined4 *)(puVar3 + 0x1d60) = uVar17;
        puVar3[0x1d64] = DAT_8008fbcc;

        DAT_8008d73c = *(undefined2 *)(param_1 + 0x1a);
        DAT_8008d8fa = 1;
        DAT_8008d8fe = 1;
        goto LAB_800499e4;
      }
    }

	// OtherFX_Play
    FUN_80028468(5,1);
  }
  
  // if 2 or 3 (delete or exit)
  else
  {
    if (

			(
				// if you are not erasing data
				(DAT_8008d978 != 2) ||

				// if this is time trial ghost data
				(DAT_8008d8f8 == 0x30)
			) ||
			(
				iVar10 = (int)*(short *)(param_1 + 0x1a) * 0x50,

				// 8008d474 is ptr to memcard data
				*(short *)(PTR_DAT_8008d474 + iVar10 + 0x2e) < 0
			)
			
		// skip deletion
		) goto LAB_800499e4;

	// At this point, assume you pressed Delete

	// GAMEPROG_NewProfile_InsideAdv
    FUN_80026cb8(PTR_DAT_8008d474 + iVar10 + 4);

	// MEMCARD_SetIcon to CrashHead
    FUN_8003d4e4(0);

	// save main CTR save file (3 = main file)
	FUN_80047198(3);
	
    DAT_8008d928 = 1;
LAB_800499e0:
    DAT_8008d8fa = 1;
  }
LAB_800499e4:
  if (((DAT_8008d47a == 7) && (DAT_8008d8fc == 0)) && (DAT_8008d8fe == 0)) {
    DAT_8008d8fa = 0;
    DAT_8008d900 = 0;
  }
  if (bVar2) {
    DAT_8008d902 = 0;
    if (DAT_8008d8f8 == 0x30) {
      uVar15 = 0x8ca00;

	  // If player structure pointer is not nullptr
      if (*(int *)(PTR_DAT_8008d2ac + 0x24ec) != 0)
	  {
										//player structure pointer
        uVar15 = *(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x24ec) + 0x514);
      }

	  // GhostData_SaveProfile
      FUN_80046c30(
					// index highlighted by cursor
					(int)*(short *)(param_1 + 0x1a),

					// Character ID Array
					(int)DAT_80086e84,

					// Level ID
					(int)*(short *)(PTR_DAT_8008d2ac + 0x1a10),

					// amount of time
					uVar15,

					// pointer to string typed in OSK
					PTR_DAT_8008d2ac + 0x1d54);

	  // index highlighted by cursor
      DAT_8009aa58 = *(undefined2 *)(param_1 + 0x1a);

      DAT_8009aa56 = -1;
      if (*(short *)(param_1 + 0x1a) < (short)DAT_8009aa5c) {
        DAT_8009aa56 = *(short *)(param_1 + 0x1a);
      }

	  // MEMCARD_SetIcon to GhostIcon
      FUN_8003d4e4(1);

	  // save ghost profile (6 = ghost)
      FUN_80047198(6);
	  
      DAT_8008d8fa = 1;
      *(uint *)(PTR_DAT_8008d2ac + 0x1d44) = *(uint *)(PTR_DAT_8008d2ac + 0x1d44) | 1;
    }
    else {
      DAT_8008d73c = *(undefined2 *)(param_1 + 0x1a);

	  // save game options
	  FUN_80043d24();

	  // GAMEPROG_SaveCupProgress
	  FUN_80026cf4();

	  // GAMEPROG_SyncGameAndCard
	  // params are: memcardPtr, ram ptr
	  // not "save", more like "sync" memcard and ram
      FUN_80026d7c(PTR_DAT_8008d474 + 0x144,&DAT_8008e6e8);


	  // 0x8fba4 is where the adventure profile (currently loaded) begins
      puVar13 = &DAT_8008fba4;

	  // 8008d474 is ptr to memcard data
	  puVar7 = (undefined4 *)(PTR_DAT_8008d474 + (int)*(short *)(param_1 + 0x1a) * 0x50 + 4);

	  // keep doing this while the pointer does
	  // not get to the Ghost Recording Buffer
	  do {
        uVar15 = puVar13[1];
        uVar16 = puVar13[2];
        uVar17 = puVar13[3];
        *puVar7 = *puVar13;
        puVar7[1] = uVar15;
        puVar7[2] = uVar16;
        puVar7[3] = uVar17;
        puVar13 = puVar13 + 4;
        puVar7 = puVar7 + 4;

		// &DAT_8008fbf4 is where the
		// ghost recording is stored

      } while (puVar13 != &DAT_8008fbf4);

	  // 8008d474 is ptr to memcard data
      puVar7 = (undefined4 *)(PTR_DAT_8008d474 + 0x144);

	  puVar13 = &DAT_8008e6e8;

      do {
        puVar11 = puVar13;
        puVar6 = puVar7;
        uVar15 = puVar11[1];
        uVar16 = puVar11[2];
        uVar17 = puVar11[3];
        *puVar6 = *puVar11;
        puVar6[1] = uVar15;
        puVar6[2] = uVar16;
        puVar6[3] = uVar17;
        puVar7 = puVar6 + 4;
        puVar13 = puVar11 + 4;
      } while (puVar11 + 4 != (undefined4 *)((int)&DAT_8008fb96 + 2));
      uVar15 = puVar11[5];
      uVar16 = puVar11[6];
      puVar6[4] = ram0x8008fb98;
      puVar6[5] = uVar15;
      puVar6[6] = uVar16;

	  // MEMCARD_SetIcon to CrashHead
      FUN_8003d4e4(0);

	  // save main CTR save file (3 = main file)
	  FUN_80047198(3);
	  
      DAT_8008d928 = 1;
      DAT_8008d8fa = 1;
    }
    DAT_8008d904 = 0x3c;
  }
  if (*(short *)(param_1 + 0x1e) == 1) {
    bVar1 = false;
    if (((DAT_8008d8fa == 0) && (DAT_8008d95c != 0)) && ((DAT_8008d928 != 0 || (DAT_8008d47a == 8)))
       ) {
      bVar1 = true;
    }
    if (
		(
			// If you are loading data
			(DAT_8008d978 == 0) &&

			// if you are handling time trial ghosts
			(DAT_8008d8f8 == 0x30)
		) &&
       (((DAT_8008d47a == 9 || (DAT_8008d47a == 0)) && ((uVar24 & 0xffff) != 0)))) {
      bVar1 = true;
    }
    uVar14 = DAT_8008d47a;

	// If you are saving data
    if (DAT_8008d978 == 1)
	{
      if ((uint)DAT_8008d47a - 8 < 2) {
        bVar1 = false;
        if (bVar2) {
          uVar14 = 3;
        }

        else {

		  // If you are handling time trial ghosts
          if (DAT_8008d8f8 == 0x30)
		  {
            bVar1 = true;

			// if not enough room to save ghost
			if (((int)DAT_8008d8ac < 0x3e00) && (local_48 == 0)) {
              bVar1 = false;
              uVar14 = 6;
            }
          }

		  // If you are handling adventure profiles
          else
		  {
            bVar1 = true;

			// if not enough room to save profile
			if ((DAT_8008d8ac < 0x1680) && (DAT_8008d928 == 0)) {
              uVar14 = 6;
              bVar1 = false;
            }
          }
        }
      }
      if ((uVar14 == 7) && (DAT_8008d902 != 0)) {
        bVar1 = true;
      }
    }

	// LoadSave_Init
    FUN_800485cc((int)*(short *)(param_1 + 0x14));

    if ((bVar1) && (DAT_8008d8fa == 0)) {

	  // if this is ghost data
	  if (DAT_8008d8f8 == 0x30) {
        if (DAT_8008d900 == 0) {
          uVar21 = 0;
          iVar10 = strlen();
          local_30 = (ushort)(iVar10 != 0);

		  // If number of boxes (ghosts + "no ghost")
		  // is less than 7
          if ((short)uVar24 < 7)
		  {
			// Make the text big
            uVar15 = 1;

			iVar23 = 0x12;
            iVar10 = 0x10;

			// If you are not saving
			if (DAT_8008d978 != 1)
			{
			  // DAT_8008d878 + 0x33c
			  // INSERT ANY MEMORY CARD WITH GHOST DATA IN MEMORY CARD SLOT 1

			  // DecalFont_DrawMultiLine
              FUN_80022b34(*(undefined4 *)(DAT_8008d878 + 0x33c),0x100,0xbe,0x1ce,2,
                           (uint)local_50 | 0xffff8000);
            }
          }

		  // If there are 7 or more boxes
          else
		  {
			// Make the text small
            uVar15 = 2;

            iVar23 = 0x12;
            if (iVar10 != 0) {
              iVar23 = 0xc;
            }
            iVar10 = 8;
          }
          uVar18 = (uint)local_50;
          sVar22 = (short)(iVar23 + iVar10);

		  // Top line text

		  // CHOOSE A GHOST, or
		  // CHOOSE A MEMORY CARD SLOT
          FUN_80022878(*(undefined4 *)
                        ((int)*(short *)(&DAT_80085d14 + (int)DAT_8008d978 * 4) * 4 + DAT_8008d878),
                       0x100,(int)(short)iVar23,uVar15,uVar18 | 0xffff8000);

		  if (local_30 != 0) {
            sVar22 = (short)iVar10 + sVar22;

			// TO LOAD or
			// TO SAVE TO
			FUN_80022878(*(undefined4 *)
                          ((int)*(short *)(&DAT_80085d16 + (int)DAT_8008d978 * 4) * 4 + DAT_8008d878
                          ),0x100,(iVar23 + iVar10) * 0x10000 >> 0x10,uVar15,uVar18 | 0xffff8000);
          }

		  // pointer to first profile
          puVar20 = &DAT_8009aa60;

          local_38 = DAT_8009aa5c + local_40;
          iVar10 = 0;
          if (0 < (int)((uint)local_38 << 0x10)) {
            iVar23 = (int)(short)uVar24;
            do {
              if (uVar21 << 0x10 == (uint)local_48 << 0x10) {
                puVar20 = (undefined *)0x0;
              }
              if (((int)(uVar21 << 0x10) >> 0x10 < iVar23 + -1) || ((uVar21 & 1) != 0)) {
                iVar8 = (uVar21 & 1) * 0xd4 + 0x2e;
              }
              else {
                iVar8 = 0x98;
              }
              iVar12 = ((int)(uVar21 << 0x10) >> 0x10) - ((int)(uVar21 << 0x10) >> 0x1f) >> 1;
              if (6 < iVar23) {
                iVar9 = iVar12 * 0x2c;
              }
              else {
                iVar9 = iVar12 * 0x30;
              }
              sVar5 = (short)uVar21;
              uVar24 = SEXT24(*(short *)(param_1 + 0x14));
              if (6 < iVar23) {
                uVar24 = uVar24 | 0x40;
              }
              uVar18 = 0;
              if ((puVar20 != (undefined *)0x0) &&
														// Level in Track Selection
                 ((int)*(short *)(puVar20 + 0x28) != *(int *)(PTR_DAT_8008d2ac + 0x1eb0))) {

				// If you are not saving
				uVar18 = (uint)(DAT_8008d978 != 1);
              }

			  // Draw Profile
              FUN_80048a30(puVar20,iVar8,((int)sVar22 + 6 + (iVar9 - iVar12)) * 0x10000 >> 0x10,
                           (uint)(sVar5 == *(short *)(param_1 + 0x1a)),(int)sVar5,uVar24,

						   // If you are loading
						   (uint)(DAT_8008d978 == 0),uVar18);

			  uVar21 = uVar21 + 1;
              if ((int)sVar5 == iVar23) break;
              iVar10 = iVar10 + 1;

			  // Go to next profile
              puVar20 = puVar20 + 0x34;

            } while (iVar10 * 0x10000 < (int)((uint)local_38 << 0x10));
          }
        }
        else
		{
		  // set menubox width to zero
          local_56[0] = 0;

		  // get width of menubox
          FUN_80045c50(&DAT_80085d5c,local_56,1);

		  // draw menubox
		  FUN_80045db0(&DAT_80085d5c,0,0,(int)local_56[0]);

		  // Draw Ghost Profile
          FUN_80048a30(&DAT_8009aa60 + (int)DAT_8009aa56 * 0x34,0x9c,0x3c,0,0,
                       (int)*(short *)(param_1 + 0x14),0,0);
        }
      }

	  // if this is adventure data
	  else {
        if (DAT_8008d900 == 0) {
          iVar10 = strlen();
          uVar24 = (uint)local_50;

		  // Top line text
		  // CHOOSE A GAME,
		  // CHOOSE A MEMORY CARD SLOT, or
		  // CHOOSE A GAME
          FUN_80022878(*(undefined4 *)
                        ((int)*(short *)(&DAT_80085d88 + (int)DAT_8008d978 * 4) * 4 + DAT_8008d878),
                       0x100,(uint)(iVar10 == 0) << 3 | 0x12,1,uVar24 | 0xffff8000);

		  if (iVar10 != 0)
		  {
			// bottom line text
			// TO LOAD,
			// TO SAVE TO, or
			// TO DELETE
            FUN_80022878(*(undefined4 *)
                          ((int)*(short *)(&DAT_80085d8a + (int)DAT_8008d978 * 4) * 4 + DAT_8008d878
                          ),0x100,0x22,1,uVar24 | 0xffff8000);
          }

		  // loop counter
		  uVar21 = 0;

		  // determine even or odd
          uVar24 = 0;

		  // for uVar21 = 0; uVar21 < 4; uVar21++
		  // Draw all Adventure Profiels
          do {
            iVar10 = (int)(uVar21 << 0x10) >> 0x10;

			// 8008d474 is ptr to memcard data

			// Draw Adventure Profile
            FUN_80047ff8(PTR_DAT_8008d474 + iVar10 * 0x50 + 4,
                         (int)((uVar24 * 0xea + 0x1a) * 0x10000) >> 0x10,
                         ((iVar10 - ((int)(uVar21 << 0x10) >> 0x1f) >> 1) * 0x43 + 0x3c) * 0x10000
                         >> 0x10,(uint)(iVar10 == (int)*(short *)(param_1 + 0x1a)),iVar10,
                         (int)*(short *)(param_1 + 0x14));

			// increment loop counter
            uVar21 = uVar21 + 1;

			// determine even or odd (left side of screen or right)
            uVar24 = uVar21 & 1;
          } while ((int)(uVar21 * 0x10000) >> 0x10 < 4);
        }
        else
		{
		  // set width to zero
          local_58 = 0;

		  // Open "Overwrite" menuBox

		  // get width of menuBox
		  FUN_80045c50(&DAT_80085d30,&local_58,1);

		  // draw menuBox
          FUN_80045db0(&DAT_80085d30,0,0,(int)local_58);

		  // 8008d474 is ptr to memcard data

		  // Draw Adventure Profile
          FUN_80047ff8(PTR_DAT_8008d474 + (int)*(short *)(param_1 + 0x1a) * 0x50 + 4,0x92,0x3c,0,
                       (int)*(short *)(param_1 + 0x1a),(int)*(short *)(param_1 + 0x14));
        }

		if (
				// If you are saving data
				(DAT_8008d978 == 1) &&

				// if the save is out-dated
				(DAT_8008d944 != 0))
		{
		  // DAT_8008d878 + 0x340
		  // ...DATA ON MEMORY CARD IS OUT OF DATE...
          FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x340),0x100,0xc3,2,0xffff8003);
        }
      }
    }
    else {
      DAT_8008d900 = 0;
      if (((DAT_8008d8fa == 0) ||
          (((DAT_8008d964 == 0 || (DAT_8008d8fc != 0)) || (DAT_8008d8fe != 0)))) ||
         (DAT_8008d904 == 0)) {
        iVar10 = (int)(short)uVar14 * 4;
        uVar19 = *(ushort *)(iVar10 + -0x7ff7a4fc); // 0x80085B04
        if (((int)(short)uVar14 == 9) && (DAT_8008d8f8 == 0x40)) {
          uVar19 = 0xffff;
        }
        iVar23 = (uint)uVar19 << 0x10;
        if ((DAT_8008d8fa != 0) && (iVar23 = (uint)uVar19 << 0x10, DAT_8008d964 != 0)) {
          uVar19 = 0xffff;
          iVar23 = -0x10000;
        }
        if ((-1 < iVar23 >> 0x10) && (DAT_8008d8fe == 0))
		{
          if (
				(iVar23 >> 0x10 == 0x10f) &&

				// If you are saving data
				(DAT_8008d978 == 1)
			 )
		  {
			// Displays this string
			// WARNING:
			// on the screen
            uVar19 = 0x106;
          }

		  if (
				(
					// if you are handling adventure data
					(DAT_8008d8f8 != 0x30) &&
					(uVar14 == 9)
				) &&

				// If the save is out-dated
				(DAT_8008d944 != 0)
			 )
		  {
			// DAT_8008d878 + 0x340
			// ...DATA ON MEMORY CARD IS OUT OF DATE...
            FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x340),0x100,0xc3,2,0xffff8003);
          }

		  // 0xea
		  // SAVING TO MEMORY CARD...

          if (
				// If you are deleting data
				(DAT_8008d978 == 2) &&

				(uVar19 == 0xea)
			 )
		  {
			// DELETING GAME SLOT...
            uVar19 = 0xfc;
          }
          if (*(short *)(iVar10 + -0x7ff7a4fa) == 0)  // 0x80085B06
		  {
												// really just uVar19 * 4
            FUN_80022878(*(undefined4 *)(((int)((uint)uVar19 << 0x10) >> 0xe) + DAT_8008d878),0x108,
                         0x12,1,(uint)local_50 | 0xffff8000);
          }
          else {
            iVar23 = 0;
            uVar24 = (uint)local_50;
            iVar10 = 0;
            do {
              iVar10 = iVar10 >> 0x10;
              uVar15 = *(undefined4 *)(((short)uVar19 + iVar10) * 4 + DAT_8008d878);
              iVar8 = strlen();
              if (iVar8 != 0) {
                iVar8 = 2;
                if (iVar10 != 0) {
                  iVar8 = 4;
                }
                iVar12 = iVar10 * ((int)*(short *)(&DAT_80082368 + iVar8) + 2);
                iVar8 = iVar12 + 0x26;
                if (0 < iVar10) {
                  iVar8 = iVar12 + 0x2e;
                }

				// Draw big string
                uVar16 = 1;

                uVar21 = uVar24 | 0xffff8000;

                if (
						(
							((short)iVar23 == 0) ||
							(
								// Draw small string
								uVar16 = 2,

								(short)iVar23 == 0
							)
						) &&
						((DAT_8008d970 & 4) == 0)
					)
				{
                  uVar21 = 0xffff8003;
                }

				// Draw String
                FUN_80022878(uVar15,0x100,iVar8 * 0x10000 >> 0x10,uVar16,uVar21);
              }
              iVar23 = iVar23 + 1;
              iVar10 = iVar23 * 0x10000;
            } while (iVar23 * 0x10000 >> 0x10 < 9);
          }

		  // Draw 2D Menu rectangle background
          FUN_800457b0(&DAT_8008d4a4,(int)*(short *)(param_1 + 0x14),
                       *(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0));
        }
      }
      else {
        uVar15 = 0xffff8004;
        if ((DAT_8008d970 & 4) == 0) {
          uVar15 = 0xffff8000;
        }

		// DAT_8008d878 + 0x4f4
		// SAVE COMPLETED.
        FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x4f4),0x108,100,1,uVar15);
      }
    }
  }
  sVar22 = DAT_8008d904;
  if ((((DAT_8008d8fa != 0) && (DAT_8008d984 != 0)) &&
      ((DAT_8008d964 != 0 || ((DAT_8008d8fc != 0 || (DAT_8008d8fe != 0)))))) &&
     ((DAT_8008d8fa == 0 ||
      ((((DAT_8008d964 == 0 || (DAT_8008d8fc != 0)) || (DAT_8008d8fe != 0)) ||
       (sVar22 = DAT_8008d904 + -1, DAT_8008d904 == 0))))))
  {
	// LoadSave_InitAndDestroy
	FUN_80048edc();

	// LoadSave_StopMemcardAction
	FUN_800471ac();
	
    uVar16 = DAT_8008fbc4;
    uVar15 = DAT_8008fbc0;
    puVar20 = PTR_DAT_8008d2ac;

	// If you are handling Adventure Profiles
    if (DAT_8008d8f8 == 0x20)
	{
      if (
			(DAT_8008d8fc == 0) &&
			(DAT_8008d96c = *(short *)(param_1 + 0x1a),

			// If you are loading data
			DAT_8008d978 == 0)
		  )
	  {

		// GAMEPROG_AdvPercent
		FUN_800265c0(&DAT_8008fba4);

		// LoadSave_LoadProfileFromHub_MenuBoxFuncPtr,
		// open menubox to load profile, while already on adv hub
        DAT_8008d924 = &DAT_80085c38;

		// DAT_8008fbd2
		// holds Level ID of the hub that your adventure
		// profile was saved in

		// Level in Track Selection
		// The level you want to load is the level you
		// Get from the Adventure Profile that you are loading
        *(int *)(PTR_DAT_8008d2ac + 0x1eb0) = (int)DAT_8008fbd2;
        DAT_80085b76 = 3;
        sVar22 = DAT_8008d904;
      }
      else
	  {
		// Change MenuBox to Green Save/Load screen
        DAT_8008d924 = &DAT_80085b5c;

        DAT_80085b76 = 3;
        sVar22 = DAT_8008d904;
      }
    }
    else {
      if (DAT_8008d8f8 < 0x21) {
        if (DAT_8008d8f8 == 0) {
          if (DAT_8008d8fc != 0)
		  {
			// Change active MenuBox to OSK
            DAT_8008d924 = &DAT_80085c0c;

			// TitleOSK_RestoreName
            FUN_8004aa08(0);

            return;
          }
          DAT_8008d96c = *(short *)(param_1 + 0x1a);

		  // Level in Track Selection = 0x1a
		  // This means the level you want to load is N Sanity Beach Adventure Hub
		  // Which means you're creating a new adventure profile
          *(undefined4 *)(PTR_DAT_8008d2ac + 0x1eb0) = 0x1a;

		  // Garage_Leave
          FUN_8003074c();
        }
        else {
          if (DAT_8008d8f8 != 0x10) {
            return;
          }
          if (DAT_8008d8fc != 0)
		  {
			// TransitionTo_MainMenu_Returning
            FUN_800b4334();

			// GetMenuBox_AdvNewLoad
			iVar10 = FUN_800ad980();

            *(uint *)(iVar10 + 8) = *(uint *)(iVar10 + 8) & 0xfffffffb;
            return;
          }

          DAT_8008d96c = *(short *)(param_1 + 0x1a);

		  // play with the name you entered in OSK
		  *(undefined4 *)(PTR_DAT_8008d2ac + 0x1d54) = DAT_8008fbbc;
          *(undefined4 *)(puVar20 + 0x1d58) = uVar15;
          *(undefined4 *)(puVar20 + 0x1d5c) = uVar16;
          uVar4 = DAT_8008fbcc;
          *(undefined4 *)(puVar20 + 0x1d60) = DAT_8008fbc8;
          puVar20[0x1d64] = uVar4;
          uVar16 = DAT_8008fbc4;
          uVar15 = DAT_8008fbc0;
          *(undefined4 *)(puVar20 + 0x1d65) = DAT_8008fbbc;
          *(undefined4 *)(puVar20 + 0x1d69) = uVar15;
          *(undefined4 *)(puVar20 + 0x1d6d) = uVar16;
          uVar4 = DAT_8008fbcc;
          *(undefined4 *)(puVar20 + 0x1d71) = DAT_8008fbc8;
          puVar20[0x1d75] = uVar4;

		  // Track to load is N Sanity Beach Adventure HUB
          iVar10 = 0x1a;

		  // If your save profile has a Level ID of where
		  // you saved the profile (if you ever manually saved)
          if ((int)DAT_8008fbd2 != 0) {

			// Set iVar10 to the levl ID of the adventure hub
			// you last saved the profile in
            iVar10 = (int)DAT_8008fbd2;
          }

		  // set the level you want to load to iVar10
          *(int *)(PTR_DAT_8008d2ac + 0x1eb0) = iVar10;
        }
      }
      else {
        if (DAT_8008d8f8 != 0x30) {
          if (DAT_8008d8f8 != 0x40) {
            return;
          }

		  // LoadSave_Destroy
          FUN_800488e0();
          if (DAT_8008d918 == 0) {
            *(uint *)(PTR_DAT_8008d2ac + 0x1d44) = *(uint *)(PTR_DAT_8008d2ac + 0x1d44) & 0xf6ffffff
            ;
          }
          else {
            if (DAT_8008d8fc != 0)
			{
			  // Change active MenuBox to
			  // "Save Game?" "Yes/No"
              DAT_8008d924 = &DAT_80085a68;
              return;
            }
          }

		  // make MenuBox invisible
          FUN_800469c8(param_1);
          return;
        }

		// LoadSave_Destroy
        FUN_800488e0();

		// if you are saving data
        if (DAT_8008d978 == 1)
		{
          if (DAT_8008d8fc != 0)
		  {
			// Change active MenuBox to
			// end of race menu with "Save Ghost" option
            DAT_8008d924 = &DAT_800a0458;
            return;
          }

		  // Change active MenuBox to
		  // end of race menu without "Save Ghost" option
          DAT_8008d924 = &DAT_800a04a4;
          return;
        }
        if (DAT_8008d8fc != 0)
		{
		  // Erase ghost of previous race from RAM
          FUN_80028410();

		  // MM_TrackSelect_GetMenuBox
          DAT_8008d924 = (undefined *)FUN_800b0eac();

		  // set default track selection values
		  FUN_800affd0();
          return;
        }

		// Make P2 the character that is saved in the
		// header of the ghost that you will see in the race
        DAT_80086e86 = *(undefined2 *)(DAT_8008d754 + 6);
      }

	  // change active MenuBox to TitleBeginTrack
      DAT_8008d924 = (undefined *)FUN_80043c04();

	  sVar22 = DAT_8008d904;
    }
  }
                    // WARNING: Read-only address (ram,0x8008fbce) is written
                    // WARNING: Read-only address (ram,0x8008fbd2) is written
  DAT_8008d904 = sVar22;
  return;
}


// TitleOSK_RestoreName
void FUN_8004aa08(undefined2 param_1)

{
  undefined2 uVar1;

  DAT_8008d906 = param_1;

  // copy the last string you typed the last time you were in
  // the OSK menu, back into the menu, avoid typing a second time
  memmove(PTR_DAT_8008d2ac + 0x1d65,PTR_DAT_8008d2ac + 0x1d54,0x11);

  // move cursor to 'A' letter
  uVar1 = 0;

  // if string exists
  if (PTR_DAT_8008d2ac[0x1d65] != '\0')
  {
	// move cursor to 'save' button
    uVar1 = 0x3e9;
  }

  // set cursor position of OSK
  *(undefined2 *)(PTR_DAT_8008d2ac + 0x1d4c) = uVar1;

  return;
}


// TitleOSK_DrawMenu (on-screen keyboard)
// called from funcptr function,
// as well as one other place
int FUN_8004aa60(ushort param_1)

{
  byte bVar1;
  short sVar2;
  uint uVar3;
  uint uVar4;
  byte *pbVar5;
  int iVar6;
  int iVar7;
  short sVar8;
  int iVar9;
  short sVar10;
  undefined local_58;
  undefined local_57;
  undefined local_56;
  undefined2 local_50;
  undefined2 local_4e;
  undefined2 local_4c;
  undefined2 local_4a;
  ushort local_48;
  short local_40;
  short local_38;
  int local_30;

  iVar9 = 0;
  local_38 = 0;

  // size of name entered is zero
  local_40 = 0;

  local_48 = param_1;
  _sVar2 = strlen();
  sVar2 = (short)_sVar2;

  // The string you typed for OSK
  pbVar5 = PTR_DAT_8008d2ac + 0x1d65;


  // if the string is not empty
  if (PTR_DAT_8008d2ac[0x1d65] != '\0') {
    bVar1 = *pbVar5;
    do
	{
	  // if character is valid
      if (2 < bVar1)
	  {
		// add to length?
        local_40 = local_40 + 1;
      }

	  // go to next character
      pbVar5 = pbVar5 + 1;

	  // get next character
      bVar1 = *pbVar5;

	  // till you hit nullptr
    } while (bVar1 != 0);
  }

  // character currently being highlighted in OSK
  _sVar2 = (int)*(short *)(PTR_DAT_8008d2ac + 0x1d4c);

  // characters in 3x13 grid are 0x0 to 0x26
  // "cancel" is 1000
  // "save" is 1001

  // if cursor doesn't know where to go, then
  // back to the 3x13 grid of characters
  if ((0x26 < _sVar2) && (_sVar2 < 1000)) {
    _sVar2 = 0x26;
  }

  // make a copy of the index that
  // the cursor is highlighting in the menu
  sVar8 = (short)_sVar2;

  DAT_8008d8f2 = DAT_8008d8f2 + 1;

  // loop counter
  iVar7 = 0;

  local_30 = 1;

  // Draw every character in each row (0 - 2)
  // for iVar7 = 0; iVar7 < 0xd; iVar7++
  do {
    iVar6 = 0;
    if (local_30 != 0) {

	  // Draw every character in each column (0 - 13)
	  // for iVar6 = 0; iVar6 < 0xd; iVar6++
      do
	  {
        sVar10 = 0;

		// if the character you are highlighting is the
		// one being drawn in this iteration of the loop
        if ((int)sVar8 == (iVar6 + iVar7 * 0xd) * 0x10000 >> 0x10)
		{
		  // make the text flash colors
          sVar10 = (short)(((uint)DAT_8008d8f2 & 1) << 2);
        }

		// 80085d94
		// Every character A-Z then 0-9

		// uVar4 is the character you are highlighting
        uVar4 = SEXT24(u_ABCDEFGHIJKLMNOPQRSTUVWXYZ012345_80085d94

						// row * 0xd + column, get the character to
						// draw in iteration of the loop
					   [(int)(short)iVar7 * 0xd + (int)(short)iVar6]);


		uVar3 = uVar4 & 0xff00;
        if ((uVar4 & 0xff00) == 0x1000) {
          uVar4 = uVar4 & 0xff;
          uVar3 = 0;
        }
        if (uVar3 == 0) {
          local_57 = 0;
          local_58 = (char)uVar4;
        }
        else {
          local_56 = 0;
          local_58 = (char)((uVar4 << 0x10) >> 0x18);
          local_57 = (char)uVar4;
        }

		// draw character
        FUN_80022878(&local_58,((int)(short)iVar6 * 0x16 + 0x74) * 0x10000 >> 0x10,
                     ((int)(short)iVar7 * 0x12 + 0x58) * 0x10000 >> 0x10,1,(int)sVar10);

		// iterate loop counter
		iVar6 = iVar6 + 1;

	  } while (iVar6 * 0x10000 >> 0x10 < 0xd);
    }

	// iterate loop counter
    iVar7 = iVar7 + 1;

  } while (iVar7 * 0x10000 >> 0x10 < 3);

  // DAT_8008d878 + 0x4f8
  // PLEASE ENTER YOUR NAME
  FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x4f8),0x100,0x2c,1,0xffff8000);

  // PTR_DAT_8008d2ac + 0x1d65
  // The string you typed for OSK
  FUN_80022878(PTR_DAT_8008d2ac + 0x1d65,0xc0,0x44,1,4);

  if (((DAT_8008d8f2 & 2) != 0) && (sVar2 < 0x10))
  {
	// DecalFont_GetLineWidth
    iVar7 = FUN_800224d0(PTR_DAT_8008d2ac + 0x1d65,1);

	// DAT_8008d4ac
	// _

	// This draws the blinking red underscore that comes
	// after the string you entered in OSK
	FUN_80022878(&DAT_8008d4ac,(iVar7 + 0xc0) * 0x10000 >> 0x10,0x44,1,0);
  }
  iVar7 = (int)sVar8;
  uVar3 = 0;
  if (iVar7 == 0x3e9) {
    uVar3 = ((uint)DAT_8008d8f2 & 1) << 2;
  }

  // Draw String
  FUN_80022878(*(undefined4 *)(((int)((uint)local_48 << 0x10) >> 0xe) + DAT_8008d878),0x1d8,0x96,1,
               uVar3 | 0x4000);
  sVar10 = 0;
  if (iVar7 == 1000) {
    sVar10 = (short)(((uint)DAT_8008d8f2 & 1) << 2);
  }

  // DAT_8008d878 + 0x504
  // CANCEL
  FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x504),0x28,0x96,1,(int)sVar10);

  local_50 = 0x20;
  local_4c = 0x1c0;
  local_4e = 0x3e;
  local_4a = 2;

  // MenuBox_DrawOuterRect_Edge (transparent)
  FUN_80044f90(&local_50,&DAT_8008d438,0x20,
               *(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0));
  local_4e = 0x27;
  local_4a = 0x82;

  // Draw 2D Menu rectangle background
  FUN_800457b0(&local_50,0,*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0));

  // If you dont press D-pad
  if ((DAT_8009a990 & 0xf) == 0) {

	// If you dont press Start
    if ((DAT_8009a990 & 0x1000) == 0) {

	  // If you dont press Triangle or Square
      if ((DAT_8009a990 & 0x40020) == 0) {

		// If you press Cross or Circle
        if ((DAT_8009a990 & 0x50) != 0) {
          if (iVar7 == 0x26) {
            iVar9 = 2;
            if ((int)sVar2 == 0) {
              iVar9 = 2;
            }
            else {
              PTR_DAT_8008d2ac[(int)sVar2 + 0x1d64] = 0;
            }
          }
          else {

			// If you hit any character within the 3x13 grid
            if (iVar7 < 0x26) {
              uVar3 = (uint)(ushort)u_ABCDEFGHIJKLMNOPQRSTUVWXYZ012345_80085d94[iVar7];
              if (((int)u_ABCDEFGHIJKLMNOPQRSTUVWXYZ012345_80085d94[iVar7] & 0xff00U) == 0x1000) {
                uVar3 = uVar3 & 0xff;
              }

			  // if name entered is less than 8 characters long
              if (local_40 < 8)
			  {
                sVar10 = sVar2;
                if ((uVar3 & 0xff00) != 0) {
                  sVar10 = sVar2 + 1;

				  // append string of your name
                  PTR_DAT_8008d2ac[(int)sVar2 + 0x1d65] = (char)((uVar3 << 0x10) >> 0x18);
                }

                iVar9 = 1;

				// replace existing character?
				PTR_DAT_8008d2ac[(int)sVar10 + 0x1d65] = (char)uVar3;
              }

			  // if name length is too long
              else {
                iVar9 = 5;
              }
            }

			// if you are not in the 3x13 grid
            else {

			  // If you hit "Save" with ID 1000 (0x3e9)
              if (iVar7 == 0x3e9) {
                iVar9 = 2;
                local_38 = 1;

				// copy the string you typed at OSK so it can be
				// used again later, when is time to enter your name again
                memmove(PTR_DAT_8008d2ac + 0x1d54,PTR_DAT_8008d2ac + 0x1d65,0x11);
              }

			  // If you did not hit "Save", which would
			  // only be if you hit "Cancel" instead
              else {
                iVar9 = 0;
                if (iVar7 != 1000) goto LAB_8004b0dc;
                iVar9 = 3;
                local_38 = -1;
              }

			  // clear gamepad input (for menus)
              FUN_80046404();
            }
          }
        }
      }

	  // If you press Triangle or Square
	  else {
        _sVar2 = (int)sVar2;
        iVar9 = 0;
        if (_sVar2 != 0) {
          PTR_DAT_8008d2ac[_sVar2 + 0x1d64] = 0;
          iVar9 = 4;
          if ((byte)(PTR_DAT_8008d2ac + _sVar2 + -2)[0x1d65] < 3) {
            (PTR_DAT_8008d2ac + _sVar2 + -2)[0x1d65] = 0;
          }
        }
      }
    }

	// If you press Start
	else {
      iVar9 = 3;
      if (iVar7 == 1000) {
        local_38 = -1;
      }
      else {
        sVar8 = 1000;
        iVar9 = 1;
      }
    }
  }

  // If you dont press D-pad
  else {

	// If you press Up
    if ((DAT_8009a990 & 1) != 0) {
      _sVar2 = _sVar2 + -0xd;
    }

	// If you press Down
    if ((DAT_8009a990 & 2) != 0) {
      _sVar2 = _sVar2 + 0xd;
    }

	// If you press Left
    if ((DAT_8009a990 & 4) != 0) {
      _sVar2 = _sVar2 + -1;
    }

    iVar9 = _sVar2 << 0x10;

	// If you press Right
	if ((DAT_8009a990 & 8) != 0) {
      _sVar2 = _sVar2 + 1;
      iVar9 = _sVar2 * 0x10000;
    }

    iVar7 = _sVar2 << 0x10;
    if (iVar9 < 0) {
      _sVar2 = 0x3e9;
      iVar7 = 0x3e90000;
    }

	sVar8 = (short)_sVar2;

    uVar3 = _sVar2 - 500;
    if ((0x26 < iVar7 >> 0x10) && (uVar3 = _sVar2 - 500, iVar7 >> 0x10 < 500)) {
      sVar8 = 0x3e9;
      uVar3 = 0x1f5;
    }
    if ((uVar3 & 0xffff) < 500) {
      sVar8 = 0x26;
    }
    iVar9 = 1;

	// if cursor goes too far
    if (0x3ea < sVar8)
	{
	  // go back to 'A' letter
      sVar8 = 0;
    }
  }
LAB_8004b0dc:

// if you want to play a sound
  if (iVar9 != 0)
  {
	// OtherFX_Play
											// 0x80085DE4
    FUN_80028468((uint)*(ushort *)(iVar9 * 4 + -0x7ff7a21c),1);
  }

  // update cursor position
  *(short *)(PTR_DAT_8008d2ac + 0x1d4c) = sVar8;

  return (int)local_38;
}


// TitleOSK_MenuBoxFuncPtr (on-screen keyboard)
void FUN_8004b144(int param_1)

{
  short sVar1;

  // TitleOSK_DrawMenu
  sVar1 = FUN_8004aa60(0x13f);

  *(short *)(param_1 + 0x1a) = sVar1;
  if (sVar1 != 0) {
    if (DAT_8008d906 == 1) {
      if (sVar1 < 0)
	  {
		// Change active MenuBox to
		//  end of race menu with "Save Ghost" option
        DAT_8008d924 = &DAT_800a0458;
      }
      else
	  {
		// Set Load/Save to Ghost mode, with slot 1 selected
        FUN_80048e2c(0x31);

		// Change active MenuBox to GhostSelection
		DAT_8008d924 = &DAT_80085bb4;
      }
    }
    else {
      if ((DAT_8008d906 < 2) && (DAT_8008d906 == 0)) {
        if (sVar1 < 0)
		{
		  // ptrDesiredMenuBox = CS_Garage_GetMenuBox
          DAT_8008d924 = (undefined *)FUN_800b854c();

		  // CS_Garage_ZoomOut (1 = just hit OSK cancel)
          FUN_800b7784(1);
        }
        else {

		  // make backup of name entered
		  DAT_8008fbbc = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1d54);
          DAT_8008fbc0 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1d58);
          DAT_8008fbc4 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1d5c);
          DAT_8008fbc8 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1d60);
          DAT_8008fbcc = PTR_DAT_8008d2ac[0x1d64];

		  // Set Load/Save to New Adventure mode
          FUN_80048e2c(1);

		  // Change active menuBox to draw four adv profiles
          DAT_8008d924 = &DAT_80085b88;
        }
      }
    }
  }
  return;
}


// PrixSaveBox_Activate (beta 'Arcade' was Gran Prix)
// Only called from 233, when you are at the cup
// podium and you need to save progress
void FUN_8004b230(undefined2 param_1)

{
  // string index to print
  DAT_8008d938 = param_1;

  // 80085a68 is where a menu buffer is stored
  // for "Save Game", "yes / no"

  // Draw the menu
  FUN_80046990(&DAT_80085a68);

  return;
}


// PrixSaveBox_MenuBoxFuncPtr (beta 'Arcade' was Gran Prix)
void FUN_8004b258(int param_1)

{
  short sVar1;

  if (*(short *)(param_1 + 0x1e) == 1)
  {
	// if there is a string to print
    if ((int)DAT_8008d938 != 0)
	{
	  // print "Save your cup progress?"
	  // and optionally "New Battle Arena Opened!"

	  // DecalFont_DrawMultiLine
      FUN_80022b34(*(undefined4 *)((int)DAT_8008d938 * 4 + DAT_8008d878),0x100,0x3c,0x1cc,1,
                   0xffff8000);
    }
  }
  else {
    sVar1 = *(short *)(param_1 + 0x1a);
    if (sVar1 == 0) {
      DAT_8008d918 = 1;

	  // Set Load/Save to "Slot Selected" mode
      FUN_80048e2c(0x41);

	  // Change active MenuBox to Warning
      DAT_8008d924 = &DAT_80085be0;
    }
    else {
      if (sVar1 < 1) {
        if (sVar1 != -1) {
          return;
        }
      }
      else {
        if (sVar1 != 1) {
          return;
        }
      }

	  // Make the menu disappear
      FUN_800469c8();
    }
  }
  return;
}


// RCNT_Init
void FUN_8004b31c(void)

{
  EnterCriticalSection();
  StopRCnt(0xf2000001);
  SetRCnt(0xf2000001,0xffff,0x2000);
  StartRCnt(0xf2000001);
  ExitCriticalSection();
  return;
}


// RCNT_Destroy
void FUN_8004b370(void)

{
  EnterCriticalSection();
  StopRCnt(0xf2000001);
  ExitCriticalSection();
  return;
}


// RCNT_GetTime_Total
// not milliseconds
int FUN_8004b3a4(void)

{
  long lVar1;
  int iVar2;

  // current system timer,
  // updated on every vsync
  iVar2 = DAT_8008d988;

  // time past since vsync
  lVar1 = GetRCnt(0xf2000001);

  // if less than 100 units past,
  // which is less than 0.006 seconds
  if (lVar1 < 100)
  {
	// do nothing?
    iVar2 = DAT_8008d988;
  }

  // 0x147e = 5246
  // (timeAtVsync + timeSinceVsync) / 5
  return ((iVar2 + lVar1) * 1000) / 0x147e;
}


// RCNT_GetTime_Elapsed
int FUN_8004b41c(int param_1,int *param_2)

{
  int iVar1;

  // RCNT_GetTime_Total
  iVar1 = FUN_8004b3a4();

  // if pointer exists, write to it
  if (param_2 != (int *)0x0) {
    *param_2 = iVar1;
  }

  if (iVar1 < param_1) {
    iVar1 = iVar1 + 0xc7e18;
  }

  // sysclock current, minus
  // sysclock previous, equals
  // elapsed time
  return iVar1 - param_1;
}


// draws heat effect as found in tiger temple (fire) or behind rockets
void FUN_8004b470(int *param_1,int param_2,int param_3,int param_4,undefined4 param_5)

{
  bool bVar1;
  short sVar2;
  int iVar3;
  undefined4 uVar4;
  uint uVar5;
  int iVar6;
  undefined4 uVar7;
  uint uVar8;
  undefined4 uVar9;
  int iVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  int iVar14;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  uint uVar15;
  undefined4 unaff_s7;
  uint uVar16;
  uint uVar17;
  int iVar18;
  undefined4 unaff_s8;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];
  
  iVar3 = 0x1f800000;
  DAT_1f800020 = &DAT_8008cf6c;
  param_4 = param_4 + -1;
  uVar4 = *(undefined4 *)(param_3 + 0xc);
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800024 = (undefined *)register0x00000074;
  DAT_1f800028 = unaff_s8;
  DAT_1f80002c = unaff_retaddr;
  DAT_1f800030 = (int)param_1;
  if (param_1 != (int *)0x0) {
    DAT_1f800038 = param_5;
    iVar18 = 0xc;
    DAT_1f80005c._2_2_ = 0;
    do {
      uVar11 = *(uint *)(param_2 + 0x28);
      uVar12 = *(uint *)(param_2 + 0x30);
      uVar5 = *(uint *)(param_2 + 0x3c);
      iVar6 = *(int *)(param_2 + 0x40);
      uVar7 = *(undefined4 *)(param_2 + 0x44);
      gte_ldL11L12(uVar11);
      gte_ldL13L21(*(undefined4 *)(param_2 + 0x2c));
      gte_ldL22L23(uVar12);
      gte_ldL31L32(*(undefined4 *)(param_2 + 0x34));
      gte_ldL33(*(undefined4 *)(param_2 + 0x38));
      gte_ldbkdir(uVar5,iVar6,uVar7);
      gte_ldR11R12(0x1000);
      gte_ldR13R21(0);
      gte_ldR31R32(0);
      gte_ldR33(0x1000);
      gte_ldtr(0,0,0);
      sVar2 = *(short *)(param_2 + 0x22);
      uVar9 = *(undefined4 *)(param_2 + 0x18);
      *(int *)(iVar3 + 0x48) = (int)*(short *)(param_2 + 0x20) << 0xf;
      *(int *)(iVar3 + 0x4c) = (int)sVar2 << 0xf;
      gte_ldH(uVar9);
      sVar2 = *(short *)(param_2 + 0x1e);
      *(undefined2 *)(iVar3 + 0x50) = *(undefined2 *)(param_2 + 0x1c);
      *(short *)(iVar3 + 0x52) = sVar2 + (short)*(undefined4 *)(iVar3 + 0x38);
      sVar2 = *(short *)(param_2 + 0x22);
      *(short *)(iVar3 + 0x54) = *(short *)(param_2 + 0x20) + -1;
      *(short *)(iVar3 + 0x56) = sVar2 + -1;
      iVar14 = *(int *)(param_2 + 0x20);
      while (param_1 != (int *)0x0) {
        gte_ldVXY0(param_1[9] >> 8 & 0xffffU | (param_1[0xb] >> 8) << 0x10);
        gte_ldVZ0(param_1[0xd] >> 8);
        uVar15 = (uint)*(byte *)((int)param_1 + 0x3d);
        uVar16 = (uint)*(byte *)((int)param_1 + 0x45);
        gte_llv0bk_b();
        uVar17 = (uint)*(byte *)((int)param_1 + 0x4d);
        *(uint *)(iVar3 + 0x44) =
             (uint)CONCAT12(*(undefined *)((int)param_1 + 0x6d),
                            CONCAT11(*(undefined *)((int)param_1 + 0x65),
                                     *(undefined *)((int)param_1 + 0x5d)));
        read_mt(uVar5,iVar6,uVar7);
        gte_ldVZ0(uVar7);
        gte_ldVZ1(uVar7);
        gte_ldVZ2(uVar7);
        gte_ldR22R23(0x1000);
        gte_ldOFX(*(undefined4 *)(iVar3 + 0x48));
        gte_ldOFY(*(undefined4 *)(iVar3 + 0x4c));
        gte_ldVXY0(iVar6 << 0x10 | uVar5 & 0xffff);
        gte_rtps_b();
        uVar8 = (int)(uVar15 * 0xb50) >> 0xc;
        uVar5 = gte_stSXY2();
        iVar10 = gte_stFLAG();
        iVar6 = (int)uVar5 >> 0x10;
        uVar5 = uVar5 & 0xffff;
        if (-1 < iVar10 << 0xe) {
          gte_stSXY2();
          gte_ldR22R23(0xa00);
          gte_ldOFX(0);
          gte_ldOFY(0);
          gte_ldVXY0(uVar15);
          gte_ldVXY1(uVar15 << 0x10);
          gte_ldVXY2(uVar8 | uVar8 << 0x10);
          gte_rtpt_b();
          uVar8 = (int)(uVar16 * 0xb50) >> 0xc;
          uVar15 = gte_stSXY0();
          uVar13 = gte_stSXY1();
          gte_ldVXY0(uVar16);
          if ((int)(uVar15 - 0x80) < 0) {
            gte_ldVXY1(uVar16 << 0x10);
            gte_ldVXY2(uVar8 | uVar8 << 0x10);
            uVar4 = FUN_8004b914(uVar5,iVar6);
            if (((0 < ((int)uVar12 >> 0x10) + -0x18) &&
                (uVar8 = ~(uVar11 - iVar14 | uVar15 - iVar14 | uVar12 - iVar14 | uVar13 - iVar14) |
                         uVar11 & uVar15 & uVar12 & uVar13, -1 < (int)uVar8)) &&
               (-1 < (int)(uVar8 << 0x10))) {
              FUN_8004b94c();
              gte_rtpt_b();
              uVar5 = (int)(uVar17 * 0xb50) >> 0xc;
              gte_stSXY0();
              gte_stSXY1();
              gte_ldVXY0(uVar17);
              gte_ldVXY1(uVar17 << 0x10);
              gte_ldVXY2(uVar5 | uVar5 << 0x10);
              FUN_8004b914();
              FUN_8004b94c();
              gte_rtpt_b();
              gte_stSXY0();
              gte_stSXY1();
              FUN_8004b914();
              FUN_8004b94c();
              FUN_8004b9cc();
              FUN_8004bd84(iVar3 + 8,iVar3 + 4);
              FUN_8004c348(iVar3 + 4,iVar3 + 8);
              FUN_8004b9cc();
              FUN_8004bd84(iVar3 + 8,iVar3 + 0xc);
              FUN_8004c348(iVar3 + 0xc,iVar3 + 8);
              FUN_8004b9cc();
              FUN_8004bd84(iVar3 + 0xc,iVar3 + 0x10);
              FUN_8004c348(iVar3 + 0xc,iVar3 + 0x10);
              FUN_8004bd84(iVar3 + 0x10,iVar3 + 0x14);
              FUN_8004c348(iVar3 + 0x14,iVar3 + 0x10);
              FUN_8004b9cc();
              FUN_8004bbe8(iVar3 + 0x18,iVar3 + 0x14);
              FUN_8004c134(iVar3 + 0x18,iVar3 + 0x14);
              FUN_8004b9cc();
              FUN_8004ba4c(iVar3 + 0x1c,iVar3 + 0x18);
              FUN_8004bf20(iVar3 + 0x1c,iVar3 + 0x18);
              FUN_8004b9cc();
              FUN_8004ba4c(iVar3 + 0x20,iVar3 + 0x1c);
              FUN_8004bf20(iVar3 + 0x20,iVar3 + 0x1c);
              FUN_8004b9cc();
              FUN_8004bbe8(iVar3 + 0x20,iVar3 + 4);
              uVar5 = iVar3 + 0x20;
              iVar6 = iVar3 + 4;
              uVar4 = FUN_8004c134(uVar5,iVar6);
            }
          }
        }
        iVar18 = iVar18 + -1;
        param_1 = (int *)*param_1;
        if (iVar18 < 1) goto LAB_8004b8d8;
      }
      param_1 = *(int **)(iVar3 + 0x30);
      param_2 = param_2 + 0x110;
      bVar1 = 0 < param_4;
      param_4 = param_4 + -1;
    } while (bVar1);
  }
LAB_8004b8d8:
  *(undefined4 *)(param_3 + 0xc) = uVar4;
  return;
}


// Should not be empty, Ghidra fail
void FUN_8004b914(void)

{
  // For some reason, Ghidra gives no C code for this

                             **************************************************************
                             *                          FUNCTION                          *
                             **************************************************************
                             undefined FUN_8004b914()
             undefined         v0:1           <RETURN>
                             FUN_8004b914                                    XREF[3]:     FUN_8004b470:8004b6c0(c),
                                                                                          FUN_8004b470:8004b74c(c),
                                                                                          FUN_8004b470:8004b790(c)
        8004b914 23 58 8c 00     subu       t3,a0,t4
             assume gp = <UNKNOWN>
        8004b918 21 60 8c 00     addu       t4,a0,t4
        8004b91c ff ff 6b 31     andi       t3,t3,0xffff
        8004b920 ff ff 8c 31     andi       t4,t4,0xffff
        8004b924 25 58 63 01     or         t3,t3,v1
        8004b928 25 60 83 01     or         t4,t4,v1
        8004b92c 03 74 0e 00     sra        t6,t6,0x10
        8004b930 23 68 ae 00     subu       t5,a1,t6
        8004b934 21 70 ae 00     addu       t6,a1,t6
        8004b938 00 6c 0d 00     sll        t5,t5,0x10
        8004b93c 00 74 0e 00     sll        t6,t6,0x10
        8004b940 25 68 a4 01     or         t5,t5,a0
        8004b944 08 00 e0 03     jr         ra
        8004b948 25 70 c4 01     _or        t6,t6,a0

  return;
}



void FUN_8004b94c(int param_1,int param_2,undefined4 param_3,int param_4)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  undefined4 in_t3;
  undefined4 in_t4;
  undefined4 in_t5;
  undefined4 in_t6;

  uVar2 = getCopReg(2,0x7000);
  *(undefined4 *)(param_4 + 0x1c) = in_t3;
  *(undefined4 *)(param_4 + 0xc) = in_t4;
  *(undefined4 *)(param_4 + 4) = in_t5;
  *(undefined4 *)(param_4 + 0x14) = in_t6;
  uVar1 = uVar2 & 0xffff;
  iVar3 = (int)uVar2 >> 0x10;
  *(uint *)(param_4 + 0x20) = param_1 - uVar1 & 0xffff | (param_2 - iVar3) * 0x10000;
  *(uint *)(param_4 + 8) = param_1 + uVar1 & 0xffff | (param_2 - iVar3) * 0x10000;
  *(uint *)(param_4 + 0x18) = param_1 - uVar1 & 0xffff | (param_2 + iVar3) * 0x10000;
  *(uint *)(param_4 + 0x10) = param_1 + uVar1 & 0xffff | (param_2 + iVar3) * 0x10000;
  return;
}



void FUN_8004b9cc(void)

{
  int in_at;
  uint in_v1;
  uint in_t0;

  if ((int)in_v1 < 0) {
    in_v1 = 0;
  }
  else {
    if (-1 < (int)(in_v1 - *(ushort *)(in_at + 0x54))) {
      in_v1 = (uint)*(ushort *)(in_at + 0x54);
    }
  }
  if ((int)in_t0 < 0) {
    in_t0 = 0;
  }
  else {
    if (-1 < (int)(in_t0 - *(ushort *)(in_at + 0x56))) {
      in_t0 = (uint)*(ushort *)(in_at + 0x56);
    }
  }
  *(ushort *)(in_at + 0x62) =
       (ushort)((in_v1 + (int)*(short *)(in_at + 0x50) & 0x3ff) >> 6) |
       (ushort)((in_t0 + (int)*(short *)(in_at + 0x52) & 0x100) >> 4) | 0x100;
  return;
}



// WARNING: Removing unreachable block (ram,0x8004bb5c)

uint * FUN_8004ba4c(int param_1,int param_2)

{
  ushort uVar1;
  ushort uVar2;
  int in_at;
  uint *in_v0;
  char cVar3;
  char cVar4;
  uint uVar5;
  uint uVar6;
  uint *unaff_s6;
  char unaff_s7;

  uVar1 = *(ushort *)(in_at + 0x68);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(in_at + 0x6a);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x5c) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x5d) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_1 + 0xb0);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_1 + 0xb2);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x60) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x61) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_2 + 0xb0);
  cVar3 = (char)uVar1;
  cVar4 = (char)*(ushort *)(param_2 + 0xb2);
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if (-1 < (int)((uint)*(ushort *)(param_2 + 0xb2) - (uint)*(ushort *)(in_at + 0x56))) {
    cVar4 = (char)*(undefined2 *)(in_at + 0x56);
  }
  *(char *)(in_at + 100) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x65) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar5 = *(uint *)(param_1 + 0x8c);
  uVar6 = *(uint *)(param_2 + 0x8c);
  in_v0[2] = *(uint *)(in_at + 0x68);
  in_v0[4] = uVar5;
  in_v0[6] = uVar6;
  in_v0[1] = *(uint *)(in_at + 0x44) | 0x24000000;
  uVar5 = *(uint *)(in_at + 0x60);
  uVar6 = *(uint *)(in_at + 100);
  in_v0[3] = *(uint *)(in_at + 0x5c);
  in_v0[5] = uVar5;
  in_v0[7] = uVar6;
  *in_v0 = *unaff_s6 | 0x7000000;
  *unaff_s6 = (uint)in_v0 & 0xffffff;
  return in_v0 + 8;
}



// WARNING: Removing unreachable block (ram,0x8004bcf8)

uint * FUN_8004bbe8(int param_1,int param_2)

{
  ushort uVar1;
  ushort uVar2;
  int in_at;
  uint *in_v0;
  char cVar3;
  char cVar4;
  uint uVar5;
  uint uVar6;
  uint *unaff_s6;
  char unaff_s7;

  uVar1 = *(ushort *)(in_at + 0x68);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(in_at + 0x6a);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x5c) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x5d) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_1 + 0xb0);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_1 + 0xb2);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x60) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x61) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_2 + 0x8c);
  cVar3 = (char)uVar1;
  cVar4 = (char)*(ushort *)(param_2 + 0x8e);
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if (-1 < (int)((uint)*(ushort *)(param_2 + 0x8e) - (uint)*(ushort *)(in_at + 0x56))) {
    cVar4 = (char)*(undefined2 *)(in_at + 0x56);
  }
  *(char *)(in_at + 100) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x65) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar5 = *(uint *)(param_1 + 0x8c);
  uVar6 = *(uint *)(param_2 + 0xb0);
  in_v0[2] = *(uint *)(in_at + 0x68);
  in_v0[4] = uVar5;
  in_v0[6] = uVar6;
  in_v0[1] = *(uint *)(in_at + 0x44) | 0x24000000;
  uVar5 = *(uint *)(in_at + 0x60);
  uVar6 = *(uint *)(in_at + 100);
  in_v0[3] = *(uint *)(in_at + 0x5c);
  in_v0[5] = uVar5;
  in_v0[7] = uVar6;
  *in_v0 = *unaff_s6 | 0x7000000;
  *unaff_s6 = (uint)in_v0 & 0xffffff;
  return in_v0 + 8;
}



// WARNING: Removing unreachable block (ram,0x8004be94)

uint * FUN_8004bd84(int param_1,int param_2)

{
  ushort uVar1;
  ushort uVar2;
  int in_at;
  uint *in_v0;
  char cVar3;
  char cVar4;
  uint uVar5;
  uint uVar6;
  uint *unaff_s6;
  char unaff_s7;

  uVar1 = *(ushort *)(in_at + 0x68);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(in_at + 0x6a);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x5c) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x5d) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_1 + 0x8c);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_1 + 0x8e);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x60) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x61) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_2 + 0x8c);
  cVar3 = (char)uVar1;
  cVar4 = (char)*(ushort *)(param_2 + 0x8e);
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if (-1 < (int)((uint)*(ushort *)(param_2 + 0x8e) - (uint)*(ushort *)(in_at + 0x56))) {
    cVar4 = (char)*(undefined2 *)(in_at + 0x56);
  }
  *(char *)(in_at + 100) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x65) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar5 = *(uint *)(param_1 + 0xb0);
  uVar6 = *(uint *)(param_2 + 0xb0);
  in_v0[2] = *(uint *)(in_at + 0x68);
  in_v0[4] = uVar5;
  in_v0[6] = uVar6;
  in_v0[1] = *(uint *)(in_at + 0x44) | 0x24000000;
  uVar5 = *(uint *)(in_at + 0x60);
  uVar6 = *(uint *)(in_at + 100);
  in_v0[3] = *(uint *)(in_at + 0x5c);
  in_v0[5] = uVar5;
  in_v0[7] = uVar6;
  *in_v0 = *unaff_s6 | 0x7000000;
  *unaff_s6 = (uint)in_v0 & 0xffffff;
  return in_v0 + 8;
}



// WARNING: Removing unreachable block (ram,0x8004c098)

uint * FUN_8004bf20(int param_1,int param_2)

{
  ushort uVar1;
  ushort uVar2;
  int in_at;
  uint *in_v0;
  char cVar3;
  char cVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint *unaff_s6;
  char unaff_s7;

  uVar1 = *(ushort *)(param_1 + 0x68);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_1 + 0x6a);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x5c) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x5d) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_2 + 0x68);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_2 + 0x6a);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x60) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x61) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_1 + 0xb0);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_1 + 0xb2);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 100) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x65) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_2 + 0xb0);
  cVar3 = (char)uVar1;
  cVar4 = (char)*(ushort *)(param_2 + 0xb2);
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if (-1 < (int)((uint)*(ushort *)(param_2 + 0xb2) - (uint)*(ushort *)(in_at + 0x56))) {
    cVar4 = (char)*(undefined2 *)(in_at + 0x56);
  }
  *(char *)(in_at + 0x66) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x67) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  in_v0[1] = *(uint *)(in_at + 0x44) | 0x2c000000;
  uVar5 = *(uint *)(in_at + 0x60);
  uVar6 = *(uint *)(in_at + 100);
  in_v0[3] = *(uint *)(in_at + 0x5c);
  in_v0[5] = uVar5;
  in_v0[7] = uVar6;
  in_v0[9] = uVar6 >> 0x10;
  uVar5 = *(uint *)(param_2 + 0x68);
  uVar6 = *(uint *)(param_1 + 0x8c);
  uVar7 = *(uint *)(param_2 + 0x8c);
  in_v0[2] = *(uint *)(param_1 + 0x68);
  in_v0[4] = uVar5;
  in_v0[6] = uVar6;
  in_v0[8] = uVar7;
  *in_v0 = *unaff_s6 | 0x9000000;
  *unaff_s6 = (uint)in_v0 & 0xffffff;
  return in_v0 + 10;
}



// WARNING: Removing unreachable block (ram,0x8004c2ac)

uint * FUN_8004c134(int param_1,int param_2)

{
  ushort uVar1;
  ushort uVar2;
  int in_at;
  uint *in_v0;
  char cVar3;
  char cVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint *unaff_s6;
  char unaff_s7;

  uVar1 = *(ushort *)(param_1 + 0x68);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_1 + 0x6a);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x5c) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x5d) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_2 + 0x68);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_2 + 0x6a);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x60) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x61) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_1 + 0xb0);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_1 + 0xb2);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 100) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x65) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_2 + 0x8c);
  cVar3 = (char)uVar1;
  cVar4 = (char)*(ushort *)(param_2 + 0x8e);
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if (-1 < (int)((uint)*(ushort *)(param_2 + 0x8e) - (uint)*(ushort *)(in_at + 0x56))) {
    cVar4 = (char)*(undefined2 *)(in_at + 0x56);
  }
  *(char *)(in_at + 0x66) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x67) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  in_v0[1] = *(uint *)(in_at + 0x44) | 0x2c000000;
  uVar5 = *(uint *)(in_at + 0x60);
  uVar6 = *(uint *)(in_at + 100);
  in_v0[3] = *(uint *)(in_at + 0x5c);
  in_v0[5] = uVar5;
  in_v0[7] = uVar6;
  in_v0[9] = uVar6 >> 0x10;
  uVar5 = *(uint *)(param_2 + 0x68);
  uVar6 = *(uint *)(param_1 + 0x8c);
  uVar7 = *(uint *)(param_2 + 0xb0);
  in_v0[2] = *(uint *)(param_1 + 0x68);
  in_v0[4] = uVar5;
  in_v0[6] = uVar6;
  in_v0[8] = uVar7;
  *in_v0 = *unaff_s6 | 0x9000000;
  *unaff_s6 = (uint)in_v0 & 0xffffff;
  return in_v0 + 10;
}



// WARNING: Removing unreachable block (ram,0x8004c4c0)

uint * FUN_8004c348(int param_1,int param_2)

{
  ushort uVar1;
  ushort uVar2;
  int in_at;
  uint *in_v0;
  char cVar3;
  char cVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint *unaff_s6;
  char unaff_s7;

  uVar1 = *(ushort *)(param_1 + 0x8c);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_1 + 0x8e);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x5c) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x5d) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_2 + 0x8c);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_2 + 0x8e);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x60) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x61) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_1 + 0x68);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_1 + 0x6a);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 100) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x65) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_2 + 0x68);
  cVar3 = (char)uVar1;
  cVar4 = (char)*(ushort *)(param_2 + 0x6a);
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if (-1 < (int)((uint)*(ushort *)(param_2 + 0x6a) - (uint)*(ushort *)(in_at + 0x56))) {
    cVar4 = (char)*(undefined2 *)(in_at + 0x56);
  }
  *(char *)(in_at + 0x66) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x67) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  in_v0[1] = *(uint *)(in_at + 0x44) | 0x2c000000;
  uVar5 = *(uint *)(in_at + 0x60);
  uVar6 = *(uint *)(in_at + 100);
  in_v0[3] = *(uint *)(in_at + 0x5c);
  in_v0[5] = uVar5;
  in_v0[7] = uVar6;
  in_v0[9] = uVar6 >> 0x10;
  uVar5 = *(uint *)(param_2 + 0xb0);
  uVar6 = *(uint *)(param_1 + 0x68);
  uVar7 = *(uint *)(param_2 + 0x68);
  in_v0[2] = *(uint *)(param_1 + 0xb0);
  in_v0[4] = uVar5;
  in_v0[6] = uVar6;
  in_v0[8] = uVar7;
  *in_v0 = *unaff_s6 | 0x9000000;
  *unaff_s6 = (uint)in_v0 & 0xffffff;
  return in_v0 + 10;
}


// Save Lap Time -- called every frame
// param1 is number of laps
// param2 lap time
// param3 driverID
void FUN_8004c55c(int param_1,int param_2,short param_3)

{
  int iVar1;
  int iVar2;

  /*
	Stores all laps for all racers

	driver[0] Minute (10s) lap 0
	driver[0] Minute (10s) lap 1
	driver[0] Minute (10s) lap 2
	...
	driver[0] Minute (10s) lap 6

	driver[1] Minute (10s) lap 0
	driver[1] Minute (10s) lap 1
	driver[1] Minute (10s) lap 2
	...
	driver[1] Minute (10s) lap 6

	Only stores for two drivers

  */


  // ( (driverID * 7) + lapIndex) * 4
  iVar2 = ((int)param_3 * 7 + param_1) * 4;

  iVar1 = param_2 / 0xe100;
  *(int *)(&DAT_8009ac00 + iVar2) = iVar1;

  // if number of minutes is more than 9
  if (9 < iVar1)
  {
	// rig to 9:59:99
    *(int *)(&DAT_8009ac00 + iVar2) = 9;
    *(undefined4 *)(&DAT_8009aca8 + iVar2) = 5;
    *(undefined4 *)(&DAT_8009ace0 + iVar2) = 9;
    *(undefined4 *)(&DAT_8009ac38 + iVar2) = 9;
    *(undefined4 *)(&DAT_8009ac70 + iVar2) = 9;
    return;
  }

  // calculate proper lap time
  *(int *)(&DAT_8009aca8 + iVar2) = param_2 / 0x2580 + iVar1 * -6;
  *(int *)(&DAT_8009ace0 + iVar2) = param_2 / 0x3c0 + (param_2 / 0x2580) * -10;
  *(int *)(&DAT_8009ac38 + iVar2) =
       ((param_2 / 6 + (param_2 >> 0x1f) >> 4) - (param_2 >> 0x1f)) + (param_2 / 0x3c0) * -10;
  *(int *)(&DAT_8009ac70 + iVar2) = ((param_2 * 100) / 0x3c0) % 10;
  return;
}


// fruitdisp and timebox
void FUN_8004c718(int param_1)

{
  undefined *puVar1;
  short sVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int iVar6;

  puVar1 = PTR_DAT_8008d2ac;

  // object from thread
  iVar6 = *(int *)(param_1 + 0x30);

  // instance from thread
  iVar5 = *(int *)(param_1 + 0x34);

  // instance color
  *(undefined4 *)(iVar5 + 0x24) = 0xffff0000;

  // if numPlyrCurrGame is 1
  if (puVar1[0x1ca8] == '\x01')
  {
	// if instance->model->modelID is not timebox
    if (*(short *)(*(int *)(iVar5 + 0x18) + 0x10) != 0x5c)
	{
	  // If player's wumpa is less than 10
      if (*(char *)(*(int *)(puVar1 + 0x24ec) + 0x30) < '\n')
	  {
		// no shine
        *(undefined2 *)(iVar5 + 0x22) = 0;
      }
      else
	  {
		// wumpaShineResult
        *(short *)(iVar5 + 0x22) = ((short)DAT_8008d994 + -0x80) * 0x10;
      }
      goto LAB_8004c7a4;
    }
  }

  // if numPlyrCurrGame is not 1
  else {
LAB_8004c7a4:

	// if HUD item is not timecrate
    if (*(short *)(*(int *)(iVar5 + 0x18) + 0x10) != 0x5c)
	{
	  // rotation speed 0x80
      sVar2 = *(short *)(iVar6 + 2) + 0x80;
      goto LAB_8004c7d4;
    }
  }

  // if wumpa or crystal,
  // rotation speed 0x40
  sVar2 = *(short *)(iVar6 + 2) + 0x40;

LAB_8004c7d4:
  *(short *)(iVar6 + 2) = sVar2;
  iVar4 = iVar5 + 0x30;

   // convert 3 rotation shorts into rotation matrix
  FUN_8006c2a4(iVar4,iVar6);

  // MatrixRotate (param_1 = param_2 matrix rotated by param_3 matrix)
  FUN_8006c3b0(iVar4,iVar6 + 8,iVar4);

  // if hud is enabled, and this is not demo mode
  if ((*(uint *)(PTR_DAT_8008d2ac + 0x1d30) & 0xff0100) == 0x100)
  {
	// make visible
    uVar3 = *(uint *)(iVar5 + 0x28) & 0xffffff7f;
  }
  else
  {
	// make invisible
    uVar3 = *(uint *)(iVar5 + 0x28) | 0x80;
  }
  *(uint *)(iVar5 + 0x28) = uVar3;
  return;
}


// Draw various objects, like relic,
// key trophy, token, crystal, etc
// UI_ThTick_Reward
void FUN_8004c850(int param_1)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  int iVar4;

  // Get instance
  iVar4 = *(int *)(param_1 + 0x34);

  // Get object
  iVar2 = *(int *)(param_1 + 0x30);

  // Spin on the Y axis
  *(short *)(iVar2 + 2) = *(short *)(iVar2 + 2) + 0x40;

  // Vector_SpecLightSpin2D
  // instance, ptr rot[6], cop registers
  FUN_800572d0(iVar4,iVar2,iVar2 + 0x28);

  // pointer to matrix
  iVar3 = iVar4 + 0x30;

   // convert 3 rotation shorts into rotation matrix
  FUN_8006c2a4(iVar3,iVar2);

  // MatrixRotate (param_1 = param_2 matrix rotated by param_3 matrix)
  FUN_8006c3b0(iVar3,iVar2 + 8,iVar3);
  
  if (
		((*(uint *)(PTR_DAT_8008d2ac + 0x1d30) & 0xff0100) == 0x100) &&

		// if any fade-in-from-black transition is over
		(0xfff < *(short *)(PTR_DAT_8008d2ac + 0x139a))
	 )
  {
	// make visible
    uVar1 = *(uint *)(iVar4 + 0x28) & 0xffffff7f;
  }
  else
  {
	// make invisible
    uVar1 = *(uint *)(iVar4 + 0x28) | 0x80;
  }
  *(uint *)(iVar4 + 0x28) = uVar1;
  return;
}


// Handle CTR letters in HUD
void FUN_8004c914(int param_1)

{
  int iVar1;
  int iVar2;
  int iVar3;
  undefined2 local_18;
  short local_16;
  undefined2 local_14;

  // thread -> instance
  iVar2 = *(int *)(param_1 + 0x34);

  // thread -> object
  iVar3 = *(int *)(param_1 + 0x30);

  // I know they dont look like they rotate in HUD,
  // believe, me, there is "rotation" to some degree,
  // that's why the lighting changes in the HUD

  // Rotate on the Y axis
  *(short *)(iVar3 + 2) = *(short *)(iVar3 + 2) + 0x40;

  // Vector_SpecLightSpin2D
  // instance, ptr rot[6], cop registers
  FUN_800572d0(iVar2,iVar3,iVar3 + 0x28);

  if (
		// If you're in End-Of-Race menu
		((*(uint *)PTR_DAT_8008d2ac & 0x200000) != 0) &&

		(
			// TitleFlag_IsTransitioning
			iVar1 = FUN_80043f44(),
			iVar1 != 0
		)
	)
  {
	// Set Scale to zero, basically stop
	// drawing letters in the HUD
    *(undefined2 *)(iVar2 + 0x1c) = 0;
    *(undefined2 *)(iVar2 + 0x1e) = 0;
    *(undefined2 *)(iVar2 + 0x20) = 0;
  }

  if (*(short *)(iVar2 + 0x1c) == 0x800) {
    local_16 = 0;
  }
  else {
    iVar1 = (int)*(short *)(iVar2 + 0x1c) + -0x800;
    if (iVar1 < 0) {
      iVar1 = (int)*(short *)(iVar2 + 0x1c) + -0x401;
    }
    local_16 = ((short)(iVar1 >> 10) + 1) * 0x200;
  }
  local_18 = 0;
  local_14 = 0;
  iVar2 = iVar2 + 0x30;

   // convert 3 rotation shorts into rotation matrix
  FUN_8006c2a4(iVar2,&local_18);

  // MatrixRotate (param_1 = param_2 matrix rotated by param_3 matrix)
  FUN_8006c3b0(iVar2,iVar3 + 8,iVar2);
  
  return;
}


// function for "big1"
void FUN_8004ca04(int param_1)

{
  undefined2 uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;

  // Get object from thread
  iVar3 = *(int *)(param_1 + 0x30);

  // Get instance from thread
  iVar4 = *(int *)(param_1 + 0x34);

  uVar1 = *(undefined2 *)(iVar3 + 6);
  *(undefined2 *)(iVar4 + 0x32) = 0;
  *(undefined2 *)(iVar4 + 0x34) = 0;
  *(undefined2 *)(iVar4 + 0x36) = 0;
  *(undefined2 *)(iVar4 + 0x30) = uVar1;
  uVar1 = *(undefined2 *)(iVar3 + 6);
  *(undefined2 *)(iVar4 + 0x3a) = 0;
  *(undefined2 *)(iVar4 + 0x3c) = 0;
  *(undefined2 *)(iVar4 + 0x3e) = 0;
  *(undefined2 *)(iVar4 + 0x38) = uVar1;
  *(undefined2 *)(iVar4 + 0x40) = *(undefined2 *)(iVar3 + 6);
  
  // MatrixRotate (param_1 = param_2 matrix rotated by param_3 matrix)
  FUN_8006c3b0(iVar4 + 0x30,iVar3 + 8,iVar4 + 0x30);
  
  if ((*(uint *)(PTR_DAT_8008d2ac + 0x1d30) & 0xff0100) == 0x100)
  {
	// make visible
    uVar2 = *(uint *)(iVar4 + 0x28) & 0xffffff7f;
  }
  else
  {
	// make invisible
    uVar2 = *(uint *)(iVar4 + 0x28) | 0x80;
  }
  *(uint *)(iVar4 + 0x28) = uVar2;
  return;
}

// UI_ConvertX_2
int FUN_8004caa8(int param_1,int param_2)

{
  // new posX = (oldPosX - midpointX) * param_2
  param_2 = (param_1 + -0x100) * param_2;
  if (param_2 < 0) {
    param_2 = param_2 + 0xff;
  }

  // divide by 256 (0x100)
  return param_2 >> 8;
}


// UI_ConvertY_2
int FUN_8004cac8(int param_1,int param_2)

{
  // new posY = (oldPosY - midpointY) * param_2
  param_2 = (param_1 + -0x6c) * param_2;

  // If new posY is on the left of the screen
  if (param_2 < 0) {
    param_2 = param_2 + 0xff;
  }

  // divide by 256 (0x100)
  return param_2 >> 8;
}


// UI_INSTANCE_BirthWithThread
int FUN_8004cae8(int param_1,undefined4 param_2,int param_3,int param_4,int param_5,
                undefined4 param_6)

{
  short sVar1;
  short sVar2;
  short sVar3;
  ushort uVar4;
  undefined2 uVar5;
  int iVar6;
  long lVar7;
  undefined *puVar8;
  undefined4 uVar9;
  undefined *puVar10;
  short *psVar11;
  undefined2 *puVar12;
  int iVar13;
  int iVar14;
  int iVar15;
  int iVar16;
  short local_30;
  undefined2 local_2e;
  undefined2 local_2c;

  // get model pointer
  iVar16 = *(int *)(PTR_DAT_8008d2ac + param_1 * 4 + 0x2160);

								// numPlyrCurrGame - 1
  puVar8 = (&PTR_DAT_8008625c)[(uint)(byte)PTR_DAT_8008d2ac[0x1ca8] - 1];

  iVar13 = 0;
  if (iVar16 != 0)
  {
	// pointer to first Player thread
    iVar15 = *(int *)(PTR_DAT_8008d2ac + 0x1b2c);

    while (iVar15 != 0)
	{
	  // thread -> object
      iVar14 = *(int *)(iVar15 + 0x30);

	  // Create a new thread for this HUD element
	  // THREAD_BirthWithObject
	  // 0x38 = size
	  // 0 = no relation to param4
	  // 0x300 = SmallStackPool
	  // 0x10 = hud thread bucket
      iVar6 = FUN_8004205c(0x380310,param_2,param_6,0);

	  // Get the object attached to the thread
      puVar12 = *(undefined2 **)(iVar6 + 0x30);

	  // INSTANCE_Birth2D: Big Number HUD element
      iVar13 = FUN_800308e4(iVar16,0,iVar6);

	  // give the Instance to the thread
      *(int *)(iVar6 + 0x34) = iVar13;

      if (*(short *)(iVar16 + 0x10) == 0x38)
	  {
		// set pointer to instance of Big Number in HUD
        *(int *)(iVar14 + 0x498) = iVar13;
      }
      else {
        if (*(short *)(iVar16 + 0x10) == 0x37) {
          *(int *)(iVar14 + 0x49c) = iVar13;
        }
      }

	  // model -> id
	  sVar1 = *(short *)(iVar16 + 0x10);

	  // if this is a gem
	  if (sVar1 == 0x5f) {
        uVar9 = 0x6c08080;
LAB_8004cc4c:
        puVar12[0x14] = 0xf368;
        puVar12[0x15] = 0x99f;
        puVar12[0x16] = 0x232;
LAB_8004cc58:
        *(undefined4 *)(iVar13 + 0x24) = uVar9;

		// specular lighting
        *(uint *)(iVar13 + 0x28) = *(uint *)(iVar13 + 0x28) | 0x20000;
      }
      else
	  {
		// relic
        if (sVar1 == 0x61) {
          uVar9 = 0x60a5ff0;
          goto LAB_8004cc4c;
        }

		// crystal
        if (sVar1 == 0x60) {
          puVar12[0x14] = 0xf4a0;
          puVar12[0x15] = 0xb60;
          uVar9 = 0xd22fff0;
          puVar12[0x16] = 0xfd28;
          goto LAB_8004cc58;
        }

		// key
        if (sVar1 == 99) {
          uVar9 = 0xdca6000;
          goto LAB_8004cc4c;
        }

		// if C-T-R letters
        if ((ushort)(*(short *)(iVar16 + 0x10) - 0x93U) < 3) {
          puVar12[0x14] = 0xf368;
          puVar12[0x15] = 0x99f;
          puVar12[0x16] = 0x232;
          puVar12[0x19] = 0xc;

		  // modelID
          sVar1 = *(short *)(iVar16 + 0x10);

		  // letter C
          if (sVar1 == 0x93) {
            uVar5 = 0xfffc;
LAB_8004ccc8:
            puVar12[0x18] = uVar5;
          }
          else
		  {
			// letter T
            if (sVar1 == 0x94)
			{
              puVar12[0x18] = 0;
            }

			else
			{
			  // letter R
              if (sVar1 == 0x95) {
                uVar5 = 4;
                goto LAB_8004ccc8;
              }
            }
          }

		  // Set color
          *(undefined4 *)(iVar13 + 0x24) = 0xffc8000;

		  // specular lighting
          *(uint *)(iVar13 + 0x28) = *(uint *)(iVar13 + 0x28) | 0x30000;
        }
        else
		{
		  // token model
          if (sVar1 == 0x7d)
		  {
			// get AdvCup ID from level metadata
            uVar4 = (&DAT_80083a92)[*(int *)(PTR_DAT_8008d2ac + 0x1a10) * 0xc];

			puVar12[0x14] = 0xf368;
            puVar12[0x15] = 0x99f;
            puVar12[0x16] = 0x232;

			// get color from Adv Cup ID
			iVar6 = (int)((uint)uVar4 << 0x10) >> 0xd;
            sVar1 = *(short *)(&DAT_80084116 + iVar6);
            sVar2 = *(short *)(&DAT_80084118 + iVar6);
            sVar3 = *(short *)(&DAT_8008411a + iVar6);

			*(uint *)(iVar13 + 0x28) = *(uint *)(iVar13 + 0x28) | 0x30000;
            *(uint *)(iVar13 + 0x24) = (int)sVar1 << 0x14 | (int)sVar2 << 0xc | (int)sVar3 << 4;
          }
        }
      }

	  // if no tileView is supplied
	  if (param_5 == 0)
	  {
        psVar11 = (short *)(puVar8 + param_3 * 8);

		// Convert X
        uVar9 = FUN_8004caa8((int)*psVar11,(int)psVar11[2]);
        *(undefined4 *)(iVar13 + 0x44) = uVar9;

		// Convert Y
		uVar9 = FUN_8004cac8((int)psVar11[1],(int)psVar11[2]);
        *(undefined4 *)(iVar13 + 0x48) = uVar9;

		*(int *)(iVar13 + 0x4c) = (int)psVar11[2];
      }

	  // if tileView is supplied
      else
	  {
		// instance->tileView
        *(int *)(iVar13 + 0x74) = param_5;

		// record that tileView is present
		*(uint *)(iVar13 + 0x28) = *(uint *)(iVar13 + 0x28) | 0x100;

        *(undefined4 *)(iVar13 + 0x44) = 0;
        *(undefined4 *)(iVar13 + 0x48) = 0;
        *(undefined4 *)(iVar13 + 0x4c) = 0x200;
      }

	  puVar10 = puVar8 + param_3 * 8;
      *(undefined2 *)(iVar13 + 0x1c) = *(undefined2 *)(puVar10 + 6);
      *(undefined2 *)(iVar13 + 0x1e) = *(undefined2 *)(puVar10 + 6);
      uVar5 = *(undefined2 *)(puVar10 + 6);
      *(undefined *)(iVar13 + 0x50) = 0x80;
      *(undefined *)(iVar13 + 0x51) = 0x80;
      *(undefined2 *)(iVar13 + 0x20) = uVar5;
      if (param_4 == 0) {
        local_30 = 0;
      }
      else {
        lVar7 = ratan2(*(long *)(iVar13 + 0x48),*(long *)(iVar13 + 0x4c));
        local_30 = -(short)lVar7;
      }
      local_2e = 0;
      local_2c = 0;

	   // convert 3 rotation shorts into rotation matrix
      FUN_8006c2a4(puVar12 + 4,&local_30);

      *puVar12 = 0;
      puVar12[1] = 0;
      puVar12[2] = 0;
      puVar12[3] = 0x1000;

	  // thread = thread -> next
      iVar15 = *(int *)(iVar15 + 0x10);

	  puVar8 = puVar8 + 0xa0;
    }
  }
  return iVar13;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// UI_INSTANCE_InitAll
void FUN_8004cec4(void)

{
  undefined *puVar1;
  int iVar2;
  uint uVar3;
  undefined *puVar4;
  int iVar5;
  undefined2 *puVar6;
  undefined2 *puVar7;
  int iVar8;

  DAT_8008d4bc = DAT_8008d4bc & 0xfffffffe;
  *(uint *)(PTR_DAT_8008d2ac + 0x256c) = *(uint *)(PTR_DAT_8008d2ac + 0x256c) | 0x8000;


  puVar1 = PTR_DAT_8008d2ac;
  uVar3 = *(uint *)puVar1;

  // uVar3 is same as PTR_DAT_8008d2ac
  // For most of the function

  // If you're not in Crystal Challenge (in adventure mode)
  if ((uVar3 & 0x8000000) == 0)
  {
	// If you're in Adventure Arena
    if ((uVar3 & 0x100000) != 0)
	{
	  // UI_INSTANCE_BirthWithThread
      FUN_8004cae8(0x61,FUN_8004c850,0xe,1,0,s_relic1_8008d4c8);   // "relic1"
      FUN_8004cae8(99,FUN_8004c850,0xf,1,0,&DAT_8008d4d0);		   // "key1"
      FUN_8004cae8(0x62,FUN_8004c850,0x10,0,0,s_trophy1_8008d4d8); // "trophy1"

	  // GAMEPROG_AdvPercent
      FUN_800265c0(&DAT_8008fba4);
      return;
    }

	// loop iteration counter
    iVar8 = 0;

	// ???
	// If you're loading, or on adventure map, or in main menu ???
    if ((uVar3 & 0x4120000) != 0) {
      puVar7 = &DAT_800862d8;
      puVar6 = &DAT_800862c8;

	  // puVar4 = PTR_DAT_8008d2ac
      puVar4 = puVar1;

	  // for iVar8 = 0; iVar8 < 8; iVar8++
      do
	  {
		// loop through all player structures

		// player structure + 0x482 is your rank in the race
		// 0 = 1st place, 1 = 2nd place, 2 = 3rd place, etc
        *puVar6 = *(undefined2 *)(*(int *)(puVar4 + 0x24ec) + 0x482);

		// if more than 1 screen
        if (1 < (byte)puVar1[0x1ca8]) {
          *puVar7 = 5;
        }

		puVar7 = puVar7 + 1;
        puVar6 = puVar6 + 1;

		// increment loop counter
        iVar8 = iVar8 + 1;

		// increment pointer to next player structure
        puVar4 = puVar4 + 4;
      } while (iVar8 < 8);

	  // If you're not in a Relic Race
      if ((*(uint *)PTR_DAT_8008d2ac & 0x4000000) == 0) {
        return;
      }

	  // The rest of this block only happens in Relic Mode

	  // UI_INSTANCE_BirthWithThread
      DAT_8008d9b4 = FUN_8004cae8(0x61,FUN_8004c850,0xe,1,0,s_relic1_8008d4c8); // "relic1"
      DAT_8008d9d8 = FUN_8004cae8(0x5c,FUN_8004c718,0x13,1,0,"timebox1");

	  iVar8 = DAT_8008d9b4;

	  // if instance
      if (DAT_8008d9b4 != 0)
	  {
		// set scale to zero
        *(undefined2 *)(DAT_8008d9b4 + 0x20) = 0;
        *(undefined2 *)(iVar8 + 0x1e) = 0;
        *(undefined2 *)(iVar8 + 0x1c) = 0;
      }

	  // Level ID
      iVar8 = *(int *)(PTR_DAT_8008d2ac + 0x1a10);

	  // Get Relic Time to put in HUD
	  
	  // If not unlocked Gold and not unlocked Platinum
      if ((((uint)(&DAT_8008fba4)[(int)(iVar8 + 0x3aU) >> 5] >> (iVar8 + 0x3aU & 0x1f) & 1) == 0) &&
         (((uint)(&DAT_8008fba4)[(int)(iVar8 + 0x28U) >> 5] >> (iVar8 + 0x28U & 0x1f) & 1) == 0)) 
	  {
		// choose to put sapphire or gold on screen
        uVar3 = (uint)(&DAT_8008fba4)[(int)(iVar8 + 0x16U) >> 5] >> (iVar8 + 0x16U & 0x1f) & 1;
      }
	  
	  // if unlocked gold or unlocked platinum
      else 
	  {
		// put platinum time on screen
        uVar3 = 2;
      }

	  // Level ID
      iVar5 = *(int *)(PTR_DAT_8008d2ac + 0x1a10);
      
	  // int offset in table
	  iVar2 = uVar3 * 4;

	  // [change for easy reading]
	  // get relic time on this track, for this relic type (sapphire, gold, platinum)
	  uVar3 = *(int *)(&DAT_80086340 + iVar2 + iVar5 * 0xc);

	  // [change for easy reading]
	  // store globally for HUD to access later
      iVar8 = uVar3 >> 0x1f;
      _DAT_8008d9b0 = uVar3 / 0xe100;
      _DAT_8008d9b8 = ((uVar3 * 100) / 0x3c0) % 10;
      _DAT_8008d9d4 = ((uVar3 / 6 + iVar8 >> 4) - iVar8) % 10;
      _DAT_8008d9e0 = (uVar3 / 0x2580) % 6;
      _DAT_8008d9e8 = (uVar3 / 0x3c0) % 10;
      return;
    }
    DAT_8008d4b4 = (undefined2 *)0x0;

	// if more than 1 screen
	if (1 < (byte)puVar1[0x1ca8])
	{
      DAT_8008d4b4 = &DAT_8009ad18;
    }
	
	// second half of pixel-LOD tileView, copy from TileView_UI
    DAT_8009ad40 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x13b0);
    DAT_8009ad44 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x13b4);
    DAT_8009ad48 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x13b8);
    DAT_8009ad4c = *(undefined4 *)(PTR_DAT_8008d2ac + 0x13bc);
    DAT_8009ad50 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x13c0);
    DAT_8009ad54 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x13c4);
    DAT_8009ad58 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x13c8);
    DAT_8009ad5c = *(undefined4 *)(PTR_DAT_8008d2ac + 0x13cc);
	
	// first half of pixel-LOD tileView, copy from TileView_UI
    DAT_8009ad18 = *(undefined2 *)(PTR_DAT_8008d2ac + 5000); // 0x1388
    DAT_8009ad1a = *(undefined2 *)(PTR_DAT_8008d2ac + 0x138a);
    DAT_8009ad1c = *(undefined2 *)(PTR_DAT_8008d2ac + 0x138c);
    DAT_8009ad34 = *(undefined2 *)(PTR_DAT_8008d2ac + 0x13a4);
    DAT_8009ad36 = *(undefined2 *)(PTR_DAT_8008d2ac + 0x13a6);
    DAT_8009ad38 = *(undefined2 *)(PTR_DAT_8008d2ac + 0x13a8);
    DAT_8009ad3a = *(undefined2 *)(PTR_DAT_8008d2ac + 0x13aa);

	// pointer to OT mem
    DAT_8009ae0c = *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c);

    DAT_8009ad30 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x13a0);

	// create thread and Instance for "fruitdisp"
	// the function returns an enttity
    DAT_8008d4b8 = FUN_8004cae8(0x37,FUN_8004c718,3,1,DAT_8008d4b4,"fruitdisp");

    if (
			// If numPlyrCurrGame is less than 3
			((byte)PTR_DAT_8008d2ac[0x1ca8] < 3) &&

			// If you're not in Battle Mode
			((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0)
		)
	{
	  // UI_INSTANCE_BirthWithThread
      FUN_8004cae8(0x38,FUN_8004ca04,2,0,0,&DAT_8008d4e0); // "big1"
    }

	// If you're not in Adventure Mode
    if ((*(uint *)PTR_DAT_8008d2ac & 0x80000) == 0) {
      return;
    }

	// UI_INSTANCE_BirthWithThread
    DAT_8008d9cc = FUN_8004cae8(0x93,FUN_8004c914,0x12,0,0,&DAT_8008d4e8); // "hudc"
    DAT_8008d9c4 = FUN_8004cae8(0x94,FUN_8004c914,0x12,0,0,&DAT_8008d4f0); // "hudt"
    DAT_8008d9c8 = FUN_8004cae8(0x95,FUN_8004c914,0x12,0,0,&DAT_8008d4f8); // "hudr"
    iVar2 = FUN_8004cae8(0x7d,FUN_8004c850,0x12,0,0,s_token_8008d4c0); // "token"

	// letter T
	iVar8 = DAT_8008d9c4;

	// make letter C invisible
    *(uint *)(DAT_8008d9cc + 0x28) = *(uint *)(DAT_8008d9cc + 0x28) | 0x80;

	// copy pointer to letter R in HUD
	iVar5 = DAT_8008d9c8;

	// make letter T invisible invisible
    *(uint *)(iVar8 + 0x28) = *(uint *)(iVar8 + 0x28) | 0x80;
  }

  // If you're in Crystal Challenge
  else
  {
	// UI_INSTANCE_BirthWithThread

	//Make a separate crystal for End of Race menu
    DAT_8008d9c0 = FUN_8004cae8(0x60,FUN_8004c850,0x11,0,0,"crystal1");

	// Make a crystal for HUD
    DAT_8008d9bc = FUN_8004cae8(0x60,FUN_8004c850,0x11,0,0,"crystal1");

	// Make a token
    iVar2 = FUN_8004cae8(0x7d,FUN_8004c850,0x12,0,0,s_token_8008d4c0); // "token"

	// copy pointer to crystal in HUD
	iVar5 = DAT_8008d9bc;
  }

  // make invisible, either crystal in HUD, or letter R in HUD
  *(uint *)(iVar5 + 0x28) = *(uint *)(iVar5 + 0x28) | 0x80;

  // make copy of Token pointer
  DAT_8008d9d0 = iVar2;

  // set Token scale (x, y, z) to zero
  *(undefined2 *)(iVar2 + 0x1c) = 0;
  *(undefined2 *)(iVar2 + 0x1e) = 0;
  *(undefined2 *)(iVar2 + 0x20) = 0;

  // make Token invisible
  *(uint *)(iVar2 + 0x28) = *(uint *)(iVar2 + 0x28) | 0x80;
  return;
}


// Draw map
void FUN_8004d614(int param_1,int param_2,short param_3,short param_4,int param_5,void *param_6,
                 byte param_7)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  undefined2 uVar5;
  short sVar6;
  short sVar7;
  short sVar8;
  int iVar9;
  void *p;
  // uVar10 is used for checking if the minimap is drawn in a color other than white; set to 1 if white, set to 0 if blue or black
  uint uVar10;
  // uVar11 stores the color that the minimap gets recolored to
  undefined4 uVar11;

  uVar10 = (uint)param_7;
  iVar9 = 0;

  // draw map with neutral/none vertex color, minimap's regular color is white
  uVar11 = 0x808080; 

  // draw map black
  // used for the minimap shadow in the track select screen
  if (param_7 == 2) {
    uVar10 = 0;
    uVar11 = 0;
  }

  // draw map blue
  // used for the minimap outline in the track select screen
  else {
    if (param_7 == 3) {
      uVar10 = 0;
      uVar11 = 0x402000;
    }
  }

  // LEV -> trial_data -> numPointers
  if (**(int **)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x134) != 0)
  {
	// LEV -> trial_data -> ptr_map
    iVar9 = (*(int **)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x134))[1];
  }

  bVar1 = *(byte *)(param_2 + 0x18);
  bVar2 = *(byte *)(param_2 + 0x14);
  sVar6 = (ushort)*(byte *)(param_2 + 0x1d) - (ushort)*(byte *)(param_2 + 0x15);

  if (
		((iVar9 != 0) && (*(short *)(iVar9 + 0x12) == 0)) ||

		// If in main menu (character selection, track selection, any part of it)
		((*(uint *)PTR_DAT_8008d2ac & 0x2000) != 0)
	)
  {
	// draw top half of map (param1)

    p = *(void **)(param_5 + 0xc);
    bVar3 = *(byte *)(param_1 + 0x1d);
    bVar4 = *(byte *)(param_1 + 0x15);
    sVar8 = param_3 - ((ushort)*(byte *)(param_1 + 0x18) - (ushort)*(byte *)(param_1 + 0x14));

	// color
	*(undefined4 *)((int)p + 4) = uVar11;

	// u0, v0, clut
    *(undefined4 *)((int)p + 0xc) = *(undefined4 *)(param_1 + 0x14);
    
	// u1, v1, tpage
	*(undefined4 *)((int)p + 0x14) = *(undefined4 *)(param_1 + 0x18);
    
	sVar7 = param_4 - (((ushort)bVar3 - (ushort)bVar4) + sVar6);
    
	// u2, v2, pad1
	*(undefined4 *)((int)p + 0x1c) = *(undefined4 *)(param_1 + 0x1c);
    
	uVar5 = *(undefined2 *)(param_1 + 0x1e);
    *(short *)((int)p + 0x1a) = param_4 - sVar6;
    *(short *)((int)p + 0x22) = param_4 - sVar6;
	
	// psyq macro setPolyFT4
    *(undefined *)((int)p + 3) = 9;
    *(undefined *)((int)p + 7) = 0x2c;
	
	// x0
    *(short *)((int)p + 8) = sVar8;
    
	// y0
	*(short *)((int)p + 10) = sVar7;
    
	// x1
	*(short *)((int)p + 0x10) = param_3;
    
	// y1
	*(short *)((int)p + 0x12) = sVar7;
    
	*(short *)((int)p + 0x18) = sVar8;
    *(short *)((int)p + 0x20) = param_3;
    *(undefined2 *)((int)p + 0x24) = uVar5;

	// if this is the white map
    if (uVar10 != 0)
	{
	  // tpage
      *(ushort *)((int)p + 0x16) = *(ushort *)((int)p + 0x16) & 0xff9f | (ushort)(uVar10 << 5);
    }

    *(byte *)((int)p + 7) = *(byte *)((int)p + 7) | 2;
    AddPrim(param_6,p);

	// POLY_FT4 is 0x28 bytes large
    *(int *)(param_5 + 0xc) = *(int *)(param_5 + 0xc) + 0x28;
  }

  // draw bottom half of map (param2)

  p = *(void **)(param_5 + 0xc);

  // color
  *(undefined4 *)((int)p + 4) = uVar11;

  // uv0
  *(undefined4 *)((int)p + 0xc) = *(undefined4 *)(param_2 + 0x14);

  // uv1
  *(undefined4 *)((int)p + 0x14) = *(undefined4 *)(param_2 + 0x18);

  // x - size
  sVar7 = param_3 - ((ushort)bVar1 - (ushort)bVar2);

  // uv2
  *(undefined4 *)((int)p + 0x1c) = *(undefined4 *)(param_2 + 0x1c);

  // uv3
  uVar5 = *(undefined2 *)(param_2 + 0x1e);

  // y0
  *(short *)((int)p + 10) = param_4 - sVar6;

  // y1
  *(short *)((int)p + 0x12) = param_4 - sVar6;

  // psyq macro setPolyFT4
  *(undefined *)((int)p + 3) = 9;
  *(undefined *)((int)p + 7) = 0x2c;

  // x0
  *(short *)((int)p + 8) = sVar7;

  // x1
  *(short *)((int)p + 0x10) = param_3;

  // x2
  *(short *)((int)p + 0x18) = sVar7;

  // y2
  *(short *)((int)p + 0x1a) = param_4;

  // x3
  *(short *)((int)p + 0x20) = param_3;

  // y3
  *(short *)((int)p + 0x22) = param_4;

  // uv3
  *(undefined2 *)((int)p + 0x24) = uVar5;

  // if this is the white map
  if (uVar10 != 0)
  {
	// tpage
    *(ushort *)((int)p + 0x16) = *(ushort *)((int)p + 0x16) & 0xff9f | (ushort)(uVar10 << 5);
  }

  *(byte *)((int)p + 7) = *(byte *)((int)p + 7) | 2;
  AddPrim(param_6,p);
  *(int *)(param_5 + 0xc) = *(int *)(param_5 + 0xc) + 0x28;
  return;
}


// UI_Map_GetIconPos
void FUN_8004d8b4(short *param_1,int *param_2,int *param_3)

{
  short sVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;

  iVar5 = (int)param_1[7] + -0x10;
  iVar3 = (int)*param_1 - (int)param_1[2];
  sVar1 = param_1[8];
  iVar4 = (int)param_1[1] - (int)param_1[3];
  if (sVar1 == 0) {
    if (iVar3 == 0) {
      trap(0x1c00);
    }
    if ((iVar3 == -1) && (*param_2 * (int)param_1[4] == -0x80000000)) {
      trap(0x1800);
    }
    iVar2 = *param_3 * (int)param_1[5] * 2;
    if (iVar4 == 0) {
      trap(0x1c00);
    }
    if ((iVar4 == -1) && (iVar2 == -0x80000000)) {
      trap(0x1800);
    }
    iVar3 = (int)param_1[6] + (*param_2 * (int)param_1[4]) / iVar3;
    iVar5 = iVar5 + iVar2 / iVar4;
  }
  else {
    if (sVar1 == 1) {
      iVar2 = *param_2 * (int)param_1[5] * 2;
      if (iVar3 == 0) {
        trap(0x1c00);
      }
      if ((iVar3 == -1) && (iVar2 == -0x80000000)) {
        trap(0x1800);
      }
      if (iVar4 == 0) {
        trap(0x1c00);
      }
      if ((iVar4 == -1) && (*param_3 * (int)param_1[4] == -0x80000000)) {
        trap(0x1800);
      }
      iVar5 = iVar5 + iVar2 / iVar3;
      iVar3 = (int)param_1[6] - (*param_3 * (int)param_1[4]) / iVar4;
    }
    else {
      if (sVar1 == 2) {
        if (iVar3 == 0) {
          trap(0x1c00);
        }
        if ((iVar3 == -1) && (*param_2 * (int)param_1[4] == -0x80000000)) {
          trap(0x1800);
        }
        iVar2 = *param_3 * (int)param_1[5] * 2;
        if (iVar4 == 0) {
          trap(0x1c00);
        }
        if ((iVar4 == -1) && (iVar2 == -0x80000000)) {
          trap(0x1800);
        }
        iVar3 = (int)param_1[6] - (*param_2 * (int)param_1[4]) / iVar3;
        iVar5 = iVar5 - iVar2 / iVar4;
      }
      else {
        iVar2 = *param_2 * (int)param_1[5] * 2;
        if (iVar3 == 0) {
          trap(0x1c00);
        }
        if ((iVar3 == -1) && (iVar2 == -0x80000000)) {
          trap(0x1800);
        }
        if (iVar4 == 0) {
          trap(0x1c00);
        }
        if ((iVar4 == -1) && (*param_3 * (int)param_1[4] == -0x80000000)) {
          trap(0x1800);
        }
        iVar5 = iVar5 - iVar2 / iVar3;
        iVar3 = (int)param_1[6] + (*param_3 * (int)param_1[4]) / iVar4;
      }
    }
  }

  // If numPlyrCurrGame is 3
  if (PTR_DAT_8008d2ac[0x1ca8] == '\x03') {
    iVar3 = iVar3 + -0x3c;
    iVar5 = iVar5 + 10;
  }
  *param_2 = iVar3;
  *param_3 = iVar5;
  return;
}



// WARNING: Could not reconcile some variable overlaps

// Draw dot for Player on 2D Adv Map
void FUN_8004dbac(undefined4 param_1,undefined4 *param_2,undefined4 param_3,undefined4 param_4,
                 short param_5,short param_6)

{
  undefined *puVar1;
  undefined4 local_18;
  undefined4 local_14;

  local_18 = *param_2;
  local_14 = param_2[2];

  // Get Icon Dimensions
  FUN_8004d8b4(param_1,&local_18,&local_14);

  puVar1 = &DAT_80086424;
  if ((*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 2) != 0) {
    puVar1 = &DAT_80086430;
  }

  // AH_Map_HubArrow
  FUN_800b0f18((int)(short)local_18,(int)(short)local_14,&DAT_80086418,puVar1,(int)param_6,
               (int)param_5);
  return;
}


// UI_Map_DrawRawIcon
// param_4 color index
// param_6 scale
void FUN_8004dc44(undefined4 param_1,undefined4 *param_2,int param_3,int param_4,undefined4 param_5,
                 short param_6)

{
  int *piVar1;
  undefined4 local_18;
  undefined4 local_14;

  local_18 = *param_2;
  local_14 = param_2[2];

  // Icon dimensions
  FUN_8004d8b4(param_1,&local_18,&local_14);

  // color data
  piVar1 = (int *)((int)&PTR_DAT_80081d70 + ((param_4 << 0x10) >> 0xe));

  // DecalHUD_DrawPolyGT4
  FUN_80023054(*(undefined4 *)
                (*(int *)(PTR_DAT_8008d2ac + 0x2128) + ((param_3 << 0x10) >> 0xe) + 0x14),

			   // dimensions
			   local_18,
               local_14,

			   // pointer to PrimMem struct
			   *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

			   // pointer to OT mem
			   *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

			   // color data
			   *(undefined4 *)*piVar1,
               *(undefined4 *)(*piVar1 + 4),
			   *(undefined4 *)(*piVar1 + 8),
               *(undefined4 *)(*piVar1 + 0xc),

			   0,

			   // scale
			   (int)param_6);
  return;
}


// UI_Map_DrawDrivers
void FUN_8004dd5c(undefined4 param_1,int param_2,short *param_3)

{
  int iVar1;
  undefined4 uVar2;
  int iVar3;

  if (param_2 != 0)
  {
	// loop through all drivers
    do
	{
	  // If numPlyrCurrGame is 1, or 3
      if ((PTR_DAT_8008d2ac[0x1ca8] == '\x01') || (PTR_DAT_8008d2ac[0x1ca8] == '\x03'))
	  {
		// Player structure
        iVar3 = *(int *)(param_2 + 0x30);

		// Player / AI structure + 0x4a shows driver index (0-7)

		// color data index 5 is where color
		// of each kart is stored in the array

		// characterID + 5
        iVar1 = (uint)(ushort)(&DAT_80086e84)[*(byte *)(iVar3 + 0x4a)] + 5;

        // if this is human and not AI
        if ((*(uint *)(iVar3 + 0x2c8) & 0x100000) == 0) {

		  // If you're in Adventure Arena
          if ((*(uint *)PTR_DAT_8008d2ac & 0x100000) != 0)
		  {
            // If this is an even-numbered frame
            if ((*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 2) == 0) {
              iVar1 = 4;
            }

			// If this is an odd numbered frame
            else
			{
			  // cast to short, remove higher bits
              iVar1 = iVar1 * 0x10000 >> 0x10;
            }

			// Draw dot for Player on 2D Adv Map
            FUN_8004dbac(param_1,*(int *)(param_2 + 0x34) + 0x44,0x32,iVar1,
                         (int)(short)(*(short *)(iVar3 + 0x2ee) + 0x800U | 0x1000),0x800);

            goto LAB_8004dea8;
          }

		  // If this is an even numbered frame
          if ((*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 2) == 0) {
            iVar1 = 4;
          }

		  // If this is an odd numbered frame
          else {
            iVar1 = iVar1 * 0x10000 >> 0x10;
          }
          uVar2 = 0x32;
        }
        else {
          uVar2 = 0x31;
          iVar1 = iVar1 * 0x10000 >> 0x10;
        }

		// UI_Map_DrawRawIcon
        FUN_8004dc44(param_1,*(int *)(param_2 + 0x34) + 0x44,uVar2,iVar1,0,0x1000);
      }
LAB_8004dea8:

	  // count how many icons have been drawn,
	  // this was used in prototypes to draw
	  // ascii numbers on maps, wasn't fully removed
      *param_3 = *param_3 + 1;

	  // thread = thread->sibling
      param_2 = *(int *)(param_2 + 0x10);

    } while (param_2 != 0);
  }
  return;
}


// Draw all ghosts on 2D map
void FUN_8004dee8(undefined4 param_1,int param_2)
{
  undefined4 uVar1;

  //if (ghost struct pointer?) is not 0 (if you are in Time Trial mode)
  if (param_2 != 0)
  {
	// loop through all ghosts
    do {
      //if you have beaten Nefarious Tropy
      if (*(short *)(*(int *)(param_2 + 0x30) + 0x632) != 0) {
        if (*(short *)(*(int *)(param_2 + 0x30) + 0x630) == 0) {
          uVar1 = 6;
          //if the number of elapsed frames since boot is odd
          if ((*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 1) != 0) {
            uVar1 = 5;
          }
        }
        else {
          uVar1 = 0x11;

		  // if timeTrialFlags for this track show [ n tropy beaten ]
          if (((*(uint *)(&DAT_8008e814 + *(int *)(PTR_DAT_8008d2ac + 0x1a10) * 0x124) & 2) != 0) &&
             (uVar1 = 3, (*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 1) != 0)) {
            uVar1 = 4;
          }
        }

		// UI_Map_DrawRawIcon
        FUN_8004dc44(param_1,*(int *)(param_2 + 0x34) + 0x44,0x31,uVar1,0,0x1000);
      }

	  // Go to next ghost
	  // thread = thread->sibling
      param_2 = *(int *)(param_2 + 0x10);

    } while (param_2 != 0);
  }
  return;
}


// Draw all "Tracking" warp balls on 2D map
void FUN_8004dffc(undefined4 param_1,int param_2)

{
  undefined4 uVar1;
  int iVar2;

  if (param_2 != 0) {
    do {

	  // thread -> instance
      iVar2 = *(int *)(param_2 + 0x34);

	  // instance -> model -> modelID == warpball
      if (*(short *)(*(int *)(iVar2 + 0x18) + 0x10) == 0x36)
	  {
		// UI_Map_DrawRawIcon
        FUN_8004dc44(param_1,iVar2 + 0x44,0x20,0,0,0x1000);

		// get object from thread
        iVar2 = **(int **)(*(int *)(iVar2 + 0x6c) + 0x30);

        uVar1 = 4;

		// if object exists
        if (iVar2 != 0) {
          if ((*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 1) != 0) {
            uVar1 = 3;
          }

		  // UI_Map_DrawRawIcon
          FUN_8004dc44(param_1,*(int *)(iVar2 + 0x1c) + 0x44,0x21,uVar1,0,0x1000);
        }
      }

      param_2 = *(int *)(param_2 + 0x10);
    } while (param_2 != 0);
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

// UI_WeaponBG_AnimateShine
void FUN_8004e0e0(void)

{
  int iVar1;
  uint local_18;
  uint local_14;
  uint local_10;

  // Sine(wumpaShineTheta)
  iVar1 = FUN_8003d184((int)DAT_8008d990);

  if (iVar1 < 0) {
    iVar1 = -iVar1;
  }
  local_18._0_2_ =
       CONCAT11((char)(iVar1 * 0x7f >> 0xc) + '\x7f',(char)(iVar1 * 0x7f >> 0xc) + '\x7f');
  local_18 = (uint)(ushort)local_18;
  DAT_8008d998 = local_18;
  local_14._0_2_ = CONCAT11((char)(iVar1 * 0x32 >> 0xc) + '2',(char)(iVar1 * 0x7f >> 0xc) + '\x7f');
  local_14 = (uint)(ushort)local_14;
  DAT_8008d99c = local_14;
  local_10._0_2_ = CONCAT11((char)(iVar1 * 0x10 >> 0xc) + '\x10',(char)(iVar1 * 0x21 >> 0xc) + '!');
  local_10 = (uint)(ushort)local_10;
  DAT_8008d9a0 = local_10;
  local_18._0_2_ = CONCAT11((char)(iVar1 * 0x5f >> 0xc) + '_',(char)(iVar1 * 0x5f >> 0xc) + '_');
  local_18 = (uint)CONCAT12((char)(iVar1 * 0x5f >> 0xc) + '_',(ushort)local_18);
  local_14._0_2_ = CONCAT11((char)(iVar1 * 0x5f >> 0xc) + '_',(char)(iVar1 * 0x5f >> 0xc) + '_');
  local_14 = (uint)CONCAT12((char)(iVar1 * 0x5f >> 0xc) + '_',(ushort)local_14);
  local_10._0_2_ = CONCAT11((char)(iVar1 * 0x5f >> 0xc) + '_',(char)(iVar1 * 0x5f >> 0xc) + '_');
  local_10 = (uint)CONCAT12((char)(iVar1 * 0x5f >> 0xc) + '_',(ushort)local_10);

  // wumpaShineResult
  DAT_8008d994 = (iVar1 * 0xff >> 0xd) + 0x80;

  DAT_8008d9a4 = local_18;
  DAT_8008d9a8 = local_14;
  DAT_8008d9ac = local_10;
  return;
}


// UI_WeaponBG_DrawShine
void FUN_8004e37c(int param_1,short param_2,short param_3,int param_4,void *param_5,byte param_6,
                 short param_7,short param_8)

{
  short sVar1;
  short sVar2;
  short sVar3;
  short sVar4;
  short sVar5;
  short sVar6;
  void *p;
  undefined4 uVar7;
  int iVar8;
  undefined4 uVar9;
  int iVar10;
  short sVar11;
  short sVar12;
  undefined4 uVar13;

  // color1[3]
  uVar7 = DAT_8008d9a4;
  uVar9 = DAT_8008d9a8;
  uVar13 = DAT_8008d9ac;
  
  if (param_6 != 3) 
  {
	// color2[3]
    uVar7 = DAT_8008d998;
    uVar9 = DAT_8008d99c;
    uVar13 = DAT_8008d9a0;
  }
  
  iVar10 = 0;
  iVar8 = (int)(((uint)*(byte *)(param_1 + 0x18) - (uint)*(byte *)(param_1 + 0x14)) * (int)param_7)
          >> 0xc;
  sVar3 = (short)iVar8;
  sVar1 = param_2 + sVar3;
  param_7 = param_7 >> 0xc;
  sVar12 = sVar1 - param_7;
  sVar4 = (short)((int)(((uint)*(byte *)(param_1 + 0x1d) - (uint)*(byte *)(param_1 + 0x15)) *
                       (int)param_8) >> 0xc);
  sVar2 = param_3 + sVar4;
  param_8 = param_8 >> 0xc;
  sVar11 = sVar2 - param_8;
  
  // loop 4 times
  do 
  {
    p = *(void **)(param_4 + 0xc);
    *(undefined4 *)((int)p + 0xc) = *(undefined4 *)(param_1 + 0x14);
    *(undefined4 *)((int)p + 0x18) = *(undefined4 *)(param_1 + 0x18);
    *(undefined4 *)((int)p + 0x24) = *(undefined4 *)(param_1 + 0x1c);
    *(undefined2 *)((int)p + 0x30) = *(undefined2 *)(param_1 + 0x1e);
    
	// first
	if (iVar10 == 0) 
	{
	  // xy0
      *(short *)((int)p + 8) = param_2;
      *(short *)((int)p + 10) = param_3;
	  
      *(short *)((int)p + 0x14) = sVar1;
      *(short *)((int)p + 0x16) = param_3;
      *(short *)((int)p + 0x20) = param_2;
      *(short *)((int)p + 0x22) = sVar2;
      *(short *)((int)p + 0x2c) = sVar1;
      *(short *)((int)p + 0x2e) = sVar2;
    }
    else 
	{
	  // second
      if (iVar10 == 1) 
	  {  
		// xy0
		sVar5 = (param_2 + (short)(iVar8 << 1)) - param_7;
        *(short *)((int)p + 8) = sVar5;
        *(short *)((int)p + 10) = param_3;
		
        *(short *)((int)p + 0x14) = sVar12;
        *(short *)((int)p + 0x16) = param_3;
        *(short *)((int)p + 0x20) = sVar5;
        *(short *)((int)p + 0x22) = sVar2;
        *(short *)((int)p + 0x2c) = sVar12;
        *(short *)((int)p + 0x2e) = sVar2;
      }
      else 
	  {
		// third  
        if (iVar10 == 2) 
		{
		  // xy0
          sVar5 = (param_3 + sVar4 * 2) - param_8;
          *(short *)((int)p + 8) = param_2;
          *(short *)((int)p + 10) = sVar5;
          
		  *(short *)((int)p + 0x14) = sVar1;
          *(short *)((int)p + 0x16) = sVar5;
          *(short *)((int)p + 0x20) = param_2;
          *(short *)((int)p + 0x22) = sVar11;
          *(short *)((int)p + 0x2c) = sVar1;
        }
        
		// fourth
		else 
		{
		  // xy0
          sVar5 = (param_2 + sVar3 * 2) - param_7;
          sVar6 = (param_3 + sVar4 * 2) - param_8;
          *(short *)((int)p + 8) = sVar5;
          *(short *)((int)p + 10) = sVar6;
		  
          *(short *)((int)p + 0x14) = sVar12;
          *(short *)((int)p + 0x16) = sVar6;
          *(short *)((int)p + 0x20) = sVar5;
          *(short *)((int)p + 0x22) = sVar11;
          *(short *)((int)p + 0x2c) = sVar12;
        }
        *(short *)((int)p + 0x2e) = sVar11;
      }
    }
    
	// color RGB
	*(undefined4 *)((int)p + 4) = uVar13;
	
    *(undefined4 *)((int)p + 0x10) = uVar9;
    *(undefined4 *)((int)p + 0x1c) = uVar9;
    *(undefined4 *)((int)p + 0x28) = uVar7;
	
	// psyq macro setPolyGT4
    *(undefined *)((int)p + 3) = 0xc;
    *(undefined *)((int)p + 7) = 0x3c;
    
	if (param_6 != 0) {
      *(ushort *)((int)p + 0x1a) =
           *(ushort *)((int)p + 0x1a) & 0xff9f | ((ushort)param_6 - 1) * 0x20;
      *(byte *)((int)p + 7) = *(byte *)((int)p + 7) | 2;
    }
	
    AddPrim(param_5,p);
    
	// count
	iVar10 = iVar10 + 1;
	
	// increment primMem
    *(int *)(param_4 + 0xc) = *(int *)(param_4 + 0xc) + 0x34;
	
  } while (iVar10 < 4);
  return;
}


// UI_TrackerBG
void FUN_8004e660(int param_1,short param_2,short param_3,int param_4,void *param_5,byte param_6,
                 short param_7,short param_8,undefined4 param_9)

{
  short sVar1;
  short sVar2;
  short sVar3;
  short sVar4;
  short sVar5;
  short sVar6;
  void *p;
  int iVar7;
  int iVar8;
  short sVar9;
  short sVar10;

  iVar8 = 0;
  iVar7 = (int)(((uint)*(byte *)(param_1 + 0x18) - (uint)*(byte *)(param_1 + 0x14)) * (int)param_7)
          >> 0xc;
  sVar3 = (short)iVar7;
  sVar1 = param_2 + sVar3;
  param_7 = param_7 >> 0xc;
  sVar10 = sVar1 - param_7;

  // wumpaShineTheta (given to sine)
  DAT_8008d990 = DAT_8008d990 + 0x100;

  sVar4 = (short)((int)(((uint)*(byte *)(param_1 + 0x1d) - (uint)*(byte *)(param_1 + 0x15)) *
                       (int)param_8) >> 0xc);
  sVar2 = param_3 + sVar4;
  param_8 = param_8 >> 0xc;
  sVar9 = sVar2 - param_8;
  
  // loop 4 times
  do {
    p = *(void **)(param_4 + 0xc);
    *(undefined4 *)((int)p + 4) = param_9;
    *(undefined4 *)((int)p + 0xc) = *(undefined4 *)(param_1 + 0x14);
    *(undefined4 *)((int)p + 0x14) = *(undefined4 *)(param_1 + 0x18);
    *(undefined4 *)((int)p + 0x1c) = *(undefined4 *)(param_1 + 0x1c);
    *(undefined2 *)((int)p + 0x24) = *(undefined2 *)(param_1 + 0x1e);
	
	// first
    if (iVar8 == 0) 
	{
	  // xy0
      *(short *)((int)p + 8) = param_2;
      *(short *)((int)p + 10) = param_3;
	  
      *(short *)((int)p + 0x10) = sVar1;
      *(short *)((int)p + 0x12) = param_3;
      *(short *)((int)p + 0x18) = param_2;
      *(short *)((int)p + 0x1a) = sVar2;
      *(short *)((int)p + 0x20) = sVar1;
      *(short *)((int)p + 0x22) = sVar2;
    }
    else 
	{
	  // second
      if (iVar8 == 1) 
	  {
		// xy0
        sVar5 = (param_2 + (short)(iVar7 << 1)) - param_7;
        *(short *)((int)p + 8) = sVar5;
        *(short *)((int)p + 10) = param_3;
		
        *(short *)((int)p + 0x10) = sVar10;
        *(short *)((int)p + 0x12) = param_3;
        *(short *)((int)p + 0x18) = sVar5;
        *(short *)((int)p + 0x1a) = sVar2;
        *(short *)((int)p + 0x20) = sVar10;
        *(short *)((int)p + 0x22) = sVar2;
      }
      else 
	  {
		// third
        if (iVar8 == 2) 
		{
		  // xy0
          sVar5 = (param_3 + sVar4 * 2) - param_8;
          *(short *)((int)p + 8) = param_2;
          *(short *)((int)p + 10) = sVar5;
          
		  *(short *)((int)p + 0x10) = sVar1;
          *(short *)((int)p + 0x12) = sVar5;
          *(short *)((int)p + 0x18) = param_2;
          *(short *)((int)p + 0x1a) = sVar9;
          *(short *)((int)p + 0x20) = sVar1;
        }
		
		// fourth
        else 
		{
		  // xy0
          sVar6 = (param_2 + sVar3 * 2) - param_7;
          sVar5 = (param_3 + sVar4 * 2) - param_8;
          *(short *)((int)p + 8) = sVar6;
          *(short *)((int)p + 10) = sVar5;
          
		  *(short *)((int)p + 0x10) = sVar10;
          *(short *)((int)p + 0x12) = sVar5;
          *(short *)((int)p + 0x18) = sVar6;
          *(short *)((int)p + 0x1a) = sVar9;
          *(short *)((int)p + 0x20) = sVar10;
        }
        *(short *)((int)p + 0x22) = sVar9;
      }
    }
    
	// psyq macro setPolyFT4
	*(undefined *)((int)p + 3) = 9;
    *(undefined *)((int)p + 7) = 0x2c;
	
    if (param_6 != 0) {
      *(ushort *)((int)p + 0x16) =
           *(ushort *)((int)p + 0x16) & 0xff9f | ((ushort)param_6 - 1) * 0x20;
      *(byte *)((int)p + 7) = *(byte *)((int)p + 7) | 2;
    }
    AddPrim(param_5,p);
    iVar8 = iVar8 + 1;
    *(int *)(param_4 + 0xc) = *(int *)(param_4 + 0xc) + 0x28;
  } while (iVar8 < 4);
  return;
}


// Only used for drawing character icon
void FUN_8004e8d8(int param_1,short param_2,int param_3,int param_4,void *param_5,byte param_6,
                 short param_7,undefined4 param_8)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  undefined2 uVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  void *p;

  // PrimMem->curr
  p = *(void **)(param_4 + 0xc);

  bVar1 = *(byte *)(param_1 + 0x18);
  bVar2 = *(byte *)(param_1 + 0x14);
  bVar3 = *(byte *)(param_1 + 0x1d);
  bVar4 = *(byte *)(param_1 + 0x15);
  *(undefined4 *)((int)p + 4) = param_8;
  *(undefined4 *)((int)p + 0xc) = *(undefined4 *)(param_1 + 0x14);
  *(undefined4 *)((int)p + 0x14) = *(undefined4 *)(param_1 + 0x18);
  iVar8 = (uint)bVar1 - (uint)bVar2;
  *(undefined4 *)((int)p + 0x1c) = *(undefined4 *)(param_1 + 0x1c);
  uVar5 = *(undefined2 *)(param_1 + 0x1e);
  *(short *)((int)p + 8) = param_2;
  *(undefined2 *)((int)p + 0x24) = uVar5;
  iVar7 = (uint)bVar3 - (uint)bVar4;
  if (param_3 < 0xa6) {
    *(undefined2 *)((int)p + 10) = (short)param_3;
  }
  else {
    *(undefined2 *)((int)p + 10) = 0xa5;
  }
  *(short *)((int)p + 0x10) = param_2 + (short)(iVar8 * param_7 >> 0xc);
  if (param_3 < 0xa6) {
    *(undefined2 *)((int)p + 0x12) = (short)param_3;
  }
  else {
    *(undefined2 *)((int)p + 0x12) = 0xa5;
  }
  iVar6 = param_3 + (iVar7 * param_7 >> 0xc);
  *(short *)((int)p + 0x18) = param_2;
  if (iVar6 < 0xa6) {
    *(undefined2 *)((int)p + 0x1a) = (short)iVar6;
  }
  else {
    *(undefined2 *)((int)p + 0x1a) = 0xa5;
  }
  *(short *)((int)p + 0x20) = param_2 + (short)(iVar8 * param_7 >> 0xc);
  iVar7 = param_3 + (iVar7 * param_7 >> 0xc);
  if (iVar7 < 0xa6) {
    *(undefined2 *)((int)p + 0x22) = (short)iVar7;
  }
  else {
    *(undefined2 *)((int)p + 0x22) = 0xa5;
  }
  
  // psyq macro setPolyFT4
  *(undefined *)((int)p + 3) = 9;
  *(undefined *)((int)p + 7) = 0x2c;
  
  *(char *)((int)p + 0x1d) = (*(char *)((int)p + 0xd) + *(char *)((int)p + 0x1a)) - (char)param_3;
  *(char *)((int)p + 0x25) = (*(char *)((int)p + 0xd) + *(char *)((int)p + 0x22)) - (char)param_3;
  if (param_6 != 0) {
    *(ushort *)((int)p + 0x16) = *(ushort *)((int)p + 0x16) & 0xff9f | ((ushort)param_6 - 1) * 0x20;
    *(byte *)((int)p + 7) = *(byte *)((int)p + 7) | 2;
  }
  AddPrim(param_5,p);

  // increment PrimMem->curr
  *(int *)(param_4 + 0xc) = *(int *)(param_4 + 0xc) + 0x28;

  return;
}


// get position of icon based on a circular motion to move
// the driver up or down in the ranks (left of screen in Arcade or Boss race)
// param1 = pointer to (x,y) position
// param2 = drawn position
// param3 = absolute position
// param4 = frame counter
void FUN_8004eaa8(short *param_1,short param_2,short param_3,short param_4)

{
  int iVar1;
  int iVar2;
  int iVar3;
  short sVar4;

  // all rotations are counter-clockwise,
  // param4 * 0x1b * x
  // is used to make the circular motion
  // (x,y) positive or negative, to change
  // the radius and side of rotation.
  // Moving up moves icon to the right,
  // Moving down moves icon to the left,
  // 0x1b is a constant for base radius

  // drawn position
  iVar2 = (int)param_2;

  // absolute position
  iVar3 = (int)param_3;

  // if driver "just" passed another driver
  if (iVar3 < iVar2)
  {
	// Sine(angle)
	iVar1 = FUN_8003d184(((int)param_4 << 0xb) / 5);

	// ivar3 - ivar2 is a negative number
	iVar2 = (int)param_4 * 0x1b * (iVar3 - iVar2);

    sVar4 = (short)((uint)iVar2 >> 0x10);
    iVar2 = (int)((ulonglong)((longlong)iVar2 * 0x66666667) >> 0x20);
    *param_1 = (short)(iVar1 * 0x14 >> 0xc) + 0x14;
  }

  // if driver "was" passed another driver
  else {

	// Sine(angle)
	iVar1 = FUN_8003d184(((int)param_4 << 0xb) / 5);

	// ivar3 - ivar2 is a positive number
	iVar2 = (int)param_4 * 0x1b * (iVar3 - iVar2);

    sVar4 = (short)((uint)iVar2 >> 0x10);
    iVar2 = (int)((ulonglong)((longlong)iVar2 * 0x66666667) >> 0x20);
    *param_1 = 0x14 - (short)(iVar1 * 0x14 >> 0xc);
  }
  param_1[1] = param_2 * 0x1b + ((short)(iVar2 >> 1) - (sVar4 >> 0xf)) + 0x39;
  return;
}


// UI_Lerp2D_HUD
// param1 pointer to array of two shorts (x,y)
// param2 startX
// param3 startY
// param4 endX
// param5 endY
// param6 curFrame
// param7 endFrame
void FUN_8004ec18(short *param_1,short param_2,short param_3,short param_4,short param_5,int param_6
                 ,short param_7)

{
  int iVar1;
  int iVar2;

  iVar2 = param_6 * ((int)param_2 - (int)param_4);
  iVar1 = (int)param_7;
  if (iVar1 == 0) {
    trap(0x1c00);
  }
  if ((iVar1 == -1) && (iVar2 == -0x80000000)) {
    trap(0x1800);
  }
  param_6 = param_6 * ((int)param_3 - (int)param_5);
  if (iVar1 == 0) {
    trap(0x1c00);
  }
  if ((iVar1 == -1) && (param_6 == -0x80000000)) {
    trap(0x1800);
  }
  *param_1 = param_4 + (short)(iVar2 / iVar1);
  param_1[1] = param_5 + (short)(param_6 / iVar1);
  return;
}


// param1 pointer to array of two shorts (x,y)
// param2 startX
// param3 startY
// param4 endX
// param5 endY
// param6 curFrame
// param7 endFrame
void FUN_8004ecd4(short *param_1,short param_2,short param_3,short param_4,short param_5,int param_6
                 ,short param_7)

{
  int iVar1;
  int iVar2;

  // Get end frame
  iVar1 = (int)param_7;

  // If interpolation is not done yet
  if (param_6 <= iVar1)
  {
	// newPosX = frame * (endX - startX)
    iVar2 = param_6 * ((int)param_4 - (int)param_2);

	// check for error
    if (iVar1 == 0) {
      trap(0x1c00);
    }
    if ((iVar1 == -1) && (iVar2 == -0x80000000)) {
      trap(0x1800);
    }

	// newPosY = frame * (endY - startY)
    param_6 = param_6 * ((int)param_5 - (int)param_3);

	// check for error
    if (iVar1 == 0) {
      trap(0x1c00);
    }
    if ((iVar1 == -1) && (param_6 == -0x80000000)) {
      trap(0x1800);
    }

	// posX = startX + newPosX / endFrame
    *param_1 = param_2 + (short)(iVar2 / iVar1);

	// posY = startY + newPosY / endFrame
    param_1[1] = param_3 + (short)(param_6 / iVar1);
    return;
  }

  // if you already reached the end

  // Set X and Y to EndX and EndY
  *param_1 = param_4;
  param_1[1] = param_5;
  return;
}


// param4 is the pointer to player structure
// UI_DrawRaceClock, both lap time and race time
void FUN_8004edac(ushort param_1,ushort param_2,uint param_3,int param_4)

{
  short sVar1;
  int local_58;
  uint uVar2;
  uint uVar3;
  undefined1 *puVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  undefined4 uVar8;
  int iVar9;
  char cVar10;
  ushort uVar11;
  short *psVar12;
  char cVar13;
  char cVar14;
  int iVar15;
  char cVar16;
  short sVar17;
  ushort uVar18;
  char cVar19;
  char cVar20;
  char acStack80 [8];
  ushort local_48;
  ushort local_40;
  char *local_38;
  int local_34;
  int local_30;

  cVar20 = '\0';

  // if pointer is nullptr
  if (param_4 == 0)
  {
	// quit the function
    return;
  }

  // if number of laps is 7
  if (PTR_DAT_8008d2ac[0x1d33] == '\a')
  {
	// timer ms in full race
    iVar9 = *(int *)(param_4 + 0x514);

	// number of minutes (10s)
    cVar20 = (char)(iVar9 / 0x8ca00);

    if (iVar9 / 0x8ca00 < 10)
	{
	  // number of minutes (1s digit)
      cVar13 = (char)(iVar9 / 0xe100);

	  // number of minutes (1s digit)
      cVar19 = cVar13 + cVar20 * -10;

	  // number of seconds (10s digit)
	  cVar10 = (char)(iVar9 / 0x2580);

	  // number of seconds (10s digit)
      cVar16 = cVar10 + cVar13 * -6;

	  // number of seconds (1s digit)
	  iVar6 = (iVar9 * 100) / 0x3c0;
      iVar5 = (int)((ulonglong)((longlong)iVar6 * 0x66666667) >> 0x20);
      cVar13 = (char)(iVar9 / 0x3c0);
      cVar14 = cVar13 + cVar10 * -10;
      cVar13 = ((char)(iVar9 / 6 + (iVar9 >> 0x1f) >> 4) - (char)(iVar9 >> 0x1f)) + cVar13 * -10;
      goto LAB_8004f02c;
    }

	// set time to 99:59:99
    cVar20 = '\t';
LAB_8004ef58:
    cVar19 = '\t';
    cVar16 = '\x05';
    cVar14 = '\t';
    cVar13 = '\t';
    cVar10 = '\t';
  }

  // if numLaps is not 7
  else
  {
	// timer ms in full race
    iVar9 = *(int *)(param_4 + 0x514);

	// number of minutes (1s digit)
    cVar19 = (char)(iVar9 / 0xe100);

	// if timer runs over 10 minutes,
	// set time to 9:59:99
    if (9 < iVar9 / 0xe100) goto LAB_8004ef58;

	// seconds (10s)
    cVar13 = (char)(iVar9 / 0x2580);

	// seconds (10s)
    cVar16 = cVar13 + cVar19 * -6;

    iVar6 = (iVar9 * 100) / 0x3c0;
    iVar5 = (int)((ulonglong)((longlong)iVar6 * 0x66666667) >> 0x20);

	// seconds (1s)
    cVar10 = (char)(iVar9 / 0x3c0);

	// seconds (1s)
    cVar14 = cVar10 + cVar13 * -10;

	// ms (10s)
    cVar13 = ((char)(iVar9 / 6 + (iVar9 >> 0x1f) >> 4) - (char)(iVar9 >> 0x1f)) + cVar10 * -10;

LAB_8004f02c:

	// ms (1s)
    cVar10 = (char)iVar6 + ((char)(iVar5 >> 2) - (char)(iVar6 >> 0x1f)) * -10;
  }

  if ((param_3 & 1) == 0)
  {
	// TIME
    iVar9 = 0x12;

	// If you're in Time Trial
    if ((*(uint *)PTR_DAT_8008d2ac & 0x20000) != 0)
	{
	  // TIME TRIAL
      iVar9 = 0x4d;
    }

	// Draw small string
    uVar8 = 2;

    sVar17 = 0;
  }
  else
  {
	// TOTAL
    iVar9 = 0xc4;

	// If you're in a Relic Race
    if ((*(uint *)PTR_DAT_8008d2ac & 0x4000000) != 0)
	{
	  // YOUR TIME
      iVar9 = 0xc5;
    }

	// Draw big string
    uVar8 = 1;

    if (((param_3 & 4) == 0) || (sVar17 = 0x4004, (*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 2) != 0))
    {
      sVar17 = 0x4000;
    }
  }
  local_48 = param_1;
  local_40 = param_2;

  // iVar9 = 0x12: TIME
  // iVar9 = 0x4d: TIME TRIAL
  // iVar9 = 0xc4: TOTAL
  // iVar9 = 0xc5: YOUR TIME
  FUN_80022878(*(undefined4 *)(iVar9 * 4 + DAT_8008d878),(int)(short)param_1,(int)(short)param_2,
               uVar8,(int)sVar17);

  // set text to white
  sVar17 = 1;

  if (
		(*(int *)(PTR_DAT_8008d2ac + 0x1e20) == 0) &&

		(
			sVar17 = 0,

			// if total time should flash
			(param_3 & 4) != 0
		)
	 )
  {
	// use timer to change color on even and odd frames,
	// alternate between white (1) and orange (0)
    sVar17 = (ushort)((*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 2) == 0) << 2;
  }

  // if number of laps is 7
  if (PTR_DAT_8008d2ac[0x1d33] == '\a')
  {
	// String for amount of time in total race
    puVar4 = &DAT_800116d4;

	// Convert each number from the binary
	// version of the number to the ascii version
	// of the number by adding ascii value of '0'
    DAT_800116d4 = cVar20 + '0'; // minutes (10s)
    DAT_800116d5 = cVar19 + '0'; // minutes (1s)
    DAT_800116d7 = cVar16 + '0'; // seconds (10s)
    DAT_800116d8 = cVar14 + '0'; // seconds (1s)
    DAT_800116da = cVar13 + '0'; // ms (10s)
    DAT_800116db = cVar10 + '0'; // ms (1s)
  }

  // if number of laps is not 7
  else
  {
	// String for amount of time in lap
    puVar4 = &DAT_8008d504;

	// Convert each number from the binary
	// version of the number to the ascii version
	// of the number by adding ascii value of '0'
    DAT_8008d504 = cVar19 + '0';
    DAT_8008d506 = cVar16 + '0';
    DAT_8008d507 = cVar14 + '0';
    DAT_8008d509 = cVar13 + '0';
    DAT_8008d50a = cVar10 + '0';
  }

  if ((param_3 & 1) == 0) {
    iVar9 = (int)(short)local_48;
    iVar6 = ((uint)local_40 + 8) * 0x10000;
  }
  else {
    iVar9 = (int)(((uint)local_48 + 0x11) * 0x10000) >> 0x10;
    iVar6 = (uint)local_40 << 0x10;
  }

  // Draw String
  FUN_80022878(puVar4,iVar9,iVar6 >> 0x10,1,(int)sVar17);

  if (
		// If you're not in a Relic Race
		((*(uint *)PTR_DAT_8008d2ac & 0x4000000) == 0) ||
		((param_3 & 2) != 0)
	)
  {
	  // If you're not in Arcade mode,
	  // nor Time Trial, nor adventure mode
    if ((*(uint *)PTR_DAT_8008d2ac & 0x4a0000) == 0) {
      return;
    }

	// uVar2 lap counter
	// param4 is PTR_DAT_8008d2ac + 0x24ec (player structure)

    uVar2 = (uint)*(byte *)(param_4 + 0x44);
    iVar9 = 0;
    if (uVar2 == 0xffffffff) {
      return;
    }
    local_38 = acStack80;
    iVar6 = 1;
    local_30 = (uint)local_48 << 0x10;
    local_34 = local_30 >> 0x10;
    do {
      if (
			// lap counter is more loop counter
			(iVar9 <= (int)uVar2) &&

			// number of laps in race is more than loop counter
			(iVar9 < (char)PTR_DAT_8008d2ac[0x1d33])
		  )
	  {
		// Save Lap Time
        FUN_8004c55c(

					// lapID
					uVar2,

					//time on the clock - lap time to substract
					*(int *)(PTR_DAT_8008d2ac + 0x1d10) - *(int *)(param_4 + 0x40),

					// Player / AI structure + 0x4a shows driver index (0-7)
                     (uint)*(byte *)(param_4 + 0x4a));

        iVar5 = iVar9 * 4;

		// set to empty
        DAT_800116d4 = ' ';

		// Convert each number from the binary
		// version of the number to the ascii version
		// of the number by adding ascii value of '0'

		// Player / AI structure + 0x4a shows driver index (0-7)
		// This is dynamically programmed to handle time for more than one player

		// 5 numbers because 9:59:99
        DAT_800116d5 = (&DAT_8009ac00)[iVar5 + (uint)*(byte *)(param_4 + 0x4a) * 0x1c] + '0';
        DAT_800116d7 = (&DAT_8009aca8)[iVar5 + (uint)*(byte *)(param_4 + 0x4a) * 0x1c] + '0';
        DAT_800116d8 = (&DAT_8009ace0)[iVar5 + (uint)*(byte *)(param_4 + 0x4a) * 0x1c] + '0';
        DAT_800116da = (&DAT_8009ac38)[iVar5 + (uint)*(byte *)(param_4 + 0x4a) * 0x1c] + '0';
        DAT_800116db = (&DAT_8009ac70)[iVar5 + (uint)*(byte *)(param_4 + 0x4a) * 0x1c] + '0';

        if (
				(
					// if this is lap 1, and if lap 1 should flash
					((iVar9 == 0) && ((param_3 & 8) != 0)) ||

					// if this is lap 2, and if lap 2 should flash
					((iVar9 == 1 && ((param_3 & 0x10) != 0)))
				) ||

				// if this is lap 3, and if lap 3 should flash
				((uVar18 = 1, iVar9 == 2 && ((param_3 & 0x20) != 0)))
			)
		{
		  // Change color based on frame counter
          uVar18 = ((ushort)(*(uint *)(PTR_DAT_8008d2ac + 0x1cec) >> 1) ^ 1) & 1;
        }

		// Otherwise, color is white by default,    ^^^
		// you can see that in "uVar18 = 1" near lap 3 check

        if ((param_3 & 1) == 0) {

		  // If you're in Arcade Mode
          if ((*(uint *)PTR_DAT_8008d2ac & 0x400000) != 0) goto LAB_8004f84c;

		  // Set lap number in "Ln" string
          DAT_8008d50d = (char)iVar9 + '1';

          iVar7 = (int)(((uint)local_40 + iVar6 * 8 + 0x10) * 0x10000) >> 0x10;

		  // draw "Ln" string
          FUN_80022878(&DAT_8008d50c,local_30 >> 0x10,iVar7,2,3);

          iVar15 = 2;
          local_58 = 1;
          iVar5 = (int)(((uint)local_48 + 0x1a) * 0x10000) >> 0x10;
        }
        else
		{
		  // draw big text for time in each lap
          iVar15 = 1;

		  // if number of laps is more than 3
          if ('\x03' < (char)PTR_DAT_8008d2ac[0x1d33])
		  {
			// draw small text for time in each lap
            iVar15 = 2;
          }

		  // DAT_8008d510
		  // %d

          sprintf(local_38,&DAT_8008d510,iVar6);
          psVar12 = (short *)(&DAT_80082368 + iVar15 * 2);

		  // draw string
          FUN_80022878(local_38,local_34,
                       (int)(((uint)local_40 -
                             ((char)PTR_DAT_8008d2ac[0x1d33] - iVar9) * (int)*psVar12) * 0x10000) >>
                       0x10,iVar15,0x4003);

		  // DAT_8008d878 + 0x60
		  // LAP
          FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x60),
                       (int)(((uint)local_48 - (uint)*(ushort *)(&DAT_80082360 + iVar15 * 2)) *
                            0x10000) >> 0x10,
                       (int)(((uint)local_40 -
                             ((char)PTR_DAT_8008d2ac[0x1d33] - iVar9) * (int)*psVar12) * 0x10000) >>
                       0x10,iVar15,0x4003);


          local_58 = (int)(short)uVar18;
          iVar7 = (int)(((uint)local_40 - ((char)PTR_DAT_8008d2ac[0x1d33] - iVar9) * (int)*psVar12)
                       * 0x10000) >> 0x10;
          iVar5 = local_34;
        }

		// draw string for total amount of time in race
        FUN_80022878(&DAT_800116d4,iVar5,iVar7,iVar15,local_58);
      }
LAB_8004f84c:
				// lap counter
      uVar2 = (uint)*(byte *)(param_4 + 0x44);

      iVar9 = iVar9 + 1;
      iVar6 = iVar6 + 1;
      if ((int)(uVar2 + 1) <= iVar9) {
        return;
      }
    } while( true );
  }

  if ((*(uint *)(PTR_DAT_8008d2ac + 0x1d44) & 0x2000000) == 0)
  {
	  // Level ID
    iVar9 = *(int *)(PTR_DAT_8008d2ac + 0x1a10);

	// 3a is bit index for unlocking plat relics
	// 28 is bit index for unlocking gold relics

    if (
			//If you have unlocked a platinum relic on this track
			(((uint)(&DAT_8008fba4)[(int)(iVar9 + 0x3aU) >> 5] >> (iVar9 + 0x3aU & 0x1f) & 1) != 0) ||

			//If you have unlocked a gold relic on this track
			(((uint)(&DAT_8008fba4)[(int)(iVar9 + 0x28U) >> 5] >> (iVar9 + 0x28U & 0x1f) & 1) != 0)
		)
	{
LAB_8004f338:
      iVar9 = 200;
      uVar18 = 0x16;
      goto LAB_8004f378;
    }

	// If you have not unlocked Gold or Plat relic on this track

	// 16 is bit index for unlocking blue relics

	// Check if you unlocked a Blue relic
    uVar2 = (uint)(&DAT_8008fba4)[(int)(iVar9 + 0x16U) >> 5] >> (iVar9 + 0x16U & 0x1f);
  }

  else {
	// Level ID = PTR_DAT_8008d2ac + 0x1a10
	// uVar3 is bit index for unlocking platinum relic on this track
	// uVar2 is bit index for unlocking gold relic on this track
    uVar3 = *(int *)(PTR_DAT_8008d2ac + 0x1a10) + 0x3a;
    uVar2 = *(int *)(PTR_DAT_8008d2ac + 0x1a10) + 0x28;


	// 0x8fba4 is where the adventure profile (currently loaded) begins
    if (((uint)(&DAT_8008fba4)[(int)uVar3 >> 5] >> (uVar3 & 0x1f) & 1) != 0) goto LAB_8004f338;

	// Check if you unlocked a gold relic
    uVar2 = (uint)(&DAT_8008fba4)[(int)uVar2 >> 5] >> (uVar2 & 0x1f);
  }
  if ((uVar2 & 1) == 0)
  {
	// SAPPHIRE
    iVar9 = 0xc6;

	// blue color
	uVar18 = 0x11;
  }
  else
  {
	// GOLD
    iVar9 = 199;

	// yellow color
    uVar18 = 0xe;
  }
LAB_8004f378:
  uVar8 = 1;
  if ((param_3 & 1) == 0) {
    uVar8 = 2;
    sVar1 = local_40 + 0x18;
    sVar17 = local_40 + 0x20;
    uVar11 = local_48;
  }
  else {
    uVar18 = uVar18 | 0x4000;
    sVar1 = local_40 - 0x11;
    sVar17 = sVar1;
    uVar11 = local_48 + 0x11;
  }

  // ivar9 0xc6: SAPPHIRE
  // ivar9 199 (c7): GOLD
  // ivar9 0xc8: PLATINUM
  FUN_80022878(*(undefined4 *)(iVar9 * 4 + DAT_8008d878),(int)(short)local_48,(int)sVar1,uVar8,
               (int)(short)uVar18);

  // Convert each number from the binary
  // version of Relic Time to the ascii version
  // of the number by adding ascii value of '0'
  DAT_8008d504 = DAT_8008d9b0 + '0';
  DAT_8008d506 = DAT_8008d9e0 + '0';
  DAT_8008d507 = DAT_8008d9e8 + '0';
  DAT_8008d509 = DAT_8008d9d4 + '0';
  DAT_8008d50a = DAT_8008d9b8 + '0';
  FUN_80022878(&DAT_8008d504,(int)(short)uVar11,(int)sVar17,1,(int)(short)(uVar18 & 0xbfff));
  return;
}


// countdown clock, used for Battle Mode and Crystal Challenge
// param1: X coordinate on the screen
// param2: Y coordinate on the screen
// param3: text size
// (0,0) is the top left corner
void FUN_8004f894(short param_1,short param_2,short param_3)

{
  undefined *puVar1;
  undefined4 uVar2;
  int iVar3;
  undefined4 uVar4;
  int iVar5;
  int iVar6;

  // amount of time event should last, minus, time elapsed in the event.
  // basically, time remaining in the event
  iVar6 = *(int *)(PTR_DAT_8008d2ac + 0x1d84) - *(int *)(PTR_DAT_8008d2ac + 0x1d10);

  // if you run out of time
  if (iVar6 < 0)
  {
	// Make a time string with zero milliseconds on the clock
    uVar2 = FUN_80044ff8(0);
    puVar1 = PTR_DAT_8008d2ac;

    // If you're not in End-Of-Race menu
    if ((*(uint *)PTR_DAT_8008d2ac & 0x200000) == 0)
	{
	  // count iterations of loop
      iVar5 = 0;

	  // If numPlyrCurrGame is not zero
      if (PTR_DAT_8008d2ac[0x1ca8] != '\0')
	  {
		// loop iteration * 4,
		// pointer incrementation (4 bytes per pointer)
        iVar3 = 0;

		// ============
		// End Race for all Players
		// ============

		// for iVar5 = 0; iVar5 < numPlyrCurrGame; iVar5++
        do
		{
		  // pointer of each player (P1, P2, P3, P4)
          iVar3 = *(int *)(puVar1 + iVar3 + 0x24ec);

          //end the race for every racer
          *(uint *)(iVar3 + 0x2c8) = *(uint *)(iVar3 + 0x2c8) | 0x2000000;

		  // increment the iteration counter
		  iVar5 = iVar5 + 1;

		  // increment the pointer
          iVar3 = iVar5 * 4;
        } while (iVar5 < (int)(uint)(byte)puVar1[0x1ca8]);
      }

	  // MainGameEnd_Initialize
      FUN_8003a3fc();
    }
  }

  // if you have not run out of time
  else
  {
	// make a string with the remaining time
    uVar2 = FUN_80044ff8(iVar6);
  }

  // default color is dark red
  uVar4 = 0x1c;

  if (
		// if less than 15 seconds remain
		(iVar6 < 0x3840) &&

		(
			// set color to white
			uVar4 = 4,

			// if number of frames is an odd number
			(*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 1) != 0
		)
	  )
  {
	// set color back to red
    uVar4 = 0x1c;
  }

  // put the time string on the screen
  FUN_80022878(uVar2,(int)param_1,(int)param_2,(int)param_3,uVar4);
  return;
}


// Draw arrows over the heads of players
void FUN_8004f9d8(int param_1)

{
  ushort uVar1;
  undefined4 uVar2;
  MATRIX* r0;
  short sVar3;
  short sVar4;
  undefined4 in_zero;
  undefined4 in_at;
  undefined *puVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  uint uVar9;
  uint **ppuVar10;
  uint *puVar11;
  int iVar12;
  uint *puVar13;
  uint uVar14;
  short sVar15;
  uint uVar16;
  undefined4 local_18;
  uint local_14;
  short sStack14;

  // Player ID of param_1 player
  uVar9 = (uint)*(byte *)(param_1 + 0x4a);

  puVar5 = PTR_DAT_8008d2ac + uVar9 * 0x110;

  // tileView ViewProj
  r0 = (MATRIX *)(PTR_DAT_8008d2ac + uVar6 * 0x110 + 0x168 + 0x28);
  gte_SetRotMatrix(r0);
  gte_SetTransMatrix(r0);

  // loop counter
  uVar14 = 0;

  // if numPlyrCurrGame is not zero
  if (PTR_DAT_8008d2ac[0x1ca8] != '\0') {
    iVar6 = 0;

	// for(int iVar14 = 0; iVar14 < numPlyrCurrGame; iVar14++)
    do
	{
	  // something related to player structure address
      iVar6 = *(int *)(PTR_DAT_8008d2ac + iVar6 + 0x24ec);

      if (
			(
				(uVar14 != uVar9) &&

				// If player is visible (not using invisibility powerup)
				(*(int *)(iVar6 + 0x28) == 0)
			) &&

			//if racer finished the race
			((*(uint *)(iVar6 + 0x2c8) & 0x2000000) == 0)
		  )
	  {
		// If 3 or 4 Players
        sVar15 = 5;

		// If numPlyrCurrGame is less than 3
        if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 3) {
          sVar15 = 3;
        }

        iVar12 = *(int *)(iVar6 + 0x1c);

		// Get X distance and Z distance between two players
        iVar7 = *(int *)(*(int *)(param_1 + 0x1c) + 0x44) - *(int *)(iVar12 + 0x44);
        iVar8 = *(int *)(*(int *)(param_1 + 0x1c) + 0x4c) - *(int *)(iVar12 + 0x4c);

		// Start doing Distance formula, but avoid sqrt to save performance
		iVar7 = iVar7 * iVar7 + iVar8 * iVar8;

		// sqrt(0x90000) is 768

		// If players are more than 768 units away from each other
        if (0x90000 < iVar7)
		{
		  // Battle Team of Player
          uVar1 = *(ushort *)(iVar6 + 0x4e8);

		  // Something with X and Height (Y)
          local_18 = CONCAT22(*(undefined2 *)(*(int *)(iVar6 + 0x1c) + 0x48),
                              *(undefined2 *)(iVar12 + 0x44));

												// something with Z position
          local_14 = local_14 & 0xffff0000 | (uint)*(ushort *)(*(int *)(iVar6 + 0x1c) + 0x4c);
          
		  // put instance position on GTE
		  setCopReg(2,in_zero,local_18);
          setCopReg(2,in_at,local_14);

		  // RTPS - Perspective Transformation (single)
		  copFunction(2,0x180001);

		  // get screenspace pos (x,y)
		  uVar2 = getCopReg(2,0xe);
		  
		  // get depth on screen (I think?)
          uVar16 = getCopControlWord(2,0xf800);

		  if ((uVar16 & 0x40000) == 0)
		  {
            // gGT->backBuffer
			iVar6 = *(int *)(PTR_DAT_8008d2ac + 0x10);

			// primMem curr
            puVar11 = *(uint **)(iVar6 + 0x80);

            puVar13 = (uint *)0x0;

			// if curr < near-end
			if (puVar11 <= *(uint **)(iVar6 + 0x84))
			{
			  // increment curr
              *(uint **)(iVar6 + 0x80) = puVar11 + 9;
              puVar13 = puVar11;
            }

            if (puVar13 == (uint *)0x0) {
              return;
            }
            sStack14 = (short)((uint)uVar2 >> 0x10);
            sStack14 = sStack14 + sVar15;
            sVar4 = (short)uVar2;
            iVar6 = (0x1000 - ((iVar7 / 6 + (iVar7 >> 0x1f) >> 0xd) - (iVar7 >> 0x1f))) * 0x10000 >>
                    0x10;
            sVar15 = (short)(iVar6 * 3 >> 10);
            *(short *)(puVar13 + 8) = sVar4 + sVar15;
            sVar3 = (short)(iVar6 * 7 >> 0xc) + 0xc;
            *(short *)((int)puVar13 + 0x22) = sStack14 - sVar3;
            *(short *)(puVar13 + 6) = sVar4;
            *(short *)((int)puVar13 + 0x1a) = sStack14 + -0xc;
            *(short *)(puVar13 + 4) = sVar4 - sVar15;
            *(undefined *)((int)puVar13 + 3) = 8;
            *(undefined *)((int)puVar13 + 0xf) = 0x32;
            puVar13[1] = 0xe1000a20;
            puVar13[2] = 0;

			// color data
            ppuVar10 = (uint **)((int)&PTR_DAT_80081d70 +
                                ((int)(((uint)uVar1 + 0x18) * 0x10000) >> 0xe));

            *(short *)((int)puVar13 + 0x12) = sStack14 - sVar3;
            puVar13[5] = (*ppuVar10)[1] | 0x30000000;
            puVar13[3] = **ppuVar10 & 0xffffff | 0x30000000;
            puVar13[7] = (*ppuVar10)[2] | 0x30000000;

			// pointer to OTMem (25c-168=0xf4)
            puVar11 = *(uint **)(PTR_DAT_8008d2ac + uVar9 * 0x110 + 0x25c);

			*puVar13 = *puVar11 | 0x8000000;
            *puVar11 = (uint)puVar13 & 0xffffff;
          }
        }
      }

	  // increment loop counter
      uVar14 = uVar14 + 1;

      iVar6 = uVar14 * 4;

	  // for(int iVar14 = 0; iVar14 < numPlyrCurrGame; iVar14++)
    } while ((int)uVar14 < (int)(uint)(byte)PTR_DAT_8008d2ac[0x1ca8]);
  }
  return;
}


// UI_TrackerSelf
// draw lock-on target for driver, if
// a missile or warpball is chasing them
// param_1 is a player/AI structure
void FUN_8004fd34(int param_1)

{
  short sVar1;
  short sVar2;
  undefined4 uVar3;
  short sVar4;
  short sVar5;
  short sVar6;
  undefined4 in_zero;
  undefined4 in_at;
  int iVar7;
  uint uVar8;
  short *psVar9;
  uint uVar10;
  undefined *puVar11;
  uint *puVar12;
  uint uVar13;
  uint *puVar14;
  short sVar15;
  undefined4 uVar16;
  int iVar17;
  short sVar18;
  uint uVar19;
  int iVar20;
  undefined4 local_30;
  uint local_2c;
  short local_28;
  short sStack38;

  // get index of driver in driver array
  uVar19 = (uint)*(byte *)(param_1 + 0x4a);

  if (
		// if there is no missile chasing this player
		(*(int *)(param_1 + 0x4a4) == 0) &&

		// ???
		(*(short *)(&DAT_800862e8 + uVar19 * 2) == 0)
	 )
  {
	// clear type of object tracking the player
    *(undefined2 *)(&DAT_800862f8 + uVar19 * 2) = 0;

    return;
  }
  iVar20 = 0;

  // If no missile or warpball is chasing this driver
  if (*(int *)(param_1 + 0x4a4) == 0) {
    sVar1 = *(short *)(&DAT_800862e8 + uVar19 * 2);
    puVar11 = &DAT_8008628c;
  }

  // if a missile or warpball is chasing this driver
  else {
    sVar1 = *(short *)(&DAT_800862e8 + uVar19 * 2);
    puVar11 = &DAT_8008626c;
  }

  sVar2 = *(short *)(puVar11 + (int)sVar1 * 4);
  sVar1 = *(short *)(puVar11 + (int)sVar1 * 4 + 1);

  // RB_GetThread_ClosestTracker (missile or warpball)
  iVar7 = FUN_800b28c0(param_1);

  if ((iVar7 == 0) && (psVar9 = (short *)(&DAT_800862e8 + uVar19 * 2), *psVar9 == 0))
  {
	// Get data from missile or warpball
	// driver -> trackerInstFollowingMe -> object -> flags ??
    if ((*(ushort *)(*(int *)(*(int *)(param_1 + 0x4a4) + 0x30) + 0x16) & 0x10) != 0)
    goto LAB_8004fe8c;
    sVar18 = 0xc;
  }
  
  else {
    if (
			(
				//if 27th bit of Actions Flag set is on (means ?)
				((*(uint *)(param_1 + 0x2c8) & 0x4000000) != 0) &&

				// driver -> trackerInstFollowingMe
				(iVar7 == *(int *)(param_1 + 0x4a4))
			) ||
			(psVar9 = (short *)(&DAT_800862e8 + uVar19 * 2), *psVar9 != 0)
		) goto LAB_8004fe8c;

    //turn on 27th bit of Actions Flag set (means ?)
    *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) | 0x4000000;
    sVar18 = 8;
  }
  *psVar9 = sVar18;
LAB_8004fe8c:
  iVar17 = uVar19 * 2;

  // set pointer of the missile or warpball chasing the player
  *(int *)(param_1 + 0x4a4) = iVar7;

  psVar9 = (short *)(&DAT_800862e8 + iVar17);
  if (*psVar9 != 0) {
    *psVar9 = *psVar9 + -1;
  }

						// something with X and Y position
  local_30 = CONCAT22(*(undefined2 *)(*(int *)(param_1 + 0x1c) + 0x48),
                      *(undefined2 *)(*(int *)(param_1 + 0x1c) + 0x44));

						// something with Z position
  local_2c = local_2c & 0xffff0000 | (uint)*(ushort *)(*(int *)(param_1 + 0x1c) + 0x4c);

  // tileView ViewProj
  r0 = (MATRIX *)(PTR_DAT_8008d2ac + uVar19 * 0x110 + 0x168 + 0x28);
  gte_SetRotMatrix(r0);
  gte_SetTransMatrix(r0);
  
  // ldv0
  // put driver pos on GTE
  setCopReg(2,in_zero,local_30);
  setCopReg(2,in_at,local_2c);

  // RTPS - Perspective Transformation (single)
  copFunction(2,0x180001);

  // stsxy
  // get driver screenspace pos
  uVar3 = getCopReg(2,0xe);
  uVar16 = 0xff;

  // if no missile or warpball is chasing this player
  if (*(int *)(param_1 + 0x4a4) == 0) {
    sVar18 = *(short *)(&DAT_800862f0 + iVar17);
  }

  // if a missile or warpball is chasing this player
  else
  {
	// get distance between missile and player

    // uVar8 = sqrt(driver->4a4->30->28 << 0)
    uVar8 = FUN_80059070(*(undefined4 *)(*(int *)(*(int *)(param_1 + 0x4a4) + 0x30) + 0x28),0);

    uVar8 = uVar8 / 0x32;
    sVar18 = (short)uVar8;
    *(short *)(&DAT_800862f0 + iVar17) = sVar18;

	// beeping gets faster as missile gets closer
	// iVar10 is beeping rate (higher is less beeps),
	// and uVar8 is distance to player

	// slowest rate, once every 0x1e frames,
	// if missile is more than 0xc9 units away
    uVar10 = 0x1e;

	if (
			// if missile is closer than 0xc9 units
			(uVar8 < 0xc9) &&


			(
				// apply beep once every 5 frames if
				// missile is less than 100 units away
				uVar10 = 5,

				// if missile is more than 100 units
				// and less than 0xc9 units away
				100 < uVar8
			)
		)
	{
	  // beep once every 10 frames
      uVar10 = 10;
    }

	// if the variable was somehow not set
	if (uVar10 == 0)
	{
	  // kill the game
      trap(0x1c00);
    }

    uVar16 = 0xff;

	// play the beeping on certain frames
    if (*(uint *)(PTR_DAT_8008d2ac + 0x1cec) % uVar10 == 0) {

	  // If game is not paused
      if ((*(uint *)PTR_DAT_8008d2ac & 0xf) == 0)
	  {
		// OtherFX_Play "homing in" sound
        FUN_80028468(0x56,1);
      }

      uVar16 = 0xffffff;
    }

	// driver -> threadTracking -> instance -> model -> modelID == WarpBall
    if (*(short *)(*(int *)(*(int *)(*(int *)(param_1 + 0x4a4) + 0x34) + 0x18) + 0x10) == 0x36)
	{
	  	// driver -> threadTracking -> object -> pathNodeStart -> pathNodeIndex?
      iVar20 = ((uint)*(ushort *)(*(int *)(*(int *)(*(int *)(param_1 + 0x4a4) + 0x30) + 0x3c) + 6) -

				// LEV -> path [driver -> pathIndex] -> pathNodeIndex (whaaaat)?
               (uint)*(ushort *)
                      ((uint)*(byte *)(param_1 + 0x495) * 0xc +
                       *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c) + 6)) * 8;

	  // if warpball is further in the lap than the driver,
	  // and warpball needs to go around the track
      if (iVar20 < 0)
	  {
		// add to distance between warpball and driver
        iVar20 = iVar20 + (uint)*(ushort *)
                                 (*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c) + 6) * 8;
      }

	  // type of object following driver is a warpball
      *(undefined2 *)(&DAT_800862f8 + uVar19 * 2) = 1;
    }

	// if this is not a warpball
	else
	{
	  // type of object is missile, or nothing?
      *(undefined2 *)(&DAT_800862f8 + uVar19 * 2) = 0;
    }
  }
  iVar7 = 0;
  
  // driver screenspace x and y
  sStack38 = (short)((uint)uVar3 >> 0x10);
  local_28 = (short)uVar3;

  // check distance
  if (iVar20 < 16000)
  {
    sVar6 = sVar18 + (sVar2 >> 8);
    sVar5 = (short)((int)sVar1 * 7 >> 0xc);
    do {
      sVar15 = 1;
      if (iVar7 == 0) {
        sVar15 = -1;
      }

	  // gGT->backBuffer
      iVar20 = *(int *)(PTR_DAT_8008d2ac + 0x10);

	  // PrimMem curr
      puVar12 = *(uint **)(iVar20 + 0x80);

	  puVar14 = (uint *)0x0;

	  // if curr < near-end
	  if (puVar12 <= *(uint **)(iVar20 + 0x84))
	  {
		// increment curr
        *(uint **)(iVar20 + 0x80) = puVar12 + 7;
        puVar14 = puVar12;
      }
      if (puVar14 == (uint *)0x0) {
        return;
      }

	  // if tracking object is warpball
      if (*(short *)(&DAT_800862f8 + uVar19 * 2) == 1) 
	  {
		// polyG3 + rgb
		uVar10 = 0x309c6900;
        
		uVar8 = 0x30ffff00;
      }

	  // if tracking object is missile
      else 
	  {
		// polyG3 + rgb
        uVar10 = 0x3000699c;
		
        uVar8 = 0x3000ffff;
      }

      puVar14[3] = 0x30ffffff;
      puVar14[1] = uVar10;
      puVar14[5] = uVar8;

      sVar4 = sVar15 * sVar6;
      *(short *)(puVar14 + 6) = local_28 + sVar4;
      *(short *)((int)puVar14 + 0x1a) = sStack38 + -0xc;
      *(short *)(puVar14 + 4) = local_28 + sVar15 * sVar18;
      *(short *)((int)puVar14 + 0x12) = sStack38 + -0xc;
      *(short *)(puVar14 + 2) = local_28 + sVar4;
      puVar11 = PTR_DAT_8008d2ac;
      *(short *)((int)puVar14 + 10) = sStack38 - (sVar5 + 0xc);

	  // pointer to OTMem (25c-168=0xf4)
      puVar12 = *(uint **)(puVar11 + uVar19 * 0x110 + 0x25c);

      *puVar14 = *puVar12 | 0x6000000;
      *puVar12 = (uint)puVar14 & 0xffffff;

	  // gGT->backBuffer
      iVar20 = *(int *)(PTR_DAT_8008d2ac + 0x10);

	  // PrimMem curr
      puVar12 = *(uint **)(iVar20 + 0x80);

      puVar14 = (uint *)0x0;

	  // if curr < near-End
	  if (puVar12 <= *(uint **)(iVar20 + 0x84))
	  {
		// increment curr
        *(uint **)(iVar20 + 0x80) = puVar12 + 7;
        puVar14 = puVar12;
      }
      if (puVar14 == (uint *)0x0) {
        return;
      }

	  // if tracking object is warpball
      if (*(short *)(&DAT_800862f8 + uVar19 * 2) == 1) {
        uVar13 = 0x305b5b00;
		
		// polyG3 + rgb
        uVar10 = 0x30322b01;
		
        uVar8 = 0x30ffbb00;
      }

	  // if tracking object is missile
      else {
        uVar13 = 0x30005b5b;
		
		// polyG3 + rgb
        uVar10 = 0x30012b32;
		
        uVar8 = 0x3000bbff;
      }

      puVar14[3] = uVar13;
      puVar14[1] = uVar10;
      puVar14[5] = uVar8;

      sVar4 = sVar15 * sVar6;
      *(short *)(puVar14 + 6) = local_28 + sVar4;
      *(short *)((int)puVar14 + 0x1a) = sStack38 + sVar5 + -0xc;
      *(short *)(puVar14 + 4) = local_28 + sVar15 * sVar18;
      *(short *)((int)puVar14 + 0x12) = sStack38 + -0xc;
      iVar7 = iVar7 + 1;
      *(short *)(puVar14 + 2) = local_28 + sVar4;
      puVar11 = PTR_DAT_8008d2ac;
      *(short *)((int)puVar14 + 10) = sStack38 + -0xc;

	  // pointer to OTMem (25c-168=0xf4)
      puVar12 = *(uint **)(puVar11 + uVar19 * 0x110 + 0x25c);

      *puVar14 = *puVar12 | 0x6000000;
      *puVar12 = (uint)puVar14 & 0xffffff;
    } while (iVar7 < 2);
  }

  // UI_TrackerBG
  FUN_8004e660(

			   // missile lock-on icon
			   *(undefined4 *)(PTR_DAT_8008d2ac + 0x1fa0),

			   (int)local_28 - ((int)sVar2 >> 7),
               (int)sStack38 - ((int)sVar1 * 0xf >> 0xb),

			   // pointer to PrimMem struct
			   *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

				// pointer to OTMem (25c-168=0xf4)
			   *(undefined4 *)(PTR_DAT_8008d2ac + uVar19 * 0x110 + 0x25c),1,(int)sVar2,(int)sVar1,
               uVar16);
  return;
}


// Draw the "st", "nd", "rd" suffix after "1st, 2nd, 3rd, etc"
void FUN_8005045c(short param_1,short param_2,int param_3,short param_4)

{
  int iVar1;

  // If you're not in Battle Mode
  if ((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0) {
    // Get the rank you're in (1st, 2nd, 3rd, etc)
	iVar1 = (int)*(short *)(param_3 + 0x482);
  }

  // If you are in Battle Mode
  else
  {
	// get the rank that the battle team is in
    iVar1 = *(int *)(PTR_DAT_8008d2ac + *(int *)(param_3 + 0x4e8) * 4 + 0x1da8);
  }

  // Draw the suffix of your position
  // 1st "st"
  // 2nd "nd"
  // 3rd "rd"
  // 4th "th"
  // etc
  FUN_80022878(*(undefined4 *)((int)*(short *)(&DAT_8008643c + iVar1 * 2) * 4 + DAT_8008d878),
               (int)param_1,(int)param_2,1,(int)param_4);

  // If pointer to instance of "Big Number" is valid
  if (*(int *)(param_3 + 0x498) != 0)
  {
	// Set [something] to position in race + 0x100
    *(int *)(*(int *)(param_3 + 0x498) + 0x4c) = (int)*(short *)(param_3 + 0x482) + 0x100;
  }
  return;
}


// Draw which lap the racer is on
void FUN_80050528(short param_1,int param_2,undefined4 param_3,int param_4)

{
  char *pcVar1;
  undefined4 uVar2;
  short sVar3;
  undefined4 local_38;
  char acStack48 [24];

  // get current lap number, then add 1
  // Draw Lap 0 as 1
  // Draw Lap 1 as 2
  // Draw Lap 2 as 3, etc
  sVar3 = (ushort)*(byte *)(param_4 + 0x44) + 1;

  // if your current lap is more than the number of laps in the race
  if ((int)(char)PTR_DAT_8008d2ac[0x1d33] < (int)((uint)*(byte *)(param_4 + 0x44) + 1))
  {
	// set current lap to the max number of laps in the race (3, 5, 7)
    sVar3 = (short)(char)PTR_DAT_8008d2ac[0x1d33];
  }

  // if numPlyrCurrGame is less than 3
  if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 3)
  {
	// DAT_8008d878 + 0x60
	// LAP
    FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x60),(int)param_1,(int)(short)param_2,2,0x4001);

	// s__d__d_8008d514
	// %d/%d

	// sVar3
	// current lap

	// (int)(char)PTR_DAT_8008d2ac[0x1d33]
	// number of laps in a race

	// turn it into a string
    sprintf(acStack48,s__d__d_8008d514,(int)sVar3,(int)(char)PTR_DAT_8008d2ac[0x1d33]);

	// copy a pointer to the string
    pcVar1 = acStack48;

	// set the Y value to the top of the string
    uVar2 = 1;

	// set the color
    local_38 = 0x4001;
  }

  // if numPlyrCurrGame is 3 or 4
  else
  {
	// set pointer to string
    pcVar1 = &DAT_8008d51c;

	// height of text
    uVar2 = 2;

	// convert current lap number to ascii
    DAT_8008d51c = (char)sVar3 + '0';

	// color
    local_38 = 1;

	// convert number of laps to ascii
    DAT_8008d51e = PTR_DAT_8008d2ac[0x1d33] + '0';
  }

  // draw string
  FUN_80022878(pcVar1,(int)param_1,(param_2 + 8) * 0x10000 >> 0x10,uVar2,local_38);
  return;
}


// Draw how many points or lifes the player has in battle
void FUN_80050654(int param_1,int param_2,int param_3)

{
  short sVar1;
  undefined4 local_40;
  undefined4 uVar2;
  int iVar3;
  char acStack48 [32];

  // DAT_8008644c has 16 shorts, each short is color + alignment
  // First 4 shorts show how text is drawn for 4 players in 1P Mode
  // Next  4 shorts show how text is drawn for 4 players in 2P Mode
  // Then 3P mode, then 4P mode

  // Set color of your string
  sVar1 = *(short *)(&DAT_8008644c +
                    (uint)*(byte *)(param_3 + 0x4a) * 2 +

					// numPlyrCurrGame - 1
                    ((uint)(byte)PTR_DAT_8008d2ac[0x1ca8] - 1) * 8);


  // If you dont have a point limit (battle)
  if ((*(uint *)PTR_DAT_8008d2ac & 0x4000) == 0)
  {
	// if you dont have a life limit (battle)
    if ((*(uint *)PTR_DAT_8008d2ac & 0x8000) == 0)
	{
      return;
    }

	// if you have a life limit (battle)

	// add life variable to string
    sprintf(acStack48,&DAT_8008d520,*(undefined4 *)(param_3 + 0x4e4));

	// Draw the string
    FUN_80022878(acStack48,(param_1 + 0x25) * 0x10000 >> 0x10,(param_2 + 4) * 0x10000 >> 0x10,2,
                 (int)sVar1);

	// pointer to backbuffer
	iVar3 = *(int *)(PTR_DAT_8008d2ac + 0x10);

	// pointer to OT memory
    local_40 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c);

	// pointer to lives icon
    uVar2 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x20fc);
  }


  // If you have a point limit (battle)
  else
  {
	// add point variable to string
    sprintf(acStack48,&DAT_8008d520,

								// Battle Team of Player -> points on this team
            *(undefined4 *)(PTR_DAT_8008d2ac + *(int *)(param_3 + 0x4e8) * 4 + 0x1d90));

	// Draw the string
	FUN_80022878(acStack48,(param_1 + 0x25) * 0x10000 >> 0x10,(param_2 + 4) * 0x10000 >> 0x10,2,
                 (int)sVar1);

	// pointer to backBuffer
    iVar3 = *(int *)(PTR_DAT_8008d2ac + 0x10);

	// pointer to OT memory
    local_40 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c);

	// pointer to points icon
    uVar2 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x2100);
  }

  // DecalHUD_DrawPolyFT4
  FUN_80022db0(

	// pointer to icon
	uVar2,

	(int)(short)param_1,
	(int)(short)param_2,

	// gGT->backBuffer->primMem
	iVar3 + 0x74,

	// pointer to OT mem
	local_40,

	1,0x1000);

  return;
}


// Draw weapon and wumpa fruit in HUD
void FUN_800507e0(short param_1,short param_2,short param_3,int param_4)

{
  uint uVar1;
  int iVar2;
  undefined4 uVar3;
  int iVar4;
  short local_20;
  short local_1e;

  // If you are not shuffling through weapon roulette
  if (*(char *)(param_4 + 0x36) != '\x10')
  {
	// If you do have "no weapon icon"
    if (*(char *)(param_4 + 0x36) == '\x0f') {
      return;
    }

	// If you have a weapon that is ready to use

    iVar4 = (uint)*(byte *)(param_4 + 0x36) + 5;

	// Get the ascii character to represent the quantity
	// of weapon that you have (3 missiles)
    DAT_8008d524 = *(char *)(param_4 + 0x37) + '0';

	if (
			(
				(
					// If your weapon is a mask
					(*(byte *)(param_4 + 0x36) == 7) &&
					(
						// Player / AI structure + 0x4a shows driver index (0-7)

													// character ID
						uVar1 = SEXT24((short)(&DAT_80086e84)[*(byte *)(param_4 + 0x4a)]),

						// if not Crash
						uVar1 != 0
					)
				) &&

				// if not Coco
				(uVar1 != 3)
			) &&

			(
				(
					// if not Polar
					uVar1 != 6 &&

					// If not Pura (7, same as mask weaponID)
					// This is some insane compiler optimization
					(uVar1 != (uint)*(byte *)(param_4 + 0x36))
				)
			)
		)
	{
	  // This is a bad guy, change icon to Uka
      iVar4 = 0x32;
    }

	// if 9 < amount of wumpa fruit
	// if you have 10 wumpa fruit
    if (('\t' < *(char *)(param_4 + 0x30)) &&

		// If your weapon is less than, or equal to, 6
       (((uint)*(byte *)(param_4 + 0x36) - 3 < 2 || (*(byte *)(param_4 + 0x36) == 6))))
	{
      iVar4 = (uint)*(byte *)(param_4 + 0x36) + 0x11;
    }
    if ((*(short *)(param_4 + 0x3c) != 0) && ((*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 1) == 0)) {
      return;
    }

	// If this weapon has a quantity (3 missiles)
    if (*(char *)(param_4 + 0x37) != '\0')
	{
	  // Draw the number near the weapon icon to show how many
      FUN_80022878(&DAT_8008d524,(int)param_1,(int)param_2,2,4);
    }

	// pointer to back buffer
    iVar2 = *(int *)(PTR_DAT_8008d2ac + 0x10);

	// pointer to OT memory
    uVar3 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c);

    iVar4 = iVar4 << 2;
    goto LAB_80050abc;
  }
  iVar4 = 0;
  local_20 = param_1;
  local_1e = param_2;

  // If game is not paused
  if ((*(uint *)PTR_DAT_8008d2ac & 0xf) == 0) {

	// If you're not in Battle Mode
    if ((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0) {
      iVar4 = rand();
      iVar4 = iVar4 + ((iVar4 / 6 + (iVar4 >> 0x1f) >> 1) - (iVar4 >> 0x1f)) * -0xc;
      if (iVar4 == 5) goto LAB_800508ec;
    }
    else {
      iVar4 = rand();
      iVar4 = iVar4 % 0xe;
      if (iVar4 == 5) {
LAB_800508ec:
        iVar4 = 0;
      }
      else {
        if (iVar4 == 8) {
          iVar4 = 1;
        }
        else {
          if (iVar4 == 9) {
            iVar4 = 3;
          }
        }
      }
    }
  }

  // if timer is not finished
  if (*(int *)(param_4 + 0x4b0) != 0)
  {
	// 4b4 and 4b6 are WindowStartPos(x,y) from TileView, inside Driver
    FUN_8004ec18(&local_20,(int)*(short *)(param_4 + 0x4b4),(int)*(short *)(param_4 + 0x4b6),
                 (int)param_1,(int)param_2,*(undefined4 *)(param_4 + 0x4b0),5);

	// subtract one from timer
    *(int *)(param_4 + 0x4b0) = *(int *)(param_4 + 0x4b0) + -1;
  }

  // pointer to back buffer
  iVar2 = *(int *)(PTR_DAT_8008d2ac + 0x10);

  // pointer to OT memory
  uVar3 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c);

  iVar4 = (iVar4 + 5) * 4;
  param_1 = local_20;
  param_2 = local_1e;
LAB_80050abc:

  // DecalHUD_DrawWeapon
  FUN_80022ec4(
				// pointer to icon, from array of icon pointers
				*(undefined4 *)(PTR_DAT_8008d2ac + iVar4 + 0x1eec),

				(int)param_1,(int)param_2,

				// PrimMem
				iVar2 + 0x74,

				// OTMem
				uVar3,

				1,(int)param_3,1);
  return;
}


// Draw_JuicedUp_Shine
void FUN_80050af8(short param_1,short param_2,short param_3,int param_4)

{
  int iVar1;
  int iVar2;

  // reduce frame timer until it hits zero (unused?)
  if (*(int *)(param_4 + 0x4e0) != 0) {
    *(int *)(param_4 + 0x4e0) = *(int *)(param_4 + 0x4e0) + -1;
  }

  iVar2 = (int)param_3;

  // wumpaShineTheta (given to sine)
  DAT_8008d990 = DAT_8008d990 + 0x100;

  iVar1 = iVar2 * 0xd000 >> 0x10;

  // UI_WeaponBG_DrawShine
  FUN_8004e37c(
				// Weapon Roulette background (shine)
				*(undefined4 *)(PTR_DAT_8008d2ac + 0x1fb0),

				(int)param_1,(int)param_2,

				// pointer to PrimMem struct
				*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

				// pointer to OTMem (25c-168=0xf4)
				*(undefined4 *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_4 + 0x4a) * 0x110 + 0x25c),

				2,iVar2,iVar1,0xff0000);

  // UI_WeaponBG_DrawShine
  FUN_8004e37c(
				// Weapon Roulette background (shine)
				*(undefined4 *)(PTR_DAT_8008d2ac + 0x1fb0),

				(int)param_1,(int)param_2,

				// pointer to PrimMem struct
				*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

				// pointer to OTMem (25c-168=0xf4)
				*(undefined4 *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_4 + 0x4a) * 0x110 + 0x25c),

				3,iVar2,iVar1,0xff0000);
  return;
}


// UI_DrawNumWumpa
void FUN_80050c20(int param_1,int param_2,int param_3)

{
  char cVar1;
  int iVar2;
  short sVar3;
  short sVar4;
  char acStack40 [16];

  sVar3 = (short)param_1;
  sVar4 = (short)param_2;

  // if numPlyrCurrGame is less than 3
  if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 3)
  {
	// Draw 'x' before drawing number of wumpa
    FUN_80022878(&DAT_8008d528,(int)sVar3,(param_2 + 4) * 0x10000 >> 0x10,2,0);

	// DAT_8008d510
	// %d

	// convert amount of wumpa to string
    sprintf(acStack40,&DAT_8008d510,(int)*(char *)(param_3 + 0x30));

	// draw string
	FUN_80022878(acStack40,(param_1 + 0xd) * 0x10000 >> 0x10,(int)sVar4,1,0);

  }

  // if numPlyrCurrGame is 3 or 4
  else
  {
	// amount of wumpa
    cVar1 = *(char *)(param_3 + 0x30);

	// amount of wumpa / 10
    iVar2 = ((int)cVar1 / 10) * 0x1000000 >> 0x18;

	// In 3P or 4P, we dont have enough time to
	// render strings, so we render individual
	// number icons 0-9

	// Draw the 10s place icon of wumpa fruit
	// DecalHUD_DrawPolyGT4
	FUN_80023054(*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x2128) + iVar2 * 4 + 0x14),

				 // Dimensions
				 (int)sVar3,
                 (int)sVar4,

				 // pointer to PrimMem struct
				 *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

				 // pointer to OT memory
                 *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				 // color data
				 *(undefined4 *)PTR_DAT_80081d70,
                 *(undefined4 *)(PTR_DAT_80081d70 + 4),
				 *(undefined4 *)(PTR_DAT_80081d70 + 8),
                 *(undefined4 *)(PTR_DAT_80081d70 + 0xc),

				 0,0x1000);

	// 0-9 - 10*0
	// 10 - 10*1

	// Draw the 1s place icon of wumpa fruit
	// DecalHUD_DrawPolyGT4
	FUN_80023054(*(undefined4 *)
                  (*(int *)(PTR_DAT_8008d2ac + 0x2128) + ((int)cVar1 + iVar2 * -10) * 4 + 0x14),

				 (int)sVar3 + 0xc,
				 (int)sVar4,

				 // pointer to PrimMem struct
				 *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

				 // pointer to OT memory
                 *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				 // color data
				 *(undefined4 *)PTR_DAT_80081d70,
                 *(undefined4 *)(PTR_DAT_80081d70 + 4),
				 *(undefined4 *)(PTR_DAT_80081d70 + 8),
                 *(undefined4 *)(PTR_DAT_80081d70 + 0xc),

				 0,0x1000);
  }
  return;
}

// UI_DrawNumTimebox
void FUN_80050e6c(int param_1,int param_2,int param_3)

{
  char acStack32 [16];

  // Draw 'x' before drawing number of time crates
  FUN_80022878(&DAT_8008d528,(param_1 + 0x14) * 0x10000 >> 0x10,(param_2 + -10) * 0x10000 >> 0x10,2,
               0);

  // Generate message for screen
  sprintf(acStack32,"%2.02d/%ld",

			// Number of Time Crates collected
			(int)*(char *)(param_3 + 0x32),

			// Number of Total Crates collected
			*(undefined4 *)(PTR_DAT_8008d2ac + 0x1e2c));

  // Draw the string
  FUN_80022878(acStack32,(param_1 + 0x21) * 0x10000 >> 0x10,(param_2 + -0xe) * 0x10000 >> 0x10,1,0);
  return;
}


// UI_DrawNumRelic
void FUN_80050f18(int param_1,int param_2)

{
  // number of relics
  int iVar1;

  // buffer for sprintf string
  char acStack32 [16];

  // Draw 'x' string before drawing number of relics
  FUN_80022878(&DAT_8008d528,(int)(short)param_1,(param_2 + 4) * 0x10000 >> 0x10,2,0);

  // get number of relics
  iVar1 = *(int *)(PTR_DAT_8008d2ac + 0x1e34);

  // If you're playing animation to increment number of relics while
  // returning to the podium after earning the relic
  if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x1000000) != 0)
  {
	// subtract one from the number of relics, then
	// after the animation is done, it will show the proper number
    iVar1 = iVar1 + -1;
  }

  // DAT_8008d520
  // %ld
  // convert number of relics to a string
  sprintf(acStack32,&DAT_8008d520,iVar1);

  // draw number of relics
  FUN_80022878(acStack32,(param_1 + 0xd) * 0x10000 >> 0x10,(int)(short)param_2,1,0);
  return;
}


// UI_DrawNumKey
void FUN_80050fc4(int param_1,int param_2)

{
  // number of keys
  int iVar1;

  // buffer for sprintf
  char acStack32 [16];

  // Draw 'x' character before drawing number of keys
  FUN_80022878(&DAT_8008d528,(int)(short)param_1,(param_2 + 4) * 0x10000 >> 0x10,2,0);

  // get number of keys
  iVar1 = *(int *)(PTR_DAT_8008d2ac + 0x1e38);

  // if you just returned to podium after earning a key, and playing
  // animation for the key counter to be incremented
  if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x2000000) != 0)
  {
	// decrease key count by one until animation ends
    iVar1 = iVar1 + -1;
  }

  // DAT_8008d520
  // %ld
  // turn number of keys into a string
  sprintf(acStack32,&DAT_8008d520,iVar1);

  // draw string for number of keys
  FUN_80022878(acStack32,(param_1 + 0xd) * 0x10000 >> 0x10,(int)(short)param_2,1,0);
  return;
}


// UI_DrawNumTrophy
void FUN_80051070(int param_1,int param_2)

{
  // number of trophies
  int iVar1;

  // buffer for sprintf
  char acStack32 [16];

  // Draw 'x' before the number of trophies
  FUN_80022878(&DAT_8008d528,(int)(short)param_1,(param_2 + 4) * 0x10000 >> 0x10,2,0);

  // number of trophies in adventure
  iVar1 = *(int *)(PTR_DAT_8008d2ac + 0x1e30);

  // If you're on the podium after winning a trophy
  if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x4000000) != 0)
  {
	// subtract a trophy, until the animation that shows
	// the trophy count incrementing is done
    iVar1 = iVar1 + -1;
  }

  // DAT_8008d520
  // %ld
  // Add trophy count to string
  sprintf(acStack32,&DAT_8008d520,iVar1);

  // Draw String
  FUN_80022878(acStack32,(param_1 + 0xd) * 0x10000 >> 0x10,(int)(short)param_2,1,0);
  return;
}


// UI_DrawNumCrystal
void FUN_8005111c(int param_1,int param_2,int param_3)

{
  char acStack32 [16];

  // Draw 'x' before drawing the number of crystals
  FUN_80022878(&DAT_8008d528,(int)(short)param_1,(param_2 + 4) * 0x10000 >> 0x10,2,0);

  // Generate message for screen
  sprintf(acStack32,"%2.02d/%ld",

			// amount of crystals you have
			(int)*(char *)(param_3 + 0x31),

			// Number of crystals you need to win
          *(undefined4 *)(PTR_DAT_8008d2ac + 0x1e28));

  // Draw the string
  FUN_80022878(acStack32,(param_1 + 0xd) * 0x10000 >> 0x10,(int)(short)param_2,1,0);
  return;
}


// draw spedometer needle
void FUN_800511c0(short param_1,short param_2,int param_3)

{
  undefined *puVar1;
  short sVar2;
  int iVar3;
  int iVar4;
  uint *puVar5;
  int iVar6;
  int iVar7;
  undefined4 uVar8;
  int iVar9;
  uint *puVar10;
  undefined4 local_28;

  iVar9 = (uint)*(ushort *)(param_3 + 0x42e) << 0x10;
  iVar6 = iVar9 >> 0x10;
  iVar3 = iVar6 + *(short *)(param_3 + 0x432) >> 8;
  iVar4 = (uint)*(ushort *)(param_3 + 0x36e) << 0x10;
  iVar7 = 0;
  iVar9 = iVar9 >> 0x18;
  if (iVar6 < iVar4 >> 0x10) {
    local_28 = 0x700;
    uVar8 = 0x980;
    iVar7 = (iVar9 * 0x1a5e0) / 64000;
  }
  else {
    local_28 = 0x980;
    uVar8 = 0xd90;
    iVar3 = iVar9;
  }

  // Map value from [oldMin, oldMax] to [newMin, newMax]
  // inverting newMin and newMax will give an inverse range mapping
  sVar2 = FUN_80058f9c(((iVar4 >> 0x18) * 0x1a5e0) / 64000,iVar7,(iVar3 * 0x1a5e0) / 64000,uVar8,
                       local_28);

  // gGT->backBuffer
  iVar7 = *(int *)(PTR_DAT_8008d2ac + 0x10);

  // PrimMem ptrCurrent
  puVar5 = *(uint **)(iVar7 + 0x80);

  puVar10 = (uint *)0x0;

  // if there is room for more
  if (puVar5 <= *(uint **)(iVar7 + 0x84))
  {
	// increment prim pointer
    *(uint **)(iVar7 + 0x80) = puVar5 + 7;
    puVar10 = puVar5;
  }

  if (puVar10 != (uint *)0x0) {
    iVar3 = (int)sVar2;
    iVar4 = iVar3 + 0x400;
    puVar10[1] = 0x30005b5b;
    puVar10[3] = 0x30012b32;
    puVar10[5] = 0x3000bbff;

	// Sine(angle)
	iVar7 = FUN_8003d184(iVar4);

	*(short *)(puVar10 + 6) = param_1 + (short)(iVar7 * 3 >> 0xb) + 0x41;

	// Cosine(angle)
	iVar7 = FUN_8003d1c0(iVar4);

	iVar7 = ((iVar7 << 2) >> 0xb) * 0x140;
    if (iVar7 < 0) {
      iVar7 = iVar7 + 0x1ff;
    }
    *(short *)((int)puVar10 + 0x1a) = param_2 + (short)(iVar7 >> 9) + 0x29;

	// Sine(angle)
	iVar7 = FUN_8003d184(iVar3);

	*(short *)(puVar10 + 4) = param_1 - ((short)(iVar7 * 3 >> 0xb) + -0x41);

	// Cosine(angle)
	iVar7 = FUN_8003d1c0(iVar3);

	iVar7 = (iVar7 * 3 >> 0xb) * 0x140;
    if (iVar7 < 0) {
      iVar7 = iVar7 + 0x1ff;
    }
    *(short *)((int)puVar10 + 0x12) = param_2 - ((short)(iVar7 >> 9) + -0x29);

	// Sine(angle)
	iVar7 = FUN_8003d184(iVar3);

	*(short *)(puVar10 + 2) = param_1 + (short)(iVar7 * 0x1e >> 0xb) + 0x41;

	// Cosine(angle)
	iVar7 = FUN_8003d1c0(iVar3);

	puVar1 = PTR_DAT_8008d2ac;
    iVar7 = (iVar7 * 0x1e >> 0xb) * 0x140;
    if (iVar7 < 0) {
      iVar7 = iVar7 + 0x1ff;
    }
    *(short *)((int)puVar10 + 10) = param_2 + (short)(iVar7 >> 9) + 0x29;

	// pointer to OT memory
    puVar5 = *(uint **)(puVar1 + 0x147c);

    *puVar10 = *puVar5 | 0x6000000;
    *puVar5 = (uint)puVar10 & 0xffffff;

	// gGT->backBuffer
    iVar7 = *(int *)(PTR_DAT_8008d2ac + 0x10);

	// PrimMem ptrCurrent
    puVar5 = *(uint **)(iVar7 + 0x80);

	puVar10 = (uint *)0x0;

	// if there is room for more
	if (puVar5 <= *(uint **)(iVar7 + 0x84))
	{
	  // increment prim pointer
      *(uint **)(iVar7 + 0x80) = puVar5 + 7;
      puVar10 = puVar5;
    }

    if (puVar10 != (uint *)0x0) {
      puVar10[1] = 0x30ffffff;
      puVar10[3] = 0x3000699c;
      puVar10[5] = 0x3000ffff;

	  // Sine(angle)
	  iVar7 = FUN_8003d184(iVar4);

	  *(short *)(puVar10 + 6) = param_1 - ((short)(iVar7 * 3 >> 0xb) + -0x41);

	  // Cosine(angle)
	  iVar7 = FUN_8003d1c0(iVar4);

	  iVar7 = ((iVar7 << 2) >> 0xb) * 0x140;
      if (iVar7 < 0) {
        iVar7 = iVar7 + 0x1ff;
      }
      *(short *)((int)puVar10 + 0x1a) = param_2 - ((short)(iVar7 >> 9) + -0x29);

	  // Sine(angle)
	  iVar7 = FUN_8003d184(iVar3);

	  *(short *)(puVar10 + 4) = param_1 - ((short)(iVar7 * 3 >> 0xb) + -0x41);

	  // Cosine(angle)
	  iVar7 = FUN_8003d1c0(iVar3);

	  iVar7 = (iVar7 * 3 >> 0xb) * 0x140;
      if (iVar7 < 0) {
        iVar7 = iVar7 + 0x1ff;
      }
      *(short *)((int)puVar10 + 0x12) = param_2 - ((short)(iVar7 >> 9) + -0x29);

	  // Sine(angle)
	  iVar7 = FUN_8003d184(iVar3);

	  *(short *)(puVar10 + 2) = param_1 + (short)(iVar7 * 0x1e >> 0xb) + 0x41;

	  // Cosine(angle)
	  iVar7 = FUN_8003d1c0(iVar3);

	  puVar1 = PTR_DAT_8008d2ac;
      iVar7 = (iVar7 * 0x1e >> 0xb) * 0x140;
      if (iVar7 < 0) {
        iVar7 = iVar7 + 0x1ff;
      }
      *(short *)((int)puVar10 + 10) = param_2 + (short)(iVar7 >> 9) + 0x29;

	  // pointer to OT memory
      puVar5 = *(uint **)(puVar1 + 0x147c);

      *puVar10 = *puVar5 | 0x6000000;
      *puVar5 = (uint)puVar10 & 0xffffff;
    }
  }
  return;
}


// speedometer background
void FUN_800516ac(void)

{
  ushort *puVar1;
  ushort uVar2;
  short sVar3;
  undefined *puVar4;
  uint uVar5;
  uint *puVar6;
  uint uVar7;
  uint *puVar8;
  int iVar9;
  int iVar10;
  ushort *puVar11;
  int iVar12;
  int iVar13;

  puVar11 = &DAT_800864a4;
  iVar10 = 1;
  iVar9 = 0;
  do {
    iVar13 = iVar9 + 2;

	// CTR_Box_DrawWirePrims
    FUN_80021500((int)(((uint)*puVar11 + 0x1e0) * 0x10000) >> 0x10,
                 (int)(((uint)puVar11[1] + 0xbe) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_800864a4)[iVar10 * 2] + 0x1e0) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_800864a6)[iVar10 * 2] + 0xbe) * 0x10000) >> 0x10,0xff,
                 0xff,0xff,

				 // pointer to OT memory
				 *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				 // pointer to PrimMem struct
                 *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

    uVar2 = *puVar11;
    puVar1 = puVar11 + 1;
    puVar11 = puVar11 + 4;

	// CTR_Box_DrawWirePrims
    FUN_80021500((int)(((uint)uVar2 + 0x1e1) * 0x10000) >> 0x10,
                 (int)(((uint)*puVar1 + 0xbf) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_800864a4)[iVar10 * 2] + 0x1e1) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_800864a6)[iVar10 * 2] + 0xbf) * 0x10000) >> 0x10,0,0,0,

				 // pointer to OT memory
				 *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				 // pointer to PrimMem struct
				 *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74
                );
    iVar10 = iVar9 + 3;
    iVar9 = iVar13;
  } while (iVar13 < 0xe);
  iVar9 = 0;
  do {
    iVar12 = iVar9 + 2;

	// CTR_Box_DrawWirePrims
    FUN_80021500((int)(((uint)(ushort)(&DAT_8008646c)[iVar9 * 2] + 0x1e0) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646e)[iVar9 * 2] + 0xbe) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646c)[iVar12 * 2] + 0x1e0) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646e)[iVar12 * 2] + 0xbe) * 0x10000) >> 0x10,0xff,
                 0xff,0xff,

				 // pointer to OT memory
				 *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				 // pointer to PrimMem struct
                 *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

    iVar13 = iVar9 + 1;
    iVar10 = iVar9 + 3;

	// CTR_Box_DrawWirePrims
    FUN_80021500((int)(((uint)(ushort)(&DAT_8008646c)[iVar13 * 2] + 0x1e0) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646e)[iVar13 * 2] + 0xbe) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646c)[iVar10 * 2] + 0x1e0) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646e)[iVar10 * 2] + 0xbe) * 0x10000) >> 0x10,0xff,
                 0xff,0xff,

				 // pointer to OT memory
				 *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				 // pointer to PrimMem struct
                 *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

	// CTR_Box_DrawWirePrims
    FUN_80021500((int)(((uint)(ushort)(&DAT_8008646c)[iVar9 * 2] + 0x1e1) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646e)[iVar9 * 2] + 0xbf) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646c)[iVar12 * 2] + 0x1e1) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646e)[iVar12 * 2] + 0xbf) * 0x10000) >> 0x10,0,0,0,

				 // pointer to OT memory
				 *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				 // pointer to PrimMem struct
				 *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

	// CTR_Box_DrawWirePrims
    FUN_80021500((int)(((uint)(ushort)(&DAT_8008646c)[iVar13 * 2] + 0x1e1) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646e)[iVar13 * 2] + 0xbf) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646c)[iVar10 * 2] + 0x1e1) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646e)[iVar10 * 2] + 0xbf) * 0x10000) >> 0x10,0,0,0,

				 // pointer to OT memory
				 *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				 // pointer to PrimMem struct
				 *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

	// backDB
    iVar10 = *(int *)(PTR_DAT_8008d2ac + 0x10);

    puVar6 = *(uint **)(iVar10 + 0x80);
    puVar8 = (uint *)0x0;
    if (puVar6 <= *(uint **)(iVar10 + 0x84)) {
      *(uint **)(iVar10 + 0x80) = puVar6 + 9;
      puVar8 = puVar6;
    }
    if (puVar8 == (uint *)0x0) {
      return;
    }
    uVar5 = 0xb500;
    uVar7 = uVar5;
    if ((2 < iVar9) && (uVar7 = 0xd1ff, 4 < iVar9)) {
      uVar5 = 0xd1ff;
      if (iVar9 < 7) {
        uVar7 = 0xdb;
      }
      else {
        uVar5 = 0xdb;
        uVar7 = uVar5;
      }
    }
    puVar8[1] = uVar5 | 0x38000000;
    puVar8[3] = uVar5 | 0x38000000;
    puVar8[5] = uVar7 | 0x38000000;
    puVar8[7] = uVar7 | 0x38000000;
    iVar10 = iVar9 + 2;
    *(short *)(puVar8 + 2) = (&DAT_8008646c)[iVar9 * 2] + 0x1e0;
    *(short *)((int)puVar8 + 10) = (&DAT_8008646e)[iVar9 * 2] + 0xbe;
    *(short *)(puVar8 + 4) = (&DAT_8008646c)[(iVar9 + 1) * 2] + 0x1e0;
    *(short *)((int)puVar8 + 0x12) = (&DAT_8008646e)[(iVar9 + 1) * 2] + 0xbe;
    *(short *)(puVar8 + 6) = (&DAT_8008646c)[iVar10 * 2] + 0x1e0;
    *(short *)((int)puVar8 + 0x1a) = (&DAT_8008646e)[iVar10 * 2] + 0xbe;
    *(short *)(puVar8 + 8) = (&DAT_8008646c)[(iVar9 + 3) * 2] + 0x1e0;
    puVar4 = PTR_DAT_8008d2ac;
    *(short *)((int)puVar8 + 0x22) = (&DAT_8008646e)[(iVar9 + 3) * 2] + 0xbe;

	// pointer to OT memory
	puVar6 = *(uint **)(puVar4 + 0x147c);

	*puVar8 = *puVar6 | 0x8000000;
    *puVar6 = (uint)puVar8 & 0xffffff;
    iVar9 = iVar10;
  } while (iVar10 < 0xc);
  iVar13 = 0;
  iVar10 = 0xc;
  iVar9 = 4;
  while( true )
  {
	// gGT->backbuffer
    iVar12 = *(int *)(PTR_DAT_8008d2ac + 0x10);

	// PrimMem ptrCurrent
	puVar6 = *(uint **)(iVar12 + 0x80);

    puVar8 = (uint *)0x0;

	// if there is room for more
	if (puVar6 <= *(uint **)(iVar12 + 0x84))
	{
	  // increment primitive pointer
      *(uint **)(iVar12 + 0x80) = puVar6 + 9;
      puVar8 = puVar6;
    }
    if (puVar8 == (uint *)0x0) break;
    *(short *)(puVar8 + 4) = *(short *)((int)&DAT_8008646c + iVar9) + 0x1e0;
    *(short *)((int)puVar8 + 0x12) = *(short *)((int)&DAT_8008646e + iVar9) + 0xbe;
    *(short *)(puVar8 + 6) = *(short *)((int)&DAT_8008646c + iVar10) + 0x1e0;
    iVar9 = iVar9 + 8;
    *(short *)((int)puVar8 + 0x1a) = *(short *)((int)&DAT_8008646e + iVar10) + 0xbe;
    iVar13 = iVar13 + 2;
    *(short *)(puVar8 + 8) = DAT_800864a0 + 0x1e0;
    sVar3 = DAT_80086472;
    *(undefined *)((int)puVar8 + 3) = 8;
    *(undefined *)((int)puVar8 + 0xf) = 0x32;
    *(undefined *)(puVar8 + 5) = 0;
    *(undefined *)((int)puVar8 + 0x15) = 0;
    *(undefined *)((int)puVar8 + 0x16) = 0;
    *(undefined *)(puVar8 + 3) = 0;
    *(undefined *)((int)puVar8 + 0xd) = 0;
    *(undefined *)((int)puVar8 + 0xe) = 0;
    *(undefined *)(puVar8 + 7) = 0;
    *(undefined *)((int)puVar8 + 0x1d) = 0;
    *(undefined *)((int)puVar8 + 0x1e) = 0;
    puVar4 = PTR_DAT_8008d2ac;
    puVar8[1] = 0xe1000a00;
    puVar8[2] = 0;
    *(short *)((int)puVar8 + 0x22) = sVar3 + 0xbe;

	// pointer to OT memory
    puVar6 = *(uint **)(puVar4 + 0x147c);

	iVar10 = iVar10 + 8;
    *puVar8 = *puVar6 | 0x8000000;
    *puVar6 = (uint)puVar8 & 0xffffff;
    if (0xb < iVar13) {
      return;
    }
  }
  return;
}


//handles Jump meter and landing boosts
//param_1 is player struct pointer
void FUN_80051c64(int param_1)
{
  short sVar1;
  int iVar2;

  //if player is not in the air
  if ((*(uint *)(param_1 + 0x2c8) & 0x80000) == 0)
  {
    //if, in previous frame? player was not in the air either
    if ((*(uint *)(param_1 + 0x2cc) & 0x80000) == 0)
	{
      //if Jump meter Timer is done
      if (*(short *)(param_1 + 0x48) == 0) {
        //reset Jump meter
        *(undefined2 *)(param_1 + 0x46) = 0;
      }
      //if Jump meter Timer is not done
      else
      {
        //iVar2 = Jump meter Timer - ~32ms
        iVar2 = (uint)*(ushort *)(param_1 + 0x48) - (uint)*(ushort *)(PTR_DAT_8008d2ac + 0x1d04);
        //reduce Jump meter Timer by ~32ms
        *(undefined2 *)(param_1 + 0x48) = (short)iVar2;
        //if Jump meter Timer goes negative
        if (iVar2 * 0x10000 < 0) {
          //prevent Jump meter Timer from going negative
          *(undefined2 *)(param_1 + 0x48) = 0;
        }
      }
    }
    //if, in previous frame? player was in the air
    else
	{
      //iVar2 = Jump meter
      iVar2 = (int)*(short *)(param_1 + 0x46);
      //if Jump meter > 0x150

	  // if jump is high enough to be significant
	  if (0x150 < iVar2) 
	  {
        // keep track of all jumps
        *(int *)(param_1 + 0x53c) = *(int *)(param_1 + 0x53c) + iVar2;
		
        iVar2 = (int)*(short *)(param_1 + 0x46);
      }

      // if highest jump is less than current jump
      if (*(short *)(param_1 + 0x550) < iVar2) 
	  {
        // save highest jump
        *(undefined2 *)(param_1 + 0x550) = *(undefined2 *)(param_1 + 0x46);
      }

      //sVar1 = Jump meter
      sVar1 = *(short *)(param_1 + 0x46);

	  //if Jump meter < 0x5A0
      if (sVar1 < 0x5a0)
	  {
        //if Jump meter < 0x3C0
        if (sVar1 < 0x3c0)
		{
          //if Jump meter > 0x27F
          if (0x27f < sVar1)
		  {
			// Turbo_Increment
            // add one second reserves
            FUN_8005abfc(param_1,0x3c0,2,0);
          }
        }

		//if Jump meter >= 0x3C0
        else
		{
		  // Turbo_Increment
          // add one second reserves, plus speed
          FUN_8005abfc(param_1,0x3c0,2,0x80);
        }
      }

      //if Jump meter >= 0x5A0
      else
	  {
		// Turbo_Increment
        // add one second reserves, plus speed
        FUN_8005abfc(param_1,0x3c0,2,0x100);
      }
    }
  }

  //if player is in the air
  else
  {
    //if (0x3FC of player struct > 0x480) and Jump meter < 0x481
    if ((0x480 < *(short *)(param_1 + 0x3fc)) && (*(short *)(param_1 + 0x46) < 0x481))
    {
      //Jump meter related operation

	  // Make driver talk
      FUN_8002cbe8(7,(int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)],0x10);
    }

    //Jump meter = 0x3FC
    *(short *)(param_1 + 0x46) = *(short *)(param_1 + 0x3fc);

	//if Jump meter > 0x960
    if (0x960 < *(short *)(param_1 + 0x3fc))
	{
      //prevent Jump meter from going over 0x960
      *(undefined2 *)(param_1 + 0x46) = 0x960;
    }
    //keep Jump meter Timer at 0x5A0.
    *(undefined2 *)(param_1 + 0x48) = 0x5a0;
  }
  return;
}


// Draw Jump Meter
void FUN_80051e24(short param_1,short param_2,int param_3)

{
  undefined *puVar1;
  uint uVar2;
  short sVar3;
  int iVar4;
  int iVar5;
  uint *puVar6;
  uint *puVar7;
  int iVar8;
  short sVar9;
  int iVar10;
  int iVar11;
  short local_48;
  short local_46;
  undefined2 local_44;
  undefined2 local_42;
  undefined auStack64 [8];
  short local_38;
  short local_36;
  undefined2 local_34;
  undefined2 local_32;
  undefined auStack48 [8];

  iVar5 = ((int)*(short *)(param_3 + 0x46) / 0x3c0) * 0x10000 >> 0x10;
  iVar4 = (int)*(short *)(param_3 + 0x46) + iVar5 * -0x3c0;
  iVar10 = ((iVar4 / 6 + (iVar4 >> 0x1f) >> 4) - (iVar4 >> 0x1f)) * 0x10000 >> 0x10;
  iVar11 = (int)param_1;
  iVar8 = (int)param_2 + -0x2b;

  // DebugFont_DrawNumbers
  FUN_80022318(iVar5,iVar11 + -0x10,iVar8);
  FUN_80022318(iVar10,iVar11 + -4,iVar8);
  FUN_80022318((((iVar4 + iVar10 * -0x60) * 100) / 0x3c0) * 0x10000 >> 0x10,iVar11 + 4,iVar8);

  sVar9 = param_1 + -0x14;
  sVar3 = param_2 + -0x2d;
  local_44 = 0x22;
  local_42 = 10;
  local_48 = sVar9;
  local_46 = sVar3;
  memset(auStack64,0,4);

  // CTR_Box_DrawWireBox
  FUN_80021594(&local_48,auStack64,

				// pointer to OT memory
				*(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

			   // pointer to PrimMem struct
			   *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

  // backDB
  iVar4 = *(int *)(PTR_DAT_8008d2ac + 0x10);

  // PrimMem ptrCurrent
  puVar6 = *(uint **)(iVar4 + 0x80);

  puVar7 = (uint *)0x0;

  // if there is room left for more
  if (puVar6 <= *(uint **)(iVar4 + 0x84))
  {
	// add primitives
    *(uint **)(iVar4 + 0x80) = puVar6 + 6;

    puVar7 = puVar6;
  }

  if (puVar7 != (uint *)0x0) {
    puVar7[1] = 0x28ffffff;
    puVar1 = PTR_DAT_8008d2ac;
    *(short *)(puVar7 + 3) = param_1 + 0xe;
    *(short *)(puVar7 + 5) = param_1 + 0xe;
    *(short *)(puVar7 + 2) = sVar9;
    *(short *)((int)puVar7 + 10) = sVar3;
    *(short *)((int)puVar7 + 0xe) = sVar3;
    *(short *)(puVar7 + 4) = sVar9;
    *(short *)((int)puVar7 + 0x12) = param_2 + -0x23;
    *(short *)((int)puVar7 + 0x16) = param_2 + -0x23;

	// pointer to OT memory
    puVar6 = *(uint **)(puVar1 + 0x147c);

    *puVar7 = *puVar6 | 0x5000000;
    *puVar6 = (uint)puVar7 & 0xffffff;
    local_36 = param_2 + -0x26;
    local_34 = 0xc;
    local_32 = 0x26;
    local_38 = param_1;
    memset(auStack48,0,4);

	// CTR_Box_DrawWireBox
    FUN_80021594(&local_38,auStack48,

				// pointer to OT memory
				*(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				// pointer to PrimMem struct
				*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

	// BackDB
	iVar4 = *(int *)(PTR_DAT_8008d2ac + 0x10);

    puVar6 = *(uint **)(iVar4 + 0x80);
    puVar7 = (uint *)0x0;
    if (puVar6 <= *(uint **)(iVar4 + 0x84)) {
      *(uint **)(iVar4 + 0x80) = puVar6 + 6;
      puVar7 = puVar6;
    }
    if (puVar7 != (uint *)0x0) {
      sVar3 = *(short *)(param_3 + 0x46);
      sVar9 = *(short *)(param_3 + 0x46);
      uVar2 = 0x28ff0000;
      if (0x27f < sVar3) {
        if (sVar3 < 0x3c0) {
          uVar2 = 0x2800ff00;
        }
        else {
          if (sVar3 < 0x5a0) {
            uVar2 = 0x2800ffff;
          }
          else {
            uVar2 = 0x280000ff;
          }
        }
      }
      puVar7[1] = uVar2;
      iVar4 = (int)sVar9 * 0x26;
      sVar9 = param_1 + 0xc;
      *(short *)(puVar7 + 2) = param_1;
      *(short *)(puVar7 + 3) = sVar9;
      *(short *)(puVar7 + 4) = param_1;
      *(short *)((int)puVar7 + 0x12) = param_2;
      *(short *)(puVar7 + 5) = sVar9;
      *(short *)((int)puVar7 + 0x16) = param_2;
      puVar1 = PTR_DAT_8008d2ac;
      sVar3 = param_2 - ((short)((ulonglong)((longlong)iVar4 * 0x1b4e81b5) >> 0x28) -
                        (short)(iVar4 >> 0x1f));
      *(short *)((int)puVar7 + 10) = sVar3;
      *(short *)((int)puVar7 + 0xe) = sVar3;

	  // pointer to OT memory
      puVar6 = *(uint **)(puVar1 + 0x147c);

	  *puVar7 = *puVar6 | 0x5000000;
      *puVar6 = (uint)puVar7 & 0xffffff;

	  // gGT->backBuffer
      iVar4 = *(int *)(PTR_DAT_8008d2ac + 0x10);

	  // primMem ptrCurrent
      puVar6 = *(uint **)(iVar4 + 0x80);
      puVar7 = (uint *)0x0;

	  // If there is room to add more
      if (puVar6 <= *(uint **)(iVar4 + 0x84))
	  {
		// Add more primitives
        *(uint **)(iVar4 + 0x80) = puVar6 + 6;
        puVar7 = puVar6;
      }
      if (puVar7 != (uint *)0x0) {
        puVar7[1] = 0x28808080;
        puVar1 = PTR_DAT_8008d2ac;
        *(short *)(puVar7 + 2) = param_1;
        *(short *)((int)puVar7 + 10) = param_2 + -0x26;
        *(short *)(puVar7 + 3) = sVar9;
        *(short *)((int)puVar7 + 0xe) = param_2 + -0x26;
        *(short *)(puVar7 + 4) = param_1;
        *(short *)((int)puVar7 + 0x12) = param_2;
        *(short *)(puVar7 + 5) = sVar9;
        *(short *)((int)puVar7 + 0x16) = param_2;

		// pointer to OT memory
        puVar6 = *(uint **)(puVar1 + 0x147c);

        *puVar7 = *puVar6 | 0x5000000;
        *puVar6 = (uint)puVar7 & 0xffffff;
      }
    }
  }
  return;
}


// Draw powerslide meter
void FUN_80052250(short param_1,short param_2,int param_3)

{
  undefined *puVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint *puVar5;
  uint *puVar6;
  short sVar7;
  short sVar8;
  short local_30;
  short local_2e;
  undefined2 local_2c;
  short local_2a;
  undefined auStack40 [8];

  sVar8 = 0;

  // height of bar in 1P or 2P
  sVar7 = 7;

  // if numPlyrCurrGame is more than 2 (3P or 4P)
  if (2 < (byte)PTR_DAT_8008d2ac[0x1ca8])
  {
	// Make the bar shorter
    sVar7 = 3;
  }

  // if powerslide meter is not zero
  if ((int)*(short *)(param_3 + 0x3dc) != 0)
  {
	// current room remaining
    iVar4 = (int)*(short *)(param_3 + 0x3dc) * 0x31;

	// max amount of room in turbo
    iVar3 = (uint)*(byte *)(param_3 + 0x476) << 5;

	// max turbo meter size must be more than zero
    if (*(byte *)(param_3 + 0x476) == 0) {
      trap(0x1c00);
    }
    if ((iVar3 == -1) && (iVar4 == -0x80000000)) {
      trap(0x1800);
    }

	// length of rectangle is currentRoom / maxRoom
    sVar8 = 0x31 - (short)(iVar4 / iVar3);
  }
  local_30 = param_1 + -0x31;
  local_2e = param_2 - sVar7;
  local_2c = 0x31;
  local_2a = sVar7;
  memset(auStack40,0,4);

  // CTR_Box_DrawWireBox
  FUN_80021594(&local_30,auStack40,

				// pointer to OT memory
				*(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				// pointer to PrimMem struct
				*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

  // BackDB
  iVar4 = *(int *)(PTR_DAT_8008d2ac + 0x10);

  // backDB->primMem.curr
  puVar6 = *(uint **)(iVar4 + 0x80);

  puVar5 = (uint *)0x0;

  // if there is room remaining to draw
  if (puVar6 <= *(uint **)(iVar4 + 0x84))
  {
	// increment "curr" for next draw after powerslide meter
    *(uint **)(iVar4 + 0x80) = puVar6 + 6;

	// set pointer for where to draw powerslide meter primMem
    puVar5 = puVar6;
  }

  // if we are definitely drawing the powerslide meter
  if (puVar5 != (uint *)0x0)
  {
	// if remaining room is more than the "low warning"
    if ((int)((uint)*(byte *)(param_3 + 0x477) << 5) < (int)*(short *)(param_3 + 0x3dc))
	{
	  // set color to green
      uVar2 = 0x2800ff00;
    }

	// if room remaining is lower than "low warning"
    else
	{
	  // set color to red
      uVar2 = 0x280000ff;
    }

    puVar5[1] = uVar2;
    puVar1 = PTR_DAT_8008d2ac;
    sVar7 = param_2 - sVar7;
    *(short *)(puVar5 + 2) = param_1 - sVar8;
    *(short *)((int)puVar5 + 10) = sVar7;
    *(short *)(puVar5 + 3) = param_1;
    *(short *)((int)puVar5 + 0xe) = sVar7;
    *(short *)((int)puVar5 + 0x12) = param_2;
    *(short *)(puVar5 + 5) = param_1;
    *(short *)((int)puVar5 + 0x16) = param_2;
    *(short *)(puVar5 + 4) = param_1 - sVar8;

	// pointer to OT memory
    puVar6 = *(uint **)(puVar1 + 0x147c);

    *puVar5 = *puVar6 | 0x5000000;
    *puVar6 = (uint)puVar5 & 0xffffff;
    iVar4 = *(int *)(PTR_DAT_8008d2ac + 0x10);
    puVar6 = *(uint **)(iVar4 + 0x80);
    puVar5 = (uint *)0x0;
    if (puVar6 <= *(uint **)(iVar4 + 0x84)) {
      *(uint **)(iVar4 + 0x80) = puVar6 + 6;
      puVar5 = puVar6;
    }
    if (puVar5 != (uint *)0x0) {
      puVar5[1] = 0x28808080;
      puVar1 = PTR_DAT_8008d2ac;
      *(short *)(puVar5 + 2) = param_1 + -0x31;
      *(short *)((int)puVar5 + 10) = sVar7;
      *(short *)(puVar5 + 3) = param_1;
      *(short *)((int)puVar5 + 0xe) = sVar7;
      *(short *)((int)puVar5 + 0x12) = param_2;
      *(short *)(puVar5 + 5) = param_1;
      *(short *)((int)puVar5 + 0x16) = param_2;
      *(short *)(puVar5 + 4) = param_1 + -0x31;

	  // pointer to OT memory
      puVar6 = *(uint **)(puVar1 + 0x147c);

	  *puVar5 = *puVar6 | 0x5000000;
      *puVar6 = (uint)puVar5 & 0xffffff;
    }
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

// Draw player icons on left side of screen
// in Arcade mode and Boss mode, and draws
// icons in multiplayer on the midY axis (and warpball)

// UI_DrawRankedDrivers
void FUN_800524c4(void)

{
  ushort uVar1;
  bool bVar2;
  int iVar3;
  int iVar4;
  undefined *puVar5;
  undefined4 uVar6;
  uint uVar7;
  short *psVar8;
  undefined2 *puVar9;
  short sVar10;
  ushort uVar11;
  int iVar12;
  short *psVar13;
  int iVar14;
  int iVar15;
  ushort *puVar16;
  short *psVar17;
  ushort uVar18;
  undefined4 local_50;
  undefined4 local_48;
  short local_44;
  short local_40;
  short local_3e;
  short local_3c;
  undefined4 local_38;
  short local_34;
  uint local_30;
  uint local_2c;

  // if numPlyrCurrGame is 1
  if (PTR_DAT_8008d2ac[0x1ca8] == '\x01')
  {
	// Number of racers that have finished race
    sVar10 = 0;

	// loop counter
    iVar14 = 0;

    puVar9 = &DAT_800862b8;
    psVar8 = &DAT_800862d8;

	// incremented when looping through player structures
    puVar5 = PTR_DAT_8008d2ac;

	// iVar14 = 0; iVar14 < 8; iVar14++
    do {
      if (*psVar8 == 0)
	  {
		// player structure + 0x482 is your rank in the race
		// 0 = 1st place, 1 = 2nd place, 2 = 3rd place, etc
        *puVar9 = *(undefined2 *)(*(int *)(puVar5 + 0x24ec) + 0x482);
      }

	  // if player structure pointer is not nullptr
      if ((*(int *)(puVar5 + 0x24ec) != 0) &&

        //if racer finished the race
        ((*(uint *)(*(int *)(puVar5 + 0x24ec) + 0x2c8) & 0x2000000) != 0))
	  {
		// count how many racers have finished
        sVar10 = sVar10 + 1;
      }

	  // increment pointer for next player structure
      puVar5 = puVar5 + 4;
      puVar9 = puVar9 + 1;

	  // increment loop counter
      iVar14 = iVar14 + 1;

      psVar8 = psVar8 + 1;
    } while (iVar14 < 8);

	// In a normal arcade race, there are 4 icons
	// on the left side of the screen, for characters
	// in the top 4 places
    iVar14 = 4;

	// If you're in a Boss Race
	// 0x80000000
    if (*(int *)PTR_DAT_8008d2ac < 0)
	{
	  // There are only 2 icons that show position
      iVar14 = 2;
    }

	// start drawing the icons
    iVar15 = 0;

	// If there are icons you want to draw,
	// in this function it will 100% happen
    if (iVar14 != 0)
	{
	  // height to draw rank (this bitshifts later)
      iVar12 = 0x380000;

	  // first racer finished the race if
	  // the number of racers that finished
	  // is more than zero
      bVar2 = 0 < (int)sVar10;

	  // for iVar15 = 0; iVar15 < iVar14; iVar15++
      do
	  {
		// make the text white by default
        uVar6 = 4;

		// if racer has finished the race
        if (bVar2)
		{
		  // make the text red
          uVar6 = 3;
        }

		// convert binary value of iVar15 to ascii
		// by adding '1'... '1', '2', '3', '4'
        DAT_8008d524 = (char)iVar15 + '1';

		// Draw the ranking string
		// white if driver is racing, red if they finished
        FUN_80022878(&DAT_8008d524,0x34,iVar12 >> 0x10,2,uVar6);

		// add to Y, which mekes it lower on screen
        iVar12 = iVar12 + 0x1b0000;

		// increment loop counter
        iVar15 = iVar15 + 1;

		// check if the next racer finished race,
		// before their iteration starts. Willl
		// be true if index is less than num racers finished
        bVar2 = iVar15 < (int)sVar10;

      } while (iVar15 < iVar14);
    }

    iVar14 = 0;

	// these two arrays are compared when animating
	// icons to move up and down the board

	// rank of driver index (drawn on left)
    psVar17 = &DAT_800862c8;

	// rank of driver index (absolute)
    psVar8 = &DAT_800862b8;

	iVar15 = 0;

	// for iVar14 = 0; iVar14 < 8; iVar14++
    do
	{
	  // This is combined with 0x24ec to get the
	  // pointer to the structure of every driver
      puVar5 = PTR_DAT_8008d2ac + iVar14 * 4;

      if (
			// if player structure pointer is not nullptr
			(*(int *)(puVar5 + 0x24ec) != 0) &&

			// if you haven't gotten to the last driver
			((int)*psVar8 + 1 < 9)
		  )
	  {
		// player structure + [some offset]
        iVar12 = *(int *)(*(int *)(puVar5 + 0x24ec) + 0x4ac);

        if (iVar12 < 1) {

		  // if icon should be turning green
		  if (iVar12 < 0) {

            local_30._0_2_ =							// player structure + [some offset]
                 CONCAT11(~(((char)*(undefined4 *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) + '\x1e') *
                           '\x04'),((char)iVar12 + '\x1e') * '\x04');
            local_30._0_3_ =							// player structure + [some offset]
                 CONCAT12(((char)*(undefined4 *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) + '\x1e') *
                          '\x04',(undefined2)local_30);
            local_30 = (uint)(uint3)local_30;

			// timer is negative,
			// add to timer, making it closer to zero
            *(int *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) =
                 *(int *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) + 1;
          }

		  // if icon should have no effect
		  // (less than 1, not less than zero, must equal zero)
          else
		  {
			// make icon white
            local_30 = 0x808080;
          }
        }

		// if icon should be turning red
        else {
          local_30._0_2_ =									// player structure + [some offset]
               CONCAT11(('\x1e' - (char)*(undefined4 *)(*(int *)(puVar5 + 0x24ec) + 0x4ac)) * '\x04'
                        ,~(('\x1e' - (char)iVar12) * '\x04'));
          local_30._0_3_ =									// player structure + [some offset]
               CONCAT12(('\x1e' - (char)*(undefined4 *)(*(int *)(puVar5 + 0x24ec) + 0x4ac)) * '\x04'
                        ,(undefined2)local_30);
          local_30 = (uint)(uint3)local_30;

		  // timer is positive,
		  // decrement to get closer to zero
          *(int *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) =
               *(int *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) + -1;
        }

        psVar13 = (short *)((int)&DAT_800862d8 + iVar15);

		if (*psVar13 == 0) {

		  // get absolute pos-rank of driver
		  iVar12 = (int)*psVar8;

		  // if that's the same as the pos-rank
		  // shown on the left of the screen
		  // (if rank is not animated to move up or down)
          if (iVar12 == (int)*psVar17)
		  {
			// if you are in the top four positions
            if (iVar12 + 1 < 5) {

			  // Draw character icon
              FUN_8004e8d8(
							// MetaDataCharacters -> iconID
							*(undefined4 *)
                            (PTR_DAT_8008d2ac +
                            (int)*(short *)(&DAT_80086d8c +
                                           (int)*(short *)((int)&DAT_80086e84 + iVar15) * 0x10) * 4
                            + 0x1eec),

							0x14,iVar12 * 0x1b + 0x39,

							// pointer to PrimMem struct
                           *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

						   // pointer to OT memory
                           *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

						   1,0x1000,local_30);

			  *psVar17 = *psVar8;
            }
            goto LAB_800528cc;
          }
        }

		// at this point, icon must be moving up or down
		// on the list of top-ranking drivers

		// get position of icon based on a circular motion to move
		// the driver up or down in the ranks (left of screen in Arcade or Boss race)
        FUN_8004eaa8(
						&local_50,
						(int)*(short *)((int)&DAT_800862c8 + iVar15),
						(int)*(short *)((int)&DAT_800862b8 + iVar15)
					);

		// Draw character icon
        FUN_8004e8d8(
					// MetaDataCharacters -> iconID
					*(undefined4 *)
                      (PTR_DAT_8008d2ac +
                      (int)*(short *)(&DAT_80086d8c +
                                     (int)*(short *)((int)&DAT_80086e84 + iVar15) * 0x10) * 4 +
                      0x1eec),(int)(short)local_50,(int)local_50._2_2_,

					  // pointer to PrimMem struct
                     *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

					 // pointer to OT memory
                     *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

					 1,0x1000,local_30);

        sVar10 = *psVar13;
        *psVar13 = sVar10 + 1;
        if (4 < (short)(sVar10 + 1)) {
          *psVar13 = 0;
          *(short *)((int)&DAT_800862c8 + iVar15) = *(short *)((int)&DAT_800862b8 + iVar15);
        }
      }
LAB_800528cc:
      psVar17 = psVar17 + 1;
      psVar8 = psVar8 + 1;

	  // increment loop counter
      iVar14 = iVar14 + 1;

      iVar15 = iVar15 + 2;
    } while (iVar14 < 8);
  }

  // if this is multiplayer
  else {

	// loop counter
    iVar14 = 0;

	// numPlyrCurrGame  +  number of AIs
    if ((uint)(byte)PTR_DAT_8008d2ac[0x1ca8] + (uint)(byte)PTR_DAT_8008d2ac[0x1cab] != 0) {
      puVar16 = &DAT_800862d8;
      iVar12 = 0;
      iVar15 = 0;

	  // for iVar14 = 0; iVar14 < numPlyrCurrGame+numBotsNextGame; iVar14++
	  do
	  {
		// puVar5 increases by 4 for each iteration

		// combined with 0x24ec to get every pointer to every driver
        puVar5 = PTR_DAT_8008d2ac + iVar15;

		// player structure + [some offset]
        iVar3 = *(int *)(*(int *)(puVar5 + 0x24ec) + 0x4ac);

        if (iVar3 < 1) {
          if (iVar3 < 0) {
            local_2c._0_2_ =							// player structure + [some offset]
                 CONCAT11(~(((char)*(undefined4 *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) + '\x1e') *
                           '\x04'),((char)iVar3 + '\x1e') * '\x04');

            local_2c._0_3_ =							// player structure + [some offset]
                 CONCAT12(((char)*(undefined4 *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) + '\x1e') *
                          '\x04',(undefined2)local_2c);
            local_2c = (uint)(uint3)local_2c;

			// player structure + [some offset]
            *(int *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) =
                 *(int *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) + 1;
          }
          else {
            local_2c = 0x808080;
          }
        }
        else {
          local_2c._0_2_ =									// player structure + [some offset]
               CONCAT11(('\x1e' - (char)*(undefined4 *)(*(int *)(puVar5 + 0x24ec) + 0x4ac)) * '\x04'
                        ,~(('\x1e' - (char)iVar3) * '\x04'));

          local_2c._0_3_ =									// player structure + [some offset]
               CONCAT12(('\x1e' - (char)*(undefined4 *)(*(int *)(puVar5 + 0x24ec) + 0x4ac)) * '\x04'
                        ,(undefined2)local_2c);
          local_2c = (uint)(uint3)local_2c;

		  // player structure + [some offset]
          *(int *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) =
               *(int *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) + -1;
        }
        local_50 = local_2c;
        uVar1 = *puVar16;

        if (
				  //if racer is in first lap and
				  (*(char *)(*(int *)(PTR_DAT_8008d2ac + iVar15 + 0x24ec) + 0x44) == '\0') &&
				  //racer crossed the startline backwards
          //this is when race starts and you're behind the finish line
				  ((*(uint *)(*(int *)(PTR_DAT_8008d2ac + iVar15 + 0x24ec) + 0x2c8) & 0x1000000) != 0)
		    )
        {
LAB_80052b00:
		  // icon posX is zero,
		  // dont go to end of lap on the graph
          uVar18 = 0;
        }
        else 
		{
		  // length of track
          iVar3 = (uint)*(ushort *)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c) + 6) * 8;

		  // icon posX = track length - driver->distanceToFinish
          iVar4 = iVar3 - *(int *)(*(int *)(PTR_DAT_8008d2ac + iVar15 + 0x24ec) + 0x488);
		  
		  // divide track length by 0x1d1 (approx screen width)
          iVar3 = iVar3 / 0x1d1;
		  
		  // divide distanceToFinish by screen width
          _uVar18 = iVar4 / iVar3;
          uVar18 = (ushort)_uVar18;
		  
          if (iVar3 == 0) {
            trap(0x1c00);
          }
          if ((iVar3 == -1) && (iVar4 == -0x80000000)) {
            trap(0x1800);
          }
          if (_uVar18 << 0x10 < 0) goto LAB_80052b00;
        }
		
		// posX
        iVar4 = (int)(short)uVar18;
        iVar3 = iVar4 - (short)uVar1;
        
		if (iVar3 < 0) {
          iVar3 = -iVar3;
        }
        uVar7 = iVar3 / 0xe;
        if ((uVar7 & 0xffff) == 0) {
          uVar7 = 1;
        }
        iVar3 = uVar1 + uVar7;
        uVar11 = (ushort)iVar3;
        if ((short)uVar1 < iVar4) {
          bVar2 = iVar4 < iVar3 * 0x10000 >> 0x10;
        }
        else {
          iVar3 = uVar1 - uVar7;
          uVar11 = (ushort)iVar3;
          bVar2 = iVar3 * 0x10000 >> 0x10 < iVar4;
        }
        if (bVar2) {
          uVar11 = uVar18;
        }
        iVar3 = (int)(short)uVar18 - (int)(short)uVar11;
        if (iVar3 < 0) {
          iVar3 = -iVar3;
        }
		
		// 400 = 0x191
        if (400 < iVar3) 
		{
          uVar11 = uVar18;
        }
        
		psVar8 = (short *)((int)&DAT_80086e84 + iVar12);
        iVar12 = iVar12 + 2;
        iVar15 = iVar15 + 4;

		// character icon
		// DecalHUD_DrawPolyGT4
        FUN_80023054(*(undefined4 *)
                      (PTR_DAT_8008d2ac +
                      (int)*(short *)(&DAT_80086d8c + (int)*psVar8 * 0x10) * 4 + 0x1eec),

					 // positionX
					 (int)(short)uVar11 + 5,
					 
					 // midpointY
					 0x66,

					 // pointer to PrimMem struct
					 *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

					 // pointer to OT memory
                     *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

					 // color data
					 local_2c,local_2c,local_2c,local_2c,

					 1,0x9d8);

        puVar5 = PTR_DAT_8008d2ac;

		// increment loop counter
        iVar14 = iVar14 + 1;

        *puVar16 = uVar11;
        puVar16 = puVar16 + 1;

		// iVar14 < numPlyrCurrGame + number of AIs
      } while (iVar14 < (int)((uint)(byte)puVar5[0x1ca8] + (uint)(byte)puVar5[0x1cab]));
    }

	// pointer to first Tracking thread
    iVar14 = *(int *)(PTR_DAT_8008d2ac + 0x1ba4);

	// loop through all "Tracking" objects, AKA WarpBalls
    while (iVar14 != 0)
	{
	  // Get Instance from Thread
      iVar15 = *(int *)(iVar14 + 0x34);

	  // Instance -> Model -> ModelID == warpball
      if (*(short *)(*(int *)(iVar15 + 0x18) + 0x10) == 0x36)
	  {
		// pointer to path data
        iVar3 = *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c);

        iVar12 = 0;

        if ((*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x148) - 1U < 0xff) &&

			// path index = warpballInst->thread->object->pathNode - lev->startNode
           (iVar4 = (int)(short)((*(int *)(*(int *)(*(int *)(iVar15 + 0x6c) + 0x30) + 0x3c) - iVar3)
                                 * -0x55555555 >> 2),

								 // if path index is valid
								 -1 < iVar4))
		{
          psVar17 = (short *)(iVar3 + (uint)*(byte *)(iVar3 + iVar4 * 0xc + 8) * 0xc);
          local_40 = *(short *)(iVar15 + 0x44);
          local_3e = *(short *)(iVar15 + 0x48);
          local_3c = *(short *)(iVar15 + 0x4c);
          psVar8 = (short *)(iVar3 + (uint)*(byte *)(psVar17 + 4) * 0xc);
          local_38 = CONCAT22(psVar17[1] - psVar8[1],*psVar17 - *psVar8);
          local_34 = psVar17[2] - psVar8[2];

		  // MATH_VectorNormalize
		  FUN_8003d378(&local_38);

		  local_48 = CONCAT22(local_3e - psVar17[1],local_40 - *psVar17);
          local_44 = local_3c - psVar17[2];
          setCopControlWord(2,0,local_38);
          setCopControlWord(2,0x800,(int)local_34);
          setCopReg(2,0,local_48);
          setCopReg(2,0x800,(int)local_44);

		  copFunction(2,0x406012);

		  iVar15 = getCopReg(2,0xc800);
          uVar1 = *(ushort *)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c) + 6);
          iVar3 = (uint)(ushort)psVar17[3] * 8 + (iVar15 >> 0xc);
          iVar15 = (uint)uVar1 << 3;
          iVar12 = iVar3 % iVar15;
          if (uVar1 == 0) {
            trap(0x1c00);
          }
          if ((iVar15 == -1) && (iVar3 == -0x80000000)) {
            trap(0x1800);
          }
        }
        if (iVar12 != 0) {
          iVar15 = (uint)*(ushort *)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c) + 6) * 8;
          iVar12 = iVar15 - iVar12;
          iVar15 = iVar15 / 0x1d1;
          if (iVar15 == 0) {
            trap(0x1c00);
          }
          if ((iVar15 == -1) && (iVar12 == -0x80000000)) {
            trap(0x1800);
          }
		  
		  // DecalHUD_DrawWeapon
          FUN_80022ec4(
						// warpball icon
						*(undefined4 *)(PTR_DAT_8008d2ac + 0x1f24),

						(int)(short)(iVar12 / iVar15) + 5,
						0x66,

					   // pointer to PrimMem struct
					   *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

					   // pointer to OT memory
                       *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

					   1,0x8aa,1);
        }
      }

	  // go to next warp ball
	  // thread = thread->sibling
      iVar14 = *(int *)(iVar14 + 0x10);
    }
  }
  return;
}

// UI_RenderFrame_Racing
void FUN_80052f98(void)

{
  short sVar1;
  short sVar2;
  bool bVar3;
  int iVar4;
  undefined4 local_80;
  undefined **ppuVar5;
  byte *pbVar6;
  int iVar7;
  undefined *puVar8;
  uint uVar9;
  undefined4 uVar10;
  uint *puVar11;
  undefined2 *puVar12;
  char *fmt;
  int iVar13;
  ushort *puVar14;
  uint *puVar15;
  int iVar16;
  short sVar17;
  ushort *puVar18;
  undefined4 local_7c;
  undefined4 local_78;
  undefined4 local_74;
  undefined4 local_70;
  int iVar19;
  short *psVar20;
  int iVar21;
  char cVar22;
  short local_60;
  short local_5e;
  short local_58;
  short local_56;
  char acStack80 [24];
  ushort local_38;
  short local_36;
  undefined2 local_30 [4];

  // Get pointer to array of HUD structs                numPlyrCurrGame - 1
  psVar20 = (short *)(&PTR_DAT_8008625c)[(uint)(byte)PTR_DAT_8008d2ac[0x1ca8] - 1];

  iVar21 = 0;

  // UI_WeaponBG_AnimateShine
  FUN_8004e0e0();

  // if time on clock is zero
  if (*(int *)(PTR_DAT_8008d2ac + 0x1d10) == 0) {

	// loop counter
    iVar7 = 0;

    puVar18 = &DAT_800862c8;
    puVar14 = &DAT_800862b8;
    puVar12 = &DAT_800862d8;

	// for iVar7 = 0; iVar7 < 8; iVar7++
    do {
      *puVar12 = 0;
      puVar12 = puVar12 + 1;
      pbVar6 = &DAT_8008d69c + iVar7;

	  // increment loop counter
      iVar7 = iVar7 + 1;

      *puVar14 = (ushort)*pbVar6;
      puVar14 = puVar14 + 1;
      *puVar18 = (ushort)*pbVar6;
      puVar18 = puVar18 + 1;
    } while (iVar7 < 8);
  }

  // If not drawing intro-race cutscene
  if ((*(uint *)PTR_DAT_8008d2ac & 0x40) == 0) {
    if ((PTR_DAT_8008d2ac[0x1d31] & 0x20) == 0) {

	  // If you press Triangle
      if ((*(uint *)(PTR_DAT_8008d2b0 + 0x14) & 0x40000) != 0)
	  {
		// if & 8, remove bit 8,
		// if !& 8, add bit 8,
		// toggle map and speedometer
        DAT_8008d000 = DAT_8008d000 ^ 8;
      }
    }
    else {
      PTR_DAT_8008d2ac[0x1d31] = PTR_DAT_8008d2ac[0x1d31] & 0xdf;
    }
  }

  // numPlyrCurrGame is 0
  if ((PTR_DAT_8008d2ac[0x1ca8] == '\0') &&

	// If this is an AI and not a human
    ((*(uint *)(*(int *)(PTR_DAT_8008d2ac + 0x24ec) + 0x2c8) & 0x100000) != 0))
  {
	// force draw speedometer, and not map, why?
    DAT_8008d000 = 8;
  }

  // LEV -> trial_data . numPointers
  if (**(int **)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x134) != 0)
  {
	// LEV -> trial_data . ptr_map
    iVar21 = (*(int **)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x134))[1];
  }

  // If you are not in Relic Race, and not in battle mode,
  // and not in time trial
  if ((*(uint *)PTR_DAT_8008d2ac & 0x4020020) == 0)
  {
	// UI_DrawRankedDrivers
    FUN_800524c4();
  }

  // pointer to first Player thread
  iVar7 = *(int *)(PTR_DAT_8008d2ac + 0x1b2c);

  cVar22 = '\0';
  if (iVar7 != 0)
  {
	// Loop through all player threads
    do
	{
	  // pointer to player structure
      iVar19 = *(int *)(iVar7 + 0x30);

	  if (
			// if player has not driven backwards very far,
			(*(int *)(iVar19 + 0x490) < 0x1f5)

			||

			// racer is not going the Wrong Way
			((*(uint *)(iVar19 + 0x2c8) & 0x100) == 0))
	  {
LAB_80053260:
	    // If game is not paused
	    if ((*(uint *)PTR_DAT_8008d2ac & 0xf) == 0)
	    {
	      //execute Jump meter and landing boost processes
	      FUN_80051c64(iVar19);
		}
      }

	  // if racer has travelled
	  // wrong way for too long
	  else
	  {
	    // If game is not paused
        if ((*(uint *)PTR_DAT_8008d2ac & 0xf) == 0)
		{
		  // Player / AI structure + 0x4a shows driver index (0-7)
		  // This is a pointer to each player's tileView buffer
          puVar8 = PTR_DAT_8008d2ac + (uint)*(byte *)(iVar19 + 0x4a) * 0x110 + 0x168;

		  // if "Time on clock" last 0xXX byte is greater than 0x80 and less than 0xFF
		  if ((*(uint *)(PTR_DAT_8008d2ac + 0x1d10) & 0x80) != 0)
		  {
			// DAT_8008d878 + 0x74
			// WRONG WAY!
            FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x74),

						 // Midpoint between Start X and Size X
                         (int)(((uint)*(ushort *)(puVar8 + 0x1c) +
                         ((int)((uint)*(ushort *)(puVar8 + 0x20) << 0x10) >> 0x11)) * 0x10000) >> 0x10,

						 // Midpoint between Start Y and Size Y, except 0x1e higher
						 (int)(((uint)*(ushort *)(puVar8 + 0x1e) +
                         ((int)((uint)*(ushort *)(puVar8 + 0x22) << 0x10) >> 0x11) + -0x1e) * 0x10000) >> 0x10,

						 1,0xffff8000);
          }

		  // The text will not show if the last byte is more than 0x00 and less than 0x7F.
		  // This is what makes the text flicker, rather than drawing solid

          cVar22 = '\x01';
          goto LAB_80053260;
        }
      }

      if (
			// numPlyrCurrGame is less than 2 (1P mode)
			((byte)PTR_DAT_8008d2ac[0x1ca8] < 2) &&

			// if want to draw speedometer
			((DAT_8008d000 & 8) != 0)
		 )
	  {
		// draw spedometer needle
        FUN_800511c0((int)psVar20[0x24],(int)psVar20[0x25],iVar19);

		// draw jump meter
        FUN_80051e24((int)psVar20[0x18],(int)psVar20[0x19],iVar19);

		// Draw Powerslide Meter
        FUN_80052250((int)psVar20[0x20],(int)psVar20[0x21],iVar19);

		// draw background of spedometer
        FUN_800516ac((int)psVar20[0x24],(int)psVar20[0x25],iVar19);
      }

      //if racer hasn't finished the race
      if ((*(uint *)(iVar19 + 0x2c8) & 0x2000000) == 0) {

		// If you're not in Battle Mode
        if ((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0)
		{
		  // Draw powerslide meter
          FUN_80052250((int)psVar20[0x20],(int)psVar20[0x21],iVar19);
        }

		// If you are not in Time Trial or Relic Race
        if ((*(uint *)PTR_DAT_8008d2ac & 0x4020000) == 0)
		{
		  // UI_DrawNumWumpa
          FUN_80050c20((int)psVar20[0x10],(int)psVar20[0x11],iVar19);
        }
      }

	  // If you're in a Relic Race
      if ((*(uint *)PTR_DAT_8008d2ac & 0x4000000) != 0)
	  {
		// UI_DrawNumTimebox
        FUN_80050e6c((int)psVar20[0x4c],(int)psVar20[0x4d],iVar19);
      }

	  // If game is not paused
      if ((*(uint *)PTR_DAT_8008d2ac & 0xf) == 0)
	  {
        if (*(int *)(iVar19 + 0x4c0) != 0)
		{
          local_60 = psVar20[0xc];
          local_5e = psVar20[0xd];

		  // if cooldown between items is over
          if (*(int *)(iVar19 + 0x4b8) == 0)
		  {
			// deduct from number of queued items to pick up
            *(int *)(iVar19 + 0x4c0) = *(int *)(iVar19 + 0x4c0) + -1;

			// Check if 231 dll is loaded
            iVar4 = FUN_800348e8(&local_60);

			// If it is loaded
            if (
					(iVar4 != 0) &&

					// If you're not in Adventure Arena
					((*(uint *)PTR_DAT_8008d2ac & 0x100000) == 0)
				)
			{
			  // RB_Player_ModifyWumpa, +1
              FUN_800abefc(iVar19,1);
            }

			// OtherFX_Play to get wumpa fruit
            FUN_80028468(0x42,1);

			// initial timer value
            iVar4 = 5;

			// if timer is already running, set new timer value
            if (*(int *)(iVar19 + 0x4c0) != 0) goto LAB_80053498;
          }
          else {
            FUN_8004ec18(&local_60,(int)*(short *)(iVar19 + 0x4bc),(int)*(short *)(iVar19 + 0x4be),
                         (int)psVar20[0xc],(int)psVar20[0xd],*(undefined4 *)(iVar19 + 0x4b8),5);

			// subtract one from timer
			iVar4 = *(int *)(iVar19 + 0x4b8) + -1;

LAB_80053498:

			// set timer value
            *(int *)(iVar19 + 0x4b8) = iVar4;
          }

		  // "wumpaposter" icon group
		  // DecalHUD_DrawPolyFT4
          FUN_80022db0(*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x2140) + 0x14),(int)local_60,
                       (int)local_5e,

					   // pointer to PrimMem struct
					   *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

					   // pointer to OT memory
					   *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

					   0,(int)psVar20[3]);
        }
        iVar16 = DAT_8008d9cc;
        iVar13 = DAT_8008d9c8;
        iVar4 = DAT_8008d9c4;
        if (*(short *)(iVar19 + 0x4c4) != 0)
		{
		  // C-Letter
          if (*(short *)(iVar19 + 0x4c6) == 0x93)
		  {
			// make visible
            *(uint *)(DAT_8008d9cc + 0x28) = *(uint *)(DAT_8008d9cc + 0x28) & 0xffffff7f;

			local_58 = psVar20[0x48];
            iVar13 = iVar16;
LAB_80053584:
            local_56 = psVar20[0x49];
            iVar4 = iVar13;
          }

		  // not C-Letter
          else
		  {
			// not T-Letter
            if (*(short *)(iVar19 + 0x4c6) != 0x94)
			{
			  // R-Letter

			  // make visible
              *(uint *)(DAT_8008d9c8 + 0x28) = *(uint *)(DAT_8008d9c8 + 0x28) & 0xffffff7f;

			  local_58 = psVar20[0x48] + 0x3a;
              goto LAB_80053584;
            }

			// T-Letter

			// make visible
            *(uint *)(DAT_8008d9c4 + 0x28) = *(uint *)(DAT_8008d9c4 + 0x28) & 0xffffff7f;

			local_58 = psVar20[0x48] + 0x1d;
            local_56 = psVar20[0x49] + -1;
          }

		  // reduce frame counter
		  *(short *)(iVar19 + 0x4c4) = *(short *)(iVar19 + 0x4c4) + -1;

		  // 4c8 and 4ca are start position of animation

		  // Interpolate from start pos to end pos
          FUN_8004ec18(&local_58,(int)*(short *)(iVar19 + 0x4c8),(int)*(short *)(iVar19 + 0x4ca),
                       (int)local_58,(int)local_56,(int)*(short *)(iVar19 + 0x4c4),10);

		  // Convert X
		  local_80 = FUN_8004caa8((int)local_58,0x200);
          *(undefined4 *)(iVar4 + 0x44) = local_80;

		  // Convert Y
		  local_80 = FUN_8004cac8((int)local_56,0x200);
          *(undefined4 *)(iVar4 + 0x48) = local_80;

		  *(undefined4 *)(iVar4 + 0x4c) = 0x200;
        }
      }

	  // If you're not in a Relic Race
      if ((*(uint *)PTR_DAT_8008d2ac & 0x4000000) == 0)
	  {
		//if racer hasn't finished the race
        if ((*(uint *)(iVar19 + 0x2c8) & 0x2000000) == 0)
		{
		  // Draw weapon and number of wumpa fruit in HUD
          FUN_800507e0((int)*psVar20,(int)psVar20[1],(int)psVar20[3],iVar19);
        }
      }

	  // if you are in relic mode
      else
	  {
		// If you smashed a time crate, this variable is set to 10
        if (*(int *)(iVar19 + 0x4b0) != 0)
		{
		  // DAT_8008d530
		  // -%ld

		  // Make string with number of time crate
		  // print "-x" where x is the amount of seconds
          sprintf(acStack80,&DAT_8008d530,*(undefined4 *)(PTR_DAT_8008d2ac + 0x1e24));

		  // 4b4 and 4b6 are WindowStartPos(x,y) from TileView, inside Driver
          FUN_8004ec18(&local_60,(int)*(short *)(iVar19 + 0x4b4),(int)*(short *)(iVar19 + 0x4b6),
                       0x14,8,*(undefined4 *)(iVar19 + 0x4b0),10);

		  // Decrease remaining number of frames for this to be on screen
          *(int *)(iVar19 + 0x4b0) = *(int *)(iVar19 + 0x4b0) + -1;

		  // Put string on the screen
		  // This happens for 10 frames
          FUN_80022878(acStack80,(int)local_60,(int)local_5e,1,1);
        }
      }

	  // if you're in battle mode, while not paused
	  // and you do not have a life limit
      if ((*(uint *)PTR_DAT_8008d2ac & 0x802f) == 0x20)
	  {
		// If the animation for adding points is over
        if (*(int *)(iVar19 + 0x4d0) == 0)
		{
		  // Delete the change that in score that was queued
          *(undefined4 *)(iVar19 + 0x4dc) = 0;
        }

		// if the animation is not done
        else
		{
          local_60 = psVar20[0x34] + 0x20;
          local_5e = psVar20[0x35];

		  // if you do not have life limit (battle)
          if ((*(uint *)PTR_DAT_8008d2ac & 0x8000) == 0)
		  {
			// This is only with point limit,
			// points can add or subtract

			// Get what should be added to your score
            iVar4 = *(int *)(iVar19 + 0x4dc);

			// Can't add 0, so it's +1 or -1

			// if you are losing points
			if (iVar4 < 1)
			{
			  // print a minus sign with your change in score

			  // -%d
              fmt = &DAT_8008d540;

			  // Get own absolute value of the change
			  if (iVar4 < 0)
			  {
				// Make a negative number positive
                iVar4 = -iVar4;
              }
            }

			else
			{
			  // print a plus sign with your change in score

			  // +%ld
              fmt = &DAT_8008d538;
            }
          }

		  // if you do have life limit (battle)
		  else
		  {
			// Life can only go down, not up

			// Get your change in score
            iVar4 = *(int *)(iVar19 + 0x4dc);

			// Print a minus sign in front of the number of lives you lose

			// -%ld
			fmt = &DAT_8008d530;
          }

		  // make the string that flies from the center of your screen to the corner
          sprintf((char *)&local_58,fmt,iVar4);

          FUN_8004ec18(&local_60,(int)*(short *)(iVar19 + 0x4d4),(int)*(short *)(iVar19 + 0x4d6),
                       (int)(((uint)(ushort)psVar20[0x34] + 0x20) * 0x10000) >> 0x10,
                       (int)(((uint)(ushort)psVar20[0x35] + 8) * 0x10000) >> 0x10,
                       *(undefined4 *)(iVar19 + 0x4d0),5);

			// subtract one from the number of frames that the animation lasts
          *(int *)(iVar19 + 0x4d0) = *(int *)(iVar19 + 0x4d0) + -1;

		  // print the string that shows the change in your score
          FUN_80022878(&local_58,(int)local_60,(int)local_5e,2,3);
        }
      }

	  // If you're not in Battle Mode
      if ((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0)
	  {
		    //if racer hasn't finished the race
        if ((*(uint *)(iVar19 + 0x2c8) & 0x2000000) == 0)
		{
		  // Draw which lap they are on (1/3, 2/3, 3/3, etc)
          FUN_80050528((int)psVar20[4],(int)psVar20[5],(int)psVar20[7],iVar19);
        }
      }

	  // if you're in battle mode
      else
	  {
		// Draw how many points or lifes the player has
        FUN_80050654((int)psVar20[0x34],(int)psVar20[0x35],iVar19);
      }

      if (
			// if you're in adventure mode or Arcade mode and
			((*(uint *)PTR_DAT_8008d2ac & 0x480000) != 0) &&

			//racer finished the race
			((*(uint *)(iVar19 + 0x2c8) & 0x2000000) != 0)
		  )
	  {
		// Player / AI structure + 0x4a shows driver index (0-7)

		// DLL 222
		// Display total time it took to finish race
        FUN_800a06f8((uint)*(byte *)(iVar19 + 0x4a),0);
      }
      uVar9 = *(uint *)PTR_DAT_8008d2ac;

	  // If you are in Relic Race, and not in battle mode,
	  // and not in time trial
      if ((uVar9 & 0x4020020) == 0)
	  {
        if (
				//if racer hasn't finished the race
				((*(uint *)(iVar19 + 0x2c8) & 0x2000000) == 0) ||
				(
					(
						// if numPlyrCurrGame is 2
						PTR_DAT_8008d2ac[0x1ca8] == '\x02' &&

						// AND

						// Not Arcade Mode (must be VS or Battle)
						((uVar9 & 0x400000) == 0)
					)
				)
			)
		{
          sVar17 = 0;
          sVar1 = psVar20[0x14];
          sVar2 = psVar20[0x15];
          uVar9 = 0;
        }
        else {

		  // if numPlyrCurrGame is less than 3
          if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 3) goto LAB_80053af4;
          sVar1 = psVar20[0x14];
          sVar2 = psVar20[0x15];
          bVar3 = (*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 1) == 0;
          sVar17 = (ushort)bVar3 << 2;
          uVar9 = ((uint)bVar3 << 0x12) >> 0x10;
        }

		// Draw the "st", "nd", "rd" suffix after "1st, 2nd, 3rd, etc"
        FUN_8005045c((int)sVar1,(int)sVar2,iVar19,uVar9);

		// if more than 2 players
        if (2 < (byte)PTR_DAT_8008d2ac[0x1ca8])
		{
		  // pointer to OT memory
          local_80 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c);

		  // position, from hud struct
          sVar1 = psVar20[8];
          sVar2 = psVar20[9];

		  // gGT->backBuffer
          iVar4 = *(int *)(PTR_DAT_8008d2ac + 0x10);

		  // Get Color Data
          ppuVar5 = &PTR_DAT_80081d70 + sVar17;

		  // Four colors, one for each corner
          local_7c = *(undefined4 *)*ppuVar5;
          local_78 = *(undefined4 *)(*ppuVar5 + 4);
          local_74 = *(undefined4 *)(*ppuVar5 + 8);
          local_70 = *(undefined4 *)(*ppuVar5 + 0xc);

		  // icon pointer
          uVar10 = *(undefined4 *)

                    (PTR_DAT_8008d2ac +

						// finishing rank of player
						((int)*(short *)(iVar19 + 0x482)

							// index of '1' icon
							+ 0x19)

								// index of icon pointer array
								* 4 + 0x1eec);
LAB_80053aec:

		  // DecalHUD_DrawPolyGT4
          FUN_80023054(
						// icon pointer
						uVar10,

						// position
						(int)sVar1,
						(int)sVar2,

						// gGT->backBuffer->primMem
						iVar4 + 0x74,

						// color data
						local_80,
						local_7c,
						local_78,
						local_74,
						local_70,

						0,0x1000);
        }
      }

	  // if you are in Relic Race, or Battle, or Time Trial
	  else
	  {
		// If you're in end-of-race and Battle
        if ((uVar9 & 0x200020) == 0x200020)
		{
          uVar9 = (uint)((*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 1) == 0);

		  // Draw the "st", "nd", "rd" suffix after "1st, 2nd, 3rd, etc"
          FUN_8005045c((int)psVar20[0x14],(int)psVar20[0x15],iVar19,uVar9 << 2);

          sVar1 = psVar20[8];
          sVar2 = psVar20[9];

		  // pointer to OT memory
          local_80 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c);

		  // gGT->backBuffer
          iVar4 = *(int *)(PTR_DAT_8008d2ac + 0x10);

		  // Get Color Data
          ppuVar5 = &PTR_DAT_80081d70 + uVar9 * 4;

		  // Four colors, one for each corner
          local_7c = *(undefined4 *)*ppuVar5;
          local_78 = *(undefined4 *)(*ppuVar5 + 4);
          local_74 = *(undefined4 *)(*ppuVar5 + 8);
          local_70 = *(undefined4 *)(*ppuVar5 + 0xc);

		  // pointer to icon
          uVar10 = *(undefined4 *)
                    (PTR_DAT_8008d2ac +

					// Battle Team of Player
                    (*(int *)(PTR_DAT_8008d2ac + *(int *)(iVar19 + 0x4e8)

					// Get finishing rank of player's team (0 for 1st place, 1 for 2nd, etc)
					* 4 + 0x1da8)

					// icon index of '1'
					+ 0x19)

					// index of icon array
					* 4 + 0x1eec);

          goto LAB_80053aec;
        }
      }
LAB_80053af4:

	  // UI_TrackerSelf
	  // draw lock-on target for driver, if
	  // a missile or warpball is chasing them
      FUN_8004fd34(iVar19);

	  // If you're in Battle
      if ((*(uint *)PTR_DAT_8008d2ac & 0x20) != 0)
	  {
		// Draw arrows over the heads of other players (not AIs)
        FUN_8004f9d8(iVar19);
      }

      if (
			(
				// if 9 < number of wumpa fruit
				// if you have 10 wumpa fruit
				('\t' < *(char *)(iVar19 + 0x30)) &&

				//if racer hasn't finished the race
				((*(uint *)(iVar19 + 0x2c8) & 0x2000000) == 0)
			) &&
			(
				// draw shining background behind wumpa fruit
				FUN_80050af8((int)psVar20[0x30],(int)psVar20[0x31],(int)psVar20[0x33],iVar19),

				// If your weapon is not "no weapon"
				*(char *)(iVar19 + 0x36) != '\x0f')
			)
	  {
		// draw shining background behind weapon
        FUN_80050af8((int)psVar20[0x2c],(int)psVar20[0x2d],(int)psVar20[0x2f],iVar19);
      }

	  // go to next player
	  // thread = thread->sibling
      iVar7 = *(int *)(iVar7 + 0x10);

	  // next HUD structure
      psVar20 = psVar20 + 0x50;

    } while (iVar7 != 0);
  }

  // (if WrongWay_bool != ???)
  if (DAT_8008d9dc != cVar22) {

    // framesDrivingSameDirection = 0
    DAT_8008d9e4 = 0;

    // WrongWay_bool = ???
    DAT_8008d9dc = cVar22;
  }

  // framesDrivingSameDirection += 1
  DAT_8008d9e4 = DAT_8008d9e4 + 1;

  // if numPlyrCurrGame is 1
  if (PTR_DAT_8008d2ac[0x1ca8] == '\x01')
  {
	// pointer to player structure
    iVar19 = *(int *)(PTR_DAT_8008d2ac + 0x24ec);

	// UI_DrawRaceClock (1P)
    FUN_8004edac(0x14,8,0,iVar19);

    iVar7 = 0;

	// If Turbo Counter Cheat is Enabled
    if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x8000000) != 0) {

	  // Get number of boosts
      sVar1 = *(short *)(iVar19 + 0x4e);

	  // If number of boosts is not zero
      if (sVar1 != 0)
	  {
		// Read pointer from address
        iVar7 = *(int *)(PTR_DAT_8008d2ac + 0x1be0);

        while ((
					// Pointer != nullptr
					iVar7 != 0 &&

					// Adds 0x30 to iVar7 pointer, gets value (new address) then adds 4.
					// If   [something]   != pointer that holds boost counter
					(*(int *)(*(int *)(iVar7 + 0x30) + 4) != iVar19)
			  ))
		{
		  // Increment pointer by 16
          iVar7 = *(int *)(iVar7 + 0x10);
        }

		// Get number of boosts
		sVar1 = *(short *)(iVar19 + 0x4e);
      }

	  // DAT_8008d2a8
	  // Position of counter
	  // 0 = offscreen
	  // 1 = just barely on screen
	  // ...
	  // 10 = clearly on screen

      if (
			// If number boosts is less than 3
			(sVar1 < 3) ||

			// If display counter is fully on screen
			(9 < DAT_8008d2a8)
		)
	  {
		// If pointer == nullptr
        if (iVar7 == 0) goto LAB_80053c98;
LAB_80053cac:

		// Set sVar1 to current display counter position
        sVar1 = DAT_8008d2a8;
        if (
			// If number boosts is less than 3
			(*(short *)(iVar19 + 0x4e) < 3) &&

			// If turbo counter is on screen
			(0 < DAT_8008d2a8)
			)
		{
LAB_80053cd4:

		  // Animate counter to move off screen
          sVar1 = DAT_8008d2a8 + -1;
        }
      }

	  // If you have more than 3 boosts, and
	  // display counter is not fully on screen
      else {

		// Animate counter to move onto screen
        sVar1 = DAT_8008d2a8 + 1;

		// If pointer == nullptr
        if (iVar7 == 0) {
LAB_80053c98:
		  // If counter is off screen
          if (DAT_8008d2a8 < 1)
		  {
			// set svar1 to display position
			// does the "else" get skipped?
			goto LAB_80053cac;
		  }

		  // If counter is on screen
		  // decrease boost counter,
		  // does the "else" get skipped?
          goto LAB_80053cd4;
        }
      }

	  // Set display position value
      DAT_8008d2a8 = sVar1;

	  // If display counter is on screen (fully or not fully)
      if ((int)DAT_8008d2a8 != 0)
	  {
		// Interpolate the turbo counter slide in from the right
        FUN_8004ecd4(&local_38,0x2c8,0x20,500,0x20,(int)DAT_8008d2a8,10);

		// The actual counter number will continue to
		// increase past 1000, but the on-screen text
		// will cap at 999

		// If you have less than 1000 boosts
        if (*(short *)(iVar19 + 0x4e) < 1000)
		{
		  // DAT_8008d54c
		  // %d

		  // build string for on-screen boost counter
          sprintf((char *)&local_60,&DAT_8008d54c);
        }

		// If you have more than 1000 boosts
        else
		{
		  // 8d544
		  // "999" <-- ascii string, not 2-byte value

		  // Cap the on-screen counter at 999
          sprintf((char *)&local_60,&DAT_8008d544);
        }

		// DAT_8008d878 + 0x92c
		// "Turbos"

		// DecalFont_GetLineWidth
        iVar7 = FUN_800224d0(*(undefined4 *)(DAT_8008d878 + 0x92c),1);

		// Draw the string
        FUN_80022878(&local_60,(int)(((uint)local_38 - iVar7) * 0x10000) >> 0x10,(int)local_36,1,
                     0x4022);

		// DAT_8008d550
		// %s

		// DAT_8008d878 + 0x92c
		// "Turbos"
        sprintf((char *)&local_60,&DAT_8008d550,*(undefined4 *)(DAT_8008d878 + 0x92c));

		// Draw the string
		FUN_80022878(&local_60,(int)(short)local_38,(int)local_36,1,0x4000);

        iVar7 = *(int *)(PTR_DAT_8008d2ac + 0x10);
        puVar11 = *(uint **)(iVar7 + 0x80);
        puVar15 = (uint *)0x0;
        if (puVar11 <= *(uint **)(iVar7 + 0x84)) {
          *(uint **)(iVar7 + 0x80) = puVar11 + 9;
          puVar15 = puVar11;
        }
        if (puVar15 == (uint *)0x0) {
          return;
        }
        puVar15[1] = 0x3800c8ff;
        puVar15[3] = 0x3800c8ff;
        puVar15[5] = 0x380000ff;
        puVar15[7] = 0x380000ff;
        *(ushort *)(puVar15 + 2) = local_38 - 0xaa;
        *(short *)((int)puVar15 + 10) = local_36 + 9;
        *(ushort *)(puVar15 + 4) = local_38 + 0x32;
        *(short *)((int)puVar15 + 0x12) = local_36 + 9;
        *(ushort *)(puVar15 + 6) = local_38 - 0x96;
        *(short *)((int)puVar15 + 0x1a) = local_36 + 0x12;
        *(ushort *)(puVar15 + 8) = local_38 + 0x32;
        puVar8 = PTR_DAT_8008d2ac;
        *(short *)((int)puVar15 + 0x22) = local_36 + 0x12;

		// pointer to OT memory
        puVar11 = *(uint **)(puVar8 + 0x147c);

        *puVar15 = *puVar11 | 0x8000000;
        *puVar11 = (uint)puVar15 & 0xffffff;
      }
    }
  }

  // if numPlyrCurrGame is not 1 (multiplayer)
  else {

	// if you have a time limit (battle)
    if ((*(uint *)PTR_DAT_8008d2ac & 0x10000) != 0)
	{
	  // draw countdown clock
      FUN_8004f894(0xd7,0x68,2);
    }
  }

  if (
		(
			(
				// if numPlyrCurrGame is 1
				(PTR_DAT_8008d2ac[0x1ca8] == '\x01') &&

				// if ptr_map is valid
				(iVar21 != 0)
			) &&
			(
				// if want to draw map, not speedometer
				(DAT_8008d000 & 8) == 0
			)
		) ||

		(
			(
				// if numPlyrCurrGame is 3
				PTR_DAT_8008d2ac[0x1ca8] == '\x03' &&

				// if ptr_map is valid
				(iVar21 != 0)
			)
		)
	)
	{
    local_30[0] = 0;

	// UI_Map_DrawDrivers
    FUN_8004dd5c(iVar21,*(undefined4 *)(PTR_DAT_8008d2ac + 0x1b2c),local_30);

	// UI_Map_DrawDrivers
    FUN_8004dd5c(iVar21,*(undefined4 *)(PTR_DAT_8008d2ac + 0x1b40),local_30);

	// Draw all ghosts on 2D map
    FUN_8004dee8(iVar21,*(undefined4 *)(PTR_DAT_8008d2ac + 0x1b54));

	// Draw all "Tracking" warpballs on 2D map
    FUN_8004dffc(iVar21,*(undefined4 *)(PTR_DAT_8008d2ac + 0x1ba4));

	// if ptr_map is valid
    if (iVar21 != 0) {

	  // If numPlyrCurrGame is 1
      if (PTR_DAT_8008d2ac[0x1ca8] == '\x01')
	  {
		// pointer to backBuffer
        iVar21 = *(int *)(PTR_DAT_8008d2ac + 0x10);

		// pointer to OT memory
		uVar10 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c);

		// posX
		local_80 = 500;

		// two halves of the map textures
        local_7c = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1ef8);
        local_78 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1efc);

		// posY
		local_74 = 0xc3;
      }

	  // if numPlyrCurrGame is not 1
      else
	  {
		// posX
        local_80 = 0x1b8;

		// if numPlyrCurrGame is not 3
        if (PTR_DAT_8008d2ac[0x1ca8] != '\x03') goto LAB_80054040;

		// This happens only if numPlyrCurrGame is 3
        // pointer to backBuffer
        iVar21 = *(int *)(PTR_DAT_8008d2ac + 0x10);

		// pointer to OT memory
        uVar10 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c);

		// two halves of the map textures
        local_7c = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1ef8);
        local_78 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1efc);

		// posY
        local_74 = 0xcd;
      }

	  // Draw the map
      FUN_8004d614(
					// top half and bottom half
					local_7c,local_78,

					// X and Y
					local_80,local_74,

					// Pointer to primary memory
					iVar21 + 0x74,

					// pointer to OT memory
					uVar10,

					// color, in this case white
                    1);
    }
  }
LAB_80054040:
  bVar3 = false;

  // loop counter
  iVar21 = 0;

  // if numPlyrCurrGame is not 0
  if (PTR_DAT_8008d2ac[0x1ca8] != '\0') {
    iVar19 = 0;
    iVar7 = 0;

	// for(int iVar21 = 0; iVar21 < numPlyrCurrGame; iVar21++)
    do
	{
	  // pointer to array of pointers for each driver (9900C, 99010, etc)
      iVar4 = *(int *)(PTR_DAT_8008d2ac + iVar7 + 0x24ec);

	  // pointer to each player's tileView buffer
      puVar8 = PTR_DAT_8008d2ac + (uint)*(byte *)(iVar4 + 0x4a) * 0x110 + 0x168;

      if (
			(
				//if racer finished the race
				((*(uint *)(iVar4 + 0x2c8) & 0x2000000) != 0) &&

				// If you're not in Arcade or Time Trial
				((*(uint *)PTR_DAT_8008d2ac & 0x420000) == 0)
			) &&
			(
				(
					// cooldown is finished
					*(short *)(PTR_DAT_8008d2ac + 0x1d36) == 0 ||

					// cooldown has not progressed far,
					// so you still need to draw "Finished" and "Loser"
					(0x96 < *(short *)(PTR_DAT_8008d2ac + 0x1d36))
				)
			)
		)
	  {

        if (
				// player structure + 0x482 is your rank in the race
				// 0 = 1st place, 1 = 2nd place, 2 = 3rd place, etc

				// Basically, out of all human players, if you did not come in last
				((int)*(short *)(iVar4 + 0x482) < (int)((uint)(byte)PTR_DAT_8008d2ac[0x1ca8] - 1)) &&

				// If you're not in Battle Mode (winner of battle mode wont be in this function)
				((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0)
			)
		{

		  // Position is the same regardless of win or lose

		  // Midpoint between tileView Start X and End X
          iVar13 = (uint)*(ushort *)(puVar8 + 0x1c) +
                   ((int)((uint)*(ushort *)(puVar8 + 0x20) << 0x10) >> 0x11);

		  // Midpoint between tileView Start Y and End Y
          iVar16 = (uint)*(ushort *)(puVar8 + 0x1e) +
                   ((int)((uint)*(ushort *)(puVar8 + 0x22) << 0x10) >> 0x11);

		  // DAT_8008d878 + 0x78
		  // FINISHED!
		  local_80 = *(undefined4 *)(DAT_8008d878 + 0x78);
        }

		// If you came in last place, or you're in battle
        else
		{
		  // Position is the same regardless of win or lose

		  // Midpoint between tileView Start X and End X
          iVar13 = (uint)*(ushort *)(puVar8 + 0x1c) +
                   ((int)((uint)*(ushort *)(puVar8 + 0x20) << 0x10) >> 0x11);

		  // Midpoint between tileView Start Y and End Y
          iVar16 = (uint)*(ushort *)(puVar8 + 0x1e) +
                   ((int)((uint)*(ushort *)(puVar8 + 0x22) << 0x10) >> 0x11);

		  // A rom hack can change 0x50c to 0x78 so that
		  // the game is more polite, like Nitro Fueled

		  // DAT_8008d878 + 0x50c
		  // LOSER!
		  local_80 = *(undefined4 *)(DAT_8008d878 + 0x50c);
        }

		// In some cases, this cuts off bits, but sometimes
		// [number] * 0x10000 >> 0x10 = [number]

		FUN_80022878(local_80,iVar13 * 0x10000 >> 0x10,(iVar16 + -0x1e) * 0x10000 >> 0x10,1,
                     0xffff8000);

        if (
				// If you press Cross or Start
				((*(uint *)(PTR_DAT_8008d2b0 + iVar19 + 0x14) & 0x1010) != 0) &&

				// If you're in End-Of-Race menu
				((*(uint *)PTR_DAT_8008d2ac & 0x200000) != 0)
			)
		{
		  // make "Finished" and "Loser" disappear, start
		  // drawing the on-screen comments
          *(undefined2 *)(PTR_DAT_8008d2ac + 0x1d36) = 0x96;
        }
      }
      //if item roll is not done
      if (*(short *)(iVar4 + 0x3a) != 0) {
        bVar3 = true;
      }
      iVar19 = iVar19 + 0x50;

	  // increment the iteration counter
      iVar21 = iVar21 + 1;

      iVar7 = iVar7 + 4;

	  // for(int iVar21 = 0; iVar21 < numPlyrCurrGame; iVar21++)
    } while (iVar21 < (int)(uint)(byte)PTR_DAT_8008d2ac[0x1ca8]);
  }
  if (
		(
			// If game is not paused
			((*(uint *)PTR_DAT_8008d2ac & 0xf) == 0) &&
      //item roll is done
			(!bVar3)
		) &&

		// If you're drawing Weapon Roulette (randomizing)
		((*(uint *)PTR_DAT_8008d2ac & 0x800000) != 0)
	  )
  {
	// OtherFX_Stop2
	// stop weapon shuffle sound
    FUN_80028844(0x5d);

	// disable the randomizing effect in the HUD
    *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac & 0xff7fffff;
  }
  return;
}


// UI_RenderFrame_AdvHub
void FUN_80054298(void)
{
  undefined *puVar1;
  undefined4 uVar2;

  // get Player 1
  uVar2 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x24ec);

								// numPlyrCurrGame - 1
  puVar1 = (&PTR_DAT_8008625c)[(uint)(byte)PTR_DAT_8008d2ac[0x1ca8] - 1];

  // UI_DrawNumRelic
  FUN_80050f18((int)(((uint)*(ushort *)(puVar1 + 0x70) + 0x10) * 0x10000) >> 0x10,
               (int)(((uint)*(ushort *)(puVar1 + 0x72) - 10) * 0x10000) >> 0x10,uVar2);

  // UI_DrawNumKey
  FUN_80050fc4((int)(((uint)*(ushort *)(puVar1 + 0x78) + 0x10) * 0x10000) >> 0x10,
               (int)(((uint)*(ushort *)(puVar1 + 0x7a) - 10) * 0x10000) >> 0x10,uVar2);

  // UI_DrawNumTrophy
  FUN_80051070((int)(((uint)*(ushort *)(puVar1 + 0x80) + 0x10) * 0x10000) >> 0x10,
               (int)(((uint)*(ushort *)(puVar1 + 0x82) - 10) * 0x10000) >> 0x10,uVar2);
  return;
}


// UI_RenderFrame_CrystChall
void FUN_8005435c(void)

{
  char cVar1;
  int iVar2;
  int iVar3;
  short *psVar4;
  int iVar5;
  short local_18;
  short local_16;

  //iVar3 = player 1 pointer struct
  iVar3 = *(int *)(PTR_DAT_8008d2ac + 0x24ec);

											// numPlyrCurrGame - 1
  psVar4 = (short *)(&PTR_DAT_8008625c)[(uint)(byte)PTR_DAT_8008d2ac[0x1ca8] - 1];

  // If game is not paused
  if ((*(uint *)PTR_DAT_8008d2ac & 0xf) == 0) {
    //execute Jump meter and landing boost processes
    FUN_80051c64(iVar3);
  }

  // draw speedometer needle
  FUN_800511c0((int)psVar4[0x24],(int)psVar4[0x25],iVar3);

  // draw jump meter
  FUN_80051e24((int)psVar4[0x18],(int)psVar4[0x19],iVar3);

  // Draw powerslide meter
  FUN_80052250((int)psVar4[0x20],(int)psVar4[0x21],iVar3);

  // draw background of speedometer
  FUN_800516ac((int)psVar4[0x24],(int)psVar4[0x25],iVar3);

  // UI_DrawNumCrystal
  FUN_8005111c((int)(((uint)(ushort)psVar4[0x44] + 0x10) * 0x10000) >> 0x10,
               (int)(((uint)(ushort)psVar4[0x45] - 0x10) * 0x10000) >> 0x10,iVar3);

  // Draw weapon and number of wumpa fruit in HUD
  FUN_800507e0((int)*psVar4,(int)psVar4[1],(int)psVar4[3],iVar3);

  // DAT_8008d878 + 0x48
  // TIME
  FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x48),0x14,8,2,0);

  // "TIME" and the actual time are printed at the same
  // X-coordinate, so we know 0x14 is the X, which only
  // leaves the next parameter as the only possible value for
  // the Y-coordinate.

  // draw countdown clock
  FUN_8004f894(0x14,0x10,1);


  // If game is paused
  if ((*(uint *)PTR_DAT_8008d2ac & 0xf) != 0) {
    return;
  }

  // If (I think) "bool visible" is false
  if (*(int *)(iVar3 + 0x4c0) == 0)
  {
	// make invisible
    *(uint *)(DAT_8008d9bc + 0x28) = *(uint *)(DAT_8008d9bc + 0x28) | 0x80;
    goto LAB_800545e8;
  }
  local_18 = psVar4[0x44];
  local_16 = psVar4[0x45];

  // make visible
  *(uint *)(DAT_8008d9bc + 0x28) = *(uint *)(DAT_8008d9bc + 0x28) & 0xffffff7f;

  // if cooldown between grabbing items is over,
  // which also means item has moved to the hud icon
  if (*(int *)(iVar3 + 0x4b8) == 0) {

	// add one to your crystal count
    cVar1 = *(char *)(iVar3 + 0x31) + '\x01';
	*(char *)(iVar3 + 0x31) = cVar1;

	// deduct from number of queued items to pick up
    *(int *)(iVar3 + 0x4c0) = *(int *)(iVar3 + 0x4c0) + -1;

	// if you have enough crystals to win the race
    if (*(int *)(PTR_DAT_8008d2ac + 0x1e28) <= (int)cVar1)
	{
	  // VehPtr_Freeze_Init
      *(undefined4 *)(iVar3 + 0x54) = 0x80062d04;

      //turn on 26th bit of Actions Flag set (means racer finished the race)
      *(uint *)(iVar3 + 0x2c8) = *(uint *)(iVar3 + 0x2c8) | 0x2000000;

	  // MainGameEnd_Initialize
      FUN_8003a3fc(0x42);
    }

	// OtherFX_Play
    FUN_80028468(0x42,1);

	// 5 frame cooldown
    iVar2 = 5;

    if (*(int *)(iVar3 + 0x4c0) != 0) goto LAB_8005456c;
  }

  // if cooldown is not done
  else
  {
	// interpolate position over course of 5 frames
    FUN_8004ec18(
					&local_18,
					(int)*(short *)(iVar3 + 0x4bc),
					(int)*(short *)(iVar3 + 0x4be),
					(int)psVar4[0x44],
					(int)psVar4[0x45],

					// cooldown (0-5)
					*(undefined4 *)(iVar3 + 0x4b8),

					// 5 frames total
					5
				);

	// reduce cooldown between getting each wumpa (or crystal)
	iVar2 = *(int *)(iVar3 + 0x4b8) + -1;

LAB_8005456c:

	// set new cooldown
    *(int *)(iVar3 + 0x4b8) = iVar2;
  }
  iVar2 = DAT_8008d9bc;
  iVar5 = ((int)local_18 + -0x100) * (int)psVar4[0x46];
  if (iVar5 < 0) {
    iVar5 = iVar5 + 0xff;
  }
  *(int *)(DAT_8008d9bc + 0x44) = iVar5 >> 8;
  iVar5 = ((int)local_16 + -0x6c) * (int)psVar4[0x46];
  if (iVar5 < 0) {
    iVar5 = iVar5 + 0xff;
  }
  *(int *)(iVar2 + 0x48) = iVar5 >> 8;
  *(int *)(iVar2 + 0x4c) = (int)psVar4[0x46];
LAB_800545e8:
  if (
		(
			// If game is not paused
			((*(uint *)PTR_DAT_8008d2ac & 0xf) == 0) &&

			// item roll is done
			(*(short *)(iVar3 + 0x3a) == 0)
		) &&

		// If you're drawing Weapon Roulette (randomizing)
		((*(uint *)PTR_DAT_8008d2ac & 0x800000) != 0)
	  )
  {
	// OtherFX_Stop2
	// stop weapon shuffle sound
    FUN_80028844(0x5d);

	// Disable the randomizing effect in the HUD
    *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac & 0xff7fffff;
  }
  return;
}

// UI_RenderFrame_Wumpa3D_2P3P4P
// param1 is gGT
void FUN_8005465c(int param_1)

{
  char cVar1;
  ushort uVar2;
  undefined *puVar3;
  undefined uVar4;
  undefined *puVar5;
  int iVar6;
  void *p;
  short sVar7;
  short sVar8;
  undefined4 *puVar9;
  undefined4 local_28;
  undefined4 local_24;
  undefined4 local_20;
  undefined4 local_1c;

  local_28 = DAT_8008d554;
  local_24 = DAT_8008d558;
  local_20 = DAT_8008d55c;
  local_1c = DAT_8008d560;
  puVar9 = &local_28;

  // if numPlyrCurrGame is more than 2
  if (2 < (byte)PTR_DAT_8008d2ac[0x1ca8]) {
    puVar9 = &local_20;
  }

  if (DAT_8008d4b4 != 0)
  {
	// called once to draw all wumpas

	// TileView_SetDrawEnv_DecalMP
    FUN_80042974(
					*(undefined4 *)(DAT_8008d4b4 + 0xf8),

					// gGT->backBuffer
					*(undefined4 *)(PTR_DAT_8008d2ac + 0x10),

					// RECT
					puVar9,

					// ofsX
					((int)(short)*(ushort *)puVar9 +
                        ((int)((uint)*(ushort *)(puVar9 + 1) << 0x10) >> 0x11) + -0x100) * 0x10000
                        >> 0x10,

					// ofsY
					((int)(short)*(ushort *)((int)puVar9 + 2) +
					((int)((uint)*(ushort *)((int)puVar9 + 6) << 0x10) >> 0x11) + -0x6c) * 0x10000 >> 0x10,

					0,0,0,0,1
				);

    iVar6 = *(int *)(DAT_8008d4b4 + 0xf4);

    if ((iVar6 != 0) && (*(int *)(DAT_8008d4b4 + 0xf8) != 0))
	{
	  // CTR_CycleTex_2p3p4pWumpaHUD
      FUN_80021b94(*(int *)(param_1 + 0x25c) + 0xffc,iVar6,
                   (*(int *)(DAT_8008d4b4 + 0xf8) - iVar6 >> 2) + 1);
    }
  }

  // if there is more than 1 screen
  if (1 < *(byte *)(param_1 + 0x1ca8))
  {
	// get HUD position variables [numPlyrCurrGame - 1]
    puVar5 = (&PTR_DAT_8008625c)[(uint)*(byte *)(param_1 + 0x1ca8) - 1];

    iVar6 = 0;

	// if numPlyrCurrGame is not zero
	if (*(byte *)(param_1 + 0x1ca8) != 0)
	{
	  // for iVar6 = 0; iVar6 < numPlyrCurrGame; iVar6++
      do {
        if (
			//if racer hasn't finished the race
			((*(uint *)(*(int *)(PTR_DAT_8008d2ac + iVar6 * 4 + 0x24ec) + 0x2c8) & 0x2000000) == 0) &&


			// If you're not in End-Of-Race menu
			((*(uint *)PTR_DAT_8008d2ac & 0x200000) == 0)
			)
		{
          sVar7 = (
						// wumpaHudPosX
						*(short *)(puVar5 + 0x18) +

						// TileView rect.x
						*(short *)(DAT_8008d4b4 + 0x1c)
				  ) -
                  ((short)*(ushort *)(puVar9 + 1) >> 1);

          sVar8 = (
						// wumpaHudPosY
						*(short *)(puVar5 + 0x1a) +

						// TileView rect.y
						*(short *)(DAT_8008d4b4 + 0x1e)
				  ) -
                  ((short)*(ushort *)((int)puVar9 + 6) >> 1);

		  // backBuffer->primMem.curr
          p = *(void **)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80);

		  // psyq macro setPolyFT4
          // sets len and code
		  *(undefined *)((int)p + 3) = 9;
          *(undefined *)((int)p + 7) = 0x2c;
		  
		  // RGB
          *(undefined *)((int)p + 6) = 0x80;
          *(undefined *)((int)p + 5) = 0x80;
          *(undefined *)((int)p + 4) = 0x80;
		  
		  // xy0
          *(short *)((int)p + 8) = sVar7;
          *(short *)((int)p + 10) = sVar8;
		  
          uVar2 = *(ushort *)(puVar9 + 1);
		  
		  // xy1, xy2, xy3
          *(short *)((int)p + 0x12) = sVar8;
          *(short *)((int)p + 0x18) = sVar7;
          *(short *)((int)p + 0x10) = uVar2 + sVar7;
          *(short *)((int)p + 0x1a) = *(ushort *)((int)puVar9 + 6) + sVar8;
          *(short *)((int)p + 0x20) = *(ushort *)(puVar9 + 1) + sVar7;
          *(short *)((int)p + 0x22) = *(ushort *)((int)puVar9 + 6) + sVar8;
		  
		  // uv0
          *(byte *)((int)p + 0xc) = *(byte *)puVar9 & 0x3f;
          *(byte *)((int)p + 0xd) = *(byte *)((int)puVar9 + 2);
		  
          cVar1 = *(char *)((int)p + 0xd);
		  
		  // uv1
          *(char *)((int)p + 0x14) = *(char *)((int)p + 0xc) + *(byte *)(puVar9 + 1);
          *(char *)((int)p + 0x15) = cVar1;
          
		  // uv2
		  *(undefined *)((int)p + 0x1c) = *(undefined *)((int)p + 0xc);
		  *(char *)((int)p + 0x1d) = cVar1 + *(byte *)((int)puVar9 + 6);
          
		  // uv3
		  *(char *)((int)p + 0x24) = *(char *)((int)p + 0xc) + *(byte *)(puVar9 + 1);
          *(char *)((int)p + 0x25) = cVar1 + *(byte *)((int)puVar9 + 6);
          
		  puVar3 = PTR_DAT_8008d2ac;
		  
		  // tpage
          *(ushort *)((int)p + 0x16) =
               (short)(*(ushort *)((int)puVar9 + 2) & 0x100) >> 4 |
               (ushort)(((uint)*(ushort *)puVar9 & 0x3ff) >> 6) | 0x100 |
               (ushort)(((uint)*(ushort *)((int)puVar9 + 2) & 0x200) << 2);

		  // wumpaShineResult
          uVar4 = (undefined)DAT_8008d994;

		  // if 9 < number of wumpa
		  // if wumpa is 10
          if ('\t' < *(char *)(*(int *)(puVar3 + iVar6 * 4 + 0x24ec) + 0x30))
		  {
			// wumpaShineResult
            *(undefined *)((int)p + 6) = (undefined)DAT_8008d994;
            *(undefined *)((int)p + 5) = uVar4;
            *(undefined *)((int)p + 4) = uVar4;
          }

		  // backBuffer->primMem.curr
		  // move pointer after writing polygons
          *(int *)(*(int *)(param_1 + 0x10) + 0x80) =
          *(int *)(*(int *)(param_1 + 0x10) + 0x80) + 0x28;

		  // pointer to OT memory, and pointer to primitive
		  AddPrim(*(void **)(param_1 + 0x147c),p);
        }
        iVar6 = iVar6 + 1;
        puVar5 = puVar5 + 0xa0;
      } while (iVar6 < (int)(uint)*(byte *)(param_1 + 0x1ca8));
    }
  }
  return;
}

// UI_VsQuipReadDriver
// param_1 driver object,
// param_2 offset,
// param_3 size
uint FUN_80054a08(int param_1,int param_2,int param_3)

{
  // if size is 2 bytes
  if (param_3 == 2)
  {
	// return a short
    return (int)*(short *)(param_1 + param_2);
  }

  // if size is 1 byte
  if (param_3 < 3) {
    if (param_3 == 1)
	{
	  // return a char
      return (uint)*(byte *)(param_1 + param_2);
    }
  }

  // if size is 4 bytes
  else {
    if (param_3 == 4)
	{
	  // return an int
      return *(undefined4 *)(param_1 + param_2);
    }

	// Sep3
	// printf("**error** invalid quip size %ld\n");

	// dictionary defines "quip" as "a witty remark"
  }
  return 0;
}


// UI_VsQuipAssign
// param_1 - driver object
void FUN_80054a78(int param_1,uint *param_2,int param_3,undefined4 param_4)

{
  undefined *puVar1;
  undefined2 uVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;

  if (
		// if driver object exists
		(param_1 != 0) &&

		(((*(ushort *)((int)param_2 + 10) & 4) == 0 || (param_1 == param_3)))
	  )
  {
    uVar5 = *param_2;
    uVar4 = uVar5 + 8;
    if (uVar4 < param_2[1]) {
      do {
        if (
				(*(int *)(uVar5 + 4) < *(int *)(uVar4 + 4)) ||
				(
					(
						*(int *)(uVar4 + 4) == *(int *)(uVar5 + 4) &&
						(
							// random number
							iVar3 = FUN_8003ea28(),
							(iVar3 >> 3 & 0xffU) < 0x40
						)
					)
				)
			)
		{
          uVar5 = uVar4;
        }
        uVar4 = uVar4 + 8;
      } while (uVar4 < param_2[1]);
    }
    if (*(int *)(param_1 + 0x56c) != 0) {
      iVar3 = *(int *)(*(int *)(param_1 + 0x56c) + 4);
      if (*(int *)(uVar5 + 4) <= iVar3) {
        if (*(int *)(uVar5 + 4) != iVar3) {
          return;
        }

		// Get random number
        iVar3 = FUN_8003ea28();

        if (0x3f < (iVar3 >> 3 & 0xffU)) {
          return;
        }
      }
      iVar3 = *(int *)(param_1 + 0x56c);
      if ((iVar3 != 0) && (*(int *)(iVar3 + 4) < 0)) {
        *(int *)(iVar3 + 4) = -*(int *)(iVar3 + 4);
      }
    }
    if (0 < *(int *)(uVar5 + 4)) {
      *(int *)(uVar5 + 4) = -*(int *)(uVar5 + 4);
    }
    puVar1 = PTR_DAT_8008d2ac;
    *(uint *)(param_1 + 0x56c) = uVar5;
    *(undefined4 *)(param_1 + 0x570) = param_4;

	// 150 frames (5 seconds) for Battle
    uVar2 = 0x96;

	// if not battle mode (VS)
    if ((*(uint *)puVar1 & 0x20) == 0)
	{
	  // 300 frames (10 seconds) for VS
      uVar2 = 300;
    }

	// set cooldown after end of VS race
	*(undefined2 *)(puVar1 + 0x1d36) = uVar2;
  }
  return;
}


// UI_VsQuipAssignAll
void FUN_80054bfc(void)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  int *piVar7;
  int iVar8;
  uint uVar9;
  undefined *puVar10;
  undefined **ppuVar11;
  int iVar12;
  undefined **ppuVar13;
  int iVar14;
  int iVar15;
  int iVar16;
  ushort *puVar17;
  uint uVar18;
  int iVar19;
  undefined **ppuVar20;
  int aiStack80 [8];
  undefined **local_30;
  int local_2c;

  local_2c = 0;

  // numPlyrCurrGame is more than 1
  if (1 < (byte)PTR_DAT_8008d2ac[0x1ca8]) {

	// If you're not in Battle Mode
    if ((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0)
	{
	  // pointer to array of LNG index for end-of-race comment
      ppuVar13 = (undefined **)0x8008664c; // &DAT_800864dc
      local_30 = (undefined **)&DAT_800869f4;
    }

	// if in battle
    else
	{
	  // pointer to array of LNG index for end-of-race comment
      ppuVar13 = &PTR_DAT_80086c0c; // 80086b64
      local_30 = (undefined **)&DAT_80086d2c;
    }

	// loop through all comments, and apply some 
	// kind of patch to each
    if (ppuVar13 < local_30) {
      ppuVar11 = ppuVar13 + 1;
      ppuVar20 = ppuVar13;
      do {
        puVar10 = *ppuVar20;
        if (puVar10 < *ppuVar11) {
          piVar7 = (int *)(puVar10 + 4);
          do {
            puVar10 = puVar10 + 8;
            *piVar7 = *piVar7 + 1;
            piVar7 = piVar7 + 2;
          } while (puVar10 < *ppuVar11);
        }
		
		// skip 0x18 bytes
        ppuVar20 = ppuVar20 + 6;
        ppuVar11 = ppuVar11 + 6;
		
      } while (ppuVar20 < local_30);
    }
    puVar10 = PTR_DAT_8008d2ac;

	// pointer to first Player thread
    iVar19 = *(int *)(PTR_DAT_8008d2ac + 0x1b2c);

    iVar2 = 0;
    iVar3 = 0;
    iVar4 = 0;

	// loop through all Player threads
    while (iVar19 != 0)
	{
	  // get Driver object from thread
      iVar14 = *(int *)(iVar19 + 0x30);

      *(undefined4 *)(iVar14 + 0x56c) = 0;

	  // If you dont have a point limit (battle)
      if ((*(uint *)puVar10 & 0x4000) == 0)
	  {
		// get number of lives in life limit (3,6,9)
        iVar8 = *(int *)(iVar14 + 0x4e4);
      }

	  // if you have point limit in (battle)
      else
	  {
		// Get number of points on this driver's team
        iVar8 = *(int *)(puVar10 + *(int *)(iVar14 + 0x4e8) * 4 + 0x1d90);
      }

      aiStack80[*(byte *)(iVar14 + 0x4a)] = iVar8;
      iVar16 = iVar4;
      if ((iVar8 <= iVar4) &&
         (bVar1 = iVar8 == iVar4, iVar8 = iVar4, iVar14 = iVar3, iVar16 = iVar2, bVar1)) {
        iVar14 = 0;
        iVar16 = iVar4;
      }

	  // thread = thread -> sibling
	  iVar19 = *(int *)(iVar19 + 0x10);

      iVar2 = iVar16;
      iVar3 = iVar14;
      iVar4 = iVar8;
    }
	
	// offset 0xA
    puVar17 = (ushort *)((int)ppuVar13 + 10);
	
    if (ppuVar13 < local_30) {
      do {
        uVar18 = 0;
        if (puVar17[-1] == 5) {
          uVar18 = 0x7fffffff;
        }
		
		// short*
		// 0xA + 1*2 = 0xC
        iVar19 = *(int *)(puVar17 + 1);
		
        if ((*puVar17 & 1) != 0)
		{
		  // get number of laps in the race
          iVar4 = (int)(char)PTR_DAT_8008d2ac[0x1d33];

		  // get absolute value
          if (iVar4 < 0) {
            iVar4 = -iVar4;
          }

          iVar19 = iVar19 * iVar4;
        }

		// pointer to first Player thread
        iVar14 = *(int *)(PTR_DAT_8008d2ac + 0x1b2c);

        iVar4 = 0;

		// loop through all Player threads
        while (iVar14 != 0)
		{
		  // get driver object from thread
          iVar15 = *(int *)(iVar14 + 0x30);

          iVar8 = iVar4;
          iVar16 = iVar19;
          uVar9 = uVar18;
		  
		  // short*
		  // 0xA + -1*2 = 0x8
          switch(puVar17[-1]) {
          case 0:
		  
		    // UI_VsQuipReadDriver
            iVar6 = FUN_80054a08(iVar15,
								*(undefined4 *)(puVar17 + 3), // 0xA + 3*2 = 0x10 (driverOffset)
								*(undefined4 *)(puVar17 + 5)  // 0xA + 5*2 = 0x14
								);
            iVar8 = iVar15;
            iVar16 = iVar6;
            if (iVar6 <= iVar19) {
LAB_80054f44:
              iVar8 = iVar4;
              iVar16 = iVar19;
              if (iVar6 == iVar19) {
                iVar8 = 0;
              }
            }
            break;
          case 1:
			// UI_VsQuipReadDriver
            iVar6 = FUN_80054a08(iVar15,
								*(undefined4 *)(puVar17 + 3), // 0xA + 3*2 = 0x10 (driverOffset)
								*(undefined4 *)(puVar17 + 5)  // 0xA + 5*2 = 0x14
								);
								
            if ((-1 < iVar6) && (iVar8 = iVar15, iVar16 = iVar6, iVar19 <= iVar6))
            goto LAB_80054f44;
            break;
          case 3:

			// loop counter
            iVar12 = 0;

            iVar6 = iVar15;

			// for iVar12 = 0; iVar12 < 8; iVar12++
			do {
              uVar9 = (uint)*(byte *)(iVar6 + 0x560);
              if (iVar19 < (int)(uVar9 - uVar18)) {
                local_2c = iVar12;
                iVar4 = iVar15;
                uVar18 = uVar9;
              }
              else {
                if ((-iVar19 < (int)(uVar9 - uVar18)) && (iVar4 = 0, (int)uVar18 < (int)uVar9)) {
                  uVar18 = uVar9;
                }
              }

			  // increment loop counter
              iVar12 = iVar12 + 1;

              iVar6 = iVar15 + iVar12;
              iVar8 = iVar4;
              uVar9 = uVar18;
            } while (iVar12 < 8);
            break;
          case 4:
			// UI_VsQuipReadDriver
            uVar5 = FUN_80054a08(iVar15,
								*(undefined4 *)(puVar17 + 3), // 0xA + 3*2 = 0x10 (driverOffset)
								*(undefined4 *)(puVar17 + 5)  // 0xA + 5*2 = 0x14
								);
            iVar8 = iVar15;
            uVar9 = uVar5;
            if (((int)(uVar5 - uVar18) <= iVar19) &&
               (bVar1 = (int)uVar18 < (int)uVar5, iVar8 = iVar4, uVar9 = uVar18,
               -iVar19 < (int)(uVar5 - uVar18))) {
LAB_80054fd0:
              iVar8 = 0;
              uVar9 = uVar18;
              if (bVar1) {
                uVar9 = uVar5;
              }
            }
            break;
          case 5:
			// UI_VsQuipReadDriver
            uVar5 = FUN_80054a08(iVar15,
								*(undefined4 *)(puVar17 + 3), // 0xA + 3*2 = 0x10 (driverOffset)
								*(undefined4 *)(puVar17 + 5)  // 0xA + 5*2 = 0x14
								);
								
            if (((-1 < (int)uVar5) &&
                (iVar8 = iVar15, uVar9 = uVar5, (int)(uVar18 - uVar5) <= iVar19)) &&
               (bVar1 = (int)uVar5 < (int)uVar18, iVar8 = iVar4, uVar9 = uVar18,
               -iVar19 < (int)(uVar18 - uVar5))) goto LAB_80054fd0;
            break;
          case 6:
			// UI_VsQuipReadDriver
            uVar18 = FUN_80054a08(iVar15,
								*(undefined4 *)(puVar17 + 3), // 0xA + 3*2 = 0x10 (driverOffset)
								*(undefined4 *)(puVar17 + 5)  // 0xA + 5*2 = 0x14
								);
								
            if (uVar18 == (uint)*(byte *)(iVar15 + 0x559)) {
              iVar8 = iVar15;
            }
            break;
          case 7:
            if (iVar19 == 0) {
              if (iVar15 == iVar3) {
                iVar8 = iVar3;
              }
            }
            else {
              if (((iVar19 == 1) && (iVar2 != 0)) && (aiStack80[*(byte *)(iVar15 + 0x4a)] == iVar2))
              {
                iVar8 = iVar15;
              }
            }
            break;
          case 8:
			// UI_VsQuipReadDriver
            iVar4 = FUN_80054a08(iVar15,
								*(undefined4 *)(puVar17 + 3), // 0xA + 3*2 = 0x10 (driverOffset)
								*(undefined4 *)(puVar17 + 5)  // 0xA + 5*2 = 0x14
								);
            if (iVar4 == iVar19) {
              iVar8 = iVar15;
            }
            break;
          case 9:
            if (*(int *)(iVar15 + 0x56c) == 0)
			{
			  // UI_VsQuipAssign
              FUN_80054a78(iVar15,ppuVar13,iVar3,0);
            }
          }
          if ((iVar8 != 0) && ((*puVar17 & 0xc) != 0))
		  {
			// UI_VsQuipAssign
            FUN_80054a78(iVar8,ppuVar13,iVar3,local_2c);
          }

		  // thread = thread -> sibling
          iVar14 = *(int *)(iVar14 + 0x10);

          iVar4 = iVar8;
          iVar19 = iVar16;
          uVar18 = uVar9;
        }

		// UI_VsQuipAssign
        FUN_80054a78(iVar4,ppuVar13,iVar3,local_2c);

		// jump 0x18 bytes
        ppuVar13 = ppuVar13 + 6;
        puVar17 = puVar17 + 0xc;
		
      } while (ppuVar13 < local_30);
    }
  }
  return;
}


// UI_VsQuipDrawAll
void FUN_800550f4(void)

{
  ushort uVar1;
  ushort uVar2;
  ushort uVar3;
  ushort uVar4;
  ushort *puVar5;
  char *pcVar6;
  int iVar7;
  ushort *puVar8;
  int iVar9;
  short sVar10;
  char acStack160 [128];

  // pointer to first Player thread
  iVar9 = *(int *)(PTR_DAT_8008d2ac + 0x1b2c);

  sVar10 = 0;

  // if thread exists
  if (iVar9 != 0)
  {
    puVar8 = (ushort *)(PTR_DAT_8008d2ac + 0x18a);

	// loop through all threads
    do
	{
	  // Dimensions of each player's tileView
	  // PosX, PosY, Width, Height
	  // (rewritten order for simplicity)
      uVar1 = puVar8[-3];
      uVar2 = puVar8[-2];
      uVar3 = puVar8[-1];
      uVar4 = *puVar8;

      iVar7 = *(int *)(iVar9 + 0x30);
      if ((((&DAT_8008d564)[sVar10] & 2) == 0) &&


         (
			// Player struct's Offset 0x56c holds which LNG string
			// will be this player's End-Of-Race comment,
			// 0 - PAUSED, 1 - RESTART, 21A - The Dominator, etc
			puVar5 = *(ushort **)(iVar7 + 0x56c),

			// make sure the string index is valid
			puVar5 != (ushort *)0x0
		 )
		)
	  {
        *(undefined4 *)(puVar5 + 2) = 0;

		// if this is only one comment
        if ((puVar5[1] & 1) == 0)
		{
		  // Print the string as a comment
          pcVar6 = *(char **)((uint)*puVar5 * 4 + DAT_8008d878);
        }

		// if the comment is conjoined
        else
		{
		  // Add two strings together
          sprintf(
			acStack160,

			// original end-of-race comment
			*(char **)((uint)*puVar5 * 4 + DAT_8008d878),

			// second part of comment,
			// lngIndex of driver,
			// for stuff like "hit by Crash Bandicoot" or something
                  *(undefined4 *)
                   ((int)*(short *)(&DAT_80086d88 + *(int *)(iVar7 + 0x570) * 0x10) * 4 +
                   DAT_8008d878));

		  // Overwrite the stack pointer to print
          pcVar6 = acStack160;
        }

		// Draw the string with a box around it
        FUN_8004568c(
					// The string to print
					pcVar6,

					// X-position of tileView, plus 50% of width
					((int)(short)uVar1 + ((int)((uint)uVar3 << 0x10) >> 0x11)) * 0x10000 >> 0x10,

					// Y-position of tileView, plus 12% of height
                    ((int)(short)uVar2 + ((int)((uint)uVar4 << 0x10) >> 0x13)) * 0x10000 >> 0x10,

					0,3,0xffff8000,4);
      }

	  // increment loop counter
      sVar10 = sVar10 + 1;

	  // next player thread
      iVar9 = *(int *)(iVar9 + 0x10);

	  // Go to next tileView
      puVar8 = puVar8 + 0x88;

    } while (iVar9 != 0);
  }
  return;
}


// UI_VsWaitForPressX
void FUN_800552a4(void)

{
  byte bVar1;
  short sVar2;
  short sVar3;
  short sVar4;
  short sVar5;
  undefined4 *puVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  byte *pbVar10;
  int iVar11;
  undefined *puVar12;
  int iVar13;
  int iVar14;
  int local_78;
  undefined4 local_70;
  undefined4 local_6c;
  undefined4 local_68;
  undefined4 local_64;
  undefined4 local_60;
  undefined4 local_5c;
  char acStack88 [8];
  short local_50;
  short local_4e;
  undefined2 local_48;
  undefined2 local_46;
  undefined2 local_44;
  undefined2 local_42;
  short local_40;
  byte *local_38;
  char *local_34;
  int local_30;

  local_40 = 0;
  local_70 = 0x350055;
  local_6c = 0x3500aa;
  local_68 = 0x430055;
  local_64 = 0x4300aa;
  local_60 = DAT_8008d568;
  local_5c = DAT_8008d56c;

  // loop counter
  iVar13 = 0;

  // if numPlyrCurrGame is not 0
  if (PTR_DAT_8008d2ac[0x1ca8] != '\0')
  {
    local_34 = acStack88;
    iVar14 = 0;
    local_30 = 0;
    iVar7 = 0;

	// for(int iVar13 = 0; iVar13 < numPlyrCurrGame; iVar13++)
    do
	{
	  // flags, for which players have pressed X to continue
      pbVar10 = &DAT_8008d564 + iVar13;

	  // Pointer to each tileView struct ???
	  puVar12 = PTR_DAT_8008d2ac + (iVar7 + iVar13) * 0x10 + 0x168;

	  // Pointer to each player (9900C, 99010, etc)
      iVar7 = *(int *)(PTR_DAT_8008d2ac + local_30 + 0x24ec);

	  // If Player has not pressed X to continue
	  // Draw comment, and battle stats
      if ((*pbVar10 & 2) == 0)
	  {
		// If you hit left or right on the D-Pad, or Analog Stick
        if (((*(uint *)(PTR_DAT_8008d2b0 + iVar14 + 0x14) & 4) != 0) ||
           ((*(uint *)(PTR_DAT_8008d2b0 + iVar14 + 0x14) & 8) != 0))
		{
		  // Flip the first bit
		  // If it is 1, make it 0
		  // If it is 0, make it 1
          *pbVar10 = *pbVar10 ^ 1;
        }

		// If player hit X (to blacken their screen to proceed to next menu)
        if (((*(uint *)(PTR_DAT_8008d2b0 + iVar14 + 0x14) & 0x1010) != 0) &&

			// if cooldown has gone down a bit,
			// This way you can't press X immediately
			// after seeing on-screen comments
           (*(short *)(PTR_DAT_8008d2ac + 0x1d36) < 0x78))
		{
		  // Flip the 2nd bit, change 0 to 2
          (&DAT_8008d564)[iVar13] = (&DAT_8008d564)[iVar13] ^ 2;
        }

		// If you want to see YOU HIT (assumed by default)
		// set string to YOU HIT
        iVar9 = 0x157;

		// If you want to see HIT YOU
        if (((&DAT_8008d564)[iVar13] & 1) != 0)
		{
		  // if you want to see who hit you
          iVar9 = 0x158;
        }

		// If you're in Battle Mode
        if ((*(uint *)PTR_DAT_8008d2ac & 0x20) != 0)
		{
          local_78 = -0x7ffc;

		  // ivar9 0x157: YOU HIT
		  // ivar9 0x158: HIT YOU
          FUN_80022878(*(undefined4 *)(iVar9 * 4 + DAT_8008d878),

						// Midpoint between tileView Start X and End X
                       (int)(((uint)*(ushort *)(puVar12 + 0x1c) +
                       ((int)((uint)*(ushort *)(puVar12 + 0x20) << 0x10) >> 0x11)) * 0x10000) >> 0x10,

					   // Start Y + 0x23
					   (int)(((uint)*(ushort *)(puVar12 + 0x1e) + 0x23) * 0x10000) >> 0x10,

					   3,0xffff8004);

		  // loop counter
		  iVar9 = 0;

		  // if numPlyrCurrGame is not zero
          if (PTR_DAT_8008d2ac[0x1ca8] != '\0')
		  {
			// same as checking HIT YOU vs YOU HIT before
            local_38 = &DAT_8008d564 + iVar13;

            iVar11 = 1;

			// If you have 3 screens, you need 9 prints
			// If you have 4 screens, you need 16 prints

			// for (a in players)
				// for (b in players)
					// print a hit b
					// print b hit a

			// for(int iVar9 = 0; iVar9 < numPlyrCurrGame; iVar9++)
            do
			{
			  // Get Battle Team of player
              sVar4 = *(short *)(*(int *)(PTR_DAT_8008d2ac + iVar9 * 4 + 0x24ec) + 0x4e8);

			  // if not two screens
			  // use flags from registers
              puVar6 = &local_70;

			  // If numPlyrCurrGame is 2
              if (PTR_DAT_8008d2ac[0x1ca8] == '\x02')
			  {
				// use flags from ram, loaded to stack
                puVar6 = &local_60;
              }

              sVar5 = *(short *)(puVar6 + iVar9);
              local_50 = sVar5;
              local_4e = *(short *)((int)(puVar6 + iVar9) + 2);
              sVar2 = *(short *)(puVar12 + 0x1c);
              sVar3 = *(short *)(puVar12 + 0x1e);
              iVar8 = (int)local_4e;

			  // YOU HIT
			  // iVar13 hit iVar9
              if ((*local_38 & 1) == 0)
			  {
                bVar1 = *(byte *)(iVar7 + 0x50c);
              }

			  // HIT YOU
			  // iVar9 hit iVar13
              else
			  {
                bVar1 = *(byte *)(iVar7 + 0x560);
              }

              sprintf(acStack88,"p%d:%2.02d",

				// basically, iVar11 = iVar9 + 1
				// which is (1, 2, 3, 4)
				iVar11,

				// Amount of times this player hit you,
				// or amount of times you hit them
				(uint)bVar1,

				local_78);

              local_78 = (int)(short)(sVar4 + 0x18U | 0x8000);

              FUN_80022878(acStack88,

						   // midpoint between Start X and Size X
						   ((int)sVar2 + (int)sVar5) * 0x10000 >> 0x10,

						   // midpoint between Start Y and Size Y
                           (sVar3 + iVar8) * 0x10000 >> 0x10,

						   2);

              iVar7 = iVar7 + 1;

			  // loop counter
			  iVar9 = iVar9 + 1;

              iVar11 = iVar11 + 1;

								// numPlyrCurrGame
            } while (iVar9 < (int)(uint)(byte)PTR_DAT_8008d2ac[0x1ca8]);
          }
        }
      }

	  // If Player has pressed X to continue
      else
	  {
		// Stop drawing comment + battle stats

        memset(local_34,0,4);

		// rectangle parameters, screen dimensions
        local_48 = *(undefined2 *)(puVar12 + 0x1c);
        local_46 = *(undefined2 *)(puVar12 + 0x1e);
        local_44 = *(undefined2 *)(puVar12 + 0x20);
        local_42 = *(undefined2 *)(puVar12 + 0x22);

		// CTR_Box_DrawClearBox
        FUN_8002177c(&local_48,local_34,0,

						*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0),

						// pointer to PrimMem struct
						*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

		// If player presses Square, to go back to view End-Of-Race comment,
		// or in Battle mode this includes "Hit You / You Hit" screen
        if ((*(uint *)(PTR_DAT_8008d2b0 + iVar14 + 0x14) & 0x8000) != 0)
		{
		  // Flip 2nd bit back from 1 to 0
          *pbVar10 = *pbVar10 ^ 2;
        }

		// increment counter of players ready to continue
        local_40 = local_40 + 1;
      }

      iVar14 = iVar14 + 0x50;
      local_30 = local_30 + 4;

	  // loop counter
      iVar13 = iVar13 + 1;

      iVar7 = iVar13 * 0x10;

	  // for(int iVar13 = 0; iVar13 < numPlyrCurrGame; iVar13++)
	} while (iVar13 < (int)(uint)(byte)PTR_DAT_8008d2ac[0x1ca8]);
  }
  iVar13 = 3;

  // if number players ready to continue is equal to numPlyrCurrGame
  // Basically: If all players press X to continue
  if ((int)local_40 == (uint)(byte)PTR_DAT_8008d2ac[0x1ca8])
  {
	// Stop drawing 4 screens, draw 1 screen and options
    *(undefined2 *)(PTR_DAT_8008d2ac + 0x1d36) = 0;
    puVar12 = &DAT_8008d567;
    do {
      *puVar12 = 0;
      iVar13 = iVar13 + -1;
      puVar12 = puVar12 + -1;
    } while (-1 < iVar13);
  }
  return;
}


// UI_RaceEnd_GetDriverClock
void FUN_8005572c(int param_1)

{
  byte bVar1;
  int iVar2;
  int iVar3;
  int iVar4;

  // If race timer is not supposed to stop for this racer
  if ((*(uint *)(param_1 + 0x2c8) & 0x40000) == 0)
  {
	// time elapsed in race
    iVar3 = *(int *)(param_1 + 0x514);

    // Stop time for this racer
    *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) | 0x40000;

	if (iVar3 != 0) 
	{
	  // get average speed over time (assumed)
	  
      iVar2 = *(int *)(param_1 + 0x518) * 100;
	  
      if (iVar3 == 0) { trap(0x1c00); }
      if ((iVar3 == -1) && (iVar2 == -0x80000000)) { trap(0x1800); }
      
	  *(int *)(param_1 + 0x518) = iVar2 / iVar3;
    }
	
	// if missiles launched is less than 4
    if (*(byte *)(param_1 + 0x55c) < 4) 
	{
      *(undefined4 *)(param_1 + 0x574) = 0xffffffff;
    }
    
	// if missiles launched is more than 4
	else 
	{
      // number of missiles launched
	  bVar1 = *(byte *)(param_1 + 0x55c);
      
	  if (bVar1 == 0) { trap(0x1c00); }
      if (((uint)bVar1 == 0xffffffff) && ((uint)*(byte *)(param_1 + 0x559) == 0x80000)) { trap(0x1800); }
	  
	  // compare number of missiles to number of attacks
      *(int *)(param_1 + 0x574) = (int)((uint)*(byte *)(param_1 + 0x559) << 0xc) / (int)(uint)bVar1;
    }
	
    iVar4 = 0;
    iVar2 = 0;
    iVar3 = param_1;
    
	// count number of times you were attacked in race
	do {
      iVar2 = iVar2 + 1;
      iVar4 = iVar4 + (uint)*(byte *)(iVar3 + 0x560);
      iVar3 = param_1 + iVar2;
    } while (iVar2 < 8);
    
	// number of times attacked
	*(int *)(param_1 + 0x57c) = iVar4;
    
	// if driver is in first place
	if (*(short *)(param_1 + 0x482) == 0) {
    
	  // duplicate amount of time spent in last place
      *(undefined4 *)(param_1 + 0x578) = *(undefined4 *)(param_1 + 0x528);
    }
  }
  return;
}


// UI_RaceStart_IntroText1P
void FUN_80055840(void)

{
  short sVar1;
  undefined *puVar2;
  int iVar3;
  uint uVar4;
  undefined *puVar5;
  char *pcVar6;
  short sVar7;
  undefined4 uVar8;
  uint uVar9;
  int iVar10;
  char acStack72 [24];
  undefined2 local_30;
  short local_2e;
  undefined2 local_2c;
  undefined2 local_2a;
  uint local_28 [2];

  puVar2 = PTR_DAT_8008d2ac;

  // by default, do not transition
  // title bars to off-screen
  iVar10 = 0;

  uVar4 = *(uint *)PTR_DAT_8008d2ac;

  // If you are not in a relic race
  if ((uVar4 & 0x4000000) == 0)
  {
	// BONUS ROUND
    uVar9 = 0xbe;

	// If you are not in Crystal challenge
    if ((uVar4 & 0x8000000) == 0) {

	  // If you are not in Adventure Cup
      if ((uVar4 & 0x10000000) == 0) {

		// If you are not in Arcade or VS cup
        if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x10) == 0) {

		  // ARCADE
		  uVar9 = 0x4e;

          if (
				// If you're in Arcade Mode
				((uVar4 & 0x400000) != 0) ||

				(
					// TIME TRIAL
					uVar9 = 0x4d,

					// if you are in time trial mode
					(uVar4 & 0x20000) != 0
				)
			  )	goto LAB_80055930;

		  if (-1 < (int)uVar4)
		  {
			// TROPHY RACE
            uVar9 = 0xb7;

			// If you're in a CTR Token Race
            if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 8) != 0)
			{
			  // CTR CHALLENGE
              uVar9 = 0x176;
            }
            goto LAB_80055930;
          }
          iVar3 = *(int *)(PTR_DAT_8008d2ac + 0x1eb8);
          puVar5 = &DAT_8008413c;
        }

		// If you are in Arcade or VS cup
		else {
		  // Get Cup ID
          iVar3 = *(int *)(PTR_DAT_8008d2ac + 0x1e58);
          puVar5 = &DAT_80086d38;
        }
      }

	  // If you are in Adventure Cup
	  else {
		// Get Cup ID
        iVar3 = *(int *)(PTR_DAT_8008d2ac + 0x1e58);
        puVar5 = &DAT_80086d2c;
      }

	  // Get the name of the cup
	  // Wumpa, Nitro, Crystal
	  // Red, Green, Purple, etc
      uVar9 = (uint)*(ushort *)(puVar5 + iVar3 * 2);
    }
  }

  // If you are in Relic Race
  else
  {
	// RELIC RACE
    uVar9 = 0xb8;
  }
LAB_80055930:

  // if fly-in animation is one second away from finishing
  if (*(short *)(PTR_DAT_8008d2ac + 0x1526) < 0x1f)
  {
	// use this to transition title bars to off-screen
    iVar10 = 0x1e - (uint)*(ushort *)(PTR_DAT_8008d2ac + 0x1526);
  }

  // TitleFlag_IsFullyOnScreen
  iVar3 = FUN_80043f1c();

  // if not
  if (iVar3 == 0)
  {
	// Draw big string
    uVar8 = 1;

	// used for transitioning bars to off-screen
    sVar1 = (short)iVar10;

	if (

		// If you are not in Adventure cup
		((*(uint *)PTR_DAT_8008d2ac & 0x10000000) == 0) &&

		// If you are not in Arcade or VS cup
		((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x10) == 0)
	)
	{
	  // X-value, not 0x100???
      iVar3 = (int)(((uint)*(ushort *)(puVar2 + 0x184) +
                    ((int)((uint)*(ushort *)(puVar2 + 0x188) << 0x10) >> 0x11)) * 0x10000) >> 0x10;

	  // string of top title bar
	  pcVar6 = *(char **)(((int)(uVar9 << 0x10) >> 0xe) + DAT_8008d878);

	  // Y-value that transitions title text to off-screen
      sVar7 = *(short *)(puVar2 + 0x186) - (sVar1 + -7);
    }

	// If you are in any cup of any kind
    else
	{
	  // Name of Cup

										  // uVar9 * 4
      FUN_80022878(*(undefined4 *)(((int)(uVar9 << 0x10) >> 0xe) + DAT_8008d878),
                   (int)(((uint)*(ushort *)(puVar2 + 0x184) +
                         ((int)((uint)*(ushort *)(puVar2 + 0x188) << 0x10) >> 0x11)) * 0x10000) >>
                   0x10,(int)((((uint)*(ushort *)(puVar2 + 0x186) - (iVar10 + -7)) + -6) * 0x10000)
                        >> 0x10,1,0xffff8000);

	  // Track 1/4, 2/4, 3/4, 4/4 in cup
      sprintf(acStack72,"%s %ld/4",

				// DAT_8008d878 + 0x5d4
				// TRACK
				*(undefined4 *)(DAT_8008d878 + 0x5d4),

				// Track Index (0, 1, 2, 3) + 1
				*(int *)(PTR_DAT_8008d2ac + 0x1e5c) + 1);

	  // string of top title bar
	  pcVar6 = acStack72;

	  // X-value, centered
      iVar3 = 0x100;

	  // Draw small string
      uVar8 = 2;

	  // Y-value that transitions title text to off-screen
      sVar7 = (*(short *)(puVar2 + 0x186) - (short)(iVar10 + -7)) + 0xb;
    }

	// Print top title text "Arcade, Time Trial, etc"
    FUN_80022878(pcVar6,iVar3,(int)sVar7,uVar8,0xffff8000);

	// Print the name of the level
	// Crash Cove, Roos Tubes, etc
    FUN_80022878(*(undefined4 *)

					// 83a88 = 110
					// 8d878 + 110*4 -> Dingo Canyon

																// Level ID
                  ((int)*(short *)(&DAT_80083a88 + *(int *)(PTR_DAT_8008d2ac + 0x1a10) * 0x18) * 4 +
                  DAT_8008d878),

                 (int)(((uint)*(ushort *)(puVar2 + 0x184) +
                       ((int)((uint)*(ushort *)(puVar2 + 0x188) << 0x10) >> 0x11)) * 0x10000) >>
                 0x10,(int)(((uint)*(ushort *)(puVar2 + 0x186) + (uint)*(ushort *)(puVar2 + 0x18a) +
                            iVar10 + -0x17) * 0x10000) >> 0x10,1,0xffff8000);

	// color of rectangle that touches Black title bar
	local_28[0] = DAT_8008d438;

	// dimensions of window, two-pixels tall
    local_30 = *(undefined2 *)(puVar2 + 0x184);
    local_2e = *(short *)(puVar2 + 0x186) - (sVar1 + -0x1c);
    local_2c = *(undefined2 *)(puVar2 + 0x188);
    local_2a = 2;

	// Draw tiny rectangle near big black title bar (first)
	// CTR_Box_DrawSolidBox
    FUN_80021894(&local_30,local_28,

					*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0),

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

	// dimensions of window, two-pixels tall
	local_30 = *(undefined2 *)(puVar2 + 0x184);
    local_2e = *(short *)(puVar2 + 0x186) + *(short *)(puVar2 + 0x18a) + sVar1 + -0x1e;
    local_2c = *(undefined2 *)(puVar2 + 0x188);
    local_2a = 2;

	// Draw tiny rectangle near big black title bar (second)
	// CTR_Box_DrawSolidBox
    FUN_80021894(&local_30,local_28,

					*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0),

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

	// clear RGB, keep alpha (which is zero anyway)
    local_28[0] = local_28[0] & 0xff000000;

	// dimensions of window, 30-pixels tall
    local_30 = *(undefined2 *)(puVar2 + 0x184);
    local_2e = *(short *)(puVar2 + 0x186) - sVar1;
    local_2c = *(undefined2 *)(puVar2 + 0x188);
    local_2a = 0x1e;

	// draw big black title bar (first)
	// CTR_Box_DrawSolidBox
    FUN_80021894(&local_30,local_28,

					*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0),

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

	// dimensions of window, 30-pixels tall
    local_30 = *(undefined2 *)(puVar2 + 0x184);
    local_2e = *(short *)(puVar2 + 0x186) + *(short *)(puVar2 + 0x18a) + sVar1 + -0x1e;
    local_2c = *(undefined2 *)(puVar2 + 0x188);
    local_2a = 0x1e;

	// draw big black title bar (second)
	// CTR_Box_DrawSolidBox
    FUN_80021894(&local_30,local_28,

					*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0),

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);
  }
  return;
}


// UI_RaceEnd_MenuBoxFuncPtr
void FUN_80055c90(int param_1)

{
  short sVar1;
  undefined *puVar2;
  uint uVar3;
  int iVar4;
  undefined4 *puVar5;
  undefined4 *puVar6;
  undefined4 *puVar7;
  ushort uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  undefined4 uVar11;

  puVar2 = PTR_DAT_8008d2ac;
  if (*(short *)(param_1 + 0x1e) == 0) {

	if (-1 < (int)*(short *)(param_1 + 0x1a))
	{
      if (*(short *)((int)*(short *)(param_1 + 0x1a) * 6 + *(int *)(param_1 + 0xc)) != 9) {

		// make MenuBox invisible
		FUN_800469c8();
      }
      DAT_8008d52c = 0;
      DAT_8008d570 = 1;

	  // rows[rowSelected].titleLngID
      sVar1 = *(short *)((int)*(short *)(param_1 + 0x1a) * 6 + *(int *)(param_1 + 0xc));

	  // if "Change Level"
      if (sVar1 == 6)
	  {
		// Erase ghost of previous race from RAM
        FUN_80028410();

		// go back to track selection
        DAT_8008d97c = 2;
      }

	  // if not "Change Level"
      else
	  {
        if (sVar1 < 7)
		{
		  // If "Retry"
          if (sVar1 == 4)
		  {
			// Turn off HUD
            PTR_DAT_8008d2ac[0x1d31] = PTR_DAT_8008d2ac[0x1d31] & 0xfe;

			// TitleFlag_IsFullyOffScreen
			iVar4 = FUN_80043f28();

            if (iVar4 == 1)
			{
			  // checkered flag, begin transition on-screen
              FUN_80043fb0(1);
            }

            DAT_8008d0f8 = -5;

			// howl_StopAudio
			// clear backup,
			// keep music,
			// destroy "most" fx, let menu fx play to end
            FUN_8002c8a8(1,0,0);

            if ((*(uint *)(PTR_DAT_8008d2ac + 0x1d44) & 1) == 0) {
              return;
            }

			// bool playGhostDuringRace
            DAT_8008d958 = 1;

            puVar5 = DAT_8008fbf4 + 0xf80;

			// Ghost recording buffer
			puVar6 = DAT_8008fbf4;

			// Ghost replay buffer (to watch while you drive)
            puVar7 = DAT_8008d754;


            if ((((uint)DAT_8008fbf4 | (uint)DAT_8008d754) & 3) == 0)
			{
			  // Copy ghost recording buffer
              do {
                uVar9 = puVar6[1];
                uVar10 = puVar6[2];
                uVar11 = puVar6[3];
                *puVar7 = *puVar6;
                puVar7[1] = uVar9;
                puVar7[2] = uVar10;
                puVar7[3] = uVar11;
                puVar6 = puVar6 + 4;
                puVar7 = puVar7 + 4;
              } while (puVar6 != puVar5);
            }

			// The contents of this "else" are identical to the "if" above,
			// you can tell by copying the contents and searching with CTRL + F

            else
			{
			  // copy ghost recording buffer
              do {
                uVar9 = puVar6[1];
                uVar10 = puVar6[2];
                uVar11 = puVar6[3];
                *puVar7 = *puVar6;
                puVar7[1] = uVar9;
                puVar7[2] = uVar10;
                puVar7[3] = uVar11;
                puVar6 = puVar6 + 4;
                puVar7 = puVar7 + 4;
              } while (puVar6 != puVar5);
            }

			// Make P2 the character that is saved in the
			// header of the ghost that you will see in the race
            DAT_80086e86 = *(undefined2 *)((int)DAT_8008d754 + 6);

			// no ghosts are drawing
            DAT_8008d740 = 0;

            return;
          }

		  if (sVar1 < 5)
		  {
			// If not "Quit"
            if (sVar1 != 3) {
              DAT_8008d52c = 0;
              DAT_8008d570 = 1;
              return;
            }

			// If "Quit"...

			// Erase ghost of previous race from RAM
            FUN_80028410();

			// go back to main menu
            DAT_8008d97c = 0;

			// load LEV of main menu
            FUN_8003cfc0(0x27);
            return;
          }

		  // Erase ghost of previous race from RAM
          FUN_80028410();

		  // go to character selection
          DAT_8008d97c = 1;
        }
        else
		{
		  // If not "Change Setup"
          if (sVar1 != 10)
		  {
            if (sVar1 < 0xb)
			{
			  // If not "Save Ghost"
              if (sVar1 != 9)
			  {
				// ???

                DAT_8008d52c = 0;
                DAT_8008d570 = 1;
                return;
              }

			  // If it is "Save Ghost"

              DAT_8008d52c = 0x3f9;

			  // Set Load/Save to Ghost mode
              FUN_80048e2c(0x31);

			  // Change active MenuBox to GhostSelection
              DAT_8008d924 = &DAT_80085bb4;
              return;
            }

			// If "Exit To Map" chosen
            if (sVar1 == 0xd)
			{
			  // when loading is done, add flag for "In Adventure Arena"
              DAT_8008d100 = DAT_8008d100 | 0x100000;

			  // when loading is done, remove flag for "CTR Challenge"
              DAT_8008d10c = DAT_8008d10c | 8;

			  // If you are in Adventure cup
              if ((*(uint *)PTR_DAT_8008d2ac & 0x10000000) != 0)
			  {
				// when loading is done, remove flags for
				// adventure cup, relic race, and crystal challenge
                DAT_8008d104 = DAT_8008d104 | 0x1c000000;

				// load Gemstone valley LEV
                FUN_8003cfc0(0x19);
                return;
              }

			  // when loading is done,
			  // remove relic race, and crystal challenge
              uVar3 = DAT_8008d104 | 0xc000000;

			  // If you're in a Boss Race
			  // 0x80000000
              if ((int)*(uint *)PTR_DAT_8008d2ac < 0)
			  {
			    // when loading is done,
			    // add flag to spawn near boss door
                DAT_8008d108 = DAT_8008d108 | 1;

			    // when loading is done, remove flags for
			    // boss race, relic race, and crystal challenge
				uVar3 = DAT_8008d104 | 0x8c000000;
              }

			  // set flags that you want removed after
			  // the loading is finished
              DAT_8008d104 = uVar3;

			  // Load LEV in Track Selection
              FUN_8003cfc0((int)*(short *)(PTR_DAT_8008d2ac + 0x1eb4));
              return;
            }

			// If not "Press X to continue"
			// how would that be in a menu?
            if (sVar1 != 0xc9) {
              DAT_8008d52c = 0;
              DAT_8008d570 = 1;
              return;
            }

            DAT_8008d4bc = DAT_8008d4bc | 1;
            DAT_8008d52c = 0;
            DAT_8008d570 = 1;
            return;
          }

		  // go to battle setup screen
          DAT_8008d97c = 3;
        }
      }

	  // when loading is done
	  // add flag for "in menus"
      DAT_8008d100 = DAT_8008d100 | 0x2000;

	  // load LEV of main menu
      FUN_8003cfc0(0x27);
    }
  }
  else {
    uVar8 = *(ushort *)(param_1 + 0x14) & 0xfeff;
    *(ushort *)(param_1 + 0x14) = uVar8;

	// if more than 2 screens
    if (2 < (byte)puVar2[0x1ca8]) {
      *(ushort *)(param_1 + 0x14) = uVar8 | 0x100;
    }
  }
  return;
}


// UI_CupStandings_FinalizeCupRanks
void FUN_8005607c(void)

{
  undefined *puVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  int *piVar5;
  int iVar6;
  short sVar7;
  short sVar8;
  int iVar9;

  puVar1 = PTR_DAT_8008d2ac;
  iVar9 = -1;

  // numPlyrCurrGame + number of AIs
  uVar3 = (uint)(byte)PTR_DAT_8008d2ac[0x1ca8] + (uint)(byte)PTR_DAT_8008d2ac[0x1cab];
  sVar8 = 0;

  // if there are more than four drivers
  if (4 < uVar3) {
    uVar3 = 4;
  }

  iVar6 = 1;

  // if there is more than one driver
  if (1 < uVar3) {
    sVar8 = 0;
    do {
      iVar2 = iVar6 << 0x10;
      iVar6 = iVar6 + 1;

	  // something related to cup ranks
      if (*(int *)(PTR_DAT_8008d2ac + *(int *)((int)&DAT_80086d44 + (iVar2 >> 0xe)) * 4 + 0x1e60) !=
          *(int *)(PTR_DAT_8008d2ac + DAT_80086d44 * 4 + 0x1e60)) break;

      sVar8 = sVar8 + 1;
    } while (iVar6 * 0x10000 >> 0x10 < (int)uVar3);
  }

  iVar6 = 0;
  if (0 < (int)sVar8 + 1) {
    do {
      sVar7 = 99;
      iVar4 = (int)(short)iVar6;
      iVar2 = iVar6;
      while (iVar4 < (int)sVar8 + 1)
	  {
		// something related to cup rank, and driver->rank (track rank)
        if (*(short *)(*(int *)(puVar1 + *(int *)((int)&DAT_80086d44 + ((iVar2 << 0x10) >> 0xe))
										* 4 + 0x24ec) + 0x482) < sVar7)
		{
          iVar9 = iVar2;

		  // something related to cup rank, and driver->rank (track rank)
          sVar7 = *(short *)(*(int *)(puVar1 + *(int *)((int)&DAT_80086d44 +
										((iVar2 << 0x10) >> 0xe)) * 4 + 0x24ec) + 0x482);
        }
        iVar2 = iVar2 + 1;
        iVar4 = iVar2 * 0x10000 >> 0x10;
      }
      iVar2 = iVar6 << 0x10;
      iVar6 = iVar6 + 1;
      piVar5 = (int *)((int)&DAT_80086d44 + (iVar2 >> 0xe));
      sVar7 = *(short *)piVar5;
      *piVar5 = (int)(short)iVar9;

	  // set cup rank
      (&DAT_80086d44)[(int)(short)iVar9] = (int)sVar7;

    } while (iVar6 * 0x10000 >> 0x10 < (int)sVar8 + 1);
  }
  return;
}



void FUN_80056220(void)

{
  undefined *puVar1;
  int iVar2;
  uint uVar3;
  undefined *puVar4;
  uint uVar5;
  short sVar6;
  uint uVar7;
  int iVar8;
  short sVar9;

  puVar1 = PTR_DAT_8008d2ac;
  uVar5 = 0;

  //        number of AIs          +        numPlyrCurrGame
  iVar2 = (uint)(byte)PTR_DAT_8008d2ac[0x1cab] + (uint)(byte)PTR_DAT_8008d2ac[0x1ca8];

  // for(int iVar8 = 0; iVar8  < totalNumCharacters; iVar8++)
  // Draw all multiplayer icons???

  iVar8 = 0;
  if (iVar2 != 0) {
    do
	{
	  // set highest numPoints value to zero
      sVar9 = 0;

	  // set driver index of highest score to zero
      uVar7 = 0xffffffff;

      sVar6 = -1;
      uVar3 = iVar2 - 1;
      if (-1 < (int)uVar3) {
        puVar4 = puVar1 + uVar3 * 4;
        do {
          if (
				// if number of points held by this player
				// is more than the biggest number found yet
				((int)sVar9 <= *(int *)(puVar4 + 0x1e60)) &&
             (((int)(uVar5 & 0xff) >> (uVar3 & 0x1f) & 1U) == 0))
		  {
			// set new highest score found
            sVar9 = *(short *)(puVar4 + 0x1e60);

            if ((int)(short)uVar7 != 0xffffffff)
			{
              uVar5 = uVar5 & ~(1 << ((int)(short)uVar7 & 0x1fU));
            }
            uVar5 = uVar5 | 1 << (uVar3 & 0x1f);

			// set ID of driver with highest score
            uVar7 = uVar3;
          }

		  // copy ID of driver with highest score
          sVar6 = (short)uVar7;

          uVar3 = uVar3 - 1;
          puVar4 = puVar4 + -4;
        } while (-1 < (int)uVar3);
      }

	  // Update cup rank of each player
      (&DAT_80086d44)[iVar8] = (int)sVar6;

      iVar8 = iVar8 + 1;
    } while (iVar8 < iVar2);
  }
  return;
}


// UI_CupStandings_UpdateAndDraw
void FUN_800562fc(void)

{
  short sVar1;
  ushort uVar2;
  bool bVar3;
  undefined *puVar4;
  short sVar5;
  int local_8c;
  uint uVar6;
  int local_90;
  short sVar7;
  uint uVar8;
  undefined4 uVar9;
  int iVar10;
  char *fmt;
  undefined *puVar11;
  int iVar12;
  int *piVar13;
  undefined4 uVar14;
  int iVar15;
  undefined4 *puVar16;
  int iVar17;
  short sVar18;
  ushort local_80;
  ushort local_7e;
  undefined2 local_7c;
  undefined2 local_7a;
  char acStack120 [8];
  char acStack112 [24];
  ushort local_58;
  ushort local_56;
  undefined4 local_50;
  undefined2 local_4c;
  undefined4 local_48;
  undefined2 local_44;
  undefined4 local_40;
  undefined2 local_3c;
  short local_38;
  short local_30;

  puVar4 = PTR_DAT_8008d2ac;

  // numPlyrCurrGame        +         number of AIs
  iVar17 = (uint)(byte)PTR_DAT_8008d2ac[0x1ca8] + (uint)(byte)PTR_DAT_8008d2ac[0x1cab];

  if (
		(
			// If you are in Arcade or VS cup
			((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x10) != 0) &&

			// if numPlyrCurrGame is not 1
			// if this is a multiplayer game
			(PTR_DAT_8008d2ac[0x1ca8] != 1)
		) &&

		(
			// TitleFlag_IsFullyOffScreen
			local_8c = FUN_80043f28(),
			local_8c == 1
		)
	)
  {
	// checkered flag, begin transition on-screen
    FUN_80043fb0(1);
  }

  // TitleFlag_IsFullyOnScreen
  local_8c = FUN_80043f1c();

  if (
		// if it is
		(local_8c != 0) &&

		// if numPlyrCurrGame is not 1
		// if this is a multiplayer game
		(PTR_DAT_8008d2ac[0x1ca8] != '\x01')
	  )
  {
	// enable checkered flag
    FUN_80044088(1);
  }

  // TitleFlag_IsFullyOnScreen
  local_8c = FUN_80043f1c();

  if (
		// if not
		(local_8c == 0) &&

		// if numPlyrCurrGame is not 1
		// if this is a multiplayer game
		(PTR_DAT_8008d2ac[0x1ca8] != '\x01')
	 )
  {
    return;
  }

  // TitleFlag_IsFullyOnScreen
  local_8c = FUN_80043f1c();

  puVar11 = PTR_DAT_8008d2ac;

  if (
		// if fully on screen
		(local_8c != 0) ||

		// If numPlyrCurrGame is 1
		(PTR_DAT_8008d2ac[0x1ca8] == '\x01')
	  )
  {
    // if flag is fully on screen, and this is multiplayer
    if (PTR_DAT_8008d2ac[0x1ca8] != '\x01')
	{
	  // disable loading screen,
	  // set amount of confetti to zero
      uVar6 = *(uint *)(PTR_DAT_8008d2ac + 0x256c);
      *(undefined2 *)(PTR_DAT_8008d2ac + 0x1b04) = 0;
      *(undefined2 *)(puVar11 + 0x1b06) = 0;
      *(uint *)(puVar11 + 0x256c) = uVar6 & 0x1000;
    }

    if ((DAT_8008d52c < 0xf0) || (((DAT_8008d4bc & 8) != 0 && (DAT_8008d52c < 400)))) {
      DAT_8008d52c = DAT_8008d52c + 1;
    }
  }

  if (
		(DAT_8008d52c < 0x3c) &&

		// If you press Cross or Circle
		((DAT_8008d950 & 0x50) != 0)
	 )
  {
    DAT_8008d52c = 0x3c;

	// Save the number of drivers
	//               numPlyrCurrGame                 +         number of AIs
    DAT_8008d570 = (ushort)(byte)PTR_DAT_8008d2ac[0x1ca8] + (ushort)(byte)PTR_DAT_8008d2ac[0x1cab];

	// clear gamepad input (for menus)
	FUN_80046404();
  }
  if ((DAT_8008d4bc & 4) == 0) {
    local_38 = -0x32;
    local_30 = 0x1e;
  }
  else {
    local_38 = 0x1e;
    local_30 = -0x32;
  }
  if (DAT_8008d52c < 0xf1) {
    uVar9 = 0xffffff6a;
    uVar14 = 0x100;
    local_90 = 0x1e;
    iVar12 = (int)local_38;
    local_8c = DAT_8008d52c;
  }
  else {
    uVar9 = 0x100;
    iVar12 = 0x1e;
    uVar14 = 0x296;
    local_90 = (int)local_30;
    local_8c = DAT_8008d52c + -0xf0;
  }

  // Interpolate variables from the previous "if-statement"
  FUN_8004ecd4(&local_58,uVar9,iVar12,uVar14,local_90,local_8c,0x14);

  if ((DAT_8008d4bc & 4) == 0) {
												// Level ID
    sVar18 = *(short *)(&DAT_80083a88 + *(int *)(PTR_DAT_8008d2ac + 0x1a10) * 0x18);
  }
  else
  {
	// If this is the last track in a cup
    if (*(int *)(PTR_DAT_8008d2ac + 0x1e5c) == 3)
	{
	  // DAT_8008d878 + 0x8b8
	  // FINAL
      uVar9 = *(undefined4 *)(DAT_8008d878 + 0x8b8);
      goto LAB_80056678;
    }

	// If you are not in Arcade or VS cup
    if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x10) == 0)
	{
	  // adv cup name LNG index
      puVar11 = &DAT_80084114;

	  // each is 8 bytes apart
      local_8c = *(int *)(PTR_DAT_8008d2ac + 0x1e58) << 3;
    }

	// If you are not in Arcade or VS cup
    else
	{
	  // arcade cup name LNG index
      puVar11 = &DAT_80084148;

	  // each is 0x12 (18) bytes apart
	  local_8c = *(int *)(PTR_DAT_8008d2ac + 0x1e58) * 0x12;
    }

	// get final lang index
    sVar18 = *(short *)(puVar11 + local_8c);
  }

  // get pointer to name from lng
  uVar9 = *(undefined4 *)((int)sVar18 * 4 + DAT_8008d878);

LAB_80056678:

  // title text
  FUN_80022878(uVar9,(int)(short)local_58,(int)(((uint)local_56 - 0x11) * 0x10000) >> 0x10,1,
               0xffff8000);

  // DAT_8008d878 + 0x328
  // STANDINGS
  FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x328),(int)(short)local_58,(int)(short)local_56,1,
               0xffff8000);

  // TRACK 1/4, 2/4, 3/4, 4/4
  sprintf(acStack112,"%s %ld/4",

			// DAT_8008d878 + 0x5d4
			// TRACK
			*(undefined4 *)(DAT_8008d878 + 0x5d4),

			// Track Index (0, 1, 2, 3) + 1
			*(int *)(PTR_DAT_8008d2ac + 0x1e5c) + 1);

  FUN_80022878(acStack112,(int)(short)local_58,(int)(((uint)local_56 + 0x11) * 0x10000) >> 0x10,2,
               0xffff8000);
  if ((DAT_8008d52c == (DAT_8008d52c / 10) * 10) && (DAT_8008d570 < iVar17)) {
    DAT_8008d570 = DAT_8008d570 + 1;
  }
  local_8c = 0;
  if (0 < DAT_8008d570) {
    local_90 = 0;
    sVar18 = 0;
    do {
      sVar5 = (short)local_8c;

	  // If you are in Purple Gem Cup
      if (*(int *)(PTR_DAT_8008d2ac + 0x1e58) == 4) {
        if (local_8c < 5) {
          uVar9 = 0x60;
          sVar7 = *(short *)(puVar4 + 0x13a4);
          sVar5 = (short)(((int)*(short *)(puVar4 + 0x13a8) + -0x20) / 5) * sVar5 + 0x10;
          goto LAB_800568d4;
        }
        sVar7 = 0;
        uVar9 = 0;
      }

	  // If this is not Purple Gem Cup
      else {

		//           numPlyrCurrGame      +       number of AIs
        // Basically, if you're in 2P Arcade
		if ((uint)(byte)PTR_DAT_8008d2ac[0x1ca8] + (uint)(byte)PTR_DAT_8008d2ac[0x1cab] == 6) {
          uVar9 = 0x42;
          if (local_8c < 3) {
            sVar7 = *(short *)(puVar4 + 0x13a4);
            sVar5 = (short)((int)*(short *)(puVar4 + 0x13a8) + -0x80 >> 2) * sVar5 + 0x20;
          }
          else {
            sVar1 = *(short *)(puVar4 + 0x13a8);
            sVar5 = sVar5 + -2;
LAB_800568b8:
            uVar9 = 0x79;
            sVar7 = *(short *)(puVar4 + 0x13a4);
            sVar5 = (short)((int)sVar1 + -0x80 >> 2) * sVar5 + 0x60;
          }
        }

		// If you are not in 2P Arcade
        else {

		  // If number of AIs is zero
          if (PTR_DAT_8008d2ac[0x1cab] == 0) {
            uVar9 = 0x6c;
            sVar7 = *(short *)(puVar4 + 0x13a4) +
                    (short)(((int)*(short *)(puVar4 + 0x13a8) + iVar17 * -0x5a + 0xc) / 2) + sVar18;
            goto LAB_800568d8;
          }
          uVar9 = 0x42;
          if (3 < local_8c) {
            sVar1 = *(short *)(puVar4 + 0x13a8);
            sVar5 = sVar5 + -4;
            goto LAB_800568b8;
          }
          sVar7 = *(short *)(puVar4 + 0x13a4);
          sVar5 = (short)((int)*(short *)(puVar4 + 0x13a8) + -0x80 >> 2) * sVar5 + 0x20;
        }
LAB_800568d4:
        sVar7 = sVar7 + sVar5;
      }
LAB_800568d8:
      if (DAT_8008d52c < 0xf1) {
        iVar10 = 0x296;
        iVar15 = (int)sVar7;
        iVar12 = DAT_8008d52c + (local_90 + local_8c) * -2;
      }
      else {
        iVar10 = (int)sVar7;
        iVar15 = -0x96;
        iVar12 = DAT_8008d52c + -0xf0;
      }

	  // Interpolate fly-in variables over 0x14 frames
      FUN_8004ecd4(&local_58,iVar10,uVar9,iVar15,uVar9,iVar12,0x14);

	  // DAT_8008d510
	  // %d
      sprintf(acStack120,&DAT_8008d510,local_8c + 1);

	  FUN_80022878(acStack120,(int)(((uint)local_58 + 0x20) * 0x10000) >> 0x10,
                   (int)(((uint)local_56 - 1) * 0x10000) >> 0x10,2,3);

	  // If this is the first screen of cup standings,
	  // where you see just amount of points added
	  if ((DAT_8008d4bc & 4) == 0)
	  {
		// get driver in order of race rank (for one track)
        iVar12 = *(int *)(PTR_DAT_8008d2ac + local_90 + 0x250c);
      }

	  // if this is not the first page,
	  // so now you see total points of drivers
	  else
	  {
		// get driver in order of cup rank (for collection of tracks)
        iVar12 = *(int *)(PTR_DAT_8008d2ac + *(int *)((int)&DAT_80086d44 + local_90) * 4 + 0x24ec);
      }

	  // Draw character icon
      FUN_8004e8d8(*(undefined4 *)
                    (PTR_DAT_8008d2ac +
                    ((int)((uint)*(ushort *)
                                  (&DAT_80086d8c +

								  // Player / AI structure + 0x4a shows driver index (0-7)

													// character ID
                                  (int)(short)(&DAT_80086e84)[*(byte *)(iVar12 + 0x4a)] * 0x10) <<
                          0x10) >> 0xe) + 0x1eec),(int)(short)local_58,(int)(short)local_56,

					// pointer to PrimMem struct
                   *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

				   // pointer to OT memory
                   *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				   1,0x1000,0x808080);

	  // If this is the first screen of cup standings,
	  // where you see just amount of points added
	  if ((DAT_8008d4bc & 4) == 0)
	  {
		// If number of AIs is zero
        if (PTR_DAT_8008d2ac[0x1cab] == '\0') {

		  // amount of points to add is based on how
		  // many players are in the race, and race position
						// numPlyrCurrGame - [unknown]
          iVar12 = (uint)(byte)PTR_DAT_8008d2ac[0x1ca8] - (local_8c + 1);
        }

		// if there are AIs
        else
		{
		  // amount of points to add is based on array
		  // 9, 6, 3, 1, 0, 0, 0, 0
          iVar12 = *(int *)((int)&DAT_80086d64 + local_90);
        }
        fmt = &DAT_8008d574;
      }

	  // if this is not the first page,
	  // so now you see total points of drivers
      else
	  {
		// The amount of points that each player has, in a cup
        iVar12 = *(int *)(PTR_DAT_8008d2ac + *(int *)((int)&DAT_80086d44 + local_90) * 4 + 0x1e60);

		// "%ld"
        fmt = &DAT_8008d520;
      }
      local_90 = local_90 + 4;

	  // make a string to draw, based on above variables
      sprintf(acStack120,fmt,iVar12);

	  sVar18 = sVar18 + 0x5a;

	  // draw string for number of points
      FUN_80022878(acStack120,(int)(((uint)local_58 + 0x2d) * 0x10000) >> 0x10,
                   (int)(((uint)local_56 + 6) * 0x10000) >> 0x10,1,1);

      local_8c = local_8c + 1;
    } while (local_8c < DAT_8008d570);
  }

  // If this is the first screen of cup standings,
  // where you see just amount of points added
  if ((DAT_8008d4bc & 4) == 0)
  {
	// fly-in interpolation
    FUN_8004ecd4(&local_58,0xfffffff6,(int)local_38,0xfffffff6,9,DAT_8008d52c,0x14);
  }

  // if it's not...
  else {
    if (DAT_8008d52c < 0xf1) {
      local_58 = 0xfff6;
      local_56 = 9;
    }
    else
	{
	  // fly-in interpolation
      FUN_8004ecd4(&local_58,0xfffffff6,9,0xfffffff6,(int)local_30,DAT_8008d52c + -0xf0,0x14);
    }
  }
  local_7c = 0x214;
  local_7a = 0x32;
  local_80 = local_58;
  local_7e = local_56;

  // Draw 2D Menu rectangle background
  FUN_800457b0(&local_80,4,*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0));

  puVar4 = PTR_DAT_8008d2ac;

  // Timer
  if (DAT_8008d52c < 0x10f) {
    if (
			(
				// Timer
				(0x3b < DAT_8008d52c) &&

				// If you are not in overall Cup standings
				((DAT_8008d4bc & 8) == 0)
			) &&
			(
				// DAT_8008d878 + 0x324
				// PRESS * TO CONTINUE
				FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x324),0x100,0xbe,1,0xffff8000),

				// If you press Cross or Circle
				(DAT_8008d950 & 0x50) != 0)
			)
	{
	  // Timer
      DAT_8008d52c = 0xf0;

	  // Proceed from Track standings to overall Cup standings,
	  // where you see how many points each driver has overall
      DAT_8008d4bc = DAT_8008d4bc | 8;

	  // clear gamepad input (for menus)
      FUN_80046404();
    }
  }
  else {
    DAT_8008d570 = 1;
    DAT_8008d52c = 0;
    uVar6 = DAT_8008d4bc & 0xfffffff6;
    uVar8 = DAT_8008d4bc & 4;

	// Proceed from end-of-race menu to Track Standings,
	// where you see how many points are added just for this race
    DAT_8008d4bc = uVar6 | 4;

	// If the "4" flag was not enabled till just now,
	// If this is the first frame of Track Standings
    if (uVar8 == 0)
	{
	  // Add points awarded from Track Standings to Cup Standings

	  // If number of AIs is zero (VS cup)
      if (PTR_DAT_8008d2ac[0x1cab] == '\0')
	  {
		// Loop counter
        iVar17 = 0;

		// if numPlyrCurrGame != 0
        if (PTR_DAT_8008d2ac[0x1ca8] != '\0')
		{
          local_8c = 0;

		  // for iVar17 = 0; iVar17 < numPlyrCurrGame; iVar17++
          do
		  {
			// Increment Loop counter
			// iVar17 = rank... 1 for 1st place, 2 for 2nd, etc
            iVar17 = iVar17 + 1;

			// the amount of points this player has in the cup
            *(uint *)(puVar4 + (uint)*(byte *)(*(int *)(puVar4 + local_8c + 0x250c) + 0x4a) * 4 + 0x1e60) =
            *(uint *)(puVar4 + (uint)*(byte *)(*(int *)(puVar4 + local_8c + 0x250c) + 0x4a) * 4 + 0x1e60) +

			// Incremented by

			// numPlyrCurrGame - rank
			((uint)(byte)puVar4[0x1ca8] - iVar17);

            local_8c = iVar17 * 4;

          } while (iVar17 < (int)(uint)(byte)puVar4[0x1ca8]);
        }
      }

	  // If there are AIs (Arcade cup)
	  else
	  {
		// Loop counter
        iVar17 = 0;

		// Array of ints that holds the amount of
		// points that should be awarded for each position
		// {9, 6, 3, 1, 0, 0, 0, 0}
        piVar13 = &DAT_80086d64;

        puVar11 = PTR_DAT_8008d2ac;

		// wont break when you have 6 drivers
		// in 2P Arcade Cup

		// for iVar17 = 0; iVar17 < 8; iVar17++
        do
		{
		  // get value at this array index
          local_8c = *piVar13;

		  // increment int pointer, jump 4 bytes to next array index
          piVar13 = piVar13 + 1;

		  // increment loop counter
          iVar17 = iVar17 + 1;

		  // the amount of points this player has in the cup
          *(int *)(puVar4 + (uint)*(byte *)(*(int *)(puVar11 + 0x250c) + 0x4a) * 4 + 0x1e60) =
          *(int *)(puVar4 + (uint)*(byte *)(*(int *)(puVar11 + 0x250c) + 0x4a) * 4 + 0x1e60) +

		  // Incremented by

		  // The amount of points that should be awarded to each position
		  local_8c;

		  // increment pointer to next player
          puVar11 = puVar11 + 4;

        } while (iVar17 < 8);

      }

	  // update cup rank of all drivers
      FUN_80056220();
    }

	// If this is not the first frame of track standings
	else
	{
      DAT_8008d4bc = uVar6;

	  // enable drawing HUD
	  PTR_DAT_8008d2ac[0x1d31] = PTR_DAT_8008d2ac[0x1d31] | 1;

	  // Disable types of HUD that are not needed for gameplay,
	  // This includes Cup rankings, which is a flag in this byte
      PTR_DAT_8008d2ac[0x1d31] = PTR_DAT_8008d2ac[0x1d31] & 0xfb;

	  puVar4 = PTR_DAT_8008d2ac;
      DAT_8008d4bc = DAT_8008d4bc & 0xfffffffb;

	  // Increment Track Number by 1 (0-3 in the cup)
      iVar17 = *(int *)(PTR_DAT_8008d2ac + 0x1e5c) + 1;
      *(int *)(PTR_DAT_8008d2ac + 0x1e5c) = iVar17;

	  // If this is not the last race in the cup
      if (iVar17 < 4)
	  {
		// If this is an Adventure Cup
        if ((*(uint *)(puVar4 + 8) & 0x10) == 0)
		{
		  // Load the next LEV, given cup ID (0-3) and track index of cup (0-3)
          FUN_8003cfc0((int)*(short *)(&DAT_800840a4 + iVar17 * 4 + *(int *)(puVar4 + 0x1e58) * 0x10
                                      ));
        }

		// If this is not an Adventure Cup
        else
		{
		  // Load the next LEV, given cup ID (0-3) and track index of cup (0-3)
          FUN_8003cfc0((int)*(short *)(&DAT_8008414a + iVar17 * 4 + *(int *)(puVar4 + 0x1e58) * 0x12
                                      ));
        }
      }

	  // If this was the last race in the cup
	  // If the cup is over
      else {
        iVar17 = 0;

		// If this is an Adventure Cup
        if ((*(uint *)(puVar4 + 8) & 0x10) == 0)
		{
		  // Array with the ranking of each player
          piVar13 = &DAT_80086d44;

		  // Set Level ID
          *(int *)(puVar4 + 0x1a10) = *(int *)(puVar4 + 0x1e58) + 100;

		  // Set Track Index of Cup to 0, for the start of the next cup
          *(undefined4 *)(puVar4 + 0x1e5c) = 0;

		  // when loading is done,
		  // remove flag for adventure cup
          DAT_8008d104 = DAT_8008d104 | 0x10000000;

          puVar11 = puVar4;

		  // Loop through 8 drivers, clear all data for next cup

		  // for iVar17 = 0; iVar17 < 8; iVar17++
          do {

			// If driver is not nullptr
            if (*(int *)(puVar4 + *piVar13 * 4 + 0x24ec) != 0)
			{
			  // Set final ranking of each player
              *(undefined2 *)(*(int *)(puVar4 + *piVar13 * 4 + 0x24ec) + 0x482) = (short)iVar17;
            }

			// set driver's cup score to zero
            *(undefined4 *)(puVar11 + 0x1e60) = 0;

			// increment offset into cup rankings array
			puVar11 = puVar11 + 4;

			// increment loop counter
            iVar17 = iVar17 + 1;

			// increment offset into player array
            piVar13 = piVar13 + 1;

		  } while (iVar17 < 8);

		  // Tawna_Init
          FUN_80041c84(PTR_DAT_8008d2ac);

          puVar4 = PTR_DAT_8008d2ac;

		  // If player 1 won the cup
          if (DAT_80086d44 == (uint)*(byte *)(*(int *)(PTR_DAT_8008d2ac + 0x24ec) + 0x4a))
		  {
			// bit offst 0x6a is where the gems start in the bits of Adventure Progress

			// If this cup has never been beaten before (if you dont have the gem)
			// 0x8fba4 is where the adventure profile (currently loaded) begins
            if (((uint)(&DAT_8008fba4)[(int)(*(int *)(PTR_DAT_8008d2ac + 0x1e58) + 0x6aU) >> 5] >>
                 (*(int *)(PTR_DAT_8008d2ac + 0x1e58) + 0x6aU & 0x1f) & 1) == 0)
			{
			  // Set podium reward model to Gem
              *(undefined2 *)(PTR_DAT_8008d2ac + 0x2572) = 0x5f;

			  // bit offset of non-adventure progress to unlock character,
			  // plus cupID
              uVar6 = *(int *)(puVar4 + 0x1e58) + 7;

			  // get index of integer array for this bit
			  iVar17 = (int)uVar6 >> 5;

			  // 4 bytes of rewards (characters + tracks)
			  // This unlocks Roo, Papu, Joe, Pinstripe, or Fake Crash
              (&DAT_8008e6ec)[iVar17] = (&DAT_8008e6ec)[iVar17] | 1 << (uVar6 & 0x1f);

			  // bit offset of adventure progress to unlock gem
			  // plus cupID
              uVar6 = *(int *)(puVar4 + 0x1e58) + 0x6a;

			  // 0x8fba4 is where the adventure profile (currently loaded) begins
			  // Unlocks one of the gems
              (&DAT_8008fba4)[(int)uVar6 >> 5] =
                   (&DAT_8008fba4)[(int)uVar6 >> 5] | 1 << (uVar6 & 0x1f);
            }

									// track index 0,1,2,3
			// reset counter for number of times you lost cup, to zero
            (&DAT_8008fbe6)[*(int *)(PTR_DAT_8008d2ac + 0x1e5c)] = 0;
          }

		  // If player 1 did not win the cup
          else
		  {
								// track index 0,1,2,3
            iVar17 = *(int *)(PTR_DAT_8008d2ac + 0x1e5c);

			// if you lost the cup less than 10 times
            if ((char)(&DAT_8008fbe6)[iVar17] < '\n')
			{
			  // increase number of times you lost the cup
              (&DAT_8008fbe6)[iVar17] = (&DAT_8008fbe6)[iVar17] + '\x01';
            }
          }

		  // Level ID for Gemstone Valley (podiums)
          FUN_8003cfc0(0x19);
        }

		// If this is not an Adventure Cup
		else
		{
		  // Set Track Index of Cup to 0, for the start of the next cup
          *(undefined4 *)(puVar4 + 0x1e5c) = 0;

		  // UI_CupStandings_FinalizeCupRanks
          FUN_8005607c();

          puVar4 = PTR_DAT_8008d2ac;
          iVar17 = 0;

		  // Array with the final ranking of each player
          piVar13 = &DAT_80086d44;

          puVar11 = PTR_DAT_8008d2ac;

		  // for iVar17 = 0; iVar17 < 8; iVar17++
          do
		  {
			// If driver is not nullptr
            if (*(int *)(puVar4 + *piVar13 * 4 + 0x24ec) != 0)
			{
				// Set final ranking of each player
              *(undefined2 *)(*(int *)(puVar4 + *piVar13 * 4 + 0x24ec) + 0x482) = (short)iVar17;
            }

			// set driver's cup score to zero
            *(undefined4 *)(puVar11 + 0x1e60) = 0;

			// increment offset into cup rankings array
            puVar11 = puVar11 + 4;

			// increment loop counter
            iVar17 = iVar17 + 1;

			// increment offset into player array
            piVar13 = piVar13 + 1;

          } while (iVar17 < 8);

		  // Tawna_Init
          FUN_80041c84(PTR_DAT_8008d2ac);

          puVar4 = PTR_DAT_8008d2ac;

		  // If Player 1 or Player 2 won the cup
          if (((*(short *)(*(int *)(PTR_DAT_8008d2ac + 0x24ec) + 0x482) == 0) ||
              (*(short *)(*(int *)(PTR_DAT_8008d2ac + 0x24f0) + 0x482) == 0)) &&

			 // If you're in Arcade Mode
             ((*(uint *)PTR_DAT_8008d2ac & 0x400000) != 0))
		  {
			// If P1 or P2 lost the cup, or if this was VS mode,
			// then nothing would unlock

			// You deserve to have something unlocked.
            bVar3 = true;

			// If Arcade difficulty is "Easy"
            if (*(int *)(PTR_DAT_8008d2ac + 0x1ebc) == 0x50)
			{
              iVar17 = 0;
            }

			// if difficulty is not easy
            else
			{
			  // If Arcade difficulty is "Hard"
              iVar17 = 2;

			  // If Arcade difficulty is "Medium"
              if (*(int *)(PTR_DAT_8008d2ac + 0x1ebc) == 0xa0) {
                iVar17 = 1;
              }
            }

			// Bit index of cup completion (curr),
			// one index per difficulty
			// [0] (easy) = 0xC
			// [1] (medium) = 0x10
			// [2] (hard) = 0x14
            local_50 = DAT_8008d578;
            local_4c = DAT_8008d57c;

			// Bit index of cup completion (prev),
			// one index per difficulty
			// [0] (easy) = 0xC
			// [1] (medium) = 0x10
			// [2] (hard) = 0x14
            local_48 = DAT_8008d580;
            local_44 = DAT_8008d584;

			// Bit index of Battle Track Unlock
			// [0] (easy) = 0xC
			// [1] (medium) = 0x10
			// [2] (hard) = 0x14
            local_40 = DAT_8008d588;
            local_3c = DAT_8008d58c;

			// get base index
            puVar16 = (undefined4 *)((int)&local_50 + iVar17 * 2);

			// add cupID to bit
			uVar6 = (int)*(short *)puVar16 + *(int *)(PTR_DAT_8008d2ac + 0x1e58);

			// byte index
			local_8c = (int)uVar6 >> 5;

			// Save record that this cup, on this difficulty, was won
            (&DAT_8008e6ec)[local_8c] = (&DAT_8008e6ec)[local_8c] | 1 << (uVar6 & 0x1f);

			// bit index of cup completion on this difficulty (prior to now)
            uVar6 = (int)*(short *)((int)&local_48 + iVar17 * 2) + *(int *)(puVar4 + 0x1e58);

			// If this cup was not previuosly beaten on this difficulty,
			// and this is the first time the cup was won
            if (((uint)(&DAT_8008e6ec)[(int)uVar6 >> 5] >> (uVar6 & 0x1f) & 1) == 0)
			{
			  // loop counter
              local_8c = 0;

			  // gGT->0x8 | 0x1000,
			  // lets 233 know to prompt the Save Game box
              *(uint *)(puVar4 + 8) = *(uint *)(puVar4 + 8) | 0x1000;

              puVar4 = PTR_DAT_8008d2ac;

			  // bit index of cup completion (curr)
              uVar8 = SEXT24(*(short *)puVar16);
              uVar6 = uVar8;

			  // loop through all 4 cups to see if they've all
			  // been beaten on the current cup difficulty

			  // for local_8c = 0; local_8c < 4; local_8c++
              do
			  {
				// increment loop counter
                local_8c = local_8c + 1;

			    // if any of four cups on this difficulty was not won
                if (((uint)(&DAT_8008e6ec)[(int)uVar6 >> 5] >> (uVar6 & 0x1f) & 1) == 0)
				{
				  // you dont deserve to unlock a battle map
                  bVar3 = false;
                  break;
                }
                uVar6 = uVar8 + local_8c;
              } while (local_8c < 4);

			  // If P1 or P2 won an Arcade Cup, and if you haven't unlocked
			  // a battle map for this difficulty, and if you've beaten all
			  // four Arcade cups on this difficulty
              if (bVar3)
			  {
				// Get bit index of battle map unlock
                uVar2 = *(ushort *)((int)&local_40 + iVar17 * 2);
                iVar17 = (int)((uint)uVar2 << 0x10) >> 0x15;

			    // Unlock a Battle Map (Parking Lot, North Bowl, Parking Lot)
                (&DAT_8008e6ec)[iVar17] = (&DAT_8008e6ec)[iVar17] | 1 << (uVar2 & 0x1f);

				// gGT -> 0x8 | 0x2000
				// battle map is now unlocked (233 overlay)
                *(uint *)(puVar4 + 8) = *(uint *)(puVar4 + 8) | 0x2000;
              }
            }
          }

		  // Set podium's reward model to "Empty"
          *(undefined2 *)(PTR_DAT_8008d2ac + 0x2572) = 0x38;

		  // Level ID for Gemstone Valley (podiums)
          FUN_8003cfc0(0x19);
        }
      }
    }
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

// Vector_SpecLightSpin2D
// instance, ptr rot[6], cop registers
void FUN_800572d0(int param_1,undefined4 param_2,SVECTOR *param_3)

{
  undefined *puVar1;
  int iVar2;
  undefined4 uVar3;
  undefined *puVar4;
  undefined auStack104 [16];
  undefined auStack88 [72];

  puVar4 = auStack104;

  // ConvertRotToMatrix_Transpose
  FUN_8006c378(auStack88, param_2);

  gte_ldv0(param_3);
  gte_rtv0();
  uVar3 = gte_stMAC1();
  *(undefined4 *)(puVar4 + 0x30) = uVar3;
  uVar3 = gte_stMAC2();
  *(undefined4 *)(puVar4 + 0x34) = uVar3;
  uVar3 = gte_stMAC3();
  *(undefined4 *)(puVar4 + 0x38) = uVar3;
  *(undefined *)(param_1 + 0x53) = puVar4[0x30];
  *(undefined4 *)(param_1 + 0x58) = *(undefined4 *)(puVar4 + 0x38);
  *(undefined2 *)(puVar4 + 0x50) = 0;
  *(undefined2 *)(puVar4 + 0x52) = 0;
  *(undefined2 *)(puVar4 + 0x54) = 0x1000;
  gte_ldv0((SVECTOR *)(puVar4 + 0x50));
  gte_rtv0();
  uVar3 = gte_stMAC1();
  *(undefined4 *)(puVar4 + 0x40) = uVar3;
  uVar3 = gte_stMAC2();
  *(undefined4 *)(puVar4 + 0x44) = uVar3;
  uVar3 = gte_stMAC3();
  *(undefined4 *)(puVar4 + 0x48) = uVar3;
  *(short *)(puVar4 + 0x50) = *(short *)(puVar4 + 0x30) + *(short *)(puVar4 + 0x40);
  *(short *)(puVar4 + 0x52) = *(short *)(puVar4 + 0x34) + *(short *)(puVar4 + 0x44);
  *(short *)(puVar4 + 0x54) = *(short *)(puVar4 + 0x38) + *(short *)(puVar4 + 0x48);

  // MATH_VectorNormalize
  FUN_8003d378();

  puVar1 = PTR_DAT_8008d2ac;
  iVar2 = 0;

  // if numPlyrCurrGame != 0
  if (PTR_DAT_8008d2ac[0x1ca8] != '\0')
  {
	// each InstDrawPerPlayer
	// for iVar2 = 0; iVar2 < numPlyrCurrGame; iVar2++
    do 
	{
	  // write specular values,
	  // increment loop index
      *(undefined2 *)(param_1 + 0xf4) = *(undefined2 *)(puVar4 + 0x50);
      *(undefined2 *)(param_1 + 0xf6) = *(undefined2 *)(puVar4 + 0x52);
      iVar2 = iVar2 + 1;
      *(undefined2 *)(param_1 + 0xf8) = *(undefined2 *)(puVar4 + 0x54);
	
	  // next InstDrawPerPlayer
      param_1 = param_1 + 0x88;
    
	} while (iVar2 < (int)(uint)(byte)puVar1[0x1ca8]);
  }
  return;
}


// WARNING: Could not reconcile some variable overlaps


// Vector_SpecLightSpin3D
// param_1 MATRIX
// param_2 vec3s rotation
void FUN_8005741c(int param_1,undefined4 param_2,SVECTOR *param_3)

{
  short *psVar1;
  undefined4 uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  SVECTOR *r0;
  MATRIX *r0_00;
  undefined *puVar8;
  undefined auStack136 [16];
  MATRIX aMStack120 [2];
  SVECTOR local_38 [2];
  undefined *puVar2;

  puVar8 = auStack136;

  // ConvertRotToMatrix_Transpose
  FUN_8006c378(aMStack120, param_2);

  iVar4 = 0;

  // if numPlyrCurrGame is not zero
  if (PTR_DAT_8008d2ac[0x1ca8] != '\0')
  {
    r0_00 = aMStack120;
    r0 = local_38;

	// offset of 8008d2ac for tileView buffers
	iVar7 = 0x168;

	// offset in tileView buffer array (0 for p1, 0x110 for p2, etc)
    iVar6 = 0;

    puVar2 = PTR_DAT_8008d2ac;
    iVar5 = param_1;

	// for iVar6 = 0; iVar6 < numPlyrCurrGame; iVar6++
    do
	{
	  // pointer to start of tileView buffer array
      psVar1 = (short *)(puVar2 + iVar7);

	  // Genius idea from Naughty Dog:
	  // Transpose-View + Vec3-Inverted = Inverse-Transpose-View + Vec3.

	  // tileView offset 0x68, CameraMatrix
      gte_SetLightMatrix((MATRIX *)((int)psVar1 + iVar6 + 0x68));

	  // param_3 = inverted specular light vector 
      gte_ldv0(param_3);
	  
      gte_llv0();
	  
	  // generate stack-matrix from result
      uVar3 = gte_stMAC1();
      *(undefined4 *)(puVar8 + 0x30) = uVar3;
      uVar3 = gte_stMAC2();
      *(undefined4 *)(puVar8 + 0x34) = uVar3;
      uVar3 = gte_stMAC3();
      *(undefined4 *)(puVar8 + 0x38) = uVar3;
      *(undefined2 *)(puVar8 + 0x58) = *(undefined2 *)(puVar8 + 0x30);
      *(undefined2 *)(puVar8 + 0x5a) = *(undefined2 *)(puVar8 + 0x34);
      *(undefined2 *)(puVar8 + 0x5c) = *(undefined2 *)(puVar8 + 0x38);

	  gte_SetLightMatrix(r0_00);

	  gte_ldv0((SVECTOR *)(puVar8 + 0x58));
      gte_llv0();
      uVar3 = gte_stMAC1();
      *(undefined4 *)(puVar8 + 0x30) = uVar3;
      uVar3 = gte_stMAC2();
      *(undefined4 *)(puVar8 + 0x34) = uVar3;
      uVar3 = gte_stMAC3();
      *(undefined4 *)(puVar8 + 0x38) = uVar3;
      *(undefined *)(iVar5 + 0x53) = puVar8[0x30];
      *(uint *)(iVar5 + 0x58) = (uint)*(ushort *)(puVar8 + 0x38);
      *(short *)(puVar8 + 0x50) = *(short *)(iVar5 + 0x44) - *psVar1;
      *(short *)(puVar8 + 0x52) = *(short *)(iVar5 + 0x48) - psVar1[1];
      *(short *)(puVar8 + 0x54) = *(short *)(iVar5 + 0x4c) - psVar1[2];

	  // MATH_VectorNormalize
	  FUN_8003d378(r0);

      gte_SetLightMatrix(r0_00);

	  gte_ldv0(r0);
      gte_llv0();
      uVar3 = gte_stMAC1();
      *(undefined4 *)(puVar8 + 0x40) = uVar3;
      uVar3 = gte_stMAC2();
      *(undefined4 *)(puVar8 + 0x44) = uVar3;
      uVar3 = gte_stMAC3();
      *(undefined4 *)(puVar8 + 0x48) = uVar3;
      *(short *)(puVar8 + 0x50) = *(short *)(puVar8 + 0x30) + *(short *)(puVar8 + 0x40);
      *(short *)(puVar8 + 0x52) = *(short *)(puVar8 + 0x34) + *(short *)(puVar8 + 0x44);
      *(short *)(puVar8 + 0x54) = *(short *)(puVar8 + 0x38) + *(short *)(puVar8 + 0x48);

	  // MATH_VectorNormalize
	  FUN_8003d378(r0);

      puVar2 = PTR_DAT_8008d2ac;

	  // next tileView
	  iVar7 = iVar7 + 0x110;

	  *(undefined2 *)(param_1 + 0xf4) = *(undefined2 *)(puVar8 + 0x50);

	  // next tileView
	  iVar6 = iVar6 + 0x110;

      *(undefined2 *)(param_1 + 0xf6) = *(undefined2 *)(puVar8 + 0x52);

	  // next loop index
	  iVar4 = iVar4 + 1;

	  *(undefined2 *)(param_1 + 0xf8) = *(undefined2 *)(puVar8 + 0x54);
	
	  // next InstDrawPerPlayer
      param_1 = param_1 + 0x88;
    
	} while (iVar4 < (int)(uint)(byte)puVar2[0x1ca8]);
  }
  return;
}


// Vector_SpecLightNoSpin3D
// used on flamejet
// param_1 - instance
// param_2 - inst->instDef->rot[3]
// param_3 - specLightDir
void FUN_800576b8(int param_1,undefined4 param_2,SVECTOR *param_3)

{
  short *psVar1;
  undefined4 uVar3;
  int iVar4;
  int iVar5;
  SVECTOR *r0;
  int iVar6;
  undefined *puVar7;
  undefined auStack112 [16];
  MATRIX aMStack96 [2];
  undefined *puVar2;

  puVar7 = auStack112;

  // ConvertRotToMatrix_Transpose
  FUN_8006c378(aMStack96, param_2);

  gte_SetLightMatrix(aMStack96);
  gte_ldv0(param_3);
  gte_llv0();
  uVar3 = gte_stMAC1();
  *(undefined4 *)(puVar7 + 0x30) = uVar3;
  uVar3 = gte_stMAC2();
  *(undefined4 *)(puVar7 + 0x34) = uVar3;
  uVar3 = gte_stMAC3();
  *(undefined4 *)(puVar7 + 0x38) = uVar3;
  *(undefined *)(param_1 + 0x53) = puVar7[0x30];
  puVar2 = PTR_DAT_8008d2ac;
  *(uint *)(param_1 + 0x58) = (uint)*(ushort *)(puVar7 + 0x38);
  iVar4 = 0;

  // if numPlyrCurrGame is not zero
  if (puVar2[0x1ca8] != '\0')
  {
    r0 = (SVECTOR *)(puVar7 + 0x50);
    iVar5 = 0x168;
    iVar6 = param_1;

	// for iVar3 = 0; iVar3 < numPlyrCurrGame; iVar3++
    do
	{
	  // pointer to tileView buffer
      psVar1 = (short *)(puVar2 + iVar5);

	  // direction vector from object to camera
      *(short *)(puVar7 + 0x50) = *(short *)(iVar6 + 0x44) - *psVar1;
      *(short *)(puVar7 + 0x52) = *(short *)(iVar6 + 0x48) - psVar1[1];
      *(short *)(puVar7 + 0x54) = *(short *)(iVar6 + 0x4c) - psVar1[2];

	  // MATH_VectorNormalize
      FUN_8003d378(r0);

      gte_ldv0(r0);
      gte_llv0();
      uVar3 = gte_stMAC1();
      *(undefined4 *)(puVar7 + 0x40) = uVar3;
      uVar3 = gte_stMAC2();
      *(undefined4 *)(puVar7 + 0x44) = uVar3;
      uVar3 = gte_stMAC3();
      *(undefined4 *)(puVar7 + 0x48) = uVar3;

	  // ???
      *(short *)(puVar7 + 0x50) = *(short *)(puVar7 + 0x30) + *(short *)(puVar7 + 0x40);
      *(short *)(puVar7 + 0x52) = *(short *)(puVar7 + 0x34) + *(short *)(puVar7 + 0x44);
      *(short *)(puVar7 + 0x54) = *(short *)(puVar7 + 0x38) + *(short *)(puVar7 + 0x48);

	  // MATH_VectorNormalize
	  FUN_8003d378(r0);

      puVar2 = PTR_DAT_8008d2ac;
      *(undefined2 *)(param_1 + 0xf4) = *(undefined2 *)(puVar7 + 0x50);

	  // increment offset to next tileView buffer
	  iVar5 = iVar5 + 0x110;

	  *(undefined2 *)(param_1 + 0xf6) = *(undefined2 *)(puVar7 + 0x52);

	  // loop index
      iVar4 = iVar4 + 1;

      *(undefined2 *)(param_1 + 0xf8) = *(undefined2 *)(puVar7 + 0x54);

	  // next InstDrawPerPlayer
	  param_1 = param_1 + 0x88;

	} while (iVar4 < (int)(uint)(byte)puVar2[0x1ca8]);
  }
  return;
}


// Vector_BakeMatrixTable
// called once during init, not related to spec light,
// NOP will distort the following driver animations into squishing:
// crashing, boosting, jumping, blasted
void FUN_80057884(undefined *param_1)

{
  int iVar1;
  MATRIX *r0;
  undefined *puVar2;
  VECTOR *r0_00;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  int iVar6;
  undefined **ppuVar7;
  undefined2 *puVar8;
  int iVar9;
  int *piVar10;
  int iVar11;
  uint uVar12;
  undefined *puVar13;
  undefined auStack128 [16];
  
  // another local matrix
  uint local_70;
  undefined4 local_6c;
  uint local_68;
  undefined4 local_64;
  undefined2 local_60;
  
  MATRIX localMatrix;
  VECTOR local_30;

  puVar13 = auStack128;

  // DAT_80087f28 is a constant for how many frames are in "blasted" anim

  // if function has not run
  if (DAT_8008d590 == '\0')
  {
	// remember the function has run
    DAT_8008d590 = '\x01';

    iVar11 = 0;

	// bakedGteMath[6].numEntires "blasted"
    if (0 < DAT_80087f28)
	{

	  iVar9 = 0;

	  // loop through blasted frames
	  do
	  {
		// pointer to matrix array
		// bakedGteMath[6], "blasted"
        puVar2 = PTR_DAT_80087f24;

		iVar6 = iVar11 << 0xd;

		// fail-safe to alert debugger
        if (DAT_80087f28 == 0) trap(0x1c00);
        if ((DAT_80087f28 == -1) && (iVar6 == -0x80000000)) trap(0x1800);

        *(short *)(PTR_DAT_80087f24 + iVar11 * 0x20 + 0xc) = (short)(iVar6 / DAT_80087f28);

		// fail-safe to alert debugger
		if (DAT_80087f28 == 0) trap(0x1c00);
        if ((DAT_80087f28 == -1) && (iVar9 == -0x80000000)) trap(0x1800);

		// MATH_Sin
        iVar1 = FUN_8003d184(iVar9 / DAT_80087f28);
        *(short *)(puVar2 + iVar11 * 0x20 + 8) = (short)(-iVar1 / 7);

		// fail-safe to alert debugger
        if (DAT_80087f28 == 0) trap(0x1c00);
        if ((DAT_80087f28 == -1) && (iVar6 == -0x80000000)) trap(0x1800);

		// MATH_Sin
        iVar1 = FUN_8003d184(iVar6 / DAT_80087f28);
        *(short *)(puVar2 + iVar11 * 0x20 + 0x10) = (short)((iVar1 * 6) / 0x28) + 0x1000;

		// fail-safe to alert debugger
        if (DAT_80087f28 == 0) trap(0x1c00);
        if ((DAT_80087f28 == -1) && (iVar6 == -0x80000000)) trap(0x1800);

		// MATH_Sin
        iVar1 = FUN_8003d184(iVar6 / DAT_80087f28);
        *(short *)(puVar2 + iVar11 * 0x20 + 0x14) = (short)((iVar1 * 6) / 0x28) + 0x1000;
        iVar_a0 = (undefined *)(iVar6 / DAT_80087f28);

		// fail-safe to alert debugger
        if (DAT_80087f28 == 0) trap(0x1c00);
        if ((DAT_80087f28 == -1) && (iVar6 == -0x80000000)) trap(0x1800);

		// MATH_Sin
        iVar6 = FUN_8003d184(iVar_a0);

        if (iVar6 < 0) {
          iVar6 = iVar6 + 3;
        }

		*(short *)(puVar2 + iVar11 * 0x20 + 0x10) = (short)(iVar6 >> 2) + 0x1000;

		// next index
		iVar11 = iVar11 + 1;

        iVar9 = iVar9 + 0x3000;

      } while (iVar11 < DAT_80087f28);
    }

    uVar12 = 0;

	// start of pointer table
	piVar10 = &DAT_80087ef4;

	// another local matrix
    local_70 = 0;
    local_6c = 0;
    local_68 = 0;
    local_64 = 0;
    local_60 = 0;
	
	// loop through 14 arrays
    do 
	{
	  // number of elements != 0, ptr to array != 0
      if (((piVar10[1] != 0) && (*piVar10 != 0)) && (iVar11 = 0, 0 < piVar10[1])) 
	  {
		// loop through each matrix of the array
        do 
		{
		  // &matrix[loopIndex]
          iVar9 = *piVar10 + iVar11 * 0x20;

		   // convert 3 rotation shorts into rotation matrix
          FUN_8006c2a4(&localMatrix,iVar9 + 8);

		  // another local matrix
          local_70 = local_70 & 0xffff0000 | (uint)*(ushort *)(iVar9 + 0x10);
          local_68 = local_68 & 0xffff0000 | (uint)*(ushort *)(iVar9 + 0x12);
          local_60 = *(undefined2 *)(iVar9 + 0x14);
		  
		  // MatrixRotate (param_1 = param_2 matrix rotated by param_3 matrix)
          FUN_8006c3b0(iVar9 + 8,&local_70,&localMatrix);
		  
		  // loop index
          iVar11 = iVar11 + 1;
          
		  param_1 = &localMatrix;
        } while (iVar11 < piVar10[1]);
      }
      uVar12 = uVar12 + 1;
      piVar10 = piVar10 + 2;
    } while (uVar12 < 0x14);
	
	// pointer to matrix array
	// bakedGteMath[6], "blasted"
    ppuVar7 = &PTR_DAT_80087f24;
	
	// loop index
    iVar11 = 0;
	
	// bakedGteMath[6].numEntires
    if (0 < DAT_80087f28) 
	{
      uVar5 = 0x2000;
      r0_00 = &local_30;
      uVar4 = 0xe0000000;
      uVar3 = 0;
      
	  // loop through all entries
	  do 
	  {  
		// bakedGteMath[6].physEntry (matArr06)
		puVar2 = *ppuVar7;
		
        *(undefined4 *)(puVar13 + 0x50) = 0;
        *(undefined4 *)(puVar13 + 0x54) = uVar5;
        *(undefined4 *)(puVar13 + 0x58) = 0;
		
		// &matrix[loopIndex]
        puVar8 = (undefined2 *)(puVar2 + iVar11 * 0x20);
        
		r0 = (MATRIX *)(puVar8 + 4);
        gte_SetRotMatrix(r0);
        gte_SetTransVector(r0_00);
        gte_ldVXY0(uVar4);
        gte_ldVZ0(uVar3);
        gte_rt();
        read_mt(r0,puVar2,param_1);
		
		// write result [0] [1] and [2]
        *puVar8 = (short)r0;
        puVar8[1] = (short)puVar2;
        puVar8[2] = (short)param_1;
        
		// loop index
		iVar11 = iVar11 + 1;
		
      } while (iVar11 < (int)ppuVar7[1]);
    }
  }
  return;
}


// get pointer to Scrub MetaData
int FUN_80057c44(uint param_1)

{
  int iVar1;

  iVar1 = param_1 << 4;
  if (6 < param_1) {
    iVar1 = 0;
  }
  return (int)&PTR_s_SOLID_80087f94 + iVar1;
}


// get pointer to terrain MetaData
int FUN_80057c68(uint param_1)

{
  int iVar1;

  iVar1 = param_1 << 6;
  if (0x14 < param_1) {
    iVar1 = 0;
  }
  return (int)&PTR_s_asphalt_800884cc + iVar1;
}


// VehInit_TeleportSelf
void FUN_80057c8c(int param_1,uint param_2,int param_3)

{
  byte bVar1;
  short sVar2;
  bool bVar3;
  undefined *puVar4;
  undefined uVar5;
  undefined2 uVar6;
  undefined4 uVar7;
  code *pcVar8;
  int iVar9;
  undefined *puVar10;
  uint uVar11;
  int *piVar12;
  ushort uVar13;
  int iVar14;
  int *piVar15;
  undefined2 *puVar16;
  short local_40;
  short local_3e;
  short local_3c;
  short local_38;
  short local_36;
  short local_34;
  short local_30;
  short local_2e;
  short local_2c;

  puVar4 = PTR_DAT_8008d2ac;
  puVar16 = (undefined2 *)0x0;
  bVar3 = false;
  
  // by default, dont spawn by a hub door
  piVar15 = (int *)0x0;

  // Check LEV data for nullptr
  if (*(int **)(PTR_DAT_8008d2ac + 0x160) == (int *)0x0) {
    return;
  }
  if (**(int **)(PTR_DAT_8008d2ac + 0x160) == 0) {
    return;
  }

  // ground and wall quadblock flags
  DAT_1f80012c = 0x3000;

  DAT_1f800130 = 0;
  
  // low-LOD collision (2 triangles)
  DAT_1f80012a = 0;

  // if numPlyrCurrGame is less than 3
  if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 3) 
  {
	// high-LOD collision (8 triangles)
    DAT_1f80012a = 2;
  }
  
  DAT_1f800134 = **(undefined4 **)(PTR_DAT_8008d2ac + 0x160);
  *(uint *)(PTR_DAT_8008d2ac + 8) = *(uint *)(PTR_DAT_8008d2ac + 8) & 0xffffbfff;
  puVar10 = PTR_DAT_8008d2ac;

  // if you are mask grabbed
  if ((param_2 & 1) == 0)
  {
	// Ordinary player position
    local_38 = (short)((uint)*(undefined4 *)(param_1 + 0x2d4) >> 8);
    local_36 = (short)((uint)*(undefined4 *)(param_1 + 0x2d8) >> 8) + 0x80;
    local_34 = (short)((uint)*(undefined4 *)(param_1 + 0x2dc) >> 8);
  }

  // if you are spawning into the world for the first time,
  // could be startline, or adv hub spawn in several places
  else
  {
	// spawn in front of hub door, beach-to-gemstone
    if (
			// If you are at podium after winning a Key
			(*(short *)(puVar4 + 0x2572) == 99) &&

			// If you have one boss key
			(*(int *)(puVar4 + 0x1e38) == 1)
		)
	{
      // lev number instDef
	  iVar9 = *(int *)(*(int *)(puVar4 + 0x160) + 0xc);
	  
	  // lev instDefs
      piVar15 = *(int **)(*(int *)(puVar4 + 0x160) + 0x10);
      
	  iVar14 = 0;
	  
	  // if there are instDefs
      if (0 < iVar9) 
	  {
		// waste of addition
        piVar12 = piVar15 + 3;
        
		// loop through instDefs
		do 
		{
		  // if door is found
          if (
				(
					(
						// InstDef+0xC+0xC (modelID) == 0x7a (STATIC_DOOR)
						(*(short *)(piVar12 + 0xc) == 0x7a) && 
						
						// if name == "door"
						(*piVar15 == 0x726f6f64)
					) &&
              
					// InstDef+0xC-0x8 (name) == "#5"
					(piVar12[-2] == 0x3523)
				) && 
				
				// last 8 bytes of 16-byte name, all zeros
				((piVar12[-1] == 0 && (*piVar12 == 0)))
			 
			 // then leave loop
			 ) break;
			  
		  // next InstDef
          piVar12 = piVar12 + 0x10;
          
		  // loop counter
		  iVar14 = iVar14 + 1;
		  
		  // next InstDef (0x10*4)
          piVar15 = piVar15 + 0x10;
        
		} while (iVar14 < iVar9);
		
		// if the hub door was found, because not all instDefs were checked, then go to spawn
        if (iVar14 < *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0xc)) goto code_r0x80057f18;
      }
	  
	  // no InstDef found with "door" title,
	  // so spawn outside boss door instead
      piVar15 = (int *)0x0;
    }

	// If you not at hub-door after beating Roo
    else
	{
	  // if you are at podium for winning a trophy
      if (*(short *)(PTR_DAT_8008d2ac + 0x2572) == 0x62)
	  {
		// By default, you have all 4 trophies on a hub,
		// but we are about to determine if that's true
        bVar3 = true;

		// loop counter
        iVar14 = 0;
								// Level ID
        iVar9 = (*(int *)(PTR_DAT_8008d2ac + 0x1a10) + -0x1a) * 8;

		// for iVar14 = 0; iVar14 < 4; iVar14++
		do
		{
		  // increment loop counter
          iVar14 = iVar14 + 1;

		  // 0x8fba4 is where the adventure profile (currently loaded) begins

		  // if you do not have a trophy on this track
          if (((uint)(&DAT_8008fba4)[(int)((int)*(short *)(&DAT_800840f4 + iVar9) + 6U) >> 5] >>
               ((int)*(short *)(&DAT_800840f4 + iVar9) + 6U & 0x1f) & 1) == 0)
		  {
			// record that not all 4 trophies are collected on this hub
            bVar3 = false;
            break;
          }
          iVar9 = iVar9 + 2;
        } while (iVar14 < 4);

		// if you have all 4 trophies on a hub
        if ((bVar3) &&

			// 0x8fba4 is where the adventure profile (currently loaded) begins
													// Level ID
           (((uint)(&DAT_8008fba4)[(int)(*(int *)(PTR_DAT_8008d2ac + 0x1a10) + 0x44U) >> 5] >>
             (*(int *)(PTR_DAT_8008d2ac + 0x1a10) + 0x44U & 0x1f) & 1) != 0)) {

		  // dont spawn outside boss garage
		  bVar3 = false;
        }
      }
    }
code_r0x80057f18:

	// if you just exited boss race
    if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 1) != 0)
	{
	  // spawn outside boss door
      bVar3 = true;
    }

	// if not spawning at hub door
    if (piVar15 == (int *)0x0)
	{
	  // if you want to spawn outside boss door
      if (bVar3)
	  {
		// position outside boss door
        local_38 = *(short *)(*(int *)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x144) + 0xc) +
                             0xc);
        local_36 = *(short *)(*(int *)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x144) + 0xc) +
                             0xe) + 0x80;
        local_34 = *(short *)(*(int *)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x144) + 0xc) +
                             0x10);
      }

	  // If spawning anywhere else
      else {

		 // If you're not in Adventure Arena,
		 // Therefore, if spawning at startline of race track
        if ((*(uint *)PTR_DAT_8008d2ac & 0x100000) == 0) {
LAB_80058158:
		  // get index where driver should spawn (0-7)
          bVar1 = (&DAT_8008d69c)[*(byte *)(param_1 + 0x4a)];

          // racer crossed the start line backwards,
		  // so lap doesn't count when race starts
          *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) | 0x1000000;

		  // set distToFinish_checkpoint = level -> distSpawnToFinish
          *(int *)(param_1 + 0x48c) =
               (uint)*(ushort *)(*(int *)(*(int *)(puVar10 + 0x160) + 0x14c) + 6) << 3;

		  // convert spawn index to byte index,
		  // each spawn position is 3 ints (x,y,z)
          iVar9 = (uint)bVar1 * 0xc;

		  // get position where each of the 8 drivers should spawn, from LEV
          local_38 = *(short *)(*(int *)(puVar10 + 0x160) + iVar9 + 0x6c);
          local_36 = *(short *)(*(int *)(puVar10 + 0x160) + iVar9 + 0x6e) + 0x80;
          local_34 = *(short *)(*(int *)(puVar10 + 0x160) + iVar9 + 0x70);
        }

		// if you are in adventure arena
        else
		{
		  // if no podium reward
          if (*(short *)(PTR_DAT_8008d2ac + 0x2572) == 0) {

			// ivar9 = level you were in previously
            iVar9 = *(int *)(PTR_DAT_8008d2ac + 0x1eb4);

			// if you just came from any of these...
            if (

				// main menu, or adv character garage
				((iVar9 == 0x27) || (iVar9 == 0x28)) ||

			   // nowhere?, or cutscene?
			   ((iVar9 == -1 || ((iVar9 == 0x40 || (iVar9 - 0x2cU < 0x14)))))) goto LAB_80058158;

			// get position where driver should spawn on map,
			// outside warppad they previously entered

			// AH_WarpPad_GetSpawnPosRot
			puVar16 = (undefined2 *)FUN_800abafc(&local_30);
            local_38 = local_30;
            local_36 = local_2e + 0x80;
            local_34 = local_2c;
          }

		  // if you have a podium reward
          else
		  {
			// spawn on the podium in the adv hub
            local_38 = **(short **)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x144) + 0xc);
            local_36 = *(short *)(*(int *)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x144) +
                                          0xc) + 2) + 0x80;
            local_34 = *(short *)(*(int *)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x144) +
                                          0xc) + 4);
          }
        }
      }
    }
    
	// if spawning at hub door
	else 
	{
	  // do trigonometry to take hub door 
		
      *(uint *)(PTR_DAT_8008d2ac + 8) = *(uint *)(PTR_DAT_8008d2ac + 8) | 0x4000;

	  // Cosine(angle)
	  // instDef rotY
	  iVar9 = FUN_8003d1c0((int)*(short *)(piVar15 + 0xe));

	  // Cosine(angle)
	  // instDef rotY+400 (perpendicular)
	  iVar14 = FUN_8003d1c0((int)*(short *)(piVar15 + 0xe) + 0x400);

	  // posX = 
			// instDef posX + (where door starts)
			// doorLengthX + (to get to midpoint between two doors)
			// perpendicularX (to spawn away from door)
	  local_38 = *(short *)(piVar15 + 0xc) + (short)(iVar9 * 800 >> 0xc) +
                 (short)((iVar14 << 9) >> 0xc);
				 
	  // posY = instDef posY + random height offset
      local_36 = *(short *)((int)piVar15 + 0x32) + 0x17a;

	  // Sine(angle)
	  // instDef rotY
	  iVar9 = FUN_8003d184((int)*(short *)(piVar15 + 0xe));

	  // Sine(angle)
	  // instDef rotY+400 (perpendicular)
      iVar14 = FUN_8003d184((int)*(short *)(piVar15 + 0xe) + 0x400);

	  // posZ = 
			// instDef posZ + (where door starts)
			// doorLengthZ + (to get to midpoint between two doors)
			// perpendicularZ (to spawn away from door)
	  local_34 = *(short *)(piVar15 + 0xd) + (short)(iVar9 * 800 >> 0xc) +
                 (short)((iVar14 << 9) >> 0xc);
    }
  }
  local_40 = local_38;
  local_3c = local_34;
  local_3e = local_36 + -0x100;

  // COLL_SearchTree_FindQuadblock_Touching
  FUN_8001eb0c(&local_40,&local_38,&DAT_1f800108,0);

  // if collision was not found
  if (DAT_1f800146 == 0) {
    *(undefined2 *)(param_1 + 0x370) = 0;
    *(undefined2 *)(param_1 + 0x372) = 0x1000;
    *(undefined2 *)(param_1 + 0x374) = 0;
  }

  // if it was found
  else {
    *(undefined2 *)(param_1 + 0x370) = DAT_1f800178;
    *(undefined2 *)(param_1 + 0x372) = DAT_1f80017a;
    *(undefined2 *)(param_1 + 0x374) = DAT_1f80017c;
    *(undefined4 *)(param_1 + 0x354) = DAT_1f800188;
  }

  // loop counter
  iVar14 = 0;

  // backup AxisAngle
  *(undefined2 *)(param_1 + 0x360) = *(undefined2 *)(param_1 + 0x370);
  *(undefined2 *)(param_1 + 0x368) = *(undefined2 *)(param_1 + 0x370);
  *(undefined2 *)(param_1 + 0x362) = *(undefined2 *)(param_1 + 0x372);
  *(undefined2 *)(param_1 + 0x36a) = *(undefined2 *)(param_1 + 0x372);
  *(undefined2 *)(param_1 + 0x364) = *(undefined2 *)(param_1 + 0x374);
  *(undefined2 *)(param_1 + 0x36c) = *(undefined2 *)(param_1 + 0x374);
  
  iVar9 = param_1;

  // for iVar14 = 0; iVar14 < 1; iVar14++
  do
  {
	// backup of backup of AxisAngle
    *(undefined2 *)(iVar9 + 0x378) = *(undefined2 *)(param_1 + 0x368);
    *(undefined2 *)(iVar9 + 0x37a) = *(undefined2 *)(param_1 + 0x36a);
	iVar14 = iVar14 + 1; // increment loop counter
	*(undefined2 *)(iVar9 + 0x37c) = *(undefined2 *)(param_1 + 0x36c);
    
	iVar9 = iVar9 + 8;
  
  } while (iVar14 < 1);

  // player structure X, Y, Z
  *(int *)(param_1 + 0x2d4) = (int)(short)DAT_1f800124 << 8;
  *(int *)(param_1 + 0x2d8) = (DAT_1f800124._2_2_ + param_3) * 0x100;
  *(int *)(param_1 + 0x2dc) = (int)((uint)DAT_1f800128 << 0x10) >> 8;

  // duplicate of coordinate variables
  *(undefined4 *)(param_1 + 0x2e4) = *(undefined4 *)(param_1 + 0x2d8);
  *(undefined4 *)(param_1 + 0x2e0) = *(undefined4 *)(param_1 + 0x2d4);
  *(undefined4 *)(param_1 + 0x2e8) = *(undefined4 *)(param_1 + 0x2dc);

  // save quadblock height
  *(int *)(param_1 + 0x2d0) = (int)DAT_1f800124._2_2_ << 8;

  puVar4 = PTR_DAT_8008d2ac;

  // if you are spawning into the world for the first time,
  // could be startline, or adv hub spawn in several places
  if ((param_2 & 1) != 0)
  {
    if (piVar15 == (int *)0x0)
	{
	  // if spawning outside boss door
      if (bVar3)
	  {
		// get desired rotation of driver when leaving portal, or spawning at startline
        uVar13 = *(short *)(*(int *)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x144) + 0xc) +
                           0x14) + 0x400U & 0xfff;

        *(ushort *)(param_1 + 0x2ee) = uVar13;

		// if just finished a boss race
        if ((*(uint *)(puVar4 + 8) & 1) != 0) {

		  // Level ID is citadel city
          if (*(int *)(puVar4 + 0x1a10) == 0x1d)
		  {
			// rotate 90 degrees to the right,
			// so you dont have a wall in your face
            uVar13 = uVar13 + 0x400;
          }

		  // if not...
          else
		  {
			// Level ID == 25
			// Level ID == GemStone Valley
            if ((*(int *)(puVar4 + 0x1a10) == 0x19) &&

				// If you just exited hot air skyway,
				// just finished pinstripe boss,
				// spawned by oxide's door
				(*(int *)(puVar4 + 0x1eb4) == 7)
			   )
			{
			  // use default rotation, face oxide's door
              *(ushort *)(param_1 + 0x2ee) = uVar13;

              goto LAB_80058438;
            }

			// If driver spawned to any other boss,
			// for any other reason

			// rotate 180 degrees, facing away from boss door
            uVar13 = *(short *)(param_1 + 0x2ee) + 0x800;
          }

		  // bitwise AND, do not go over 0x1000 (360 degrees)
          *(ushort *)(param_1 + 0x2ee) = uVar13 & 0xfff;
        }
LAB_80058438:
        *(uint *)(PTR_DAT_8008d2ac + 8) = *(uint *)(PTR_DAT_8008d2ac + 8) & 0xfffffffc;
      }

	  // if not outside boss door
	  else {

		// If you're not in Adventure Arena
        if ((*(uint *)PTR_DAT_8008d2ac & 0x100000) == 0)
		{
LAB_800584f8:

		  // position index on starting line
          iVar9 = (uint)(byte)(&DAT_8008d69c)[*(byte *)(param_1 + 0x4a)] * 0xc;

		  // rotation data of all 8 drivers on starting line
          *(undefined2 *)(param_1 + 0x2ec) =
               *(undefined2 *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + iVar9 + 0x72);
          sVar2 = *(short *)(*(int *)(puVar4 + 0x160) + iVar9 + 0x74);
          *(short *)(param_1 + 0x2ee) = sVar2;
          uVar6 = *(undefined2 *)(*(int *)(puVar4 + 0x160) + iVar9 + 0x76);
        }

		// if on adv hub
        else
		{
		  // podium reward
          if (*(short *)(PTR_DAT_8008d2ac + 0x2572) != 0)
		  {
			// set rotation, expecting driver to spawn on podium
            *(ushort *)(param_1 + 0x2ee) =
                 *(ushort *)
                  (*(int *)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x144) + 0xc) + 8) & 0xfff
            ;
            goto LAB_80058568;
          }


          if (
				(
					// If you just came from the main menu
					(*(int *)(PTR_DAT_8008d2ac + 0x1eb4) == 0x27) ||

					// If you just came from "nothing"
					(*(int *)(PTR_DAT_8008d2ac + 0x1eb4) == -1)

				// if WarpPad_ReturnToMap failed to find a matching portal
				) || (puVar16 == (undefined2 *)0x0))

		  // skip
		  goto LAB_800584f8;

		  // rotation data from spawning near hub warppad,
		  // after leaving a race or event
          *(undefined2 *)(param_1 + 0x2ec) = *puVar16;
          sVar2 = puVar16[1];
          *(short *)(param_1 + 0x2ee) = sVar2;
          uVar6 = puVar16[2];
        }
        *(ushort *)(param_1 + 0x2ee) = sVar2 + 0x400U & 0xfff;
        *(undefined2 *)(param_1 + 0x2f0) = uVar6;
      }
    }
    else {
      *(ushort *)(param_1 + 0x2ee) = *(short *)(piVar15 + 0xe) + 0x800U & 0xfff;
      *(uint *)(puVar4 + 8) = *(uint *)(puVar4 + 8) & 0xfffffffc;
    }
  }
LAB_80058568:

  // set speed to zero
  *(undefined2 *)(param_1 + 0x38c) = 0;

  *(undefined2 *)(param_1 + 0x38e) = 0;
  *(undefined2 *)(param_1 + 0x390) = 0;
  *(undefined2 *)(param_1 + 0x392) = 0;
  *(undefined2 *)(param_1 + 0x3b2) = 0;
  *(undefined2 *)(param_1 + 0x39a) = *(undefined2 *)(param_1 + 0x2ee);
  *(undefined2 *)(param_1 + 0x2f4) = *(undefined2 *)(param_1 + 0x2ec);
  *(undefined2 *)(param_1 + 0x2f6) = *(undefined2 *)(param_1 + 0x2ee);
  *(undefined2 *)(param_1 + 0x2f8) = *(undefined2 *)(param_1 + 0x2f0);

  if (
		(piVar15 != (int *)0x0) &&

		// if spawning into world (not mask grab)
		((param_2 & 1) != 0)
	 )
  {
	// spawn with speed (what? when does that ever happen?)
    *(undefined2 *)(param_1 + 0x38c) = 0xa00;
  }

  // set animation to zero
  *(undefined *)(*(int *)(param_1 + 0x1c) + 0x52) = 0;

  // get number of frames in animation
  uVar7 = FUN_8005b0f4(*(undefined4 *)(param_1 + 0x1c),0);

  // Instance_GetStartFrame
  uVar6 = FUN_8005b0c4(0,uVar7);

  // Animation frame
  *(undefined2 *)(*(int *)(param_1 + 0x1c) + 0x54) = uVar6;

  // Set Scale (x, y, z)
  *(undefined2 *)(*(int *)(param_1 + 0x1c) + 0x1c) = 0xccc;
  *(undefined2 *)(*(int *)(param_1 + 0x1c) + 0x1e) = 0xccc;
  *(undefined2 *)(*(int *)(param_1 + 0x1c) + 0x20) = 0xccc;

  *(undefined *)(param_1 + 0x4c) = 0;
  *(undefined *)(param_1 + 0x4d) = 0;
  *(undefined2 *)(param_1 + 0x3fc) = 0;
  *(undefined2 *)(param_1 + 0x46) = 0;
  *(undefined2 *)(param_1 + 0x48) = 0;
  *(undefined2 *)(param_1 + 0x3c6) = 0;
  *(undefined2 *)(param_1 + 0x3d2) = 0;
  *(undefined2 *)(param_1 + 0x3c8) = 0;
  *(undefined2 *)(param_1 + 0x2f2) = 0;
  *(undefined2 *)(param_1 + 0x2fa) = 0;
  *(undefined *)(param_1 + 0x4ff) = 0;
  *(undefined2 *)(param_1 + 0x40c) = 0;
  *(undefined4 *)(param_1 + 0x350) = 0;
  *(undefined4 *)(param_1 + 0x490) = 0;
  *(undefined2 *)(param_1 + 0xc) = 0;
  *(undefined *)(param_1 + 0x4fe) = 0;

  //turn off 7th and 20th bits of Actions Flag set (means ? (7) and racer is not in the air (20))
  *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) & 0xfff7ffbf;
  if ((param_2 & 2) == 0) {
    return;
  }
  iVar9 = 0xc;

  // driver -> instane -> thread -> modelIndex == "player" of any kind
  if (*(short *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x44) == 0x18)
  {
	// This erases all driver funcPtrs, 12 funcPtrs, 0x30 bytes total,
	// it is the strangest way to do it, but that's what it does

	// pointer = driver + 0x30
    iVar14 = param_1 + 0x30;

	// erase 12 (0xC) function pointers from
	// driver struct, 0x54 - 0x84 (0x30 bytes),
	// but erase them backwards
    do {
      *(undefined4 *)(iVar14 + 0x54) = 0;
      iVar9 = iVar9 + -1;
      iVar14 = iVar14 + -4;
    } while (-1 < iVar9);

	// CAM_StartOfRace
    FUN_80018d20(PTR_DAT_8008d2ac + (uint)*(byte *)(param_1 + 0x4a) * 0xdc + 0x1498);

    puVar4 = PTR_DAT_8008d2ac;

	// if you are not in cutscene and not in main menu
    if ((*(uint *)PTR_DAT_8008d2ac & 0x20002000) == 0) {
      puVar10 = (undefined *)0x0;
    }

	// if you are in cutscene or main menu
    else
	{
	  // 0x80058c44 is an empty function that does nothing
      puVar10 = &FUN_80058c44;
    }

	// driver -> instance -> thread -> funcThTick = puVar10
    *(undefined **)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x2c) = puVar10;


	// If you're not in Adventure Arena
	if ((*(uint *)puVar4 & 0x100000) == 0)
	{
	  // VehPtr_EngineRevving_Init
      pcVar8 = FUN_80067f4c;
    }

	// If you're in Adventure Arena
    else
	{
	  // VehPtr_Driving_Init
      pcVar8 = FUN_80062b74;
    }

	// set OnInit function
    *(code **)(param_1 + 0x54) = pcVar8;
  }

  // lapIndex = 0
  *(undefined *)(param_1 + 0x44) = 0;

  // numWumpa = 0
  *(undefined *)(param_1 + 0x30) = 0;

  puVar4 = PTR_DAT_8008d2ac;

  // lapTime = 0
  *(undefined4 *)(param_1 + 0x40) = 0;

  // no lap progress
  *(undefined4 *)(param_1 + 0x488) = 0;

  //turn off 21th and 26th flags of Actions Flag set
  //(means ? (21) and racer hasn't finished the race)
  *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) & 0xfdefffff;

  // If unlimited wumpa cheat is enabled
  if ((*(uint *)(puVar4 + 8) & 0x200) != 0)
  {
	// Set wumpa to 99
    *(undefined *)(param_1 + 0x30) = 99;
  }

  //set Held item to none
  *(undefined *)(param_1 + 0x36) = 0xf;

  //set Held item Quantity to 0
  *(undefined *)(param_1 + 0x37) = 0;

  puVar4 = PTR_DAT_8008d2ac;

  // collected zero C-T-R letters
  *(undefined4 *)(param_1 + 0x4cc) = 0;

  // cheat flags
  uVar11 = *(uint *)(puVar4 + 8);

  // set weaponID to mask
  uVar5 = 7;

  // if unlimited masks is disabled
  if ((uVar11 & 0x400) == 0)
  {
	// if unlimited turbos is disabled
    if ((uVar11 & 0x800) == 0)
	{
	  // set weaponID to bomb
      uVar5 = 1;

	  // if infinite bombs is disabled
      if ((uVar11 & 0x400000) == 0) goto LAB_800587cc;

	  goto LAB_800587c0;
    }

	// set weaponID to turbo
    *(undefined *)(param_1 + 0x36) = 0;
  }
  else
  {
LAB_800587c0:
	// set weaponID
    *(undefined *)(param_1 + 0x36) = uVar5;
  }

  //set Held item Quantity to 9 (Cheat related)
  *(undefined *)(param_1 + 0x37) = 9;

LAB_800587cc:
  puVar4 = PTR_DAT_8008d2ac;

  // set driver's life limit to the global life limit
  *(undefined4 *)(param_1 + 0x4e4) = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1d88);

  if (
		// If Permanent Invisibility Cheat is Enabled
		((*(uint *)(puVar4 + 8) & 0x8000) != 0) &&

		// Player / AI structure + 0x4a shows driver index (0-7)

		// driver ID must be less than numPlyrCurrGame,
		// which makes the cheat apply to players and not AIs
		(*(byte *)(param_1 + 0x4a) < (byte)puVar4[0x1ca8]))
  {
	// instance flags
    *(uint *)(*(int *)(param_1 + 0x1c) + 0x28) =
         *(uint *)(*(int *)(param_1 + 0x1c) + 0x28) & 0xfff8ffff;

	// instance flags
    *(uint *)(*(int *)(param_1 + 0x1c) + 0x28) =
         *(uint *)(*(int *)(param_1 + 0x1c) + 0x28) | 0x60000;

	// invisible timer
    *(undefined4 *)(param_1 + 0x28) = 0x2d00;
  }


  // If Super Engine Cheat is enabled
  if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x10000) != 0) {
    *(undefined2 *)(param_1 + 0x38) = 0x2d00;
  }
  return;
}


// VehInit_TeleportAll
void FUN_80058898(undefined4 param_1,uint param_2)

{
  // pointer to player address
  int iVar1;

  // iteration counter
  int iVar2;
  iVar2 = 0;

  do
  {
	// address of player structure, idk which
    iVar1 = *(int *)(PTR_DAT_8008d2ac + ((iVar2 << 0x10) >> 0xe) + 0x24ec);

	// if player structure is not nullptr
    if (iVar1 != 0)
	{
	  // driver -> instance -> thread -> modelIndex == "robotcar" of any kind
      if (*(short *)(*(int *)(*(int *)(iVar1 + 0x1c) + 0x6c) + 0x44) == 0x3f)
	  {
		// BOTS_GotoStartingLine
        FUN_8001702c();
      }
      else
	  {
		// VehInit_TeleportSelf (startline)
        FUN_80057c8c(iVar1,param_2 | 1,0);
      }
    }

	// increment loop iteration counter
    iVar2 = iVar2 + 1;

  } while (iVar2 * 0x10000 >> 0x10 < 8);
  return;
}


// Driver_SearchModelByString
int * FUN_80058948(int *param_1)

{
  int *piVar1;
  int **ppiVar2;
  int *piVar3;
  int iVar4;

  piVar3 = (int *)0x0;

  // loop counter
  iVar4 = 0;

  // array to character models loaded,
  // maximum of 4, used in VS mode
  ppiVar2 = (int **)&DAT_80083a10;

  // for iVar4 = 0; iVar4 < 3; iVar4++
  do {

	// dereference model pointer
    piVar1 = *ppiVar2;

	// if model pointer exists,
	// check first 16 bytes of model
	// for a matching string
    if (
			(
				(
					// if model pointer exists
					(piVar1 != (int *)0x0) &&

					// 0-3
					(*piVar1 == *param_1)
				) &&

				// 4-7
				(piVar1[1] == param_1[1])
			) &&
			(
				(
					// 8-11
					piVar1[2] == param_1[2] &&

					// 12-15
					(piVar1[3] == param_1[3])
				)
			)
		)
	{
	  // character found, return pointer
      return piVar1;
    }

	// loop counter
    iVar4 = iVar4 + 1;

	// pointer to next model
    ppiVar2 = ppiVar2 + 1;

  } while (iVar4 < 3);

  if (
		// if PLYROBJECTLIST is not nullptr
		(DAT_8008d870 != (int **)0x0) &&

		// make sure elements of PLYROBJECTLIST are valid
		(piVar3 = *DAT_8008d870, piVar3 != (int *)0x0)

		)
  {
	// PLYROBJECTLIST, used for arcade (6-8 players)
    ppiVar2 = DAT_8008d870;

	// loop until all strings are checked (until current is not nullptr)
    do
	{
	  // if model pointer exists,
	  // check first 16 bytes of model
	  // for a matching string
	  if (
			(
				(
					// if model exists
					(*piVar3 == *param_1) &&

					// 0-3
					(piVar3[1] == param_1[1])
				) &&

				// 4-7
				(piVar3[2] == param_1[2])
			) &&

			// 8-11
			(piVar3[3] == param_1[3])
		 )
	  {
	    // character found, return pointer
        return piVar3;
      }

	  // increment pointer
      ppiVar2 = ppiVar2 + 1;

	  // set to pointer
      piVar3 = *ppiVar2;

    } while (piVar3 != (int *)0x0);
  }
  return piVar3;
}



// VehInit_SetConsts(driver*), based on driver class
void FUN_80058a60(int param_1)
{

  uint uVar1;
  int iVar2;
  uint uVar3;
  int iVar4;

  // loop counter
  uVar3 = 0;

  // array of structure indexes
  // 0x80088A0C
  iVar4 = -0x7ff775f4;

  // 0x1c * loop counter
  iVar2 = 0;

  // for uVar3 = 0; uVar3 < 0x41 (65); uVar3++
  do {

	// Get the size of the variable
    uVar1 = *(uint *)(iVar4 + 8);

	// If variable size == 2 bytes
    if (uVar1 == 2) {

      // *(2 bytes *) (driver + metaPhys[i]->driverOffset) =
      *(undefined2 *)(param_1 + *(int *)(iVar4 + 4)) =

         // *(2 bytes *) (metaPhys[i]->value[meta[charID].engineID])
        *(undefined2 *)(&DAT_80088a18 + *(int *)(&DAT_80086d90 + (int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)] * 0x10) * 4 + iVar2);
    }

    // if variable size != 2 bytes
    else {

      // if variable size < 3 bytes
      if (uVar1 < 3) {


		    // If variable size == 1 byte
        if (uVar1 == 1) {

          // *(1 byte *) (driver + metaPhys[i]->driverOffset) =
          *(undefined *)(param_1 + *(int *)(iVar4 + 4)) =

            // *(byte *) (metaPhys[i]->value[meta[charID].engineID])
            (&DAT_80088a18)[*(int *)(&DAT_80086d90 + (int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)] * 0x10) * 4 + iVar2];
        }

		/*
		Sep3
		else
			printf("**error** invalid phys size \'%s\' %ld\n",*puVar3,puVar3[2]);
		*/

      }

      // if variable size >= 3 bytes
      else {

        // if variable size == 4 bytes
        if (uVar1 == 4) {

          // *(4 bytes *) (driver + metaPhys[i]->driverOffset) =
          *(undefined4 *)(param_1 + *(int *)(iVar4 + 4)) =

            // *(4 bytes *) (metaPhys[i]->value[meta[charID].engineID])
            *(undefined4 *) (&DAT_80088a18 + *(int *)(&DAT_80086d90 + (int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)] * 0x10) * 4 + iVar2);
        }
      }
    }

	// array of structure indexes += 0x1C
	iVar4 = iVar4 + 0x1c;

	// loop counter
	uVar3 = uVar3 + 1;

	iVar2 = iVar2 + 0x1c;

  } while (uVar3 < 0x41);

  return;
}

// VehInit_EngineAudio_AllPlayers
void FUN_80058ba4(void)

{
  uint uVar1;
  int iVar2;

  // pointer to first Player thread
  iVar2 = *(int *)(PTR_DAT_8008d2ac + 0x1b2c);

  // while pointer is valid
  while (iVar2 != 0)
  {
	// Player / AI structure + 0x4a shows driver index (0-7)

	// thread -> driver -> driverID
    uVar1 = (uint)*(byte *)(*(int *)(iVar2 + 0x30) + 0x4a);

	// Initialize car engine sound
    FUN_80028880(

		// engineID from metadata, given characterID
		*(int *)(&DAT_80086d90 + (int)(short)(&DAT_80086e84)[uVar1] * 0x10) * 4 + uVar1 &
        0xffff,0x8080);

	// go to next Player in linked list
	iVar2 = *(int *)(iVar2 + 0x10);
  }
  return;
}

#if 0
// intentionally left empty, not a ghidra fail,
// This is inside "#if 0" because it is not
// a function on it's own, it is a pointer to
// the last 8 bytes of the previous function
void FUN_80058c44()
{
	return;
}
#endif


// initialize driver tires
void FUN_80058c4c(int param_1)

{
  undefined *puVar1;
  int iVar2;
  int *piVar3;

  puVar1 = PTR_DAT_8008d2ac;

  // thread -> driver object
  piVar3 = *(int **)(param_1 + 0x30);

  // IconGroup* tireAnim
  iVar2 = *(int *)(PTR_DAT_8008d2ac + 0x2114);

  // wheel scale
  *(undefined2 *)(piVar3 + 1) = 0xccc;

  // wheelSprites = tireAnim->icons
  *piVar3 = iVar2 + 0x14;

  if (
		// Player / AI structure + 0x4a shows driver index (0-7)

		// if character ID is oxide
		((&DAT_80086e84)[*(byte *)((int)piVar3 + 0x4a)] == 0xf) &&

		// Level ID != 39
		// Not in Main Menu
		(*(int *)(puVar1 + 0x1a10) != 0x27)
     )
  {
    *(undefined2 *)(piVar3 + 1) = 0;
  }

  piVar3[2] = 0x2e808080;
  *(undefined2 *)(piVar3 + 0xef) = 0xa00;

  // item held to 0xF (nothing)
  *(undefined *)((int)piVar3 + 0x36) = 0xf;

  // related to engine sound
  *(undefined *)((int)piVar3 + 0x47b) = 2;

  *(undefined2 *)((int)piVar3 + 0x362) = 0x1000;
  *(undefined2 *)((int)piVar3 + 0x36a) = 0x1000;
  *(undefined2 *)((int)piVar3 + 0x412) = 0x600;
  *(undefined2 *)((int)piVar3 + 0x3e6) = 10000;

  // terrain meta
  iVar2 = FUN_80057c68(10);
  piVar3[0xd6] = iVar2;

  // get number of lives in battle
  iVar2 = *(int *)(PTR_DAT_8008d2ac + 0x1d80);

  // 0x4e8
  // team in battle mode
  piVar3[0x13a] = (uint)*(byte *)((int)piVar3 + 0x4a);

  *(undefined2 *)(piVar3 + 0x13c) = 0xffff;
  *(undefined2 *)(piVar3 + 0x13d) = 0xffff;

  // 0x4e4
  // player lives in battle mode
  piVar3[0x139] = iVar2;

  return;
}

// Init NonGhost Driver
// param1 is thread
// param2 is driverID (0-7)
void FUN_80058d2c(int param_1,int param_2)

{
  short sVar1;
  undefined *puVar2;
  undefined4 uVar3;
  int iVar4;
  int iVar5;

  // model index = DYNAMIC_PLAYER,
  // AI will override this right after
  // the end of the function
  *(undefined2 *)(param_1 + 0x44) = 0x18;

  // unknown thread variables?
  *(undefined2 *)(param_1 + 0x42) = 0x40;
  *(undefined4 *)(param_1 + 0x38) = 0x1000;
  *(undefined2 *)(param_1 + 0x3e) = 0x40;

  // get pointer to game config
  puVar2 = PTR_DAT_8008d2ac;

  // unknown thread variables?
  *(undefined2 *)(param_1 + 0x3c) = 0;
  *(undefined2 *)(param_1 + 0x40) = 0;

  // get object from thread
  iVar5 = *(int *)(param_1 + 0x30);

  // by default, get ID of first character
  sVar1 = DAT_80086e84;

  // if you are not in the main menu
  if ((*(uint *)puVar2 & 0x2000) == 0)
  {
	// get ID of character, given param2
    sVar1 = (&DAT_80086e84)[param_2];
  }

  // Driver_SearchModelByString
  uVar3 = FUN_80058948((&PTR_s_crash_80086d84)[(int)sVar1 * 4]);

  // INSTANCE_Birth3D -- ptrModel, name, thread
  uVar3 = FUN_8003086c(uVar3,uVar3,param_1);

  // get pointer to game config
  puVar2 = PTR_DAT_8008d2ac;

  // give instance to thread
  *(undefined4 *)(param_1 + 0x34) = uVar3;

  // Ptr Model "Wake"
  iVar4 = *(int *)(puVar2 + 0x226c);

  // if "Wake" exists
  if (iVar4 != 0)
  {
	// INSTANCE_Birth3D -- ptrModel, name, thread
    iVar4 = FUN_8003086c(iVar4,iVar4,0);

	// pointer to "Wake" instance
    *(int *)(iVar5 + 0x4f8) = iVar4;

	// instance flags
	if (iVar4 != 0)
	{
	  // make invisible, set to anim 1
      *(uint *)(iVar4 + 0x28) = *(uint *)(iVar4 + 0x28) | 0x90;
    }

	// sep 3
	// else
    // player %d wake create failed
  }

  /*
  sep 3
  else
  printf("wake not in level\n");
  */

  // get instance from thread
  iVar4 = *(int *)(param_1 + 0x34);

  // if driverID is less than numPlyrCurrGame,
  // "If driver belongs to human player"
  if (param_2 < (int)(uint)(byte)PTR_DAT_8008d2ac[0x1ca8])
  {
	// thread flag
    *(uint *)(iVar4 + 0x28) = *(uint *)(iVar4 + 0x28) | 0x4000000;
  }

  // give driverID to driver
  *(undefined *)(iVar5 + 0x4a) = (char)param_2;

  // give instance to driver
  *(int *)(iVar5 + 0x1c) = iVar4;

  // initialize tire data
  FUN_80058c4c(param_1);

  // VehInit_SetConsts(driver*), based on driver class
  FUN_80058a60(iVar5);

  // if you are not in cutscene and not in main menu
  if ((*(uint *)PTR_DAT_8008d2ac & 0x20002000) != 0)
  {
	// funcThTick
	// 0x80058c44 is an empty function that does nothing
    *(undefined4 *)(param_1 + 0x2c) = 0x80058c44;

	// make invisible
    *(uint *)(iVar4 + 0x28) = *(uint *)(iVar4 + 0x28) | 0x80;
  }
  return;
}

// VehInit_Player
struct Driver* FUN_80058ec0(int param_1)

{
  char cVar1;
  int iVar2;
  struct Driver* iVar3;

  // s_player_8008d614
  // "player"

  // THREAD_BirthWithObject
  // 0x62c = size
  // 0 = no relation to param4
  // 0x100 flag = LargeStackPool
  // 0 = player thread bucket
  iVar2 = FUN_8004205c(0x62c0100,0,s_player_8008d614,0);

  // Get player pointer from the thread
  iVar3 = *(int *)(iVar2 + 0x30);

  // player Driver is 0x62C bytes large
  memset(iVar3,0,0x62c);

  // Init NonGhost Driver
  FUN_80058d2c(iVar2,param_1);

  // Get Team that player chose from Battle Setup menu
  cVar1 = PTR_DAT_8008d2ac[param_1 + 0x1da4];

  // VehPtr_Driving_Init
  *(undefined4 *)(iVar3 + 0x54) = 0x80062b74;

  // Battle Team that the player is on
  *(int *)(iVar3 + 0x4e8) = (int)cVar1;

  return iVar3;
}


// param1 is current rotation
// param2 is speed of rotation
// param3 is desired rotation
// Rotation Interpolation
int FUN_80058f54(int param_1,int param_2,int param_3)

{
  int iVar1;
  int iVar2;

  // if desired rotation is less than current
  if (param_3 < param_1)
  {
	// subtract current by a rate of "speed"
    iVar2 = param_1 - param_2;

	// if new rotation is less than desired
    if (param_1 - param_2 < param_3)
	{
	  // Just use desired rotation
      return param_3;
    }
  }

  // if desired rotation is not less than current
  else
  {
	// make a copy of current
    iVar1 = param_1;
    if (
		// desired <= current,
		// we know desired is not less than current,
		// so this really checks if it is current
		(param_3 <= param_1) ||
		(
			// copy desired
			iVar2 = param_3,

			// add to rotation at rate of "speed"
			iVar1 = param_1 + param_2,

			// if new rotation overshoots desired,
			// probably should say >=
			param_1 + param_2 <= param_3)
		)
	{
	  // if current = desired
	  // if current is overshot past desired

	  // current = desired
      iVar2 = iVar1;
    }
  }

  // return new current
  return iVar2;
}


// Map value from [oldMin, oldMax] to [newMin, newMax]
// inverting newMin and newMax will give an inverse range mapping
int FUN_80058f9c(int param_1,int param_2,int param_3,int param_4,int param_5)
{
  int iVar1;

  // if value is lessor equal than oldMin, return newMin
  if (param_1 <= param_2) {
    return param_4;
  }

  // if value is less than old Max
  if (param_1 < param_3)
  {

	// distance from old min, multiplied by new range
    iVar1 = (param_1 - param_2) * (param_5 - param_4);

	// get range of first min and max
    param_3 = param_3 - param_2;

	// if min === max, crash
	if (param_3 == 0) {
      trap(0x1c00);
    }

	// if min is less than max, crash
    if ((param_3 == -1) && (iVar1 == -0x80000000)) {
      trap(0x1800);
    }

	// new min, plus [...] / old range
    return param_4 + iVar1 / param_3;
  }

  // return new max
  return param_5;
}


// Player_SteerAccel
undefined4
FUN_8005900c(int param_1,int param_2,int param_3,undefined4 param_4,undefined4 param_5,
            undefined4 param_6)

{
  // Crash Bandicoot:
  // param_2: 0x4	SteerAccel_Stage2_FirstFrame
  // param_3: 0x8	SteerAccel_Stage2_FrameLength
  // param_4: 0x40	SteerAccel_Stage4_FirstFrame
  // param_5: 0x800	SteerAccel_Stage1_MinSteer
  // param_6: 0xC00	SteerAccel_Stage1_MaxSteer
	
  // Steering Stage 1,
  // if first 4 frames of steering
  // increase steer acceleration as time passes
  if (param_1 < param_2) 
  {

	// map "frame" from [0,4] -> [0x800,0xC00]

    // Map value from [oldMin, oldMax] to [newMin, newMax]
    // inverting newMin and newMax will give an inverse range mapping
    param_6 = FUN_80058f9c(param_1, 0,param_2, param_5,param_6);
  }
  
  else 
  {
	// Steering Stage 3
	// frames 12+
	// decrease steer acceleration as time passes
    if (param_2 + param_3 < param_1) 
	{
	  // map "frame" from [12,64] -> [0xC00,0]

      // Map value from [oldMin, oldMax] to [newMin, newMax]
      // inverting newMin and newMax will give an inverse range mapping
      param_6 = FUN_80058f9c(param_1, param_2 + param_3,param_4, param_6,0);
    }
  }
  
  // Steering Stage 2,
  // next 0x8 frames (frame 4 to 12)
  // max steer accel of 0xC00
  return param_6;
  
  // Steering Stage 4,
  // part of Stage 3's mapping,
  // for all steering after frame 64,
  // steer acceleration is zero, so 
  // angular velocity is constant
}


// if you're interested in learning about the algorithm:
// https://en.wikipedia.org/wiki/Integer_square_root#Digit-by-digit_algorithm

// f(n, i) = sqrt(n<<i)
// FastSqrt(n, i)
uint FUN_80059070(uint param_1,uint param_2)
/*
  f(n, 0) will always output the sqrt(n)

  the idea for this function is to first computer the length of the square root in numbers of bits,
  and then test each bit and see if it belongs to the square root. if so, keep the bit, otherwise discard.
*/


{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;

  // result
  uVar5 = 0;

  // uVar4 = x + 1
  uVar4 = 1;

  // last_approximation = 0
  uVar6 = 0;

  uVar3 = 1 << (param_2 & 0x1f);

  /* what this is doing is picking the least x that 4^x >= n
    notice that:
      4^x = n
      log_4(n) = x
      log_2(n) / log_2(4) = x
      log_2(n) / 2 = x
      x = log_2(sqrt(n))

      in order words, x is the length in bits of the square root of n
  */
  while ((uVar3 < param_1 && (uVar3 << 2 != 0))) {
    uVar4 = uVar4 + 1;
    uVar3 = uVar3 << 2;
  }

  uVar1 = 1 << (uVar4 + (param_2 - 1) & 0x1f);

  // while 4^x != 0
  while (uVar3 != 0) {

    // current_approximation = result << x + 1
    uVar2 = uVar5 << (uVar4 & 0x1f);

    if ((int)uVar4 < 0) {
      uVar2 = uVar5 >> (-uVar4 & 0x1f);
    }

    // current_approximation = (result << x + 1) + last_approximation + current_bit_squared
    uVar2 = uVar2 + uVar6 + uVar3;

    // if current_approximation <= n
    if (uVar2 <= param_1) {

      // result += current_bit
      uVar5 = uVar5 + uVar1;

      // last_approximation = current_approximation
      uVar6 = uVar2;
    }

    // current_bit /= 2
    uVar1 = uVar1 >> 1;

    // current_bit_squared /= 4
    uVar3 = uVar3 >> 2;

    // (x + 1) -= 1
    uVar4 = uVar4 - 1;
  }
  return uVar5;
}


// VehParticle_Exhaust
int FUN_80059100(int param_1,int *param_2,int *param_3)

{
  int iVar1;
  undefined *puVar2;
  int iVar3;

  if (
		// if driver is not using invisibility powerup
		(*(int *)(param_1 + 0x28) == 0) &&

		// if driver -> instSelf -> instFlags & INVISIBLE is false
		((*(uint *)(*(int *)(param_1 + 0x1c) + 0x28) & 0x80) == 0)
	 )
  {
	// If you're in 1P mode
	// high LOD exhaust
    puVar2 = (undefined *)0x80089224;

	// if numPlyrCurrGame is less than 3
    if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 3) {

	  // if numPlyrCurrGame is more than 1
      if (1 < (byte)PTR_DAT_8008d2ac[0x1ca8]) {

		// really only happens if numPlyrCurrGame is 2
		// med LOD exhaust
        puVar2 = (undefined *)0x80089344;
      }
    }

	// if numPlyrCurrGame is 3 or 4
    else
	{
	  // low LOD exhaust
      puVar2 = &DAT_80089464;
    }

	// driver -> instance -> thread -> modelIndex == "robotcar" of any kind
    if (*(short *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x44) == 0x3f)
	{
	  // low LOD exhaust
      puVar2 = &DAT_80089464;
    }
    iVar3 = 1;

	// driver -> instance -> flags
    if (((*(uint *)(*(int *)(param_1 + 0x1c) + 0x28) & 0x2000) != 0) &&
       ((param_2[1] - param_3[1]) + *(int *)(param_1 + 0x2d8) < 0x100))
	{
      iVar3 = 7;

	  // exhaust when you're underwater,
	  // which makes bubbles comes out
      puVar2 = &DAT_80089128;
    }

	// Create instance in particle pool
    iVar1 = FUN_80040308(0,*(undefined4 *)(PTR_DAT_8008d2ac + iVar3 * 4 + 0x2114),puVar2);

	// if particle exists
    if (iVar1 != 0)
	{
	  // posX
      *(int *)(iVar1 + 0x24) = *(int *)(iVar1 + 0x24) + (*param_2 - *param_3);

	  // velX
	  *(undefined2 *)(iVar1 + 0x28) = *(undefined2 *)param_3;

	  // posY
	  *(int *)(iVar1 + 0x2c) = *(int *)(iVar1 + 0x2c) + (param_2[1] - param_3[1]);

	  // velY
	  *(undefined2 *)(iVar1 + 0x30) = *(undefined2 *)(param_3 + 1);

	  // posZ
      *(int *)(iVar1 + 0x34) = *(int *)(iVar1 + 0x34) + (param_2[2] - param_3[2]);

	  // velZ
	  *(undefined2 *)(iVar1 + 0x38) = *(undefined2 *)(param_3 + 2);

	  *(undefined *)(iVar1 + 0x18) = *(undefined *)(*(int *)(param_1 + 0x1c) + 0x50);

	  // driver->instSelf
      *(undefined4 *)(iVar1 + 0x20) = *(undefined4 *)(param_1 + 0x1c);

	  if (iVar3 == 7)
	  {
		// Particle_FuncPtr_ExhaustUnderwater
        *(undefined4 *)(iVar1 + 0x1c) = 0x8003ee20;
      }

	  // if engine revving
	  if (*(char *)(param_1 + 0x376) == '\x04')
	  {
        if (*(char *)(param_1 + 0x4fe) != '\x01') {
          return iVar1;
        }
      }

	  // if not engine revving
	  else {
        if ((int)*(short *)(param_1 + 0x3dc) < 0x81) {
          return iVar1;
        }
        if ((int)(((uint)*(byte *)(param_1 + 0x477) + 2) * 0x20) < (int)*(short *)(param_1 + 0x3dc))
        {
          return iVar1;
        }
      }
      *(ushort *)(iVar1 + 0x12) = *(ushort *)(iVar1 + 0x12) & 0xff9f | 0x40;
    }
  }
  else {
    iVar1 = 0;
  }
  return iVar1;
}


// VehParticle_Sparks_Ground
void FUN_80059344(int param_1,undefined4 param_2)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  int iVar11;
  int iVar12;
  int iVar13;

  setCopReg(2,0,0);
  setCopReg(2,0x800,0xffffe800);

  // rtv0     cop2 $0486012  v0 * rotmatrix
  copFunction(2,0x486012);

  iVar4 = getCopReg(2,0xc800);
  iVar5 = getCopReg(2,0xd000);
  iVar6 = getCopReg(2,0xd800);
  setCopReg(2,0,0x1800);
  setCopReg(2,0x800,0);

  // rtv0     cop2 $0486012  v0 * rotmatrix
  copFunction(2,0x486012);

  iVar13 = getCopReg(2,0xc800);
  iVar12 = getCopReg(2,0xd000);
  iVar11 = getCopReg(2,0xd800);
  setCopReg(2,0,0);
  setCopReg(2,0x800,0xfffffe00);

  // rtv0     cop2 $0486012  v0 * rotmatrix
  copFunction(2,0x486012);

  uVar10 = getCopReg(2,0xc800);
  uVar9 = getCopReg(2,0xd000);
  uVar8 = getCopReg(2,0xd800);
  iVar7 = 10;
  do
  {
	// Create instance in particle pool
    iVar1 = FUN_80040308(0,*(undefined4 *)(PTR_DAT_8008d2ac + 0x2114),param_2);

    if (iVar1 != 0)
	{
	  // RNG
      uVar2 = FUN_8006c684(PTR_DAT_8008d2ac + 0x252c);
      uVar3 = uVar2 & 0x7ff;
      if ((uVar2 & 1) != 0) {
        uVar3 = -uVar3;
      }

	  // velocity variables
      *(short *)(iVar1 + 0x28) =
           *(short *)(iVar1 + 0x28) + (short)uVar10 + (short)((int)(uVar3 * iVar13) >> 0xc);
      *(short *)(iVar1 + 0x30) =
           *(short *)(iVar1 + 0x30) + (short)uVar9 + (short)((int)(uVar3 * iVar12) >> 0xc);
      *(short *)(iVar1 + 0x38) =
           *(short *)(iVar1 + 0x38) + (short)uVar8 + (short)((int)(uVar3 * iVar11) >> 0xc);

	  // position variables
	  *(int *)(iVar1 + 0x24) = *(int *)(iVar1 + 0x24) + iVar4 + *(short *)(iVar1 + 0x28);
      *(int *)(iVar1 + 0x2c) = *(int *)(iVar1 + 0x2c) + iVar5 + *(short *)(iVar1 + 0x30);
      *(int *)(iVar1 + 0x34) = *(int *)(iVar1 + 0x34) + iVar6 + *(short *)(iVar1 + 0x38);

	  // driver -> instSelf
      *(undefined4 *)(iVar1 + 0x20) = *(undefined4 *)(param_1 + 0x1c);

	  *(undefined *)(iVar1 + 0x18) = *(undefined *)(*(int *)(param_1 + 0x1c) + 0x50);
    }
    iVar7 = iVar7 + -1;
  } while (iVar7 != 0);
  return;
}


// VehParticle_Terrain_Ground
void FUN_80059558(int param_1,undefined4 param_2)

{
  int iVar1;
  int iVar2;
  undefined4 uVar3;
  int iVar4;
  int iVar5;
  undefined4 uVar6;
  int iVar7;
  undefined4 uVar8;

  //if racer is on the ground and not in accel prevention
  if (((*(uint *)(param_1 + 0x2c8) & 1) != 0) && ((*(uint *)(param_1 + 0x2c8) & 8) == 0)) {
    iVar1 = (int)*(short *)(param_1 + 0x39e);
    if (iVar1 < 0) {
      iVar1 = -iVar1;
    }
    if (iVar1 < 0x300) {
      iVar1 = (int)*(short *)(param_1 + 0x38e);
      if (iVar1 < 0) {
        iVar1 = -iVar1;
      }
      if (iVar1 < 0x300) {
        return;
      }
    }
    iVar1 = 2;
    if (*(char *)(param_1 + 0x376) == '\x02') {
      iVar1 = 4;
    }
    while (iVar1 != 0) {
      if (iVar1 == 3) {
        setCopReg(2,0,0xa001e);
        uVar3 = 0x28;
        setCopReg(2,0x800,0x28);
      }
      else {
        if (iVar1 < 4) {
          if (iVar1 == 2) {
            setCopReg(2,0,0xaffe2);
            uVar3 = 0xffffffec;
            setCopReg(2,0x800,0xffffffec);
          }
          else {
LAB_80059674:
            setCopReg(2,0,0xa001e);
            uVar3 = 0xffffffec;
            setCopReg(2,0x800,0xffffffec);
          }
        }
        else {
          if (iVar1 != 4) goto LAB_80059674;
          setCopReg(2,0,0xaffe2);
          uVar3 = 0x28;
          setCopReg(2,0x800,0x28);
        }
      }

	  // rtv0     cop2 $0486012  v0 * rotmatrix
      copFunction(2,0x486012);

	  iVar4 = getCopReg(2,0xc800);
      iVar5 = getCopReg(2,0xd000);
      iVar7 = getCopReg(2,0xd800);

	  // Create instance in particle pool
      iVar2 = FUN_80040308(0,*(undefined4 *)(PTR_DAT_8008d2ac + 0x2114),param_2,uVar3);

	  if (iVar2 != 0)
	  {
		// position variables
        *(int *)(iVar2 + 0x24) = *(int *)(iVar2 + 0x24) + iVar4 * 0x100;
        *(int *)(iVar2 + 0x2c) = *(int *)(iVar2 + 0x2c) + iVar5 * 0x100;
        *(int *)(iVar2 + 0x34) = *(int *)(iVar2 + 0x34) + iVar7 * 0x100;

		setCopReg(2,0,CONCAT22(*(undefined2 *)(iVar2 + 0x30),*(undefined2 *)(iVar2 + 0x28)));
        setCopReg(2,0x800,(uint)*(ushort *)(iVar2 + 0x38));

		// rtv0     cop2 $0486012  v0 * rotmatrix
		copFunction(2,0x486012);

		uVar3 = getCopReg(2,0xc800);
        uVar6 = getCopReg(2,0xd000);
        uVar8 = getCopReg(2,0xd800);
        *(undefined2 *)(iVar2 + 0x28) = (short)uVar3;
        *(undefined2 *)(iVar2 + 0x30) = (short)uVar6;
        *(undefined2 *)(iVar2 + 0x38) = (short)uVar8;

		// driver -> instSelf
		*(undefined4 *)(iVar2 + 0x20) = *(undefined4 *)(param_1 + 0x1c);

        *(undefined *)(iVar2 + 0x18) = *(undefined *)(*(int *)(param_1 + 0x1c) + 0x50);
      }
      iVar1 = iVar1 + -1;
    }
  }
  return;
}

// VehParticle_Sparks_Wall
// param_1 is driver struct
// param_2 is always 0x800896c8, particle data for sparks
void FUN_80059780(int param_1,undefined4 param_2)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  undefined4 uVar7;
  uint uVar8;
  undefined4 uVar9;
  uint uVar10;
  undefined4 uVar11;

  if (*(short *)(param_1 + 0x39e) == 0) {
    iVar1 = (int)*(short *)(param_1 + 0x38e);
    if (iVar1 < 0) {
      iVar1 = -iVar1;
    }
    if (0x200 < iVar1) goto LAB_800597d0;
  }
  else {
LAB_800597d0:

	// if time against wall is less than 15 seconds
    if (*(short *)(param_1 + 0x50) < 0x1c2)
	{
	  // both gamepad vibration
      FUN_80026440(param_1,8,0);
      FUN_800264c0(param_1,8,0x7f);

	  // increment time against wall
	  *(short *)(param_1 + 0x50) = *(short *)(param_1 + 0x50) + 1;

	  goto LAB_80059818;
    }
  }

  // reset time against wall to zero
  *(undefined2 *)(param_1 + 0x50) = 0;

LAB_80059818:
  if (*(short *)(param_1 + 0x38e) < 0x201) {
    if (-0x201 < *(short *)(param_1 + 0x38e)) {
      return;
    }
    setCopReg(2,0,0xa00de00);
    setCopReg(2,0x800,0xffffec00);
    setCopReg(2,0x1000,0xa002200);
    setCopReg(2,0x1800,0xffffec00);
  }
  else {
    setCopReg(2,0,0xa00de00);
    setCopReg(2,0x800,0x2800);
    setCopReg(2,0x1000,0xa002200);
    setCopReg(2,0x1800,0x2800);
  }

  // rtv0     cop2 $0486012  v0 * rotmatrix
  copFunction(2,0x486012);

  uVar6 = getCopReg(2,0xc800);
  uVar8 = getCopReg(2,0xd000);
  uVar10 = getCopReg(2,0xd800);

  // rtv1     cop2 $048E012  v1 * rotmatrix
  copFunction(2,0x48e012);

  // get result
  uVar3 = getCopReg(2,0xc800);
  uVar4 = getCopReg(2,0xd000);
  uVar5 = getCopReg(2,0xd800);
  
  setCopControlWord(2,0x4000,uVar6 & 0xffff | uVar8 << 0x10);
  setCopControlWord(2,0x4800,uVar10 & 0xffff | uVar3 << 0x10);
  setCopControlWord(2,0x5000,uVar4 & 0xffff | uVar5 << 0x10);
  
  // ldv0 vec3(driver->0x384) - vec3(driver->posCurr)
  // direction from driver to the point of collision with wall
  setCopReg(2,0,(int)*(short *)(param_1 + 900) * 0x100 - *(int *)(param_1 + 0x2d4) & 0xffffU |
                ((int)*(short *)(param_1 + 0x386) * 0x100 - *(int *)(param_1 + 0x2d8)) * 0x10000);
  setCopReg(2,0x800,(int)*(short *)(param_1 + 0x388) * 0x100 - *(int *)(param_1 + 0x2dc));

  // llv0     cop2 $04A6012  v0 * light matrix
  copFunction(2,0x4a6012);

  iVar1 = getCopReg(2,0xc800);
  iVar2 = getCopReg(2,0xd000);
  if (iVar1 < iVar2) {
    uVar6 = uVar3;
    uVar8 = uVar4;
    uVar10 = uVar5;
  }

  // Create instance in particle pool
  iVar1 = FUN_80040308(0,*(undefined4 *)(PTR_DAT_8008d2ac + 0x2114),param_2);

  if (iVar1 != 0)
  {
	// position variables
    *(int *)(iVar1 + 0x24) = *(int *)(iVar1 + 0x24) + uVar6;
    *(int *)(iVar1 + 0x34) = *(int *)(iVar1 + 0x34) + uVar10;
    *(int *)(iVar1 + 0x2c) = *(int *)(iVar1 + 0x2c) + uVar8;

    setCopReg(2,0,CONCAT22(*(undefined2 *)(iVar1 + 0x30),*(undefined2 *)(iVar1 + 0x28)));
    setCopReg(2,0x800,(uint)*(ushort *)(iVar1 + 0x38));

	// rtv0     cop2 $0486012  v0 * rotmatrix
	copFunction(2,0x486012);

	uVar7 = getCopReg(2,0xc800);
    uVar9 = getCopReg(2,0xd000);
    uVar11 = getCopReg(2,0xd800);
	
    *(undefined2 *)(iVar1 + 0x28) = (short)uVar7;
    *(undefined2 *)(iVar1 + 0x30) = (short)uVar9;
    *(undefined2 *)(iVar1 + 0x38) = (short)uVar11;

	// driver -> instSelf
    *(undefined4 *)(iVar1 + 0x20) = *(undefined4 *)(param_1 + 0x1c);
  }
  return;
}


// VehParticle_DriverMain (calls all other SpawnParticle functions)
void FUN_80059a18(int param_1,int param_2)

{
  undefined uVar1;
  byte bVar2;
  short sVar3;
  short sVar4;
  short sVar5;
  short sVar6;
  short sVar7;
  short sVar8;
  short sVar9;
  short sVar10;
  short sVar11;
  short sVar12;
  ushort uVar13;
  int iVar14;
  int iVar15;
  uint uVar16;
  undefined4 uVar17;
  undefined2 uVar18;
  undefined4 uVar19;
  int iVar20;
  undefined4 uVar21;
  int iVar22;
  char cVar23;
  int iVar24;
  undefined4 local_50;
  undefined4 local_4c;
  undefined4 local_48;
  undefined4 local_40;
  undefined4 local_3c;
  undefined4 local_38;
  uint local_30;

  // driver -> terrain meta
  iVar22 = *(int *)(param_2 + 0x358);

  // get instance from thread
  iVar24 = *(int *)(param_1 + 0x34);

  // backup previous frame's skidmark flags, in the upper bits of itself
  *(int *)(param_2 + 0x2c4) = (*(uint *)(param_2 + 0x2c4) & 0xfffff) << 4;
  
  *(byte *)(param_2 + 0xc3) = *(char *)(param_2 + 0xc3) - 1U & 7;
  local_30 = *(uint *)(iVar22 + 4);
  sVar3 = *(short *)(iVar22 + 0x30);

  // thread -> modelIndex == "player" of any kind
  if (*(short *)(param_1 + 0x44) == 0x18) {
    iVar20 = -1;
    //if racer is on the ground and (?)
    if (((*(uint *)(param_2 + 0x2c8) & 1) != 0) && ((local_30 & 0x20) == 0)) {
      iVar20 = (int)*(short *)(iVar22 + 0x32);
    }
    iVar15 = (int)*(short *)(param_2 + 0x38e);
    if (iVar15 < 0) {
      iVar15 = -iVar15;
    }

    // Map value from [oldMin, oldMax] to [newMin, newMax]
    // inverting newMin and newMax will give an inverse range mapping
    iVar14 = FUN_80058f9c(iVar15,0,5000,0,200);

    iVar15 = (int)*(short *)(param_2 + 0x38e);
    if (iVar15 < 0) {
      iVar15 = -iVar15;
    }

    // Map value from [oldMin, oldMax] to [newMin, newMax]
    // inverting newMin and newMax will give an inverse range mapping
    iVar15 = FUN_80058f9c(iVar15,0,12000,0x6c,0xd2);

	// distortion
    uVar16 = iVar15 << 8;

	// if echo is required
    if ((*(uint *)(param_2 + 0x2c8) & 0x10000) != 0)
	{
	  // add echo
      uVar16 = uVar16 | 0x1000000;
    }

	// driver audio
    FUN_8002e690(param_2 + 0x304,iVar20,

		// volume
		iVar14 << 0x10 |

		// distortion
		uVar16 |

		// L/R
		0x80);

	// If this is human and not an AI
    if ((*(uint *)(param_2 + 0x2c8) & 0x100000) == 0)
	{
	  // get speedApprox
      iVar20 = (int)*(short *)(param_2 + 0x38e);

	  // absolute value
      if (iVar20 < 0) {
        iVar20 = -iVar20;
      }

	  // if speed high enough
      if (0x200 < iVar20)
	  {
		// both gamepad vibration
        FUN_80026440(param_2,(uint)*(byte *)(iVar22 + 0x2c),(uint)*(byte *)(iVar22 + 0x2d));
        FUN_80026540(param_2,(uint)*(byte *)(iVar22 + 0x2e),(uint)*(byte *)(iVar22 + 0x2f));
      }

      //if racer started touching the ground in this frame
      if ((*(uint *)(param_2 + 0x2c8) & 2) != 0) {
        iVar20 = (int)*(short *)(param_2 + 0x392);
        if (iVar20 < 0) {
          iVar20 = -iVar20;
        }

        if (0x1600 < iVar20)
		{
		  // gamepad vibration
          FUN_800264c0(param_2,3,0xff);
        }
      }
    }
  }

  // if numPlyrCurrGame is less than 2
  if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 2)
  {
    iVar20 = (int)*(short *)(param_2 + 0x38c);
    if (iVar20 < 0) {
      iVar20 = -iVar20;
    }
    if (
			// high speed
			(0x500 < iVar20) &&

			// current terrain
			(*(char *)(param_2 + 0xc2) == '\x0e')
		)
	{

	  // number of particles
	  iVar20 = 10;

	  //if racer didn't start touching the ground in this frame
      if ((*(uint *)(param_2 + 0x2c8) & 2) == 0)
	  {
		// Create instance in particle pool (land jump in mud)
        iVar20 = FUN_80040308(0,*(undefined4 *)(PTR_DAT_8008d2ac + 0x2148),&DAT_8008980c);

		if (iVar20 != 0) {
          *(undefined *)(iVar20 + 0x18) = *(undefined *)(*(int *)(param_2 + 0x1c) + 0x50);

		  // driver -> instSelf
          *(undefined4 *)(iVar20 + 0x20) = *(undefined4 *)(param_2 + 0x1c);

		  // driverID
          uVar1 = *(undefined *)(param_2 + 0x4a);

          *(int *)(iVar20 + 0x24) = *(int *)(iVar20 + 0x24) + (int)*(short *)(iVar20 + 0x28) * 0x10;

		  // driverID
		  *(undefined *)(iVar20 + 0x19) = uVar1;

          *(int *)(iVar20 + 0x34) = *(int *)(iVar20 + 0x34) + (int)*(short *)(iVar20 + 0x38) * 0x10;
          *(short *)(iVar20 + 0x2a) = *(short *)(iVar20 + 0x2a) - (*(short *)(iVar20 + 0x28) >> 4);
          *(short *)(iVar20 + 0x3a) = *(short *)(iVar20 + 0x3a) - (*(short *)(iVar20 + 0x38) >> 4);
        }
      }

      else
	  {
        do
		{
		  // Create instance in particle pool (mud)
          iVar15 = FUN_80040308(0,*(undefined4 *)(PTR_DAT_8008d2ac + 0x2148),&DAT_8008980c);
          if (iVar15 != 0) {
            *(undefined *)(iVar15 + 0x18) = *(undefined *)(*(int *)(param_2 + 0x1c) + 0x50);

			// driver -> instSelf
            *(undefined4 *)(iVar15 + 0x20) = *(undefined4 *)(param_2 + 0x1c);

            uVar1 = *(undefined *)(param_2 + 0x4a);
            *(int *)(iVar15 + 0x24) =
                 *(int *)(iVar15 + 0x24) + (int)*(short *)(iVar15 + 0x28) * 0x10;
            *(undefined *)(iVar15 + 0x19) = uVar1;
            *(int *)(iVar15 + 0x34) =
                 *(int *)(iVar15 + 0x34) + (int)*(short *)(iVar15 + 0x38) * 0x10;
            *(short *)(iVar15 + 0x2a) = *(short *)(iVar15 + 0x2a) - (*(short *)(iVar15 + 0x28) >> 4)
            ;
            *(short *)(iVar15 + 0x3a) = *(short *)(iVar15 + 0x3a) - (*(short *)(iVar15 + 0x38) >> 4)
            ;
          }

		  // loop count
          iVar20 = iVar20 + -1;

        } while (iVar20 != 0);
      }
    }

	// if numPlyrCurrGame is less than 2 (useless if?)
    if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 2)
	{
      //if racer started touching the ground in this frame
      if (((local_30 & 0x40) != 0) && ((*(uint *)(param_2 + 0x2c8) & 2) != 0)) {

		// get speedApprox
		iVar20 = (int)*(short *)(param_2 + 0x38e);

		// absolute value
		if (iVar20 < 0) {
          iVar20 = -iVar20;
        }

		// if speed is high enough
        if (0x600 < iVar20) {
          iVar20 = (int)*(short *)(param_2 + 0x392);
          if (iVar20 < 0) {
            iVar20 = -iVar20;
          }
          if (0x1600 < iVar20) 
		  {
			// instance -> matrix
			r0 = (MATRIX *)(iVar24 + 0x30);
			gte_SetRotMatrix(r0);
			gte_SetTransMatrix(r0);

			// VehParticle_Sparks_Ground
            FUN_80059344(param_2,&DAT_80089584);
          }
        }
      }

	  // if terrain  has particle data
      if (*(int *)(iVar22 + 0x18) != 0)
	  {
		// instance -> matrix
		r0 = (MATRIX *)(iVar24 + 0x30);
		gte_SetRotMatrix(r0);
		gte_SetTransMatrix(r0);

		// particles even frame
		iVar20 = *(int *)(iVar22 + 0x1c);

		// if data is invalid, or odd-number frame
        if ((iVar20 == 0) || ((*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 1) == 0))
		{
		  // particles odd frame
          iVar20 = *(int *)(iVar22 + 0x18);
        }

		// VehParticle_Terrain_Ground
		FUN_80059558(param_2,iVar20);
      }

      if (
			// if wall rubbing right now
			(*(short *)(param_2 + 0x3fe) == 0xf0) &&

			// if you are not being mask grabbed
			(*(char *)(param_2 + 0x376) != '\x05')
		  )
	  {
		// instance -> matrix
		r0 = (MATRIX *)(iVar24 + 0x30);
		gte_SetRotMatrix(r0);
		gte_SetTransMatrix(r0);

		// VehParticle_Sparks_Wall
		FUN_80059780(param_2,&DAT_800896c8);

		uVar21 = 0x14;

		// increase engine volume
        sVar12 = *(short *)(param_2 + 0x496) + 0x14;
        *(short *)(param_2 + 0x496) = sVar12;

		// max engine volume
        if (0xff < sVar12) {
          *(undefined2 *)(param_2 + 0x496) = 0xff;
        }
      }

	  // if being mask grabbed
      else
	  {
        if (*(short *)(param_2 + 0x3fe) == 0)
		{
		  // reset time against wall
          *(undefined2 *)(param_2 + 0x50) = 0;
        }

		// decrease engine volume
        uVar13 = *(short *)(param_2 + 0x496) - 0x14;
        *(ushort *)(param_2 + 0x496) = uVar13;

		// minimum engine volume
        if ((int)((uint)uVar13 << 0x10) < 0) {
          *(undefined2 *)(param_2 + 0x496) = 0;
        }

        uVar21 = 0x14;
        if (*(short *)(param_2 + 0x496) == 0) {
          uVar21 = 0xffffffff;
        }
      }

	  // thread -> modelIndex == "player" of any kind
      if (*(short *)(param_1 + 0x44) == 0x18)
	  {
		// volume
        uVar16 = (int)*(short *)(param_2 + 0x496) << 0x10;

		// if echo is not requierd
        if ((*(uint *)(param_2 + 0x2c8) & 0x10000) == 0)
		{
		  // volume, distortion, left/right
          uVar16 = uVar16 | 0x8080;
        }

		// if echo
        else
		{
		  // add echo, volume, distortion, left/right
          uVar16 = uVar16 | 0x1008080;
        }

		// driver audio
        FUN_8002e690(param_2 + 0x308,uVar21,uVar16);
      }
    }
  }
  if ((local_30 & 8) != 0)
  {
	// driver is drifting (0x1000)
	// driver is skidding (0x800)
    *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) | 0x1800;
  }
  bVar2 = *(byte *)(param_2 + 0x4c);
  if (bVar2 == 1) {
    //turn on 12th bit of Actions Flag set (means racer is leaving skid marks)
    *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) | 0x800;
LAB_8005a094:
    //turn off 13th bit of Actions Flag set (means racer is not drifting)
    *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) & 0xffffefff;
  }
  else {
    if ((bVar2 != 0) && (bVar2 < 4)) goto LAB_8005a094;
  }

  //if racer is not on the ground, not leaving skid marks on front or back tires
  if (((*(uint *)(param_2 + 0x2c8) & 1) == 0) || ((*(uint *)(param_2 + 0x2c8) & 0x1800) == 0)) {
LAB_8005a73c:

	// if driver sound exists
    if (*(int *)(param_2 + 0x300) != 0)
	{
	  // OtherFX_Stop1
      FUN_80028808();

	  // erase sound
      *(undefined4 *)(param_2 + 0x300) = 0;
    }
  }

  // if driver is on ground, and leaving skidmarks (or drift)
  else
  {
	// get speedApprox
    iVar22 = (int)*(short *)(param_2 + 0x38e);

	// absolute value
    if (iVar22 < 0) {
      iVar22 = -iVar22;
    }

	// if speed is low
    if (iVar22 < 0x201) goto LAB_8005a73c;

	// if speed is high

	// thread -> modelIndex == "player" of any kind
    if (*(short *)(param_1 + 0x44) == 0x18) {
      iVar20 = (int)*(char *)(param_2 + 0x4b);
      if (iVar20 < 0) {
        iVar20 = -iVar20;
      }

      // Map value from [oldMin, oldMax] to [newMin, newMax]
      // inverting newMin and newMax will give an inverse range mapping
      iVar15 = FUN_80058f9c(iVar22,2000,12000,0x14,0xaa);

	  // approxSpeed
      iVar22 = (int)*(short *)(param_2 + 0x38e);

	  // absolute value
      if (iVar22 < 0) {
        iVar22 = -iVar22;
      }

      // Map value from [oldMin, oldMax] to [newMin, newMax]
      // inverting newMin and newMax will give an inverse range mapping
      iVar22 = FUN_80058f9c(iVar22,2000,12000,0x92,0x78);

	  if (*(char *)(param_2 + 0x376) == '\x02') {
        iVar14 = (int)*(short *)(param_2 + 0x3d4);
        if (iVar14 < 0) {
          iVar14 = -iVar14;
        }
        iVar22 = iVar22 - iVar14;
        if (iVar22 < 0) {
          iVar22 = 0;
        }
      }
      iVar22 = iVar22 + iVar20;
      if (0x92 < iVar22) {
        iVar22 = 0x92;
      }

	  // distortion
      uVar16 = iVar22 << 8;

      // if echo is required
      if ((*(uint *)(param_2 + 0x2c8) & 0x10000) != 0)
	  {
		// add echo
        uVar16 = uVar16 | 0x1000000;
      }

	  FUN_8002e690(

			// driver audio
			param_2 + 0x300,

			(int)sVar3,

			// volume
			(iVar15 + (iVar20 >> 1)) * 0x10000 |

			// echo + distort
			uVar16 |

			// L/R with no safeguard
			0x80U - ((int)((uint)*(byte *)(param_2 + 0x4b) << 0x18) >> 0x1a));
    }
    if ((*(uint *)(iVar24 + 0x28) & 0x2000) == 0) {
      cVar23 = *(char *)(iVar24 + 0x50);
    }
    else {
      cVar23 = *(char *)(iVar24 + 0x51);
    }
    cVar23 = cVar23 + '\x02';

	// Cosine(angle)
    FUN_8003d1c0((int)*(short *)(param_2 + 0x396));

	// Sine(angle)
	iVar22 = FUN_8003d184((int)*(short *)(param_2 + 0x396));

	// Cosine(angle)
	iVar20 = FUN_8003d1c0((int)*(short *)(param_2 + 0x396));

	// Sine(angle)
	FUN_8003d184((int)*(short *)(param_2 + 0x396));

	// Cosine(angle)
	iVar15 = FUN_8003d1c0((int)*(short *)(param_2 + 0x396));

	// Sine(angle)
	FUN_8003d184((int)*(short *)(param_2 + 0x396));

	// Cosine(angle)
	FUN_8003d1c0((int)*(short *)(param_2 + 0x396));

	// Sine(angle)
	iVar14 = FUN_8003d184((int)*(short *)(param_2 + 0x396));

	// instance -> matrix
	r0 = (MATRIX *)(iVar24 + 0x30);
	gte_SetRotMatrix(r0);
	gte_SetTransMatrix(r0);
	
    sVar3 = (short)(iVar15 * 10 >> 0xc);
    sVar12 = (short)(iVar14 * -10 >> 0xc);
    sVar6 = (short)(iVar15 * 10 >> 0xd);
    sVar7 = (short)(iVar14 * -10 >> 0xd);
    sVar10 = (short)(iVar22 * 0xf >> 0xc);
    sVar11 = (short)(iVar20 * 0xf >> 0xc);
    sVar8 = (short)(iVar22 * 0xf >> 0xd);
    sVar9 = (short)(iVar20 * 0xf >> 0xd);
	
    // front wheel skids
    if ((*(uint *)(param_2 + 0x2c8) & 0x800) != 0) 
	{
	  // enable skidmarks for first tire
      *(uint *)(param_2 + 0x2c4) = *(uint *)(param_2 + 0x2c4) | 1;
      
	  // ldv0
	  setCopReg(2,0,0xffe2);
      setCopReg(2,0x800,0xffffffec);

	  // rtv0tr   cop2 $0480012  v0 * rotmatrix + tr vector
      copFunction(2,0x480012);

	  // get result
      uVar21 = getCopReg(2,0xc800);
      uVar19 = getCopReg(2,0xd000);
      uVar17 = getCopReg(2,0xd800);
	  
      sVar4 = (short)uVar21 - sVar8;
	  
	  // skidmark index (0-7)
      bVar2 = *(byte *)(param_2 + 0xc3);
	  
      sVar5 = (short)uVar17 - sVar9;
      iVar22 = param_2 + (uint)bVar2 * 0x40;
      
	  // store to skidmark buffer
	  *(short *)(iVar22 + 0xc4) = sVar4 + sVar3;
      *(short *)(iVar22 + 200) = sVar5 + sVar12;
      *(short *)(iVar22 + 0xcc) = sVar4 - sVar3;
	  
      uVar18 = (undefined2)uVar19;
      *(undefined2 *)(iVar22 + 0xc6) = uVar18;
      *(undefined2 *)(iVar22 + 0xce) = uVar18;
      *(short *)(iVar22 + 0xd0) = sVar5 - sVar12;
      *(char *)(iVar22 + 0xca) = cVar23;
      if ((local_30 & 8) == 0) {
        *(undefined *)(iVar22 + 0xcb) = 0;
      }
      else {
        *(undefined *)(iVar22 + 0xcb) = 1;
      }
	  
	  // previous skidmark index
      uVar16 = (uint)bVar2 - 1 & 7;
      iVar22 = param_2 + uVar16 * 0x40;
	  
	  // record skidmark buffer
      *(short *)(iVar22 + 0xc4) = sVar4 + sVar10 + sVar6;
      *(undefined2 *)(iVar22 + 0xc6) = uVar18;
      *(short *)(iVar22 + 200) = sVar5 + sVar11 + sVar7;
      *(short *)(iVar22 + 0xcc) = (sVar4 + sVar10) - sVar6;
      *(undefined2 *)(iVar22 + 0xce) = uVar18;
      *(short *)(iVar22 + 0xd0) = (sVar5 + sVar11) - sVar7;
      *(char *)(iVar22 + 0xca) = cVar23;
	  
      if ((local_30 & 8) == 0) {
        *(undefined *)(iVar22 + 0xcb) = 0;
      }
      else {
        *(undefined *)(iVar22 + 0xcb) = 1;
      }
	  
	  // enable skidmarks for second tire
      *(uint *)(param_2 + 0x2c4) = *(uint *)(param_2 + 0x2c4) | 2;
	  
	  // ldv0
      setCopReg(2,0,0x1e);
      setCopReg(2,0x800,0xffffffec);

	  // rtv0tr   cop2 $0480012  v0 * rotmatrix + tr vector
      copFunction(2,0x480012);

	  // get result
      uVar21 = getCopReg(2,0xc800);
      uVar19 = getCopReg(2,0xd000);
      uVar17 = getCopReg(2,0xd800);
	  
	  // next skidmark index
      uVar16 = uVar16 + 1 & 7;
      sVar4 = (short)uVar21 - sVar8;
      sVar5 = (short)uVar17 - sVar9;
      iVar22 = param_2 + uVar16 * 0x40;
	  
	  // skidmark data
      *(short *)(iVar22 + 0xd4) = sVar4 + sVar3;
      *(short *)(iVar22 + 0xd8) = sVar5 + sVar12;
      *(short *)(iVar22 + 0xdc) = sVar4 - sVar3;
      uVar18 = (undefined2)uVar19;
      *(undefined2 *)(iVar22 + 0xd6) = uVar18;
      *(undefined2 *)(iVar22 + 0xde) = uVar18;
      *(short *)(iVar22 + 0xe0) = sVar5 - sVar12;
      *(char *)(iVar22 + 0xda) = cVar23;
      if ((local_30 & 8) == 0) {
        *(undefined *)(iVar22 + 0xdb) = 0;
      }
      else {
        *(undefined *)(iVar22 + 0xdb) = 1;
      }
	  
	  // previous skidmark index
      iVar22 = param_2 + (uVar16 - 1 & 7) * 0x40;
	  
      *(short *)(iVar22 + 0xd4) = sVar4 + sVar10 + sVar6;
      *(undefined2 *)(iVar22 + 0xd6) = uVar18;
      *(short *)(iVar22 + 0xd8) = sVar5 + sVar11 + sVar7;
      *(short *)(iVar22 + 0xdc) = (sVar4 + sVar10) - sVar6;
      *(undefined2 *)(iVar22 + 0xde) = uVar18;
      *(short *)(iVar22 + 0xe0) = (sVar5 + sVar11) - sVar7;
      *(char *)(iVar22 + 0xda) = cVar23;
      if ((local_30 & 8) == 0) {
        *(undefined *)(iVar22 + 0xdb) = 0;
      }
      else {
        *(undefined *)(iVar22 + 0xdb) = 1;
      }
    }
	
    // back wheel skids
    if ((*(uint *)(param_2 + 0x2c8) & 0x1000) != 0) 
	{
	  // enable skidmarks for third tire
      *(uint *)(param_2 + 0x2c4) = *(uint *)(param_2 + 0x2c4) | 4;
      
	  // ldv0
	  setCopReg(2,0,0xffe2);
      setCopReg(2,0x800,0x28);

	  // rtv0tr   cop2 $0480012  v0 * rotmatrix + tr vector
      copFunction(2,0x480012);

      uVar21 = getCopReg(2,0xc800);
      uVar19 = getCopReg(2,0xd000);
      uVar17 = getCopReg(2,0xd800);
	  
      sVar4 = (short)uVar21 - sVar8;
      bVar2 = *(byte *)(param_2 + 0xc3);
      sVar5 = (short)uVar17 - sVar9;
      iVar22 = param_2 + (uint)bVar2 * 0x40;
      *(short *)(iVar22 + 0xe4) = sVar4 + sVar3;
      *(short *)(iVar22 + 0xe8) = sVar5 + sVar12;
      *(short *)(iVar22 + 0xec) = sVar4 - sVar3;
      uVar18 = (undefined2)uVar19;
      *(undefined2 *)(iVar22 + 0xe6) = uVar18;
      *(undefined2 *)(iVar22 + 0xee) = uVar18;
      *(short *)(iVar22 + 0xf0) = sVar5 - sVar12;
      *(char *)(iVar22 + 0xea) = cVar23;
      if ((local_30 & 8) == 0) {
        *(undefined *)(iVar22 + 0xeb) = 0;
      }
      else {
        *(undefined *)(iVar22 + 0xeb) = 1;
      }
	  
	  // next skidmark buffer
      uVar16 = (uint)bVar2 - 1 & 7;
      iVar22 = param_2 + uVar16 * 0x40;
	  
      *(short *)(iVar22 + 0xe4) = sVar4 + sVar10 + sVar6;
      *(undefined2 *)(iVar22 + 0xe6) = uVar18;
      *(short *)(iVar22 + 0xe8) = sVar5 + sVar11 + sVar7;
      *(short *)(iVar22 + 0xec) = (sVar4 + sVar10) - sVar6;
      *(undefined2 *)(iVar22 + 0xee) = uVar18;
      *(short *)(iVar22 + 0xf0) = (sVar5 + sVar11) - sVar7;
      *(char *)(iVar22 + 0xea) = cVar23;
      if ((local_30 & 8) == 0) {
        *(undefined *)(iVar22 + 0xeb) = 0;
      }
      else {
        *(undefined *)(iVar22 + 0xeb) = 1;
      }
	  
	  // enable skidmarks for fourth tire
      *(uint *)(param_2 + 0x2c4) = *(uint *)(param_2 + 0x2c4) | 8;
	  
	  // ldv0
      setCopReg(2,0,0x1e);
      setCopReg(2,0x800,0x28);

	  // rtv0tr   cop2 $0480012  v0 * rotmatrix + tr vector
      copFunction(2,0x480012);

	  uVar21 = getCopReg(2,0xc800);
      uVar19 = getCopReg(2,0xd000);
      uVar17 = getCopReg(2,0xd800);
	  
	  // next skidmark buffer
      uVar16 = uVar16 + 1 & 7;
	  
      sVar8 = (short)uVar21 - sVar8;
      sVar9 = (short)uVar17 - sVar9;
      iVar22 = param_2 + uVar16 * 0x40;
      *(short *)(iVar22 + 0xf4) = sVar8 + sVar3;
      *(short *)(iVar22 + 0xf8) = sVar9 + sVar12;
      *(short *)(iVar22 + 0xfc) = sVar8 - sVar3;
      uVar18 = (undefined2)uVar19;
      *(undefined2 *)(iVar22 + 0xf6) = uVar18;
      *(undefined2 *)(iVar22 + 0xfe) = uVar18;
      *(short *)(iVar22 + 0x100) = sVar9 - sVar12;
      *(char *)(iVar22 + 0xfa) = cVar23;
      if ((local_30 & 8) == 0) {
        *(undefined *)(iVar22 + 0xfb) = 0;
      }
      else {
        *(undefined *)(iVar22 + 0xfb) = 1;
      }
      iVar22 = param_2 + (uVar16 - 1 & 7) * 0x40;
      *(short *)(iVar22 + 0xf4) = sVar8 + sVar10 + sVar6;
      *(undefined2 *)(iVar22 + 0xf6) = uVar18;
      *(short *)(iVar22 + 0xf8) = sVar9 + sVar11 + sVar7;
      *(short *)(iVar22 + 0xfc) = (sVar8 + sVar10) - sVar6;
      *(undefined2 *)(iVar22 + 0xfe) = uVar18;
      *(short *)(iVar22 + 0x100) = (sVar9 + sVar11) - sVar7;
      *(char *)(iVar22 + 0xfa) = cVar23;
      if ((local_30 & 8) == 0) {
        *(undefined *)(iVar22 + 0xfb) = 0;
      }
      else {
        *(undefined *)(iVar22 + 0xfb) = 1;
      }
    }
  }

  // thread -> modelIndex == "robotcar" of any kind
  if (*(short *)(param_1 + 0x44) == 0x3f)
  {
    if (
			// put each driver on alternates frames of 4 (0,1,2,3)
			(*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 3) !=
			((uint)*(byte *)(param_2 + 0x4a) & 3)
		)

	goto LAB_8005a9d8;
	LAB_8005a858:

	if (*(char *)(param_2 + 0x381) != '\0') goto LAB_8005a868;
  }

  // else if "player"???
  else {
    if (
		(*(char *)(param_2 + 0x4fe) == '\x02') ||
		(
			(
				// If numPlyrCurrGame is more than 1
				// If this is a multiplayer game
				1 < (byte)PTR_DAT_8008d2ac[0x1ca8] &&
				(
					(
						(
							// If numPlyrCurrGame is not 2
							PTR_DAT_8008d2ac[0x1ca8] != 2 ||
							(
								// for 2P mode, make driver skids on alternating frames (0 or 1)
								(*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 1) != (uint)*(byte *)(param_2 + 0x4a)
							)
						) &&
						(
							// for 3P or 4P mode, make skids on alternating frames of 4 (0,1,2,3)
							(*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 3) != (uint)*(byte *)(param_2 + 0x4a))
						)
				)
			)
		)
	   )
    goto LAB_8005a9d8;
    if (*(char *)(param_2 + 0x381) == '\0') {
      if (
			(
				((int)*(short *)(param_2 + 0x3dc) < 0x81) ||

				(
					(int)(((uint)*(byte *)(param_2 + 0x477) + 2) * 0x20) <
					(int)*(short *)(param_2 + 0x3dc)
				)
			) &&

			(	
				// THREAD_SearchForModel(thread->childThread, turbo fire)
				iVar22 = FUN_80042394(*(undefined4 *)(param_1 + 0x14),0x2c),

				// result found
				iVar22 != 0
			)
		 )
	  {
		goto LAB_8005a9d8;
      }
	  goto LAB_8005a858;
    }
LAB_8005a868:
    *(char *)(param_2 + 0x381) = *(char *)(param_2 + 0x381) + -1;
  }
  
  // gte_setRotMatrix
  setCopControlWord(2,0,*(undefined4 *)(iVar24 + 0x30));
  setCopControlWord(2,0x800,*(undefined4 *)(iVar24 + 0x34));
  setCopControlWord(2,0x1000,*(undefined4 *)(iVar24 + 0x38));
  setCopControlWord(2,0x1800,*(undefined4 *)(iVar24 + 0x3c));
  setCopControlWord(2,0x2000,*(undefined4 *)(iVar24 + 0x40));
  
  // ldv0
  setCopReg(2,0,0x4000000);
  setCopReg(2,0x800,0xfffffc00);

  // rtv0     cop2 $0486012  v0 * rotmatrix
  copFunction(2,0x486012);

  local_40 = getCopReg(2,0xc800);
  local_3c = getCopReg(2,0xd000);
  local_38 = getCopReg(2,0xd800);
  
  // ldv0
  setCopReg(2,0,(int)*(short *)(iVar24 + 0x1c) * 9 >> 3 & 0xffffU |
                ((int)*(short *)(iVar24 + 0x1e) * 7 >> 1) << 0x10);
  setCopReg(2,0x800,(int)*(short *)(iVar24 + 0x20) * -0x38 >> 4);

  // rtv0     cop2 $0486012  v0 * rotmatrix
  copFunction(2,0x486012);

  local_50 = getCopReg(2,0x19);
  local_4c = getCopReg(2,0x1a);
  local_48 = getCopReg(2,0x1b);

  // VehParticle_Exhaust
  FUN_80059100(param_2,&local_50,&local_40);

  // ldv0
  setCopReg(2,0,(int)*(short *)(iVar24 + 0x1c) * -0x12 >> 4 & 0xffffU |
                ((int)*(short *)(iVar24 + 0x1e) * 7 >> 1) << 0x10);
  setCopReg(2,0x800,(int)*(short *)(iVar24 + 0x20) * -0x38 >> 4);

  // rtv0     cop2 $0486012  v0 * rotmatrix
  copFunction(2,0x486012);

  local_50 = getCopReg(2,0x19);
  local_4c = getCopReg(2,0x1a);
  local_48 = getCopReg(2,0x1b);

  // VehParticle_Exhaust
  FUN_80059100(param_2,&local_50,&local_40);

LAB_8005a9d8:

  // if driver is burnt
  if (*(short *)(param_2 + 0x402) != 0)
  {
    *(undefined2 *)(param_2 + 0x508) = 0x1000;

	// set alpha to max (draws black)
    *(undefined2 *)(*(int *)(param_2 + 0x1c) + 0x22) = 0x1000;
  }

  // if driver is invisible
  if (*(int *)(param_2 + 0x28) != 0)
  {
	// set transparency to max
    *(undefined2 *)(iVar24 + 0x22) = 0x1000;
  }

  //if racer is not driving normally and not drifting
  if ((*(char *)(param_2 + 0x376) != '\0') && (*(char *)(param_2 + 0x376) != '\x02'))
  {
    //turn off 20th bit of Actions Flag set (means racer is not in the air)
    *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) & 0xfff7ffff;
  }

  //if racer is being mask grabbed or repositioned, or is on the ground
  if (((uint)*(byte *)(param_2 + 0x376) - 4 < 2) || ((*(uint *)(param_2 + 0x2c8) & 1) != 0))
  {
	// GAMEPAD_Vib_2
	FUN_800263fc(param_2,0x27,0);

	if (*(short *)(param_2 + 0x3d4) == 0) {
      return;
    }
    if ((*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 3) == 0) {
      uVar21 = 0x27;
    }
    else {
      uVar21 = 0xf0;
    }
    uVar17 = 0x100;
  }
  else {
    if (*(short *)(param_2 + 0x3fc) < 0x80) {
      uVar21 = 0x12;
      if ((*(char *)(param_2 + 0x4b) < '\0') || (uVar21 = 0x22, '\0' < *(char *)(param_2 + 0x4b)))
	  {
		// GAMEPAD_Vib_1
        FUN_800263a0(param_2,uVar21,0x20);
      }
    }
    uVar21 = 0;
    uVar17 = uVar21;
  }

  // GAMEPAD_Vib_2
  FUN_800263fc(param_2,uVar21,uVar17);

  return;
}


// param1 - driver
// param2 - speed cap
// Turbo_Audio
void FUN_8005ab24(int param_1,int param_2)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;

  // if turbo audio cooldown is not done
  if (*(short *)(param_1 + 0x3e0) != 0) {
    return;
  }

  // half volume
  iVar4 = 0x80;

  if (param_2 < 0x40)
  {
	// distort
    iVar3 = 0x94;
  }

  else
  {
	// 3/4 volume
    iVar4 = 0xc0;

	if (0x7f < param_2)
	{
	  // distort
      iVar3 = 0x6c;

	  // Make driver talk
      FUN_8002cbe8(0x10,(int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)],0x10);

	  // max volume
	  uVar2 = 0xff0000;

	  goto LAB_8005aba4;
    }

	// no distort
    iVar3 = 0x80;
  }

  // volume
  uVar2 = iVar4 << 0x10;

LAB_8005aba4:

  // distortion
  uVar1 = iVar3 << 8;

  // if echo is requierd
  if ((*(uint *)(param_1 + 0x2c8) & 0x10000) != 0)
  {
	// add echo
    uVar1 = uVar1 | 0x1000000;
  }

  // OtherFX_Play_LowLevel
  // 0xD = Turbo Boost Sound
  // 0x80 = balance L/R
  FUN_800284d0(0xd,1,uVar2 | uVar1 | 0x80);

  // turbo audio cooldown 0.24s
  *(undefined2 *)(param_1 + 0x3e0) = 0xf0;

  return;
}

// param1 - driver
// param2 - reserves to add
// param3 - add type
// param4 - fire level
// Turbo_Increment
void FUN_8005abfc(int param_1,int param_2,uint param_3,int param_4)

{
  char cVar1;
  short sVar2;
  undefined *puVar3;
  undefined uVar4;
  int iVar5;
  uint uVar6;
  int *piVar7;
  int iVar8;
  short sVar9;

  if (
		//if pointer is not null and
		((param_3 & 4) != 0) &&
		
		//racer is in accel prevention
		((*(uint *)(param_1 + 0x2c8) & 8) != 0)
	)
  {
    return;
  }

  if (
	// Player / AI structure + 0x4a shows driver index (0-7)

    // If this is the first driver (P1) and
		(*(char *)(param_1 + 0x4a) == '\0') &&

		// driver -> instance -> thread -> modelIndex == "player" of any kind
		(*(short *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x44) == 0x18)
	 )
  {
    // Add Reserves to ghost buffer
    FUN_8002838c(param_2,param_3,param_4);
  }

  //puVar3 = 0x96B20
  puVar3 = PTR_DAT_8008d2ac;
  //cVar1 = Kart state
  cVar1 = *(char *)(param_1 + 0x376);

  //if player is spinning, blasted, or mask grabbed, quit the function
  if (cVar1 == '\x03') {
    return;
  }
  if (cVar1 == '\x06') {
    return;
  }
  if (cVar1 == '\x05') {
    return;
  }

  //turn off 8th flag, turn on 22nd flag of actions flag set
  //means ? (!(8)) and racer just got an outside turbo (22)
  *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) & 0xffffff7f | 0x200000;

  // turbo thread bucket
  iVar5 = *(int *)(puVar3 + 0x1be0);

  // turbo thread bucket exists
  if (iVar5 != 0)
  {
    // check all turbo threads
    do
	{
      // if this turbo thread is owned by this driver
	  // turboThread->object->offset0x4 == driver
      if (*(int *)(*(int *)(iVar5 + 0x30) + 4) == param_1)
	  {
		  // quit, iVar5 is now this driver's turbo thread
		  break;
	  }

	  // next turbo thread in bucket
      iVar5 = *(int *)(iVar5 + 0x10);

    } while (iVar5 != 0);

    // if this driver's turbo thread was found
    if (iVar5 != 0)
	{
	  // get the turbo's object
      piVar7 = *(int **)(iVar5 + 0x30);

      // get the turbo's instance
      iVar8 = *(int *)(iVar5 + 0x34);

	  // thread flags
      *(uint *)(iVar5 + 0x1c) = *(uint *)(iVar5 + 0x1c) & 0xfffff7ff;

	  // manipulate how turbo draws, depending on Add Type flag
      if ((param_3 & 4) == 0)
	  {

        // turbo instance (1/2) attached to thread, edit instance draw flags
        *(uint *)(iVar8 + 0x28) = *(uint *)(iVar8 + 0x28) | 0x1000080;

        // turbo instance (2/2) in thread's object, edit instance draw flags
        *(uint *)(*piVar7 + 0x28) = *(uint *)(*piVar7 + 0x28) | 0x1000080;

        *(undefined2 *)((int)piVar7 + 0xe) = 0x60;

LAB_8005ad6c:

        //increase Turbo counter by 1
        *(short *)(param_1 + 0x4e) = *(short *)(param_1 + 0x4e) + 1;
      }

	  // if AddType is different
      else
	  {
        //if racer got an Outside turbo, add it to the Turbo counter
        if ((*(uint *)(param_1 + 0x2cc) & 0x200000) == 0) goto LAB_8005ad6c;
      }

      *(undefined *)(piVar7 + 3) = 0xff;
      *(undefined2 *)(iVar8 + 0x22) = 0;
      *(undefined2 *)(*piVar7 + 0x22) = 0;

      if (
			// driver -> instance -> thread -> modelIndex == "player" of any kind
			(*(short *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x44) == 0x18) &&
			(
				(
					//if racer is not getting a new boost this frame
					(*(uint *)(param_1 + 0x2c8) & 0x200000) == 0 ||

					//racer was not getting a new boost previous frame
					((*(uint *)(param_1 + 0x2cc) & 0x200000) == 0)
				)
			)
		)
      {
        *(undefined *)((int)piVar7 + 0xd) = 0;

		// Turbo_Audio
        FUN_8005ab24(param_1,param_4);
      }

      // skip code, do not re-initialize turbo thread,
	  // because it already exists
      goto LAB_8005af38;
    }
  }

  // If the program reaches this point,
  // it means a boost was added to the driver,
  // and a thread does not already exist, so
  // a turbo thread is created

  //Turbo counter = 1
  *(undefined2 *)(param_1 + 0x4e) = 1;

  // definitely related to turbo display counter,
  // because it is in the HUD thread bucket...

  // s_turbo1_8008d61c
  // "turbo1"
  // 0x300 flag = SmallStackPool
  // 0x10 = HUD thread bucket
  iVar5 = FUN_800309a4(0x2c,s_turbo1_8008d61c,0x300,9,FUN_800693c8,0x10,0);

  // piVar7 = nullptr
  piVar7 = (int *)0x0;

  //if iVar5 != nullptr
  if (iVar5 != 0)
  {
    // turboInstance->thread->object
    piVar7 = *(int **)(*(int *)(iVar5 + 0x6c) + 0x30);

    // store Driver pointer inside Turbo object
    piVar7[1] = param_1;

    *(undefined2 *)((int)piVar7 + 0xe) = 0;

    // allow this thread to ignore all collisions
    *(uint *)(*(int *)(iVar5 + 0x6c) + 0x1c) = *(uint *)(*(int *)(iVar5 + 0x6c) + 0x1c) | 0x1000;

    if (

	  // driver -> instance -> thread -> modelIndex == "player" of any kind
      (*(short *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x44) == 0x18) &&
      (
		*(undefined *)((int)piVar7 + 0xd) = 0,

		//racer is not crashing
		*(char *)(param_1 + 0x376) != '\x01'
	  )
    )
    {
	  // Turbo_Audio
      FUN_8005ab24(param_1,param_4);
    }

    //puVar3 = 0x96B20
    puVar3 = PTR_DAT_8008d2ac;

	// turbo thread OnDestroy
    *(undefined4 *)(*(int *)(iVar5 + 0x6c) + 0x24) = 0x80069370;

    // s_turbo2_8008d624
    // "turbo2"

	// INSTANCE_Birth3D -- ptrModel, name, thread,
	// model 0x2c, first turbo_effect
    iVar8 = FUN_8003086c(*(undefined4 *)(puVar3 + 0x2210),
			s_turbo2_8008d624,

			// turbo thread
      *(undefined4 *)(iVar5 + 0x6c));

    //puVar3 = 0x96B20 (again)
    puVar3 = PTR_DAT_8008d2ac;

	// store pointer to 2nd turbo
	// inside Turbo object
    *piVar7 = iVar8;

    // if numPlyrCurrGame is not 1
    uVar6 = 0x1040000;

    // if numPlyrCurrGame is 1
    if (puVar3[0x1ca8] == '\x01')
	{
      uVar6 = 0x3040000;
    }

	// turbo (1/2) instance flag (attached to thread)
    *(uint *)(iVar5 + 0x28) =
	*(uint *)(iVar5 + 0x28) | uVar6 | 0x80;

	// turbo (2/2) instance flag (attached to object)
    *(uint *)(*piVar7 + 0x28) =
	*(uint *)(*piVar7 + 0x28) | uVar6 | 0x80;

    *(undefined2 *)(piVar7 + 2) = 0;
    if ((param_3 & 2) == 0) {
      uVar4 = 0xff;
    }
    else {
      uVar4 = 2;
    }
    *(undefined *)(piVar7 + 3) = uVar4;
  }

// This code only seem to run when you either are on a turbo pad/super turbo pad or you get any sort of boost
LAB_8005af38:

  // param_4 = multiplier that represents the level of fire of your boost
  // Constant values:
  // sacred fire speed cap = 0x1000
  // single turbo speed cap = 0x800

  // iVar5 = (param_4 * sacred fire speed cap) - (single turbo speed cap >> 8) + (single turbo speed cap)
  // iVar5 = ground speed cap represented by your multiplier

  iVar5 = (param_4 * ((int)*(short *)(param_1 + 0x432) - (int)*(short *)(param_1 + 0x430)) >> 8) +
          (int)*(short *)(param_1 + 0x430);

  if (
      (
		(
			// Reserves are equal to zero
			(*(short *)(param_1 + 0x3e2) == 0) ||

			// OR

			// Current ground speed cap is less than iVar5
			((int)*(short *)(param_1 + 0x3e4) < iVar5)
		) ||

		// OR

		(
			(
				// Current speed cap is greater than 0x1000
				(int)*(short *)(param_1 + 0x432) < (int)*(short *)(param_1 + 0x3e4) &&

				// AND

				// You are not on a super turbo pad
				((*(uint *)(param_1 + 0xbc) & 2) == 0)
			)
		)
	  ) &&

    // AND

	  (
		(
			// Current speed cap = iVar5
			*(undefined2 *)(param_1 + 0x3e4) = (short)iVar5,

			// Compare !=
			piVar7 != (int *)0x0 &&

			// AND

			(
				// Assignment
				iVar5 = (param_4 >> 6) + 5,

				// Assignment
				*(undefined2 *)((int)piVar7 + 10) = (short)iVar5,

				// Compoare <
				8 < iVar5 * 0x10000 >> 0x10
			)
		)
	  )
	 )
  {
    *(undefined2 *)((int)piVar7 + 10) = 8;
  }

  if ((param_3 & 8) != 0)
  {
	// driver is using turbo weapon
    *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) | 0x200;
  }

  sVar9 = (short)param_2;
  if ((param_3 & 1) == 0)
  {
    if ((param_3 & 0x10) == 0)
	{
	  // increase reserves BY param2
      *(short *)(param_1 + 0x3e2) = *(short *)(param_1 + 0x3e2) + sVar9;
    }
    else
	{
	  // increase reserves TO param2
      if (*(short *)(param_1 + 0x3e2) < param_2)
	  {
        *(short *)(param_1 + 0x3e2) = sVar9;
      }
    }
  }
  else {
    sVar2 = *(short *)(param_1 + 0x3de);
    if (*(short *)(param_1 + 0x3de) < param_2) {
      *(short *)(param_1 + 0x3de) = sVar9;
      *(short *)(param_1 + 0x3e2) = *(short *)(param_1 + 0x3e2) + (sVar9 - sVar2);
    }
  }

  // driver -> instance -> thread -> modelIndex == "player" of any kind
  if (*(short *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x44) == 0x18) {

	// CameraDC flag
    *(uint *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_1 + 0x4a) * 0xdc + 0x1508) =
         *(uint *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_1 + 0x4a) * 0xdc + 0x1508) | 0x80;

	// gamepad vibration
    FUN_800264c0(param_1,8,0x7f);
  }
  return;
}


// animation index, and number of frames
// 0 - midpoint (steering should start at midpoint)
// 1 - start
// 2 - start
// 3 - start
// 4 - end

// Instance_GetStartFrame
int FUN_8005b0c4(int param_1,int param_2)
{
  if (param_1 == 0) {
    return param_2 >> 1;
  }
  if (param_1 != 4) {
    return 0;
  }
  return param_2 + -1;
}


// get number of frames in animation
// param1 - instance
// param2 - animIndex
uint FUN_8005b0f4(int param_1,int param_2)
{
  int iVar1;

  // instance -> model
  iVar1 = *(int *)(param_1 + 0x18);

  // if model is valid, and if numHeaders is more than zero
  if ((((iVar1 != 0) && (0 < *(short *)(iVar1 + 0x12))) &&

	  // get header, check for nullptr
      (iVar1 = *(int *)(iVar1 + 0x14), iVar1 != 0)) &&

	  // animIndex < numAnimations in model
	  (param_2 < *(int *)(iVar1 + 0x34)))
  {
	// if pointer to animation data is valid
    if (*(int *)(iVar1 + 0x38) != 0)
	{
	  // get pointer to animation, given animIndex
      iVar1 = *(int *)(param_2 * 4 + *(int *)(iVar1 + 0x38));
      if (iVar1 != 0)
	  {
		// return number of animation frames
        return (uint)*(ushort *)(iVar1 + 0x10) & 0x7fff;
      }
      return 0;
    }
  }
  return 0;
}


// OnAnimate_Driving
// param1 = thread, param2 = driver
void FUN_8005b178(int param_1,int param_2)
{
  byte bVar1;
  undefined *puVar2;
  char cVar3;
  undefined2 uVar4;
  int iVar5;
  short sVar6;
  int iVar7;
  undefined4 uVar8;
  int iVar9;
  int iVar10;
  uint uVar11;

  // Get instance from thread
  iVar10 = *(int *)(param_1 + 0x34);

  // animation is drive forwards
  uVar11 = 0;

  //if you don't have a TNT over you and state of kart is not in a warp pad
  if ((*(int *)(param_2 + 0x18) == 0) && (*(char *)(param_2 + 0x376) != '\n'))
  {
    if (*(short *)(param_2 + 0x39e) < 0)
	{
      // check if you are driving backwards
	  // (0) forwards
	  // (1) backwards
      uVar11 = (uint)(*(short *)(param_2 + 0x38e) < 1);
    }
    if (((0x600 < *(short *)(param_2 + 0x390)) || (*(char *)(iVar10 + 0x52) == '\x03')) &&

	   // if player height is far from quadblock height
	   (0x8000 < *(int *)(param_2 + 0x2d8) - *(int *)(param_2 + 0x2d0)))
	{
	  // jumping animation
      uVar11 = 3;
    }
  }

  // get number of frames in animation
  iVar5 = FUN_8005b0f4(iVar10,(uint)*(byte *)(iVar10 + 0x52));

  // if animation has frames
  if (0 < iVar5)
  {
	// get animation frame currently
    bVar1 = *(byte *)(iVar10 + 0x52);

	// if animation changes
    if (uVar11 != (uint)bVar1)
	{
	  // if crashing animation
      if (bVar1 == 2)
	  {
		// get number of frames in animation
        iVar5 = FUN_8005b0f4(iVar10);

		// start on last frame
        iVar5 = iVar5 + -1;
      }

      else
	  {
		// Instance_GetStartFrame
        iVar5 = FUN_8005b0c4((uint)bVar1,iVar5);
      }

	  // if animation frame has changed
	  if ((int)*(short *)(iVar10 + 0x54) != iVar5) 
	  {
		// if steering animation
        if (*(char *)(iVar10 + 0x52) == '\0') {
          uVar8 = 6;
        }
		
        else 
		{
		  // jump or reverse?
          uVar8 = 2;
          
		  // crashing
		  if (*(char *)(iVar10 + 0x52) == '\x02') 
		  {
            uVar8 = 1;
            
			//kart emote frame = *(uchar *)(iVar10 + 0x54)
            *(undefined *)(param_2 + 0x4d) = *(undefined *)(iVar10 + 0x54);
          }
        }

		// Interpolate animation by speed
        uVar4 = FUN_80058f54((int)*(short *)(iVar10 + 0x54),uVar8,iVar5);
        *(undefined2 *)(iVar10 + 0x54) = uVar4;

        if (1 < (uint)*(byte *)(iVar10 + 0x52) - 2) {
          return;
        }

		// get animation frame from Instance
        cVar3 = *(char *)(iVar10 + 0x54);

        // Give it to driver
        *(char *)(param_2 + 0x4d) = cVar3;

		if (cVar3 != '\0') {
          return;
        }
        //kart animation Index
        *(undefined *)(param_2 + 0x4c) = 0;

        //kart animation frame
        *(undefined *)(param_2 + 0x4d) = 0;
        return;
      }

	  // get number of frames in animation
      iVar5 = FUN_8005b0f4(iVar10,uVar11);
      if (iVar5 < 1) {
        return;
      }

	  // set animation
      *(undefined *)(iVar10 + 0x52) = (char)uVar11;

	  // Instance_GetStartFrame
      uVar4 = FUN_8005b0c4(uVar11,iVar5);

	  // set animation frame
      *(undefined2 *)(iVar10 + 0x54) = uVar4;

	  // animation index
      *(undefined *)(param_2 + 0x4c) = 0;

	  // animation frame
	  *(undefined *)(param_2 + 0x4d) = 0;
    }
    //puVar2 = 0x96B20
    puVar2 = PTR_DAT_8008d2ac;

	// steering animation
	if (uVar11 == 0)
	{
      iVar9 = iVar5 >> 1;

	  //if you don't have a TNT over you
      if (*(int *)(param_2 + 0x18) == 0)
	  {
        //sVar6 = time burnt left
        sVar6 = *(short *)(param_2 + 0x402);

		//if you're not burnt or your time burnt left is bigger than 0x1df
        if ((sVar6 == 0) || (0x1df < sVar6))
		{
		  //iVar9 = negative turning stat while braking
          iVar9 = -0x40;

		  //if you're not in accel prevention
          if ((*(uint *)(param_2 + 0x2c8) & 8) == 0) 
		  {
            //iVar7 = simplified turning state
            iVar7 = (int)*(char *)(param_2 + 0x4b);

			//uVar11 = character's turn stat
            uVar11 = (uint)*(byte *)(param_2 + 0x43a);

			//iVar9 = negative character's turn stat
            iVar9 = -uVar11;
          }
          //if you're braking or being mask grabbed
          else {
            //uVar11 = positive turning stat while braking
            uVar11 = 0x40;

			//iVar7 = amplified turning state
            iVar7 = (int)*(short *)(param_2 + 0xc0);
          }

          //seems like iVar9 gets set to 0 if you're turning, or to iVar5 - 1 if you're not
          // Map value from [oldMin, oldMax] to [newMin, newMax]
          // inverting newMin and newMax will give an inverse range mapping
          iVar9 = FUN_80058f9c(-iVar7,iVar9,uVar11,0,iVar5 + -1);
        }

        //if your time burnt left is between (0x0, 0x1df)
        else {
          iVar9 = (((int)(sVar6 >> 5) % 5) * 0x10000 >> 0xe) + -8 + iVar9;
          *(undefined2 *)(iVar10 + 0x54) = (short)iVar9;

		  // Create instance in particle pool
          iVar5 = FUN_80040308(0,*(undefined4 *)(puVar2 + 0x2118),&DAT_80089974);

          if (iVar5 != 0) {
            *(undefined *)(iVar5 + 0x18) = *(undefined *)(*(int *)(param_2 + 0x1c) + 0x50);

			// driver -> instSelf
            *(undefined4 *)(iVar5 + 0x20) = *(undefined4 *)(param_2 + 0x1c);

			// driverID
            *(undefined *)(iVar5 + 0x19) = *(undefined *)(param_2 + 0x4a);
          }
        }
      }
      sVar6 = *(short *)(iVar10 + 0x54);
    }
    
	else 
	{
	  // jump animation
      if (uVar11 == 3)
	  {
		// Interpolate animation frame by speed
        uVar4 = FUN_80058f54((int)*(short *)(iVar10 + 0x54),1,iVar5 + -1);

		// set animation frame
        *(undefined2 *)(iVar10 + 0x54) = uVar4;

		    //if you're getting mask grabbed
        if (*(char *)(param_2 + 0x376) == '\x05') {
          return;
        }

    //player / AI structure + 0x4a shows driver index (0-7)

		    //get character ID
        sVar6 = (&DAT_80086e84)[*(byte *)(param_2 + 0x4a)];

		    //if this is penta
        if (sVar6 == 0xd) {
          sVar6 = 3;
        }

		    //if this is fake crash
        if (sVar6 == 0xe) {
          sVar6 = 0;
        }

		//cVar3 = (char)sVar6 + 0x7
        cVar3 = (char)sVar6 + '\a';

		    //if this is oxide
        if (sVar6 == 0xf) {
          //cVar3 = 0x7 (hex equivalent of ascii \a)
          cVar3 = '\a';
        }

		// set animation
        *(char *)(param_2 + 0x4c) = cVar3;

        // set animation frame
        *(undefined *)(param_2 + 0x4d) = *(undefined *)(iVar10 + 0x54);
        return;
      }
      iVar9 = iVar5 + -1;

	  // set animation frame
      sVar6 = *(short *)(iVar10 + 0x54);
    }

	// Interpolate rotation by speed
    uVar4 = FUN_80058f54((int)sVar6,1,iVar9);

	  // set animation frame
    *(undefined2 *)(iVar10 + 0x54) = uVar4;
    return;
  }
  return;
}

// OnAnimate_Spinning
// param1 = thread, param2 = driver
void FUN_8005b510(int param_1,int param_2)

{
  undefined2 uVar1;
  int iVar2;
  int iVar3;
  int iVar4;

  // get instance from thread
  iVar4 = *(int *)(param_1 + 0x34);

  // Instance_GetNumAnimFrames(instance, animIndex)
  iVar2 = FUN_8005b0f4(iVar4,(uint)*(byte *)(iVar4 + 0x52));

  // if there are no frames
  if (iVar2 < 1)
  {
	// quit
    return;
  }

  // if animation is not zero
  if (*(byte *)(iVar4 + 0x52) != 0)
  {
	// Instance_GetStartFrame
    iVar3 = FUN_8005b0c4((uint)*(byte *)(iVar4 + 0x52),iVar2);

	// If animation is negative
    if ((uint)*(byte *)(iVar4 + 0x52) - 2 < 2)
	{
	  // reset animation id and frame
      *(undefined *)(param_2 + 0x4c) = 0;
      *(undefined *)(param_2 + 0x4d) = 0;
    }

    if ((int)*(short *)(iVar4 + 0x54) == iVar3)
	{
	  // get number of frames in animation
      iVar2 = FUN_8005b0f4(iVar4,0);
      if (iVar2 < 1) {
        return;
      }

	  // set animation
      *(undefined *)(iVar4 + 0x52) = 0;
    }
    if (*(char *)(iVar4 + 0x52) != '\0') goto LAB_8005b5d0;
  }
  iVar3 = 0;
  if (-1 < *(short *)(param_2 + 0x582)) {
    iVar3 = iVar2 + -1;
  }
LAB_8005b5d0:

  // Interpolate animation frame by speed
  uVar1 = FUN_80058f54((int)*(short *)(iVar4 + 0x54),4,iVar3);

  // set animation frame
  *(undefined2 *)(iVar4 + 0x54) = uVar1;

  return;
}

// OnAnimate_LastSpin
// param1 = thread, param2 = driver
void FUN_8005b5fc(int param_1,int param_2)

{
  short sVar1;
  undefined2 uVar2;
  int iVar3;
  int iVar4;
  int iVar5;

  // get instance from thread
  iVar5 = *(int *)(param_1 + 0x34);

  // if animation is zero
  if (*(char *)(iVar5 + 0x52) == '\0')
  {
	// get number of frames in animation
    iVar3 = FUN_8005b0f4(iVar5,0);

    if (0 < iVar3) {
      sVar1 = *(short *)(param_2 + 0x3c6);

	  // get animation frame
      iVar4 = (int)*(short *)(iVar5 + 0x54);

      if (0 < sVar1)
	  {
        if (*(short *)(param_2 + 0x3d2) < 0) {
          iVar4 = iVar3 + -1;
        }
        sVar1 = *(short *)(param_2 + 0x3c6);
      }

      if ((sVar1 < 0) && (0 < *(short *)(param_2 + 0x3d2))) {
        iVar4 = 0;
      }

	  // Interpolate animation frame by speed
      uVar2 = FUN_80058f54((int)*(short *)(iVar5 + 0x54),3,iVar4);

	  // set animation frame
      *(undefined2 *)(iVar5 + 0x54) = uVar2;
    }
  }
  else
  {
	// OnAnimate_Spinning
    FUN_8005b510();
  }
  return;
}


// without this, all shadows are solid rectangles
// Shadow_Subset
undefined4 FUN_8005b6b8(undefined4 *param_1,int param_2)

{
  int iVar1;

  // get pointer to icon
  iVar1 = *(int *)(PTR_DAT_8008d2ac + param_2 * 4 + 0x1eec);

  // if icon is valid
  if (iVar1 != 0) {
    *param_1 = *(undefined4 *)(iVar1 + 0x14);
    param_1[1] = *(uint *)(iVar1 + 0x18) & 0xff9fffff | 0x400000;
    *(undefined2 *)(param_1 + 2) = *(undefined2 *)(iVar1 + 0x1c);
    *(undefined2 *)((int)param_1 + 10) = *(undefined2 *)(iVar1 + 0x1e);
    return 1;
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Restarted to delay deadcode elimination for space: ram

//draws shadows
void FUN_8005b720(void)

{
  undefined *puVar1;
  char cVar2;
  ushort uVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  short sVar8;
  int iVar9;
  MATRIX *pMVar10;
  int iVar11;
  uint *puVar12;
  uint uVar13;
  short sVar14;
  undefined *puVar15;
  uint *puVar16;
  int iVar17;
  short sVar18;
  int iVar19;
  int iVar20;
  uint uVar21;
  MATRIX *r0;
  uint *puVar22;
  uint *puVar23;
  uint *puVar24;
  uint *puVar25;
  undefined2 *puVar26;
  SVECTOR *r0_00;
  undefined *puVar27;
  uint *puVar28;
  undefined auStack72 [32];
  
  puVar27 = auStack72;
  puVar23 = &DAT_1f800000;
  
  // without this, all shadows are solid rectangles
  iVar4 = FUN_8005b6b8(&DAT_1f800224,0);
  
  if (
		(
			(iVar4 != 0) && 
			(
				// without this, all shadows are solid rectangles
				iVar4 = FUN_8005b6b8(&DAT_1f800230,1), 
				iVar4 != 0
			)
		) &&
     
		(
			// backBuffer->primMem.curr
			puVar28 = *(uint **)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80),
		
			// if enough primMem remains to draw shadows
			puVar28 + 0x140 < *(uint **)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x84)
		)
	  ) 
  {
	// set transformation vector to (0,0,0)
    _DAT_1f800090 = 0;
    DAT_1f800094 = 0;
    DAT_1f800098 = 0;
    gte_SetTransVector((VECTOR *)&DAT_1f800090);
	
	// loop counter
    iVar4 = 0;
	
    puVar15 = (undefined *)((uint)puVar23 | 0xb6);
    uVar21 = (uint)puVar23 | 0xa4;
	
	// for iVar4 = 0; iVar4 < 8; iVar4++
    do 
	{
      uVar6 = uVar21;
      puVar1 = PTR_DAT_8008d2ac;
	  
	  // pointer to each player structure
      iVar11 = *(int *)(PTR_DAT_8008d2ac + iVar4 * 4 + 0x24ec);
	  
	  // if player pointer is invalid
      if (iVar11 == 0) {
        *(undefined4 *)(puVar15 + 2) = 0;
      }
	  
	  // if player pointer is valid
      else 
	  {
        *(int *)(puVar15 + 2) = iVar11;
        
		// get instance
		iVar19 = *(int *)(iVar11 + 0x1c);
        
		*(int *)(puVar15 + 6) = iVar19;
        
											// instance flags
		*(undefined2 *)(puVar15 + 0x14) = *(undefined2 *)(iVar19 + 0x28);
        
		// numPlyrCurrGame - 1
		iVar17 = (byte)puVar1[0x1ca8] - 1;
        
		// numPlyrCurrGame > 0
		if (-1 < iVar17) 
		{
		  // InstDrawPerPlayer = Instance -> InstDrawPerPlayer[iVar17]
          iVar9 = iVar17 * 0x88 + iVar19;
          
		  // loop for all players
		  do 
		  {
			// flags?
            puVar1 = (undefined *)(iVar9 + 0xb8);
			
			// next InstDrawPerPlayer
            iVar9 = iVar9 + -0x88;
			
            iVar5 = uVar6 + iVar17;
            iVar17 = iVar17 + -1;
            *(undefined *)(iVar5 + 0x1c) = *puVar1;
          } while (-1 < iVar17);
        }
		
		// PlayerX, quadblockHeight+3, PlayerZ
        *(short *)(puVar15 + 0xe) = (short)((uint)*(undefined4 *)(iVar11 + 0x2d4) >> 8);
        *(short *)(puVar15 + 0x10) = (short)((uint)*(undefined4 *)(iVar11 + 0x2d0) >> 8) + 3;
        *(short *)(puVar15 + 0x12) = (short)((uint)*(undefined4 *)(iVar11 + 0x2dc) >> 8);
        
		if ((*(ushort *)(puVar15 + 0x14) & 0x2000) == 0) {
          cVar2 = *(char *)(iVar19 + 0x50);
        }
        else {
          cVar2 = *(char *)(iVar19 + 0x51);
        }
        puVar15[1] = cVar2 + '\x01';
      }
      *puVar15 = 0;
      puVar1 = PTR_DAT_8008d2ac;
	  
	  // increment loop iteration counter
      iVar4 = iVar4 + 1;
	  
      puVar15 = puVar15 + 0x28;
      uVar21 = uVar6 + 0x28;
    } while (iVar4 < 8);
    
	*(undefined4 *)(uVar6 + 0x3c) = 0;
	
	// numPlyrCurrGame - 1
    iVar4 = (byte)puVar1[0x1ca8] - 1;
	
	// loop through all player screens
    if (-1 < iVar4) 
	{
      iVar11 = -1;
      r0_00 = (SVECTOR *)(puVar23 + 0x12);
      uVar21 = 1;
	  
	  // tileView offset 0x38
      puVar26 = (undefined2 *)(puVar1 + iVar4 * 0x110 + 0x1a0);
	  
      do {
        puVar23[0x90] = *(uint *)(puVar26 + -0x10);
        puVar23[0x8f] = *(uint *)(puVar26 + 0x5e);
		
		// screen dimensions
        gte_SetGeomOffset((int)((uint)(ushort)puVar26[-0xc] << 0x10) >> 0x11,
                          (int)((uint)(ushort)puVar26[-0xb] << 0x10) >> 0x11);
						  
		// distToScreen
        gte_ldH(puVar23[0x90]);
		
        puVar23[0x24] = *(uint *)(puVar26 + 0x22);
        puVar23[0x25] = *(uint *)(puVar26 + 0x24);
        puVar23[0x26] = *(uint *)(puVar26 + 0x26);
        puVar23[0x14] = *(uint *)(puVar26 + -8);
        puVar23[0x15] = *(uint *)(puVar26 + -6);
        puVar23[0x16] = *(uint *)(puVar26 + -4);
        uVar6 = *(uint *)(puVar26 + -2);
        *(undefined2 *)(puVar23 + 0x18) = *puVar26;
        puVar23[0x17] = uVar6;
		
        gte_SetRotMatrix((MATRIX *)(puVar23 + 0x14));
        
		puVar12 = puVar23 + 0x29;
        uVar6 = puVar23[0x2e];
        if (uVar6 != 0) {
          puVar22 = puVar23 + 0x2e;
          do {
            if (*(char *)((int)puVar22 + -2) != iVar11) {
              if ((*(ushort *)((int)puVar22 + 0x12) & 0x80) == 0) {
                if ((*(byte *)((int)puVar12 + iVar4 + 0x1c) & 0x40) != 0) {
                  uVar3 = *(ushort *)(puVar22 + 3);
                  *(short *)(puVar23 + 0x27) =
                       (short)((uint)uVar3 - (uint)*(ushort *)(puVar23 + 0x24)) * 4;
                  iVar9 = (int)(((uint)uVar3 - (uint)*(ushort *)(puVar23 + 0x24)) * 0x40000) >> 0x10
                  ;
                  iVar17 = (uint)*(ushort *)((int)puVar22 + 0xe) - (uint)*(ushort *)(puVar23 + 0x25)
                  ;
                  *(short *)((int)puVar23 + 0x9e) = (short)iVar17 * 4;
                  iVar19 = iVar17 * 0x40000 >> 0x10;
                  iVar17 = (int)(((uint)*(ushort *)(puVar22 + 4) - (uint)*(ushort *)(puVar23 + 0x26)
                                 ) * 0x40000) >> 0x10;
                  *(short *)(puVar23 + 0x28) =
                       (short)((uint)*(ushort *)(puVar22 + 4) - (uint)*(ushort *)(puVar23 + 0x26)) *
                       4;
                  uVar7 = (uint)((int)puVar23[0x90] < 0x101);
                  if ((uVar7 == 0) ||
                     ((((iVar9 < 0x1771 && (iVar19 < 0x1771)) &&
                       ((iVar17 < 0x1771 && ((-0x1771 < iVar9 && (-0x1771 < iVar19)))))) &&
                      (-0x1771 < iVar17)))) {
                    gte_ldv0((SVECTOR *)(puVar23 + 0x27));
                    gte_rtv0();
                    iVar5 = gte_stMAC3();
                    iVar5 = iVar5 >> 2;
                    if (-0x35 < iVar5) {
                      if (uVar7 == 0) {
                        uVar7 = 0x2e1f1f1f;
                      }
                      else {
                        if (iVar5 < 0x180) {
                          uVar7 = 0x1f;
                        }
                        else 
						{
						  // asm address 8005bb04,
						  // changing 0x200 to 0x800, increases
						  // the render distance of shadows
                          iVar5 = (0x200 - iVar5) * 0x1f;
						  
                          if (iVar5 < 0) {
                            iVar5 = iVar5 + 0x7f;
                          }
                          
						  uVar7 = iVar5 >> 7;
                          
						  // skip shadow draw
						  if ((int)uVar7 < 1) goto LAB_8005c0b8;
                        }
                        uVar7 = uVar7 | uVar7 << 8 | 0x2e000000 | uVar7 << 0x10;
                      }
                      puVar25 = puVar12;
                      if (*(char *)((int)puVar22 + -2) == '\0') 
					  {
						// player height, minus quadblock height
                        iVar17 = 0x100 - (*(int *)(uVar6 + 0x2d8) - *(int *)(uVar6 + 0x2d0) >> 8);
                        
						// if driver is too far from ground, skip shadow draw
						if ((iVar17 < 1) || (0x109 < iVar17)) goto LAB_8005bb94;
						
                        r0 = (MATRIX *)(puVar23 + 0x1c);
                        if (0x100 < iVar17) {
                          iVar17 = 0x100;
                        }
                        iVar19 = (int)*(short *)(uVar6 + 0x2ee);
                        *(int *)(puVar27 + 0x10) = iVar11;
                        *(uint *)(puVar27 + 0x14) = uVar21;
                        *(SVECTOR **)(puVar27 + 0x18) = r0_00;
                        pMVar10 = r0;
						
						// Rot_AxisAngle
                        FUN_8005f89c(r0,uVar6 + 0x370);
						
                        gte_SetLightMatrix(r0);
                        
						// loop counter
						uVar6 = 0;
						
                        iVar20 = iVar17 * 0x29 >> 6;
                        iVar5 = iVar17 * 0x34 >> 6;
                        *(short *)(puVar23 + 0x12) = (short)(iVar17 * 0x28 >> 6);
                        *(undefined2 *)((int)puVar23 + 0x4a) = 0;
                        *(undefined2 *)(puVar23 + 0x13) = 0;
                        r0_00 = *(SVECTOR **)(puVar27 + 0x18);
                        uVar21 = *(uint *)(puVar27 + 0x14);
                        iVar11 = *(int *)(puVar27 + 0x10);
                        puVar25 = puVar12;
						
						// for uVar6 = 0; uVar6 < 3; uVar6++
                        do 
						{
                          gte_ldv0(r0_00);
                          gte_llv0();
                          if (uVar6 == 0) {
                            *(undefined2 *)(puVar23 + 0x12) = 0;
                            *(short *)(puVar23 + 0x13) = (short)iVar20;
                          }
                          else if (uVar6 == uVar21) {
                            *(short *)(puVar23 + 0x13) = (short)iVar5;
                          }
                          read_mt(iVar9,iVar19,pMVar10);
                          *(short *)puVar12 = (short)iVar9;
                          *(short *)((int)puVar12 + 2) = (short)iVar19;
                          *(short *)(puVar12 + 1) = (short)pMVar10;
						  
						  // increment loop counter
                          uVar6 = uVar6 + 1;
						  
                          puVar12 = (uint *)((int)puVar12 + 6);
                        
						} while ((int)uVar6 < 3);
						
                        gte_SetRotMatrix((MATRIX *)(puVar23 + 0x14));
						
                        sVar8 = *(short *)(puVar23 + 0x27);
                        sVar14 = *(short *)((int)puVar23 + 0x9e);
                        sVar18 = *(short *)(puVar23 + 0x28);
                        *(char *)((int)puVar22 + -2) = (char)uVar21;
                        iVar9 = (int)sVar8;
                        iVar19 = (int)sVar14;
                        iVar17 = (int)sVar18;
                      }
                      sVar18 = (short)iVar9;
                      *(short *)(puVar23 + 0x83) = sVar18;
                      sVar14 = (short)iVar19;
                      *(short *)((int)puVar23 + 0x20e) = sVar14;
                      sVar8 = (short)iVar17;
                      *(short *)(puVar23 + 0x84) = sVar8;
                      *(short *)(puVar23 + 0x85) =
                           (sVar18 - *(short *)puVar25) - *(short *)((int)puVar22 + -0xe);
                      *(short *)((int)puVar23 + 0x216) =
                           (sVar14 - *(short *)((int)puVar22 + -0x12)) - *(short *)(puVar22 + -3);
                      *(short *)(puVar23 + 0x86) =
                           (sVar8 - *(short *)(puVar22 + -4)) - *(short *)((int)puVar22 + -10);
                      iVar5 = 0;
                      *(short *)(puVar23 + 0x87) = sVar18 - *(short *)((int)puVar22 + -0xe);
                      iVar20 = 0x24;
                      *(short *)((int)puVar23 + 0x21e) = sVar14 - *(short *)(puVar22 + -3);
                      *(short *)(puVar23 + 0x88) = sVar8 - *(short *)((int)puVar22 + -10);
                      puVar24 = puVar23;
                      do {
                        gte_ldv3c((SVECTOR *)(puVar24 + 0x83));
                        gte_rtpt();
                        sVar8 = (short)iVar9;
                        sVar14 = (short)iVar19;
                        sVar18 = (short)iVar17;
                        if (iVar5 == 0) {
                          *(short *)(puVar24 + 0x83) =
                               (*(short *)puVar25 + sVar8) - *(short *)((int)puVar22 + -0xe);
                          *(short *)((int)puVar24 + 0x20e) =
                               (*(short *)((int)puVar22 + -0x12) + sVar14) -
                               *(short *)(puVar22 + -3);
                          *(short *)(puVar24 + 0x84) =
                               (*(short *)(puVar22 + -4) + sVar18) - *(short *)((int)puVar22 + -10);
                          *(short *)(puVar24 + 0x85) = *(short *)puVar25 + sVar8;
                          *(short *)((int)puVar24 + 0x216) =
                               *(short *)((int)puVar22 + -0x12) + sVar14;
                          *(short *)(puVar24 + 0x86) = *(short *)(puVar22 + -4) + sVar18;
                          *(short *)(puVar24 + 0x87) =
                               *(short *)(puVar22 + -2) + *(short *)puVar25 + sVar8;
                          *(short *)((int)puVar24 + 0x21e) =
                               *(short *)((int)puVar22 + -6) +
                               *(short *)((int)puVar22 + -0x12) + sVar14;
                          *(short *)(puVar24 + 0x88) =
                               *(short *)(puVar22 + -1) + *(short *)(puVar22 + -4) + sVar18;
                        }
                        else if (iVar5 == 3) {
                          *(short *)(puVar24 + 0x83) = *(short *)(puVar22 + -2) + sVar8;
                          *(short *)((int)puVar24 + 0x20e) = *(short *)((int)puVar22 + -6) + sVar14;
                          *(short *)(puVar24 + 0x84) = *(short *)(puVar22 + -1) + sVar18;
                          *(short *)(puVar24 + 0x85) =
                               *(short *)(puVar22 + -2) + (sVar8 - *(short *)puVar25);
                          *(short *)((int)puVar24 + 0x216) =
                               *(short *)((int)puVar22 + -6) +
                               (sVar14 - *(short *)((int)puVar22 + -0x12));
                          *(short *)(puVar24 + 0x86) =
                               *(short *)(puVar22 + -1) + (sVar18 - *(short *)(puVar22 + -4));
                          *(short *)(puVar24 + 0x87) = sVar8 - *(short *)puVar25;
                          *(short *)((int)puVar24 + 0x21e) =
                               sVar14 - *(short *)((int)puVar22 + -0x12);
                          *(short *)(puVar24 + 0x88) = sVar18 - *(short *)(puVar22 + -4);
                        }
                        gte_stsxy3c((long *)puVar23);
                        gte_stsz3c((long *)((int)puVar24 + iVar20));
                        iVar20 = iVar20 + 0xc;
                        iVar5 = iVar5 + 3;
                        puVar23 = puVar23 + 3;
                      } while (iVar5 < 9);
                      uVar6 = 0;
                      puVar16 = puVar28 + 8;
                      do {
                        puVar23 = puVar24 + 0x89;
                        if ((uVar6 & 1) != 0) {
                          puVar23 = puVar24 + 0x8c;
                        }
                        puVar16[-7] = uVar7;
                        puVar16[-5] = *puVar23;
                        puVar16[-3] = puVar23[1];
                        *(undefined2 *)(puVar16 + -1) = *(undefined2 *)(puVar23 + 2);
                        *(undefined2 *)(puVar16 + 1) = *(undefined2 *)((int)puVar23 + 10);
                        if (uVar6 == uVar21) {
                          puVar16[-6] = puVar24[8];
                          puVar16[-4] = *puVar24;
                          puVar16[-2] = puVar24[7];
LAB_8005c044:
                          *puVar16 = puVar24[6];
                        }
                        else if ((int)uVar6 < 2) {
                          if (uVar6 == 0) {
                            puVar16[-6] = puVar24[8];
                            puVar16[-4] = *puVar24;
                            puVar16[-2] = puVar24[1];
                            *puVar16 = puVar24[2];
                          }
                        }
                        else if (uVar6 == 2) {
                          puVar16[-6] = puVar24[4];
                          puVar16[-4] = *puVar24;
                          puVar16[-2] = puVar24[3];
                          *puVar16 = puVar24[2];
                        }
                        else if (uVar6 == 3) {
                          puVar16[-6] = puVar24[4];
                          puVar16[-4] = *puVar24;
                          puVar16[-2] = puVar24[5];
                          goto LAB_8005c044;
                        }
                        iVar19 = ((int)puVar24[9] >> 8) + (int)*(char *)((int)puVar22 + -1);
                        iVar17 = iVar19;
                        if (iVar19 < 0) {
                          iVar17 = 0;
                        }
                        if (0x3ff < iVar19) {
                          iVar17 = 0x3ff;
                        }
                        puVar16 = puVar16 + 10;
                        uVar6 = uVar6 + 1;
                        uVar13 = (uint)puVar28 & 0xffffff;
                        puVar23 = (uint *)(puVar24[0x8f] + iVar17 * 4);
                        *puVar28 = *puVar23 | 0x9000000;
                        puVar28 = puVar28 + 10;
                        *puVar23 = uVar13;
                        puVar23 = puVar24;
                        puVar12 = puVar25;
                      } while ((int)uVar6 < 4);
                    }
                  }
                }
              }
              else {
LAB_8005bb94:
                *(char *)((int)puVar22 + -2) = (char)iVar11;
              }
            }
LAB_8005c0b8:
            puVar22 = puVar22 + 10;
            uVar6 = *puVar22;
            puVar12 = puVar12 + 10;
          } while (uVar6 != 0);
        }
        iVar4 = iVar4 + -1;
        puVar26 = puVar26 + -0x88;
      } while (-1 < iVar4);
    }
	
	// backBuffer->primMem.curr
    *(uint **)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80) = puVar28;
  }
  return;
}


// DrawSkidMarks_Subset1
void FUN_8005c120(uint *param_1,uint *param_2,int param_3,int param_4)

{
  undefined *puVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  uint *puVar5;
  uint *puVar6;

  puVar1 = PTR_DAT_8008d2ac;

  // gGT->backDB
  iVar3 = *(int *)(PTR_DAT_8008d2ac + 0x10);

  // primMem.curr
  puVar6 = *(uint **)(iVar3 + 0x80);

  // if there is room to draw
  if (puVar6 + 0xd <= *(uint **)(iVar3 + 0x84))
  {
    
	// primMem.curr += 0x34
	*(uint **)(iVar3 + 0x80) = puVar6 + 0xd;
	
    puVar6[1] = *(uint *)(param_4 + 0x1c);
    puVar6[4] = *(uint *)(param_4 + 0x1c);
    puVar6[7] = *(uint *)(param_4 + 0x20);
    puVar6[10] = *(uint *)(param_4 + 0x20);
    puVar6[2] = *param_1;
    puVar6[5] = param_1[1];
    puVar6[8] = *param_2;
    puVar6[0xb] = param_2[1];
	
	// gGT->0x1fa8 = gGT->0x1eec[0x2f*4] = skidmark
	
    puVar6[3] = *(uint *)(*(int *)(puVar1 + 0x1fa8) + 0x14);
    if ((*(uint *)(param_4 + 0x24) & 1) == 0) {
      uVar2 = *(uint *)(*(int *)(puVar1 + 0x1fa8) + 0x18);
      uVar4 = 0x400000;
    }
    else {
      uVar2 = *(uint *)(*(int *)(puVar1 + 0x1fa8) + 0x18);
      uVar4 = 0x600000;
    }
    puVar6[6] = uVar2 & 0xff9fffff | uVar4;
    puVar1 = PTR_DAT_8008d2ac;
    *(undefined2 *)(puVar6 + 9) = *(undefined2 *)(*(int *)(PTR_DAT_8008d2ac + 0x1fa8) + 0x1c);
    *(undefined2 *)(puVar6 + 0xc) = *(undefined2 *)(*(int *)(puVar1 + 0x1fa8) + 0x1e);
    puVar5 = (uint *)(*(int *)(*(int *)(param_4 + 0x18) + 0xf4) + (param_3 >> 6) * 4);
    *puVar6 = *puVar5 | 0xc000000;
    *puVar5 = (uint)puVar6 & 0xffffff;
  }
  return;
}


// DrawSkidMarks_Subset2
void FUN_8005c278(short *param_1,short *param_2,short *param_3,short *param_4)

{
  *param_1 = (*param_2 - param_1[0x5c]) * 4;
  param_1[1] = (param_2[1] - param_1[0x5e]) * 4;
  param_1[2] = (param_2[2] - param_1[0x60]) * 4;
  param_1[4] = (*param_3 - param_1[0x5c]) * 4;
  param_1[5] = (param_3[1] - param_1[0x5e]) * 4;
  param_1[6] = (param_3[2] - param_1[0x60]) * 4;
  param_1[8] = (*param_4 - param_1[0x5c]) * 4;
  param_1[9] = (param_4[1] - param_1[0x5e]) * 4;
  param_1[10] = (param_4[2] - param_1[0x60]) * 4;
  return;
}


// draws skidmarks
// param_1 - thread pointer (player or robot)
// param_2 - tileView pointer
void FUN_8005c354(undefined4 param_1,int param_2)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  SVECTOR *pSVar6;
  SVECTOR *pSVar7;
  SVECTOR *r0;
  SVECTOR *pSVar8;
  SVECTOR *r0_00;
  uint uVar9;
  SVECTOR *pSVar10;
  undefined *puVar11;
  uint uVar12;
  undefined auStack64 [24];
  
  puVar11 = auStack64;
  
  // window dimensions
  gte_SetGeomOffset((int)((uint)*(ushort *)(param_2 + 0x20) << 0x10) >> 0x11,
                    (int)((uint)*(ushort *)(param_2 + 0x22) << 0x10) >> 0x11);
	
  // distance to screen	
  gte_ldH(*(undefined4 *)(param_2 + 0x18));
  
  r0 = (SVECTOR *)&DAT_1f800000;
  DAT_1f8000b8 = 0;
  DAT_1f8000bc = 0;
  DAT_1f8000c0 = 0;
  DAT_1f800018 = param_2;
  
  // tileView offset 0x28, ViewProj
  gte_SetRotMatrix((MATRIX *)(param_2 + 0x28));
  gte_SetTransVector((VECTOR *)&DAT_1f8000b8);
  
  *(undefined4 *)(r0 + 0x17) = *(undefined4 *)(param_2 + 0x7c);
  *(undefined4 *)&r0[0x17].vz = *(undefined4 *)(param_2 + 0x80);
  *(undefined4 *)(r0 + 0x18) = *(undefined4 *)(param_2 + 0x84);
  
  // this is "somehow" param_1 (thread)
  iVar5 = *(int *)(puVar11 + 0x40);
  
  do {
    if (iVar5 == 0) {
      return;
    }
	
	// thread -> object
    iVar5 = *(int *)(*(int *)(puVar11 + 0x40) + 0x30);
	
    *(int *)(puVar11 + 0x10) = iVar5;
	
	// if skidmarks are enabled...
	// will be enabled for 7 frames after drift stops,
	// because of how the bit shifting works
    uVar9 = *(uint *)(iVar5 + 0x2c4);
	
	// if skidmarks are enabled
    if (0xf < uVar9) {
      uVar12 = 0;
      pSVar7 = r0 + 5;
      pSVar6 = r0 + 0xe;
      pSVar10 = (SVECTOR *)&r0[9].vz;
      uVar1 = *(byte *)(iVar5 + 0xc3) - 1 & 7;
      *(uint *)(puVar11 + 0x14) = uVar1;
      iVar5 = iVar5 + uVar1 * 0x40;
      iVar2 = (int)*(short *)(iVar5 + 0xc4) - *(int *)(r0 + 0x17);
      iVar4 = iVar2 * 4;
      iVar3 = iVar4;
      if (iVar4 < 0) {
        iVar3 = iVar2 * -4;
      }
      pSVar8 = (SVECTOR *)&r0[0x12].vz;
      if (iVar3 < 0x1771) {
        r0->vx = (short)iVar4;
        iVar2 = (int)*(short *)(iVar5 + 0xc6) - *(int *)&r0[0x17].vz;
        iVar4 = iVar2 * 4;
        iVar3 = iVar4;
        if (iVar4 < 0) {
          iVar3 = iVar2 * -4;
        }
        if (iVar3 < 0x1771) {
          r0->vy = (short)iVar4;
          iVar3 = (int)*(short *)(iVar5 + 200) - *(int *)(r0 + 0x18);
          iVar2 = iVar3 * 4;
          iVar5 = iVar2;
          if (iVar2 < 0) {
            iVar5 = iVar3 * -4;
          }
          if (iVar5 < 0x1771) {
            r0->vz = (short)iVar2;
            gte_ldv0(r0);
            gte_rtv0();
            iVar5 = gte_stMAC3();
            if (iVar5 >> 2 < 0x180) {
              uVar1 = 0x7f;
            }
            else {
              gte_ldLZCS((iVar5 >> 2) + -0x180);
              iVar5 = gte_stLZCR();
              uVar1 = 0x1a - iVar5;
              if ((int)uVar1 < 0) {
                uVar1 = 0;
              }
              uVar1 = 0x7f >> (uVar1 & 0x1f);
              if ((int)uVar1 < 0x10) goto LAB_8005c9dc;
            }
            *(uint *)&r0[3].vz = uVar1 | uVar1 << 8 | 0x3e000000 | uVar1 << 0x10;
            *(undefined4 *)(r0 + 4) = 0xffffffff;
            do {
              uVar1 = uVar9;
              r0_00 = pSVar7;
              pSVar7 = pSVar6;
              if (uVar1 == 0) break;
              if ((uVar1 & 0xf) != 0) 
			  {
                iVar3 = *(int *)(puVar11 + 0x14) * 0x40;
                iVar5 = *(int *)(puVar11 + 0x10) + iVar3 + 0xc4;
                
				FUN_8005c278(r0,iVar5,iVar5 + 8,iVar5 + 0x10);
                gte_ldv3c(r0);
                gte_rtpt();
				
                FUN_8005c278(r0,iVar5 + 0x18,iVar5 + 0x20,iVar5 + 0x28);
                gte_stsxy3c((long *)r0_00);
                gte_stsz3c((long *)pSVar7);
                gte_ldv3c(r0);
                gte_rtpt();
                
				FUN_8005c278(r0,iVar5 + 0x30,iVar5 + 0x38,iVar5);
                gte_stsxy3c((long *)&r0_00[1].vz);
                gte_stsz3c((long *)&pSVar7[1].vz);
                gte_ldv3c(r0);
                gte_rtpt();
                
				gte_stsxy3c((long *)(r0_00 + 3));
                gte_stsz3c((long *)(pSVar7 + 3));
                
				// skidmark primitive 1/4
				if (((((uVar1 & uVar12 & 1) != 0) && (0x20 < *(int *)pSVar7)) &&
                    (0x20 < *(int *)&pSVar7->vz)) &&
                   ((0x20 < *(int *)pSVar8 && (0x20 < *(int *)&pSVar8->vz)))) 
				{
                  iVar5 = *(int *)(puVar11 + 0x10);
                  *(uint *)&r0[4].vz = (uint)*(byte *)(iVar5 + iVar3 + 0xcb);
                  
				  // draw prim
				  FUN_8005c120(r0_00,pSVar10,
                               (*(int *)pSVar7 >> 2) + (uint)*(byte *)(iVar5 + iVar3 + 0xca) * 0x40,
                               r0);
                }
				
				// skidmark primitive 2/4
                if ((((uVar1 & uVar12 & 2) != 0) && (0x20 < *(int *)(pSVar7 + 1))) &&
                   ((0x20 < *(int *)&pSVar7[1].vz &&
                    ((0x20 < *(int *)(pSVar8 + 1) && (0x20 < *(int *)&pSVar8[1].vz)))))) 
				{
                  iVar5 = *(int *)(puVar11 + 0x14);
                  iVar3 = *(int *)(puVar11 + 0x10);
                  *(uint *)&r0[4].vz = (uint)*(byte *)(iVar3 + iVar5 * 0x40 + 0xdb);
                  
				  // draw prim
				  FUN_8005c120(r0_00 + 1,pSVar10 + 1,
                               (*(int *)(pSVar7 + 1) >> 2) +
                               (uint)*(byte *)(iVar3 + iVar5 * 0x40 + 0xda) * 0x40,r0);
                }
				
				// skidmark primitive 3/4
                if (((((uVar1 & uVar12 & 4) != 0) && (0x20 < *(int *)(pSVar7 + 2))) &&
                    (0x20 < *(int *)&pSVar7[2].vz)) &&
                   ((0x20 < *(int *)(pSVar8 + 2) && (0x20 < *(int *)&pSVar8[2].vz)))) 
				{
                  iVar5 = *(int *)(puVar11 + 0x14);
                  iVar3 = *(int *)(puVar11 + 0x10);
                  *(uint *)&r0[4].vz = (uint)*(byte *)(iVar3 + iVar5 * 0x40 + 0xeb);
                  
				  // draw prim
				  FUN_8005c120(r0_00 + 2,pSVar10 + 2,
                               (*(int *)(pSVar7 + 2) >> 2) +
                               (uint)*(byte *)(iVar3 + iVar5 * 0x40 + 0xea) * 0x40,r0);
                }
				
				// skidmark primitive 4/4
                if ((((uVar1 & uVar12 & 8) != 0) && (0x20 < *(int *)(pSVar7 + 3))) &&
                   ((0x20 < *(int *)&pSVar7[3].vz &&
                    ((0x20 < *(int *)(pSVar8 + 3) && (0x20 < *(int *)&pSVar8[3].vz)))))) 
				{
                  iVar5 = *(int *)(puVar11 + 0x14);
                  iVar3 = *(int *)(puVar11 + 0x10);
                  *(uint *)&r0[4].vz = (uint)*(byte *)(iVar3 + iVar5 * 0x40 + 0xfb);
				  
				  // draw prim
                  FUN_8005c120(r0_00 + 3,pSVar10 + 3,
                               (*(int *)(pSVar7 + 3) >> 2) +
                               (uint)*(byte *)(iVar3 + iVar5 * 0x40 + 0xfa) * 0x40,r0);
                }
              }
              *(uint *)(puVar11 + 0x14) = *(int *)(puVar11 + 0x14) + 1U & 7;
              if (*(int *)(r0 + 4) == -1) {
                *(undefined4 *)(r0 + 4) = *(undefined4 *)&r0[3].vz;
                uVar9 = uVar1;
                uVar1 = 0xf;
              }
              else {
                uVar9 = uVar1 >> 4;
                uVar12 = (int)(*(uint *)&r0[3].vz & 0xff) >> 1;
                *(undefined4 *)(r0 + 4) = *(undefined4 *)&r0[3].vz;
                *(uint *)&r0[3].vz = uVar12 | uVar12 << 8 | 0x3e000000 | uVar12 << 0x10;
              }
              pSVar6 = pSVar8;
              pSVar8 = pSVar7;
              pSVar7 = pSVar10;
              pSVar10 = r0_00;
              uVar12 = uVar1;
            } while (*(int *)(r0 + 4) != 0);
          }
        }
      }
    }
LAB_8005c9dc:

	// thread = thread -> next
    iVar5 = *(int *)(*(int *)(puVar11 + 0x40) + 0x10);
    *(int *)(puVar11 + 0x40) = iVar5;
	
  } while( true );
}


// Driver_UpdateLapProgress (param1=driver)
void FUN_8005ca24(int param_1)

{
  ushort uVar1;
  undefined *puVar2;
  undefined4 in_zero;
  undefined4 in_at;
  undefined4 uVar3;
  undefined4 uVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  short *psVar8;
  int iVar9;
  short *psVar10;
  ushort uVar11;
  int iVar12;
  undefined4 local_30;
  undefined4 local_20;
  uint local_1c;

  // if player structure is not nullptr
  if (param_1 != 0)
  {
    uVar11 = 0xffff;

	// If this is human and not an AI
    if ((*(uint *)(param_1 + 0x2c8) & 0x100000) == 0)
	{
	  // quadblock (last valid)
      iVar7 = *(int *)(param_1 + 0x354);

      if (
			// if quadblock exists
			(iVar7 != 0) &&

			// quadBlock -> respawnIndex is valid
			(*(char *)(iVar7 + 0x3e) != -1)
		 )
	  {
		// quadblock -> respawnIndex
        uVar11 = (ushort)*(byte *)(iVar7 + 0x3e);
      }
    }

	// If this is an AI
    else
	{
	  // duplicate of quadblock respawnIndex (AI-exclusive)
      uVar11 = (ushort)*(byte *)(param_1 + 0x60a);
    }

	// if level has respawn points
    if ((*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x148) - 1U < 0xff) &&

	   // respawnIndex is valid
	   (-1 < (int)(short)uVar11))
	{
	  // array of respawn points
      iVar7 = *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c);

	  // byte offset of respawn point from last-valid quadblock
      iVar12 = iVar7 + (int)(short)uVar11 * 0xc;

	  // pointer to desired respawn point
	  psVar10 = (short *)(iVar7 + (uint)*(byte *)(iVar12 + 8) * 0xc);

	  // Player X, Y, and Z
      uVar3 = *(undefined4 *)(param_1 + 0x2d4);
      uVar4 = *(undefined4 *)(param_1 + 0x2d8);
      uVar5 = *(uint *)(param_1 + 0x2dc);

      psVar8 = (short *)(iVar7 + (uint)*(byte *)(psVar10 + 4) * 0xc);
      local_20 = CONCAT22(psVar10[1] - psVar8[1],*psVar10 - *psVar8);
      local_1c = local_1c & 0xffff0000 | (uint)(ushort)(psVar10[2] - psVar8[2]);

	  // MATH_VectorNormalize
	  FUN_8003d378(&local_20);

	  puVar2 = PTR_DAT_8008d2ac;
      local_30 = CONCAT22((short)((uint)uVar4 >> 8) - psVar10[1],
                          (short)((uint)uVar3 >> 8) - *psVar10);
      setCopControlWord(2,0,local_30);
      setCopControlWord(2,0x800,(uVar5 >> 8 & 0xffff) - (uint)(ushort)psVar10[2] & 0xffff |
                                ((int)((uint)*(ushort *)(param_1 + 0x314) << 0x10) >> 0x15) << 0x10)
      ;
      setCopControlWord(2,0x1000,(int)((uint)*(ushort *)(param_1 + 0x31a) << 0x10) >> 0x15 & 0xffffU
                                 | ((int)((uint)*(ushort *)(param_1 + 800) << 0x10) >> 0x15) << 0x10
                       );
      setCopReg(2,in_zero,local_20);
      setCopReg(2,in_at,local_1c);

      copFunction(2,0x406012);

	  iVar7 = getCopReg(2,0xc800);
      iVar9 = getCopReg(2,0xd000);
      iVar6 = (uint)(ushort)psVar10[3] * 8 + (iVar7 >> 0xc);

	  // set new progress
      *(int *)(param_1 + 0x488) = iVar6;

	  uVar1 = *(ushort *)(*(int *)(*(int *)(puVar2 + 0x160) + 0x14c) + 6);
      iVar7 = (uint)uVar1 << 3;
      if (uVar1 == 0) {
        trap(0x1c00);
      }
      if ((iVar7 == -1) && (iVar6 == -0x80000000)) {
        trap(0x1800);
      }

	  // set new progress
      *(int *)(param_1 + 0x488) = iVar6 % iVar7;

	  if (iVar9 < 0x5a801) {
        //uVar5 = Actions Flag set with 9th bit off
        uVar5 = *(uint *)(param_1 + 0x2c8) & 0xfffffeff;
      }
      else {
        //uVar5 = Actions Flag set with 9th bit on
        uVar5 = *(uint *)(param_1 + 0x2c8) | 0x100;
      }

	  //manage 9th bit of Actions Flag set
      *(uint *)(param_1 + 0x2c8) = uVar5;

      //if 28th bit of Actions Flag set is on (means ?) and
      if (((*(uint *)(param_1 + 0x2c8) & 0x8000000) != 0) &&
         ((uint)*(byte *)(param_1 + 0x495) != (int)(short)uVar11))
	  {
		// save respawn index
        *(undefined *)(param_1 + 0x494) = (char)uVar11;

		//turn off 28th bit of Actions Flag set (means ?)
        *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) & 0xf7ffffff;
      }
      if (*(char *)(iVar12 + 9) != -1) {
        //turn on 28th bit of Actions Flag set (means ?)
        *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) | 0x8000000;
      }

	  // respawnIndex
      *(undefined *)(param_1 + 0x495) = (char)uVar11;
    }
  }
  return;
}

// Driver_ConvertVectorsToSpeed
// param_1: &driver
// param_2: velocityXYZs
void FUN_8005cd1c(int param_1,int *param_2)

{
  undefined2 extraout_var;
  short extraout_var_00;
  short extraout_var_01;
  long x;
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;

  // 2D movement
  // x = sqrt(x2+z2 << 0x10)
  x = FUN_80059070(*param_2 * *param_2 + param_2[2] * param_2[2], 0x10);

  // 3D movement
  // sqrt(x2+y2+z2 << 0x10)
  FUN_80059070(*param_2 * *param_2 + param_2[1] * param_2[1] + param_2[2] * param_2[2],0x10);

  // Ghidra missed this!
  // extraout_var = FUN_80059070(*param_2 * *param_2 + param_2[1] * param_2[1] + param_2[2] * param_2[2],0x10);
  // extraout_var = extraout_var << 0x8;

  // 3D speed
  *(undefined2 *)(param_1 + 0x38c) = extraout_var;
  
  // X speed
  x = ratan2(param_2[1] << 8,x);
  *(undefined2 *)(param_1 + 0x394) = (short)x;
  
  // Z speed
  x = ratan2(*param_2,param_2[2]);
  *(undefined2 *)(param_1 + 0x396) = (short)x;
  
  iVar4 = *param_2 * (int)*(short *)(param_1 + 0x312) +
          param_2[1] * (int)*(short *)(param_1 + 0x318) +
          param_2[2] * (int)*(short *)(param_1 + 0x31e) >> 0xc;
		  
  iVar1 = (int)*(short *)(param_1 + 0x312) * iVar4 >> 0xc;
  iVar2 = (int)*(short *)(param_1 + 0x318) * iVar4 >> 0xc;
  iVar3 = (int)*(short *)(param_1 + 0x31e) * iVar4 >> 0xc;

  // sqrt(x2+y2+z2 << 0x10)
  FUN_80059070(iVar1 * iVar1 + iVar2 * iVar2 + iVar3 * iVar3,0x10);

  // Ghidra missed this!
  // extraout_var_00 = FUN_80059070(iVar1 * iVar1 + iVar2 * iVar2 + iVar3 * iVar3,0x10);
  // extraout_var_00 = extraout_var_00 << 0x8;

  *(short *)(param_1 + 0x390) = extraout_var_00;
  if (iVar4 < 0) {
    *(short *)(param_1 + 0x390) = -extraout_var_00;
  }
  iVar1 = *param_2 - iVar1;
  iVar2 = param_2[1] - iVar2;
  iVar3 = param_2[2] - iVar3;

  // sqrt(x2+y2+z2 << 0x10)
  FUN_80059070(iVar1 * iVar1 + iVar2 * iVar2 + iVar3 * iVar3,0x10);

  // Ghidra missed this!
  // extraout_var_01 = FUN_80059070(iVar1 * iVar1 + iVar2 * iVar2 + iVar3 * iVar3,0x10);
  // extraout_var_01 = extraout_var_01 << 0x8;

  *(short *)(param_1 + 0x38e) = extraout_var_01;
  if (
		iVar1 * *(short *)(param_1 + 0x314) + 
		iVar2 * *(short *)(param_1 + 0x31a) +
		iVar3 * *(short *)(param_1 + 0x320) 
		< 0
	  ) {
    *(short *)(param_1 + 0x38e) = -extraout_var_01;
  }
  return;
}


// DriverCrash_BounceSelf
undefined4 FUN_8005cf64(short *param_1,int *param_2,int *param_3,int param_4)

{
  short sVar1;
  short sVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;

  iVar5 = param_2[1];
  iVar6 = param_2[2];
  iVar8 = (*param_3 - *param_2) * (int)*param_1 + (param_3[1] - iVar5) * (int)param_1[1] +
          (param_3[2] - iVar6) * (int)param_1[2] >> 0xc;
  if (param_4 == 0) {
    if (iVar8 < 0) goto LAB_8005cfdc;
  }
  else {
    if (0 < iVar8) {
LAB_8005cfdc:
      iVar7 = iVar8;
      if (iVar8 < 0) {
        iVar7 = -iVar8;
      }
      if (DAT_8008d9f4 < iVar7) {
        DAT_8008d9f4 = iVar7;
      }
      iVar7 = iVar8 * *param_1 >> 0x1f;
      sVar1 = param_1[1];
      sVar2 = param_1[2];
      iVar3 = iVar8 * sVar1 >> 0x1f;
      iVar4 = iVar8 * sVar2 >> 0x1f;
      *param_3 = ((*param_3 - *param_2) - (((iVar8 * *param_1) / 6 + iVar7 >> 9) - iVar7)) +
                 *param_2;
      iVar5 = ((param_3[1] - iVar5) - (((iVar8 * sVar1) / 6 + iVar3 >> 9) - iVar3)) + param_2[1];
      if ((param_3[1] < iVar5) && (0x3200 < iVar5)) {
        iVar5 = 0x3200;
      }
      param_3[1] = iVar5;
      param_3[2] = ((param_3[2] - iVar6) - (((iVar8 * sVar2) / 6 + iVar4 >> 9) - iVar4)) +
                   param_2[2];
      return 0;
    }
  }
  return 0;
}


// DriverCrash_AI
void FUN_8005d0d0(int param_1,int *param_2)

{
  int iVar1;
  int iVar2;

  DAT_8008d9ec = (ushort)*(byte *)(*(int *)(param_1 + 0x5a4) + 6) << 4;
  DAT_8008d9ee = (ushort)*(byte *)(*(int *)(param_1 + 0x5a4) + 7) << 4;
  DAT_8008d9f0 = (ushort)*(byte *)(*(int *)(param_1 + 0x5a4) + 8) << 4;

   // convert 3 rotation shorts into rotation matrix
  FUN_8006c2a4(&DAT_8009ae38,&DAT_8008d9ec);

  DAT_8009ae28 = (int)((uint)DAT_8009ae3c << 0x10) >> 0x14;
  DAT_8009ae2c = (int)((uint)DAT_8009ae42 << 0x10) >> 0x14;
  DAT_8009ae30 = (int)((uint)DAT_8009ae48 << 0x10) >> 0x14;
  iVar1 = DAT_8009ae28 * *param_2 + DAT_8009ae2c * param_2[1] + DAT_8009ae30 * param_2[2] >> 8;
  *(int *)(param_1 + 0x5d4) = iVar1;
  *(int *)(param_1 + 0x5d8) = *param_2 - (DAT_8009ae28 * iVar1 >> 8);
  iVar1 = DAT_8009ae30 * iVar1;
  iVar2 = param_2[2];
  *(uint *)(param_1 + 0x5b0) = *(uint *)(param_1 + 0x5b0) | 8;
  *(int *)(param_1 + 0x5e0) = iVar2 - (iVar1 >> 8);
  return;
}

// DriverCrash_Attack
//param_1 = driver pointer
//param_2 = driver pointer
int FUN_8005d218(int param_1,int param_2,int param_3,int param_4)
{
  int iVar1;

  //if driver (1) is not using mask weapon
  if ((*(uint *)(param_1 + 0x2c8) & 0x800000) == 0)
  {
	//if driver (2) is using mask weapon
    if ((*(uint *)(param_2 + 0x2c8) & 0x800000) != 0)
	{
	  // param_1 was hit with a mask weapon
      *(undefined *)(param_1 + 0x4ff) = 2;
      *(undefined *)(param_1 + 0x504) = 6;
      *(int *)(param_1 + 0x500) = param_2;

	  if (((param_3 != 0) && (*(char *)(param_1 + 0x376) != '\x06')) &&
         (*(int *)(param_1 + 0x24) == 0))
	  {
		// OtherFX_DriverCrashing
        FUN_8002e760(

			// if driver is supposed to echo
			(uint)*(ushort *)(param_1 + 0x2ca) & 1,

			0xff
		);

		// Make driver talk
        FUN_8002cbe8(1,(int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)],0x10);
      }
    }

	// if one driver has a bubble, and the other does not
	if ((*(int *)(param_2 + 0x14) != 0) && (*(int *)(param_1 + 0x14) == 0))
	{
		// driver -> bubbleInst -> thread -> object
      iVar1 = *(int *)(*(int *)(*(int *)(param_2 + 0x14) + 0x6c) + 0x30);

      *(ushort *)(iVar1 + 6) = *(ushort *)(iVar1 + 6) | 8;

	  // clear bubbleInst pointer
      *(undefined4 *)(param_2 + 0x14) = 0;

      *(undefined *)(param_1 + 0x4ff) = 2;
      *(undefined *)(param_1 + 0x504) = 0;
      *(int *)(param_1 + 0x500) = param_2;

	  if (
			(param_3 != 0) &&

			(
				(
					// if driver is not blasted
					*(char *)(param_1 + 0x376) != '\x06' &&

					// if driver is not invincible
					(*(int *)(param_1 + 0x24) == 0)
				)
			)
		 )
	  {
		// OtherFX_DriverCrashing
        FUN_8002e760(

			// if driver is supposed to echo
			(uint)*(ushort *)(param_1 + 0x2ca) & 1,

			0xff
		);

		if (param_4 != 0)
		{
		  // OtherFX_Play
          FUN_80028468(0x4f,1);
        }

		// Make driver talk
        FUN_8002cbe8(1,(int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)],0x10);
      }
    }

	// if one driver squished the other with turbo
    if (
		(
			(
				// force that the drivers collided is high
				(0xa00 < DAT_8008d9f4) && 
				
				// attacking driver has reserves
				(*(short *)(param_2 + 0x3e2) != 0)
			) &&
      
			// attacking driver is using turbo weapon
			((*(uint *)(param_2 + 0x2c8) & 0x200) != 0)
		) && 
		
		// attacked driver has no reserves
		(*(short *)(param_1 + 0x3e2) == 0)
	  ) 
	{
	  // set forcedJump_trampoline on attacking driver
      *(undefined *)(param_2 + 0x366) = 2;
	  
	  // attacked driver has been squished by attacking driver,
	  // this happens when one driver uses turbo weapon on another
      *(undefined *)(param_1 + 0x4ff) = 3;
      *(undefined *)(param_1 + 0x504) = 5;
      *(int *)(param_1 + 0x500) = param_2;
    }
  }
  return param_3;
}

// DriverCrash_AnyTwoCars
// pass the thread, collision data, and driver->88 velocityXYZ[] (x, y, z)
// calls Crash_AI and Crash_HumanToHuman
void FUN_8005d404(int param_1,int param_2,int *param_3)

{
  undefined2 uVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  undefined4 uVar9;
  uint uVar10;
  int local_48;
  int local_44;
  int local_40;
  int local_38;
  int local_34;
  int local_30;

  // fast sqrt
  iVar2 = FUN_8003d214(*(undefined4 *)(param_2 + 0xc),0);

  uVar1 = 0x1000;
  if (iVar2 == 0) {
    *(undefined2 *)(param_2 + 0x18) = 0;
    *(undefined2 *)(param_2 + 0x1a) = 0;
  }
  else 
  {
	// distX
    iVar8 = (int)*(short *)(param_2 + 0x10) << 0xc;
    
	// safety check
	if (iVar2 == 0) { trap(0x1c00); }
    if ((iVar2 == -1) && (iVar8 == -0x80000000)) { trap(0x1800); }
	
	// distY
    iVar5 = (int)*(short *)(param_2 + 0x12) << 0xc;
	
	// safety check
    if (iVar2 == 0) { trap(0x1c00); }
    if ((iVar2 == -1) && (iVar5 == -0x80000000)) { trap(0x1800); }
    
	// distZ
	iVar3 = (int)*(short *)(param_2 + 0x14) << 0xc;
    
	// safety check
	if (iVar2 == 0) { trap(0x1c00); }
    if ((iVar2 == -1) && (iVar3 == -0x80000000)) { trap(0x1800); }
	
	// hit direction vector,
	// divide each direction by distance
    uVar1 = (undefined2)(iVar3 / iVar2);
    *(undefined2 *)(param_2 + 0x18) = (short)(iVar8 / iVar2);
    *(undefined2 *)(param_2 + 0x1a) = (short)(iVar5 / iVar2);
  }
  
  // hit direction vector
  *(undefined2 *)(param_2 + 0x1c) = uVar1;
  
  // two driver objects
  iVar8 = *(int *)(*(int *)(param_2 + 8) + 0x30);
  iVar5 = *(int *)(param_1 + 0x30);

  // hit strength
  iVar2 = 
			(
				// driver1 radius
				(int)*(short *)(param_1 + 0x42) +
				
				// driver2 radius
				(int)*(short *)(*(int *)(*(int *)(iVar8 + 0x1c) + 0x6c) + 0x42)
			) 
			
			// minus distance between them
			- iVar2;

  // if hitStrength < 0, drivers dont collide,
  // if hitStrength == 0, drivers touch, but with no force
  // if hitStrength > 0, drivers touch with force
  
  // if drivers hit each other
  if (0 < iVar2)
  {
    DAT_8008d9f4 = 0;

	// If this is human and not AI
    if ((*(uint *)(iVar5 + 0x2c8) & 0x100000) == 0) {
      iVar3 = param_2 + 0x18;

	  // If this (other driver) is human and not AI
      if ((*(uint *)(iVar8 + 0x2c8) & 0x100000) == 0) {
        iVar7 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar6 = *param_3 * (int)*(short *)(iVar5 + 0x47c) +
                *(int *)(iVar8 + 0x88) * (int)*(short *)(iVar8 + 0x47c);
        local_38 = iVar6 / iVar7;
        if (iVar7 == 0) {
          trap(0x1c00);
        }
        if ((iVar7 == -1) && (iVar6 == -0x80000000)) {
          trap(0x1800);
        }
        iVar7 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar6 = param_3[1] * (int)*(short *)(iVar5 + 0x47c) +
                *(int *)(iVar8 + 0x8c) * (int)*(short *)(iVar8 + 0x47c);
        local_34 = iVar6 / iVar7;
        if (iVar7 == 0) {
          trap(0x1c00);
        }
        if ((iVar7 == -1) && (iVar6 == -0x80000000)) {
          trap(0x1800);
        }
        iVar7 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar6 = param_3[2] * (int)*(short *)(iVar5 + 0x47c) +
                *(int *)(iVar8 + 0x90) * (int)*(short *)(iVar8 + 0x47c);
        local_30 = iVar6 / iVar7;
        if (iVar7 == 0) {
          trap(0x1c00);
        }
        if ((iVar7 == -1) && (iVar6 == -0x80000000)) {
          trap(0x1800);
        }

		// DriverCrash_BounceSelf
        iVar6 = FUN_8005cf64(iVar3,&local_38,iVar8 + 0x88,1);

        if (iVar6 < 0) {
          DAT_8008d9f4 = 0;
        }

		// DriverCrash_BounceSelf
		iVar3 = FUN_8005cf64(iVar3,&local_38,param_3,0);

        if (0 < iVar3) {
          DAT_8008d9f4 = 0;
        }
        *param_3 = *param_3 + (*(short *)(param_2 + 0x18) * iVar2 >> 8);
        param_3[1] = param_3[1] + (*(short *)(param_2 + 0x1a) * iVar2 >> 8);
        param_3[2] = param_3[2] + (*(short *)(param_2 + 0x1c) * iVar2 >> 8);
		
		// deduct speed by (dirVec * hitStrength)
        *(int *)(iVar8 + 0x88) = *(int *)(iVar8 + 0x88) - (*(short *)(param_2 + 0x18) * iVar2 >> 8);
        *(int *)(iVar8 + 0x8c) = *(int *)(iVar8 + 0x8c) - (*(short *)(param_2 + 0x1a) * iVar2 >> 8);
        *(int *)(iVar8 + 0x90) = *(int *)(iVar8 + 0x90) - (*(short *)(param_2 + 0x1c) * iVar2 >> 8);
      }

	  // If this (other driver) is an AI
	  else {
        local_48 = *(int *)(iVar8 + 0x3a0) + *(int *)(iVar8 + 0x5d8);
        local_44 = *(int *)(iVar8 + 0x3a4) + *(int *)(iVar8 + 0x5dc);
        local_40 = *(int *)(iVar8 + 0x3a8) + *(int *)(iVar8 + 0x5e0);
        iVar7 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar6 = *param_3 * (int)*(short *)(iVar5 + 0x47c) +
                local_48 * (int)*(short *)(iVar8 + 0x47c);
        local_38 = iVar6 / iVar7;
        if (iVar7 == 0) {
          trap(0x1c00);
        }
        if ((iVar7 == -1) && (iVar6 == -0x80000000)) {
          trap(0x1800);
        }
        iVar7 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar6 = param_3[1] * (int)*(short *)(iVar5 + 0x47c) +
                local_44 * (int)*(short *)(iVar8 + 0x47c);
        local_34 = iVar6 / iVar7;
        if (iVar7 == 0) {
          trap(0x1c00);
        }
        if ((iVar7 == -1) && (iVar6 == -0x80000000)) {
          trap(0x1800);
        }
        iVar7 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar6 = param_3[2] * (int)*(short *)(iVar5 + 0x47c) +
                local_40 * (int)*(short *)(iVar8 + 0x47c);
        local_30 = iVar6 / iVar7;
        if (iVar7 == 0) {
          trap(0x1c00);
        }
        if ((iVar7 == -1) && (iVar6 == -0x80000000)) {
          trap(0x1800);
        }

		// DriverCrash_BounceSelf
        iVar6 = FUN_8005cf64(iVar3,&local_38,&local_48,1);

		if (iVar6 < 0) {
          DAT_8008d9f4 = 0;
        }

		// DriverCrash_BounceSelf
		iVar3 = FUN_8005cf64(iVar3,&local_38,param_3,0);

		if (0 < iVar3) {
          DAT_8008d9f4 = 0;
        }

		*param_3 = *param_3 + (*(short *)(param_2 + 0x18) * iVar2 >> 8);
        param_3[1] = param_3[1] + (*(short *)(param_2 + 0x1a) * iVar2 >> 8);
        param_3[2] = param_3[2] + (*(short *)(param_2 + 0x1c) * iVar2 >> 8);

        local_48 = local_48 - (*(short *)(param_2 + 0x18) * iVar2 >> 8);
        local_44 = local_44 - (*(short *)(param_2 + 0x1a) * iVar2 >> 8);
        local_40 = local_40 - (*(short *)(param_2 + 0x1c) * iVar2 >> 8);

		// DriverCrash_AI
        FUN_8005d0d0(iVar8,&local_48);
      }
      uVar10 = (uint)((uint)(*(int *)(PTR_DAT_8008d2ac + 0x1cf8) - DAT_8008d838) < 3) ^ 1;
      if (0x200 < DAT_8008d9f4)
	  {
		  // thread -> modelIndex == "player" of any kind
        if ((((*(short *)(param_1 + 0x44) == 0x18) ||

			// modelIndex == "player" of any kind
            (*(short *)(*(int *)(param_2 + 8) + 0x44) == 0x18)) &&

            // Map value from [oldMin, oldMax] to [newMin, newMax]
            // inverting newMin and newMax will give an inverse range mapping
            (uVar4 = FUN_80058f9c(DAT_8008d9f4,0,0x1900,0x3f,0xff), uVar10 != 0)) &&
             (
				// if both drivers are not blasted and not invincible
				((*(char *)(iVar5 + 0x376) != '\x06' && (*(int *)(iVar5 + 0x24) == 0)) &&
				((*(char *)(iVar8 + 0x376) != '\x06' && (*(int *)(iVar8 + 0x24) == 0))))
			  )
			)
		{
		  // OtherFX_DriverCrashing
          FUN_8002e760(

				// if driver is supposed to echo
				(uint)*(ushort *)(iVar5 + 0x2ca) & 1,

				uVar4
			);

		  DAT_8008d838 = *(int *)(PTR_DAT_8008d2ac + 0x1cf8);
          if (0xdc < uVar4)
		  {
			// Make driver talk
            FUN_8002cbe8(5,(int)(short)(&DAT_80086e84)[*(byte *)(iVar5 + 0x4a)],0x10);
          }
        }

		// both vibration related
		FUN_80026440(iVar8,8,0);
        FUN_800264c0(iVar8,8,0x7f);

        if (*(char *)(iVar8 + 0x4b) < '\x01') {
          uVar9 = 0x19;
        }
        else {
          uVar9 = 0x29;
        }

		// all three are vibration related
        FUN_800263a0(iVar8,uVar9,0x60);
        FUN_80026440(iVar5,8,0);
        FUN_800264c0(iVar5,8,0x7f);

        if (*(char *)(iVar5 + 0x4b) < '\x01') {
          uVar9 = 0x19;
        }
        else {
          uVar9 = 0x29;
        }

		// gamepad vibration
        FUN_800263a0(iVar5,uVar9,0x60);

		// flag used in 80062e04
		// Let both human drivers know, they are in a human-human collision
        *(uint *)(iVar5 + 0x2c8) = *(uint *)(iVar5 + 0x2c8) | 0x10000000;
        *(uint *)(iVar8 + 0x2c8) = *(uint *)(iVar8 + 0x2c8) | 0x10000000;
      }
	  
	  // DriverCrash_Attack
      uVar9 = FUN_8005d218(iVar5,iVar8,uVar10,0);
      FUN_8005d218(iVar8,iVar5,uVar9,1);
    }

	// If this is an AI
	else
	{
	  // If this (other driver) is human and not AI
      if ((*(uint *)(iVar8 + 0x2c8) & 0x100000) == 0)
	  {
		// Driver_ConvertSpeedToVectors
        FUN_8005e104(iVar8,&local_48);

        iVar6 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar3 = *param_3 * (int)*(short *)(iVar5 + 0x47c) +
                local_48 * (int)*(short *)(iVar8 + 0x47c);
        local_38 = iVar3 / iVar6;
        if (iVar6 == 0) {
          trap(0x1c00);
        }
        if ((iVar6 == -1) && (iVar3 == -0x80000000)) {
          trap(0x1800);
        }
        iVar6 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar3 = param_3[1] * (int)*(short *)(iVar5 + 0x47c) +
                local_44 * (int)*(short *)(iVar8 + 0x47c);
        local_34 = iVar3 / iVar6;
        if (iVar6 == 0) {
          trap(0x1c00);
        }
        if ((iVar6 == -1) && (iVar3 == -0x80000000)) {
          trap(0x1800);
        }
        iVar6 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar3 = param_3[2] * (int)*(short *)(iVar5 + 0x47c) +
                local_40 * (int)*(short *)(iVar8 + 0x47c);
        local_30 = iVar3 / iVar6;
        if (iVar6 == 0) {
          trap(0x1c00);
        }
        if ((iVar6 == -1) && (iVar3 == -0x80000000)) {
          trap(0x1800);
        }

		// DriverCrash_BounceSelf
        iVar3 = FUN_8005cf64(param_2 + 0x18,&local_38,&local_48,1);

		if (iVar3 < 0) {
          DAT_8008d9f4 = 0;
        }

		// DriverCrash_BounceSelf
		iVar3 = FUN_8005cf64(param_2 + 0x18,&local_38,param_3,0);

		if (0 < iVar3) {
          DAT_8008d9f4 = 0;
        }

		*param_3 = *param_3 + (*(short *)(param_2 + 0x18) * iVar2 >> 8);
        param_3[1] = param_3[1] + (*(short *)(param_2 + 0x1a) * iVar2 >> 8);
        param_3[2] = param_3[2] + (*(short *)(param_2 + 0x1c) * iVar2 >> 8);

		local_48 = local_48 - (*(short *)(param_2 + 0x18) * iVar2 >> 8);
        local_44 = local_44 - (*(short *)(param_2 + 0x1a) * iVar2 >> 8);
        local_40 = local_40 - (*(short *)(param_2 + 0x1c) * iVar2 >> 8);

		// DriverCrash_AI
        FUN_8005d0d0(iVar5,param_3);

		// Driver_ConvertVectorsToSpeed
        FUN_8005cd1c(iVar8,&local_48,0);
      }

	   // If this (other driver) is an AI
	  else {
        local_48 = *(int *)(iVar8 + 0x3a0) + *(int *)(iVar8 + 0x5d8);
        local_44 = *(int *)(iVar8 + 0x3a4) + *(int *)(iVar8 + 0x5dc);
        local_40 = *(int *)(iVar8 + 0x3a8) + *(int *)(iVar8 + 0x5e0);
        iVar6 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar3 = *param_3 * (int)*(short *)(iVar5 + 0x47c) +
                local_48 * (int)*(short *)(iVar8 + 0x47c);
        local_38 = iVar3 / iVar6;
        if (iVar6 == 0) {
          trap(0x1c00);
        }
        if ((iVar6 == -1) && (iVar3 == -0x80000000)) {
          trap(0x1800);
        }
        iVar6 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar3 = param_3[1] * (int)*(short *)(iVar5 + 0x47c) +
                local_44 * (int)*(short *)(iVar8 + 0x47c);
        local_34 = iVar3 / iVar6;
        if (iVar6 == 0) {
          trap(0x1c00);
        }
        if ((iVar6 == -1) && (iVar3 == -0x80000000)) {
          trap(0x1800);
        }
        iVar6 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar3 = param_3[2] * (int)*(short *)(iVar5 + 0x47c) +
                local_40 * (int)*(short *)(iVar8 + 0x47c);
        local_30 = iVar3 / iVar6;
        if (iVar6 == 0) {
          trap(0x1c00);
        }
        if ((iVar6 == -1) && (iVar3 == -0x80000000)) {
          trap(0x1800);
        }

		// DriverCrash_BounceSelf
        iVar3 = FUN_8005cf64(param_2 + 0x18,&local_38,&local_48,1);

		if (iVar3 < 0) {
          DAT_8008d9f4 = 0;
        }

		// DriverCrash_BounceSelf
		iVar3 = FUN_8005cf64(param_2 + 0x18,&local_38,param_3,0);

		if (0 < iVar3) {
          DAT_8008d9f4 = 0;
        }

		*param_3 = *param_3 + (*(short *)(param_2 + 0x18) * iVar2 >> 8);
        param_3[1] = param_3[1] + (*(short *)(param_2 + 0x1a) * iVar2 >> 8);
        param_3[2] = param_3[2] + (*(short *)(param_2 + 0x1c) * iVar2 >> 8);

        local_48 = local_48 - (*(short *)(param_2 + 0x18) * iVar2 >> 8);
        local_44 = local_44 - (*(short *)(param_2 + 0x1a) * iVar2 >> 8);
        local_40 = local_40 - (*(short *)(param_2 + 0x1c) * iVar2 >> 8);

		// DriverCrash_AI (twice)
        FUN_8005d0d0(iVar8,&local_48);
        FUN_8005d0d0(iVar5,param_3);

		// pass pointer to two drivers,
		// this is AI-on-AI collision
        FUN_80016ec8(iVar5,iVar8);
      }
    }
  }
  return;
}

// Driver_ConvertSpeedToVectors
// param_1 = &driver
// param_2 = &driver.velocityXYZ
void FUN_8005e104(int param_1,int *param_2)

{
  short sVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  uint uVar6;

  // angle = axisRotationY
  uVar6 = SEXT24(*(short *)(param_1 + 0x394));

  // approximate trigonometry
  // sVar1 = sin(angle)
  sVar1 = (short)*(int *)(&DAT_800845a0 + (uVar6 & 0x3ff) * 4);
  // iVar5 = cos(angle)
  iVar5 = *(int *)(&DAT_800845a0 + (uVar6 & 0x3ff) * 4) >> 0x10;

  if ((uVar6 & 0x400) == 0) {
    iVar2 = (int)sVar1;
    if ((uVar6 & 0x800) != 0) {
      iVar3 = -iVar5;
      goto LAB_8005e15c;
    }
  }
  else {
    iVar3 = (int)sVar1;
    iVar2 = iVar5;
    if ((uVar6 & 0x800) == 0) {
      iVar5 = -iVar3;
    }
    else {
LAB_8005e15c:
      iVar2 = -iVar2;
      iVar5 = iVar3;
    }
  }

  // velocityXYZ[y] = (driver.speed * ???) >> 0xC
  param_2[1] = *(short *)(param_1 + 0x38c) * iVar2 >> 0xc;

  // angle = axisRotationX
  uVar6 = SEXT24(*(short *)(param_1 + 0x396));
  iVar2 = *(short *)(param_1 + 0x38c) * iVar5 >> 0xc;

  // approximate trigonometry
  iVar5 = *(int *)(&DAT_800845a0 + (uVar6 & 0x3ff) * 4) >> 0x10;
  sVar1 = (short)*(int *)(&DAT_800845a0 + (uVar6 & 0x3ff) * 4);

  if ((uVar6 & 0x400) == 0) {
    iVar3 = (int)sVar1;
    if ((uVar6 & 0x800) == 0) goto LAB_8005e1e8;
    iVar4 = -iVar5;
  }
  else {
    iVar4 = (int)sVar1;
    iVar3 = iVar5;
    if ((uVar6 & 0x800) == 0) {
      iVar5 = -iVar4;
      goto LAB_8005e1e8;
    }
  }
  iVar3 = -iVar3;
  iVar5 = iVar4;

LAB_8005e1e8:
  
  // velocityXYZ[x] and velocityXYZ[z]
  *param_2 = iVar2 * iVar3 >> 0xc;
  param_2[2] = iVar2 * iVar5 >> 0xc;
  return;
}


// OnGravity (for humans only)
// param1 - driver, param2 - velocityXYZ
void FUN_8005e214(int param_1,VECTOR *param_2)

{
  char cVar1;
  undefined2 uVar2;
  int iVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  int iVar13;
  uint unaff_s3;
  uint unaff_s5;
  undefined *puVar14;
  int unaff_s8;
  int iVar15;
  int iVar16;
  undefined auStack72 [16];
  
  puVar14 = auStack72;
  
  // driver -> 0x310 matrix
  uVar8 = *(uint *)(param_1 + 0x310);
  uVar7 = *(uint *)(param_1 + 0x314);
  uVar10 = *(uint *)(param_1 + 0x318);
  uVar9 = *(uint *)(param_1 + 0x31c);
  
  // load matrix into GTE
  gte_ldR11R12(uVar8);
  gte_ldR13R21(uVar7);
  gte_ldR22R23(uVar10);
  gte_ldR31R32(uVar9);
  gte_ldR33((int)*(short *)(param_1 + 800)); // 0x320
  
  // transpose matrix
  gte_ldL11L12(uVar8 & 0xffff | uVar7 & 0xffff0000);
  uVar8 = uVar8 & 0xffff0000;
  gte_ldL13L21(uVar9 & 0xffff | uVar8);
  gte_ldL22L23(uVar10 & 0xffff | uVar9 & 0xffff0000);
  uVar7 = uVar7 & 0xffff | uVar10 & 0xffff0000;
  gte_ldL31L32(uVar7);
  gte_ldL33((int)*(short *)(param_1 + 800)); // 0x320
  
  // load vector from param_2
  gte_ldVXY0((uint)*(ushort *)&param_2->vx | param_2->vy << 0x10);
  gte_ldVZ0(param_2->vz);
  gte_llv0();
  
  // these registers hold movement vector,
  // but why does that need driver matrix?
  read_mt(unaff_s5,unaff_s8,unaff_s3);
  
  // driver gravity constant
  iVar3 = -(int)*(short *)(param_1 + 0x416);

  // elapsed milliseconds per frame, ~32
  iVar5 = *(int *)(PTR_DAT_8008d2ac + 0x1d04);
  iVar6 = iVar5;
  
  // If the driver's under-quadblock has moon gravity
  if ((*(ushort *)(*(int *)(param_1 + 0x350) + 0x12) & 2) != 0) 
  {
	// 41% gravity (41 / 100)
    iVar6 = *(short *)(param_1 + 0x416) * -0x29;
    iVar3 = iVar6 >> 0x1f;
    iVar6 = iVar6 / 100 + iVar3;
    iVar3 = iVar6 - iVar3;
  }
  
  // vector = {0, gravity*elapsedMS, 0}
  // matrix = driver orientation (driver->0x310)
  gte_ldVXY0((iVar3 * iVar5 >> 5) << 0x10);
  gte_ldVZ0(0);
  gte_llv0();
  
  // gravity is a vector, not straight down,
  // this causes road grip, and halfpipe physics
  read_mt(uVar7,uVar8,iVar6);
  
  if (((iVar6 < 0) && (0 < *(short *)(param_1 + 0x3b2))) ||
     ((0 < iVar6 && (*(short *)(param_1 + 0x3b2) < 0)))) {
    iVar6 = 0;
  }
  
  // driver flags
  uVar10 = *(uint *)(param_1 + 0x2c8);
  
  iVar3 = (int)*(short *)(param_1 + 0x38e);     // speed approximate magnitude
  uVar9 = (uint)*(short *)(param_1 + 0x39c);	// baseSpeed
  
  if ((((uVar10 & 8) != 0) || ((0 < (int)uVar9 && (iVar3 < 0)))) ||
     (((int)uVar9 < 0 && (0 < iVar3)))) {
    uVar7 = 0;
    iVar6 = 0;
  }
  
  // movementY + gravityY
  iVar15 = unaff_s8 + uVar8;
  
  uVar11 = (int)*(short *)(param_1 + 0x39e) + (int)*(short *)(param_1 + 0x47e);
  uVar8 = unaff_s3 + iVar6;
  if (((int)uVar11 < (int)(unaff_s3 + iVar6)) && (uVar8 = unaff_s3, (int)unaff_s3 < (int)uVar11)) {
    uVar8 = uVar11;
  }
  uVar11 = (int)*(short *)(param_1 + 0x39e) - ((int)*(short *)(param_1 + 0x47e) >> 1);
  if (((int)uVar8 < (int)uVar11) && (uVar8 = unaff_s3, (int)uVar11 < (int)unaff_s3)) {
    uVar8 = uVar11;
  }
  
  uVar12 = (uint)*(short *)(param_1 + 0x480);
  
  // terrainMeta1
  uVar4 = *(uint *)(*(int *)(param_1 + 0x358) + 4);
  
  uVar11 = unaff_s5 + uVar7;
  if (((int)(unaff_s5 + uVar7) <= (int)uVar12) ||
     (uVar11 = uVar12, uVar7 = unaff_s5, (int)unaff_s5 < (int)uVar12)) {
    uVar7 = uVar11;
  }
  uVar12 = -uVar12;
  if (((int)uVar7 < (int)uVar12) && (uVar7 = unaff_s5, (int)uVar12 < (int)unaff_s5)) {
    uVar7 = uVar12;
  }
  
  // const_TerminalVelocity
  iVar6 = (int)*(short *)(param_1 + 0x442);
  
  if (
		(
			// if falling
			(iVar15 < 0) && 
			
			// terrain = zero-gravity
			// in oxide station
			((uVar4 & 0x80) != 0)
			
		) && 
		
		(
			// terminalVelocity
			iVar6 = 0x100, 
			
			// if movementY is less
			unaff_s8 < -0x100)
	 ) 
  {
	// dont let movementY go 
	// below terminalVelocity
    unaff_s8 = -0x100;
  }
  
  if (
		// if totalY is less than terminalVelocity
		(iVar15 <= iVar6) || 
		
		(
			// copy of terminalVelocity
			iVar15 = iVar6, 
			
			// movementY
			iVar16 = unaff_s8, 
			
			// movementY is less than terminalVelocity
			unaff_s8 < iVar6
		)
	) 
  {
	// movementY = terminalVelocity
    iVar16 = iVar15;
  }
  
  // negate terminal velocity and check again,
  // just in case gravity is upside down (scrapped feature)?
  // that or just make sure you dont go upward too fast
  iVar6 = -iVar6;
  if ((iVar16 < iVar6) && (iVar16 = unaff_s8, iVar6 < unaff_s8)) 
  {
	// movementY = max upward terminalVelocity
    iVar16 = iVar6;
  }
  
  // kart state
  cVar1 = *(char *)(param_1 + 0x376);
  
  // if mask grab
  if (cVar1 == '\x05') {
    uVar7 = 0;
    uVar8 = 0;
  }
  
  // if not mask grab
  else if (
			(
				((*(uint *)(param_1 + 0x2cc) & 1) != 0) || 
				
				// blasted
				(cVar1 == '\x06')
			) ||
			(
				(
					*(short *)(param_1 + 0x3c4) < *(short *)(param_1 + 0x38e) &&
					
					// terrainMeta2
					(*(int *)(*(int *)(param_1 + 0x35c) + 8) < 0x100)
				)
			)
		  ) 
  {
	// 2c8 & 8
	// not in accel-prevention,
	// not holding square, etc...
    if ((uVar10 & 8) == 0) 
	{
	  // current baseSpeed is zero,
	  // which includes kart rolling on hill
	  // without gas pedal or reserves
      if (uVar9 == 0) 
	  {
		// const_NoPedalFriction_Perpendicular
        iVar15 = (int)*(short *)(param_1 + 0x41e);
		
		// const_NoPedalFriction_Forward
        iVar6 = (int)*(short *)(param_1 + 0x420);
		
		// driverRankItemValue
        if (*(short *)(param_1 + 0x50a) == 5) 
		{
		  // const_BrakeFriction
          iVar15 = (int)*(short *)(param_1 + 0x422) << 4;
          iVar6 = iVar15;
        }
      }
	  
	  // baseSpeed > 0,
	  // driving in some way
      else {
        iVar6 = iVar3;
        if (iVar3 < 0) {
          iVar6 = -iVar3;
        }
        if (
				(iVar6 < 0x301) ||
				(
					(
						((int)uVar9 < 1 || (-1 < iVar3)) && 
						((-1 < (int)uVar9 || (iVar3 < 1)))
					)
				)
			) 
		{
		  // kartState drifting
          if (cVar1 == '\x02') 
		  {
			// const_DriftCurve
            iVar15 = (int)*(short *)(param_1 + 0x424);
			
			// const_DriftFriction
            iVar6 = (int)*(short *)(param_1 + 0x426);
          }
		  
		  // driving straight
          else {
            if (iVar3 < 0) {
              iVar3 = -iVar3;
            }
			
			// const_PedalFriction_Perpendicular
            iVar15 = (int)*(short *)(param_1 + 0x41a);
			
			// const_PedalFriction_Forward
            iVar6 = (int)*(short *)(param_1 + 0x41c);
			
            if (0x300 < iVar3) {
              uVar11 = uVar9;
              if ((int)uVar9 < 0) {
                uVar11 = -uVar9;
              }
              if (iVar3 < (int)uVar11 >> 1) {
                uVar10 = uVar10 | 0x800;
              }
            }
          }
        }
        else {
          if (iVar3 < 0) {
            iVar3 = -iVar3;
          }
		  
		  // const_PedalFriction_Perpendicular
          iVar15 = (int)*(short *)(param_1 + 0x41a);
		  
		  // const_BrakeFriction
          iVar6 = (int)*(short *)(param_1 + 0x422);
		  
          if (0x300 < iVar3) {
            uVar10 = uVar10 | 0x800;
          }
        }
      }
    }
    
	// if in accel-prevention
	else {
      if (iVar3 < 0) {
        iVar3 = -iVar3;
      }
      if (0x300 < iVar3) {
        uVar10 = uVar10 | 0x800;
      }
	  
	  // const_BrakeFriction
      iVar3 = (uint)*(ushort *)(param_1 + 0x422) << 0x10;
	  
      iVar15 = iVar3 >> 0x10;
	  
	  // driverRankItemValue
      if (*(short *)(param_1 + 0x50a) == 5) {
        iVar15 = iVar15 << 4;
        iVar6 = iVar15;
      }
	  
	  // blasted kartState
      else if (cVar1 == '\x06') {
        iVar15 = iVar15 * 3 >> 2;
        iVar6 = iVar15;
      }
	  
      else {
        iVar6 = iVar15;
		
		// If you're spinning: if you hit a glass 
		// or spun out from drifting
        if (cVar1 == '\x03') {
          iVar15 = iVar3 >> 0x11;
          iVar6 = iVar15;
        }
      }
    }
	
	// terrainMeta1
    iVar13 = *(int *)(*(int *)(param_1 + 0x358) + 0x20);
	
    iVar3 = iVar15 * iVar5 >> 5;
    iVar6 = iVar6 * iVar5 >> 5;
    if (iVar13 != 0x100) {
      iVar3 = iVar13 * iVar3 >> 8;
      iVar6 = iVar13 * iVar6 >> 8;
    }
    
	iVar15 = (int)*(short *)(param_1 + 0x414);
    
	if (iVar15 < 0) {
      uVar11 = uVar7;
      if (iVar15 == -0x140) {
        if ((int)uVar7 < 0) {
          uVar11 = -uVar7;
        }
        iVar3 = (int)uVar11 >> 1;
      }
      else {
        iVar3 = iVar3 + (iVar3 * *(short *)(param_1 + 0x444) >> 8);
        if (iVar3 < 0) {
          iVar3 = 0;
        }
        if ((int)uVar7 < 0) {
          uVar11 = -uVar7;
        }
      }
      if (0 < (int)uVar11) {
        uVar10 = uVar10 | 0x1800;
		
		  // gamepad vibration
        FUN_800264c0(param_1,4,0x7f);
        FUN_80026440(param_1,4,0);
      }
      iVar15 = iVar15 + iVar5;
      if (0 < iVar15) {
        iVar15 = 0;
      }
      *(short *)(param_1 + 0x414) = (short)iVar15;
    }
    else if (0 < iVar15) {
      iVar15 = iVar15 - iVar5;
      if (iVar15 < 0) {
        iVar15 = 0;
      }
      iVar3 = iVar3 + (iVar3 * *(short *)(param_1 + 0x444) >> 8);
      *(short *)(param_1 + 0x414) = (short)iVar15;
      if (iVar3 < 0) {
        iVar3 = 0;
      }
    }
    if (((uVar10 & 0x800000) == 0) && (iVar5 = (int)uVar7 >> 3, (uVar4 & 0x80) != 0)) {
      if (iVar5 < 0) {
        iVar5 = -iVar5;
      }
      if (iVar3 < iVar5) {
        iVar3 = iVar5;
      }
      if (((uVar8 == 0) || (uVar9 == 0)) || (-1 < (int)(uVar8 ^ uVar9))) {
        if ((((int)uVar9 <= (int)uVar8) || (0 < (int)uVar8)) &&
           (((int)uVar8 <= (int)uVar9 || ((int)uVar8 < 0)))) goto LAB_8005e8d8;
        iVar5 = uVar8 - uVar9;
        if (iVar5 < 0) {
          iVar5 = -iVar5;
        }
        iVar5 = iVar5 >> 1;
      }
      else {
        iVar5 = (int)uVar8 >> 1;
        if (iVar5 < 0) {
          iVar5 = -iVar5;
        }
      }
      if (iVar6 < iVar5) {
        iVar6 = iVar5;
      }
    }
LAB_8005e8d8:
    if (((uVar4 & 0x100) == 0) || (iVar5 = iVar3 * 3 >> 2, iVar3 = iVar6, iVar5 < iVar6)) {
      iVar5 = iVar3;
    }
	
	// Interpolate rotation by speed
    uVar7 = FUN_80058f54(uVar7,iVar5,0);
    uVar8 = FUN_80058f54(uVar8,iVar6,0);
  }
  
  // load new movement vector
  gte_ldVXY0(uVar7 & 0xffff | iVar16 << 0x10);
  gte_ldVZ0(uVar8);
  gte_rtv0();
  
  // save new movement vector
  gte_stlvnl(param_2);
  
  // set flag
  *(uint *)(param_1 + 0x2c8) = uVar10;
  
  // if driver is not in air
  if ((uVar10 & 0x80000) == 0) 
  {
    if (
			// firstFrameSinceEngineRevving
			(*(char *)(param_1 + 0x449) != '\0') && 
			
			(uVar8 != 0)
		) 
	{
	  // move forward
      uVar2 = 1;
	  
	  // move backward
      if ((int)uVar8 < 0) {
        uVar2 = 0xffff;
      }
	  
	  // forwardDir (0x3e8)
      *(undefined2 *)(param_1 + 1000) = uVar2;
	  
	  // firstFrameSinceEngineRevving
      *(undefined *)(param_1 + 0x449) = 0;
	  
      goto LAB_8005e9d8;
    }
	
    if (*(int *)(puVar14 + 0x10) < 0) 
	{

LAB_8005e9cc:

	  // moving forward
      if (-1 < (int)uVar8) 
	  {
		// forwardDir (0x3e8)
        *(undefined2 *)(param_1 + 1000) = 1;
      }
      goto LAB_8005e9d8;
    }
    
	// moving backward
	if ((int)uVar8 < 0) 
	{
	  // forwardDir (0x3e8)
      *(undefined2 *)(param_1 + 1000) = 0xffff;
    }
	
    if (*(int *)(puVar14 + 0x10) < 1) goto LAB_8005e9cc;

LAB_8005e9e8:
    
	// moving backward
	if ((int)uVar8 < 0) goto LAB_8005ea08;
    
	if (0 < *(int *)(puVar14 + 0x10)) {
      return;
    }
  }
  
  // if driver is in air
  else {
LAB_8005e9d8:
    if (-1 < *(int *)(puVar14 + 0x10)) goto LAB_8005e9e8;
  }
  if ((int)uVar8 < 1) {
    return;
  }
  
// start Rollback
LAB_8005ea08:


  // if rollback is starting, but in the last 0.64s
  // the driver started rollback already, then rolled 
  // forward, and is now rolling back AGAIN, count
  // V_Shift, inside two quadblocks in the shape of a V
  if (*(short *)(param_1 + 0x408) != 0) 
  {
	// increment number of V_Shifts
    *(short *)(param_1 + 0x40a) = *(short *)(param_1 + 0x40a) + 1;
  }

  // reset timer, rolling backward
  *(undefined2 *)(param_1 + 0x408) = 0x280;
  
  return;
}


// OnApplyForces
void FUN_8005ea60(undefined4 param_1,int param_2)

{
  undefined4 uVar1;
  int iVar2;

  // if speed is more than top speed
  if (0x6400 < *(short *)(param_2 + 0x38c))
  {
	// set top speed
    *(undefined2 *)(param_2 + 0x38c) = 0x6400;
  }

  // vec3_originToCenter
  // origin of driver model is center-bottom of kart,
  // 0x19 is the half-radius of the model,
  // calculate normalVec with magnitude 0x19 of driver,
  // then we can find the "true center" of the model
  gte_SetColorMatrix((MATRIX *)(param_2 + 0x330));
  gte_ldVXY0(0x190000);
  gte_ldVZ0(0);
  gte_lcv0();
  gte_stlvnl0((long *)(param_2 + 0x94));
  gte_stlvnl1((long *)(param_2 + 0x98));
  gte_stlvnl2((long *)(param_2 + 0x9c));

  // Driver_ConvertSpeedToVectors
  FUN_8005e104(param_2,param_2 + 0x88,0);

  if (
		(
			// if under-quadblock exists
			(*(int *)(param_2 + 0x350) != 0) &&

			// if quadblock terrain is mud
			(*(char *)(*(int *)(param_2 + 0x350) + 0x38) == '\x0e')
		)
	 )
  {
	// if you have not sinked to the mud's bottom (-0x1000)
	if(-0x1000 < *(int *)(param_2 + 0x2d8))
	{
		// sink slower as you approach the mud's bottom
		iVar2 = -0x1000 - *(int *)(param_2 + 0x2d8)
	
		// set driver velY
		if(*(int *)(param_2 + 0x8c) < iVar2)
		{
			*(int *)(param_2 + 0x8c) = iVar2;
		}
	}
  }

  // OnGravity
  FUN_8005e214(param_2,param_2 + 0x88);

  *(undefined4 *)(param_2 + 0xa4) = 0x10000000;
  *(undefined4 *)(param_2 + 0x360) = 0x10000000;

  // driver is not touching quadblock
  *(undefined4 *)(param_2 + 0xa0) = 0;

  *(undefined2 *)(param_2 + 0xa8) = 0;
  *(undefined2 *)(param_2 + 0x364) = 0;
  *(undefined2 *)(param_2 + 0xaa) = 0;

  // increase velocity by acceleration
  *(int *)(param_2 + 0x88) = *(int *)(param_2 + 0x88) + (int)*(short *)(param_2 + 0x3cc);
  *(int *)(param_2 + 0x90) = *(int *)(param_2 + 0x90) + (int)*(short *)(param_2 + 0x3d0);
  *(int *)(param_2 + 0x8c) = *(int *)(param_2 + 0x8c) + (int)*(short *)(param_2 + 0x3ce);
  
  return;
}

// OnCollide_Drivers
// handle collision with turbo pads and robotcars
void FUN_8005ebac(int param_1,int param_2)

{
  int iVar1;
  undefined4 uVar2;
  int iVar3;
  undefined4 uVar4;
  uint uVar5;
  undefined2 local_40;
  undefined2 local_3e;
  undefined2 local_3c;
  int local_38;
  int local_34;

  // decrease velocity by acceleration
  *(int *)(param_2 + 0x8c) = *(int *)(param_2 + 0x8c) - (int)*(short *)(param_2 + 0x3ce);
  *(int *)(param_2 + 0x88) = *(int *)(param_2 + 0x88) - (int)*(short *)(param_2 + 0x3cc);
  uVar5 = *(uint *)(param_2 + 0xbc);
  *(int *)(param_2 + 0x90) = *(int *)(param_2 + 0x90) - (int)*(short *)(param_2 + 0x3d0);

  if ((uVar5 & 0x4000) != 0) {
    *(ushort *)(param_2 + 0xaa) = *(ushort *)(param_2 + 0xaa) | 1;
  }

  // If this is not a super turbo pad
  if ((uVar5 & 2) == 0) {

	// If this is not an ordinary turbo pad
    if ((uVar5 & 1) == 0) goto LAB_8005ec70;

	// add one second reserves
    uVar2 = 0x3c0;

	// If Super Turbo Pads is enabled
    if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x100000) != 0)
	{
		// Skip a few lines
		goto LAB_8005ec50;
	}

	// set speed of turbo to normal speed
    uVar4 = 0x100;
  }

  // If this is a super turbo pad (only on some tracks)
  else {
LAB_8005ec50:

	// add 0.12s reserves
    uVar2 = 0x78;

	// Set speed of turbo to big speed
    uVar4 = 0x800;
  }

  // Turbo_Increment
  // add reserves and speed of turbo pad
  FUN_8005abfc(param_2,uVar2,5,uVar4);

LAB_8005ec70:
  if ((uVar5 & 0x8000) == 0)
  {
	// thread -> instance -> flags
	// instance is not in water or mud
    *(uint *)(*(int *)(param_1 + 0x34) + 0x28) =
         *(uint *)(*(int *)(param_1 + 0x34) + 0x28) & 0xffffdfff;
  }

  // if instance is in water or mud
  else
  {
	// thread -> instance
    iVar1 = *(int *)(param_1 + 0x34);

	// set vertical split height
	// (Y=0 for all water and mud)
    *(undefined2 *)(iVar1 + 0x56) = 0;

	// instance -> flags
	// split the instance
	*(uint *)(iVar1 + 0x28) = *(uint *)(iVar1 + 0x28) | 0x2000;
  }

  // if collision is not disabled for this thread
  if ((*(uint *)(param_1 + 0x1c) & 0x1000) == 0)
  {
	// 40, 3e, 3c, 38, 34, allocated in that order

	// position X and Y
    local_40 = (undefined2)((uint)*(undefined4 *)(param_2 + 0x2d4) >> 8);
    local_3e = (undefined2)((uint)*(undefined4 *)(param_2 + 0x2d8) >> 8);

	// distance between two objects
	local_34 = 0x7fffffff;

	// thread you collide with
	local_38 = 0;

	// position Z
    local_3c = (undefined2)((uint)*(undefined4 *)(param_2 + 0x2dc) >> 8);

	// check for collision with all sibling threads
	// THREAD_CollidePointWithBucket
    FUN_80042348(*(undefined4 *)(param_1 + 0x10),&local_40);

	// pointer to first robotcar thread
	// THREAD_CollidePointWithBucket
    FUN_80042348(*(undefined4 *)(PTR_DAT_8008d2ac + 0x1b40),&local_40);

	if (
			// if there was a collision
			(local_38 != 0) &&
			(
				// thread offset 0x42?
				iVar1 = (int)*(short *)(param_1 + 0x42) + (int)*(short *)(local_38 + 0x42),

				local_34 < iVar1 * iVar1
			)
	    )
	{
	  // pass the thread, collision data, and driver->88 is velocity?
      FUN_8005d404(param_1,&local_40,param_2 + 0x88);
    }
  }
  if ((*(ushort *)(param_2 + 0xaa) & 2) != 0) 
  {
    iVar3 = (*(int *)(param_2 + 0x2d4) >> 8) - (int)*(short *)(param_2 + 0xac);
    iVar1 = (*(int *)(param_2 + 0x2dc) >> 8) - (int)*(short *)(param_2 + 0xb0);
    
	if (
		*(short *)(param_2 + 0xb4) * iVar3 +
        (int)*(short *)(param_2 + 0xb6) * (((*(int *)(param_2 + 0x2d0) >> 8) - (int)*(short *)(param_2 + 0xae)) + 4) +
        *(short *)(param_2 + 0xb8) * iVar1 < 0) 
	{
	  // calculate speed vector
      *(int *)(param_2 + 0x88) = *(int *)(param_2 + 0x88) + iVar3 * 0x40;
      *(int *)(param_2 + 0x8c) = *(int *)(param_2 + 0x8c) + ((*(int *)(param_2 + 0x2d8) >> 8) - (int)*(short *)(param_2 + 0xae)) * 0x40;
      *(int *)(param_2 + 0x90) = *(int *)(param_2 + 0x90) + iVar1 * 0x40;
    }
  }
  return;
}

// OnRender -- move position to instance matrix
// param1 = thread, param2 = driver
void FUN_8005ee34(int param_1,int param_2)

{
  bool bVar1;
  undefined *puVar2;
  byte bVar3;
  undefined2 uVar4;
  short sVar5;
  int iVar6;
  undefined4 uVar7;
  int iVar8;
  int iVar9;
  MATRIX *pMVar10;
  int iVar11;
  int *piVar12;
  uint uVar13;
  MATRIX *r0;
  int iVar14;
  undefined uVar15;
  
  // get instance from thread
  iVar14 = *(int *)(param_1 + 0x34);
  
  // If you are not in a warp pad
  if (*(char *)(param_2 + 0x376) != '\n') 
  {
	// if you're being mask grabbed and you're not on the ground
    if ((*(char *)(param_2 + 0x376) == '\x05') && ((*(uint *)(param_2 + 0x2c8) & 1) == 0)) 
	{
	  // set Y scale
      *(short *)(iVar14 + 0x1e) = *(short *)(param_2 + 0x40c) + 0xccc;
	  
      iVar6 = *(short *)(param_2 + 0x40c) * 0x28;
      if (iVar6 < 0) {
        iVar6 = iVar6 + 0xff;
      }
	  
	  // X and Z
      iVar6 = 0xccc - (iVar6 >> 8);
      if (iVar6 < 0x400) {
        iVar6 = 0x400;
      }
	  
	  // Set X and Z scale
      *(short *)(iVar14 + 0x1c) = (short)iVar6;
      *(short *)(iVar14 + 0x20) = (short)iVar6;
    }
	
	// on ground, or mid-air without a mask-grab
    else 
	{
      sVar5 = *(short *)(param_2 + 0x390);
      iVar8 = (int)sVar5;
      iVar6 = -800;
	  
	  // if player did not start jumping this frame
      if ((*(uint *)(param_2 + 0x2c8) & 0x400) == 0) 
	  {
        iVar11 = (int)*(short *)(param_2 + 0x410) -
                 (*(short *)(param_2 + 0x410) * 9 + iVar8 * 7 >> 4);
        iVar6 = iVar11 * 4;
        iVar9 = iVar6;
        if (iVar6 < 0) {
          iVar9 = iVar11 * -4;
        }
        if (iVar9 < 0x960) {
          iVar6 = 0;
        }
		
		// if racer did not just touch ground this frame or last
        if (((*(uint *)(param_2 + 0x2c8) | *(uint *)(param_2 + 0x2cc)) & 2) == 0) {
          bVar1 = iVar6 < 0x321;
          if (iVar6 < -800) {
            iVar6 = -800;
            goto LAB_8005ef64;
          }
        }
		
		// if racer just touched ground this frame or last
        else {
          bVar1 = iVar6 < 0x321;
          if (iVar6 < -0x640) {
            iVar6 = -0x640;
LAB_8005ef64:
            bVar1 = iVar6 < 0x321;
          }
        }
        if (!bVar1) {
          iVar6 = 800;
        }
      }
	  
      //if Hazard Timer > 0 and Hazard Timer & 80 = 0 and (?)
      if (((0 < *(short *)(param_2 + 0xe)) && ((*(ushort *)(param_2 + 0xe) & 0x80) == 0)) &&
         (-800 < iVar6)) {
        iVar6 = -800;
      }
	  
	  // if racer is not on the ground
      if (((*(uint *)(param_2 + 0x2c8) & 1) == 0) && (iVar8 < 0)) 
	  {
        // Map value from [oldMin, oldMax] to [newMin, newMax]
        // inverting newMin and newMax will give an inverse range mapping
        iVar9 = FUN_80058f9c(-iVar8,0,0xa00,0x280);
		
        if (iVar6 < iVar9) {
          iVar6 = iVar9;
        }
        *(short *)(param_2 + 0x410) = sVar5;
      }
      if ((*(int *)(param_2 + 0x18) != 0) &&
         (iVar9 = (int)*(short *)(*(int *)(param_2 + 0x18) + 0x1e), iVar9 < 0x9c4)) {
        iVar6 = iVar6 + (iVar9 + -0x800) * 2;
      }
      iVar11 = (int)*(short *)(param_2 + 0x40c);
      iVar9 = iVar6;
      if (iVar6 < 0) {
        iVar9 = -iVar6;
      }
      if (iVar11 < 0) {
        iVar11 = -iVar11;
      }
      if (iVar11 < iVar9) {
        *(short *)(param_2 + 0x40c) = (short)iVar6;
      }
	  
	  // Interpolate rotation by speed
      uVar4 = FUN_80058f54((int)*(short *)(param_2 + 0x40c),300,0);
      *(undefined2 *)(param_2 + 0x40c) = uVar4;
	  
      *(short *)(param_2 + 0x410) = (short)(*(short *)(param_2 + 0x410) * 9 + iVar8 * 7 >> 4);
      
	  if (*(short *)(param_2 + 0x404) == 0) 
	  {
        if (*(short *)(iVar14 + 0x1e) == 0) 
		{
		  // driver -> instance -> thread -> modelIndex == "player" of any kind
          if (*(short *)(*(int *)(*(int *)(param_2 + 0x1c) + 0x6c) + 0x44) == 0x18) 
		  {
			// OtherFX_Play_Echo
			// 0x5b?
            FUN_80028494(0x5b,1,*(ushort *)(param_2 + 0x2ca) & 1);
          }
          *(short *)(iVar14 + 0x1e) = *(short *)(param_2 + 0x40c) + 0xccc;
          *(undefined *)(param_2 + 0x4c) = 5;
          *(undefined *)(param_2 + 0x4d) = 0;
        }
		
        else 
		{
		  // Interpolate scale by speed
          uVar4 = FUN_80058f54((int)*(short *)(iVar14 + 0x1e),0xa0,
                               *(short *)(param_2 + 0x40c) + 0xccc);
          *(undefined2 *)(iVar14 + 0x1e) = uVar4;
        }
      }
      else {
        *(undefined2 *)(iVar14 + 0x1e) = 0;
      }
      iVar6 = *(short *)(param_2 + 0x40c) * 0xa0;
      if (iVar6 < 0) {
        iVar6 = iVar6 + 0xff;
      }
	  
	  // Interpolate scale by speed
      uVar4 = FUN_80058f54((int)*(short *)(iVar14 + 0x1c),0xa0,0xccc - (iVar6 >> 8));
      *(undefined2 *)(iVar14 + 0x1c) = uVar4;
      iVar6 = *(short *)(param_2 + 0x40c) * 0xa0;
      if (iVar6 < 0) {
        iVar6 = iVar6 + 0xff;
      }
	  
	  // Interpolate rotation by speed
      uVar4 = FUN_80058f54((int)*(short *)(iVar14 + 0x20),0xa0,0xccc - (iVar6 >> 8));
      *(undefined2 *)(iVar14 + 0x20) = uVar4;
    }
  }
  
  // Rot_AxisAngle
  FUN_8005f89c(param_2 + 0x330,param_2 + 0x368,(int)*(short *)(param_2 + 0x2ee));
  
  if (
		(
			(*(short *)(param_2 + 0x3e2) == 0) ||
			(*(short *)(param_2 + 0x39e) < *(short *)(param_2 + 0x42c))
		) ||
     
		((*(uint *)(param_2 + 0x2c8) & 0x80) != 0)
	 ) 
  {
    bVar3 = *(byte *)(param_2 + 0x4c);
    if (bVar3 != 0) {
      if (bVar3 == 2) {
        *(undefined *)(param_2 + 0x4c) = 3;
LAB_8005f398:
        *(undefined *)(param_2 + 0x4d) = 0;
      }
      else if (bVar3 < 3) {
        if (bVar3 == 1) {
          iVar6 = DAT_80087f00 + -1;
          if (iVar6 == 0) {
            trap(0x1c00);
          }
          if ((iVar6 == -1) && (*(byte *)(param_2 + 0x4d) == 0x800000)) {
            trap(0x1800);
          }
          iVar8 = 0x100 - (int)((uint)*(byte *)(param_2 + 0x4d) << 8) / iVar6;
          iVar6 = iVar8;
          if (iVar8 < 0) {
            iVar6 = 0;
          }
          if (0x100 < iVar8) {
            iVar6 = 0x100;
          }
          uVar15 = (undefined)((uint)(iVar6 * (DAT_80087f10 + -1)) >> 8);
          *(undefined *)(param_2 + 0x4c) = 3;
          goto LAB_8005f354;
        }
      }
      else if ((bVar3 == 3) &&
              (bVar3 = *(char *)(param_2 + 0x4d) + 1, *(byte *)(param_2 + 0x4d) = bVar3,
              DAT_80087f10 <= (int)(uint)bVar3)) {
        *(undefined *)(param_2 + 0x4c) = 0;
        goto LAB_8005f398;
      }
    }
LAB_8005f39c:
    bVar3 = *(byte *)(param_2 + 0x4c);
  }
  else {
    bVar3 = *(byte *)(param_2 + 0x4c);
    if (bVar3 == 1) {
      bVar3 = *(char *)(param_2 + 0x4d) + 1;
      *(byte *)(param_2 + 0x4d) = bVar3;
      if (DAT_80087f00 <= (int)(uint)bVar3) {
        *(undefined *)(param_2 + 0x4c) = 2;
        goto LAB_8005f398;
      }
      goto LAB_8005f39c;
    }
    if (1 < bVar3) {
      if ((bVar3 != 2) && (bVar3 == 3)) {
        iVar6 = DAT_80087f10 + -1;
        if (iVar6 == 0) {
          trap(0x1c00);
        }
        if ((iVar6 == -1) && (*(byte *)(param_2 + 0x4d) == 0x800000)) {
          trap(0x1800);
        }
        iVar8 = 0x100 - (int)((uint)*(byte *)(param_2 + 0x4d) << 8) / iVar6;
        iVar6 = iVar8;
        if (iVar8 < 0) {
          iVar6 = 0;
        }
        if (0x100 < iVar8) {
          iVar6 = 0x100;
        }
        uVar15 = (undefined)((uint)(iVar6 * (DAT_80087f00 + -1)) >> 8);
        *(undefined *)(param_2 + 0x4c) = 1;
LAB_8005f354:
        *(undefined *)(param_2 + 0x4d) = uVar15;
      }
      goto LAB_8005f39c;
    }
    if (bVar3 == 0) {
      *(undefined *)(param_2 + 0x4c) = 1;
      goto LAB_8005f398;
    }
  }
  if ((bVar3 == 5) &&
     (bVar3 = *(char *)(param_2 + 0x4d) + 1, *(byte *)(param_2 + 0x4d) = bVar3,
     DAT_80087f20 <= (int)(uint)bVar3)) {
    *(undefined *)(param_2 + 0x4c) = 0;
    *(undefined *)(param_2 + 0x4d) = 0;
  }
  
  // animation index
  if (*(byte *)(param_2 + 0x4c) == 0) 
  {
	// copy matrix from driver to instance?
    *(undefined4 *)(iVar14 + 0x30) = *(undefined4 *)(param_2 + 0x330);
    *(undefined4 *)(iVar14 + 0x34) = *(undefined4 *)(param_2 + 0x334);
    *(undefined4 *)(iVar14 + 0x38) = *(undefined4 *)(param_2 + 0x338);
    *(undefined4 *)(iVar14 + 0x3c) = *(undefined4 *)(param_2 + 0x33c);
    *(undefined2 *)(iVar14 + 0x40) = *(undefined2 *)(param_2 + 0x340);
	
	// position (xyz)
    *(int *)(iVar14 + 0x44) = *(int *)(param_2 + 0x2d4) >> 8;
    *(int *)(iVar14 + 0x48) = (*(int *)(param_2 + 0x2d8) >> 8) + (*(char *)(param_2 + 0x377) * 3 >> 3);
    iVar6 = *(int *)(param_2 + 0x2dc);
  }
  
  // different animation index
  else 
  {
	// driver -> 0x330 matrix
    r0 = (MATRIX *)(param_2 + 0x330);
    
	// 0x4C - which matrix array
	// 0x4D - which matrix index
	piVar12 = (int *)((&DAT_80087ef4)[(uint)*(byte *)(param_2 + 0x4c) * 2] +
                     (uint)*(byte *)(param_2 + 0x4d) * 0x20);
    
	pMVar10 = r0;
    
	// MatrixRotate (param_1 = param_2 matrix rotated by param_3 matrix)
	FUN_8006c3b0(iVar14 + 0x30,r0,piVar12 + 2);
	
	// load matrix
    gte_SetRotMatrix(r0);
    
	// load vector
	iVar6 = *piVar12;
	gte_ldVXY0(iVar6);
    gte_ldVZ0((uint)*(ushort *)(piVar12 + 1));
    
	gte_rtv0();
	
	// x shares register with iVar6
	// y shares register with r0
	// z shares register with pMVar10
    read_mt(iVar6,r0,pMVar10);
    
	// position (xyz)
	*(int *)(iVar14 + 0x44) = *(int *)(param_2 + 0x2d4) + iVar6 >> 8;
    *(int *)(iVar14 + 0x48) = ((int)r0->m + *(int *)(param_2 + 0x2d8) >> 8) + (*(char *)(param_2 + 0x377) * 3 >> 3);
    iVar6 = (int)pMVar10->m + *(int *)(param_2 + 0x2dc);
  }
  
  // matrix -> 0x4C (posZ)
  *(int *)(iVar14 + 0x4c) = iVar6 >> 8;
  
  // if driver is squished
  if (*(short *)(param_2 + 0x404) != 0) 
  {
	// increment position by AngleAxis_NormalVec
    *(int *)(iVar14 + 0x44) = *(int *)(iVar14 + 0x44) + (*(short *)(param_2 + 0x368) * 0x13 >> 0xc);
    *(int *)(iVar14 + 0x48) = *(int *)(iVar14 + 0x48) + (*(short *)(param_2 + 0x36a) * 0x13 >> 0xc);
    *(int *)(iVar14 + 0x4c) = *(int *)(iVar14 + 0x4c) + (*(short *)(param_2 + 0x36c) * 0x13 >> 0xc);
  }
  
  iVar6 = *(int *)(iVar14 + 0x48);
  if (-1 < iVar6) {
code_r0x8005f834:
    if (0 < iVar6) {
      *(uint *)(iVar14 + 0x28) = *(uint *)(iVar14 + 0x28) & 0xffffdfff;
    }
	
	// wakeInst
    iVar14 = *(int *)(param_2 + 0x4f8);
    
	// if valid
	if (iVar14 != 0) 
	{
	  // make invisible
      *(uint *)(iVar14 + 0x28) = *(uint *)(iVar14 + 0x28) | 0x80;
	  
	  // clear driver->wakeScale, and wakeInst->scale
      *(undefined2 *)(param_2 + 0x4fc) = 0;
      *(undefined2 *)(iVar14 + 0x1c) = 0;
      *(undefined2 *)(iVar14 + 0x20) = *(undefined2 *)(param_2 + 0x4fc);
    }
    return;
  }
  
  // touching wall so???? or is it water?
  if ((iVar6 < -0x4f) || ((*(uint *)(iVar14 + 0x28) & 0x2000) == 0)) {
    iVar6 = *(int *)(iVar14 + 0x48);
    goto code_r0x8005f834;
  }
  iVar6 = *(int *)(param_2 + 0x4f8);
  if (iVar6 == 0) {
    return;
  }
  
  // make visible
  *(uint *)(iVar6 + 0x28) = *(uint *)(iVar6 + 0x28) & 0xffffff7f;
  
  // animation data
  *(char *)(iVar6 + 0x50) = *(char *)(iVar14 + 0x50) + '\x01';
  *(char *)(iVar6 + 0x51) = *(char *)(iVar14 + 0x51) + -1;
  
  // instance posX, posY, posZ
  uVar7 = *(undefined4 *)(iVar14 + 0x44);
  *(undefined4 *)(iVar6 + 0x48) = 0;
  *(undefined4 *)(iVar6 + 0x44) = uVar7;
  *(undefined4 *)(iVar6 + 0x4c) = *(undefined4 *)(iVar14 + 0x4c);
  
  // driver -> rotation
  uVar13 = (uint)*(short *)(param_2 + 0x39a);

  // approximate trigonometry

  // Sin(angle)
  sVar5 = (short)*(int *)(&DAT_800845a0 + (uVar13 & 0x3ff) * 4);

  // Cos(angle)
  iVar14 = *(int *)(&DAT_800845a0 + (uVar13 & 0x3ff) * 4) >> 0x10;

  // if (0 < angle < 90) or (180 < angle < 270)
  if ((uVar13 & 0x400) == 0) {
    iVar8 = (int)sVar5;
    if ((uVar13 & 0x800) == 0) goto LAB_8005f6a4;
    iVar9 = -iVar14;
  }

  // if (90 < angle < 180) or (270 < angle < 360)
  else {
    iVar9 = (int)sVar5;
    iVar8 = iVar14;
    if ((uVar13 & 0x800) == 0) {
      iVar14 = -iVar9;
      goto LAB_8005f6a4;
    }
  }
  iVar8 = -iVar8;
  iVar14 = iVar9;
LAB_8005f6a4:

  // instance rotation
  // looks like 5 int variables, but it's really
  // 9 short variables, 3x3 rotation matrix
  *(int *)(iVar6 + 0x30) = iVar14;
  *(int *)(iVar6 + 0x34) = iVar8;
  *(undefined4 *)(iVar6 + 0x38) = 0x1000;
  *(int *)(iVar6 + 0x3c) = -iVar8;
  *(short *)(iVar6 + 0x40) = (short)iVar14;
  
  puVar2 = PTR_DAT_8008d2ac;
  
  // if wake is not visible,
  // then do this for first frame of wake,
  // which sets scale, and makes a splash
  if (*(short *)(param_2 + 0x4fc) == 0) 
  {
	// wake is now visible (set scale)
    *(undefined2 *)(param_2 + 0x4fc) = 0x1000;
	
	// if less than 2 screens
    if ((byte)puVar2[0x1ca8] < 2) 
	{
	  // get speed
      iVar14 = (int)*(short *)(param_2 + 0x38c);
	  
	  // absolute value
      if (iVar14 < 0) {
        iVar14 = -iVar14;
      }
	  
      if (
			// if speed is high
			(0xc00 < iVar14) && 
			
			(
				// spawn 10 particles
				iVar14 = 10, 

				// racerY position is more than -0x200
				-0x200 < *(int *)(param_2 + 0x2e4)
			)
		  ) 
	  {
		// spawn particles till counter runs out
        do 
		{
		  // 0x2138 = "falling"
		  // like splashing in water on coco park

		  // Create instance in particle pool
          iVar8 = FUN_80040308(0,*(undefined4 *)(PTR_DAT_8008d2ac + 0x2138),&DAT_80089a94);
          
		  // if particle was made properly
		  if (iVar8 != 0) 
		  {
            *(undefined *)(iVar8 + 0x18) = *(undefined *)(*(int *)(param_2 + 0x1c) + 0x50);

			// driver->instSelf
			*(undefined4 *)(iVar8 + 0x20) = *(undefined4 *)(param_2 + 0x1c);

			// driverID
            *(undefined *)(iVar8 + 0x19) = *(undefined *)(param_2 + 0x4a);
          }

		  // reduce counter
          iVar14 = iVar14 + -1;
		  
        } while (iVar14 != 0);
      }
    }
  }
  
  // if numPlyrCurrGame is less than 2
  else if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 2) 
  {
	// get speed
    iVar14 = (int)*(short *)(param_2 + 0x38c);
	
	// absolute value
    if (iVar14 < 0) {
      iVar14 = -iVar14;
    }
	
    if (
			// if speed is high
			(0xc00 < iVar14) &&
			
			// spawn one particle
			(
				// 0x2138 = "falling"
				// like splashing in water on coco park

				// Create instance in particle pool
				iVar14 = FUN_80040308(0,*(undefined4 *)(PTR_DAT_8008d2ac + 0x2138),&DAT_80089a94),
				iVar14 != 0
			)
		) 
	{
      *(undefined *)(iVar14 + 0x18) = *(undefined *)(*(int *)(param_2 + 0x1c) + 0x50);
      
	  // driver -> instSelf
	  *(undefined4 *)(iVar14 + 0x20) = *(undefined4 *)(param_2 + 0x1c);
      
	  // driverID
	  *(undefined *)(iVar14 + 0x19) = *(undefined *)(param_2 + 0x4a);
    }
  }

  // instance -> scale (x, z)
  *(undefined2 *)(iVar6 + 0x1c) = *(undefined2 *)(param_2 + 0x4fc);
  *(undefined2 *)(iVar6 + 0x20) = *(undefined2 *)(param_2 + 0x4fc);
  return;
}


// Rot_AxisAngle
// param1 - matrix
// param2 - normal axis
// param3 - angle
// equivalent to glm::AngleAxis, Unity Quaternion.AngleAxis, UE4 FVector AngleAxis
void FUN_8005f89c(undefined2 *param_1,short *param_2,uint param_3)

{
  short sVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  short sVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  short sVar9;
  int iVar10;
  int iVar11;
  undefined4 uVar12;
  int iVar13;
  undefined4 uVar14;
  undefined4 uVar15;
  int iVar16;
  int iVar17;
  int iVar18;

  // normalX
  sVar1 = *param_2;
  param_1[1] = sVar1;

  // normalY
  sVar9 = param_2[1];
  iVar11 = (int)sVar1;
  param_1[4] = sVar9;

  // normalZ
  iVar10 = (int)param_2[2];
  param_1[7] = param_2[2];

  // approximate trigonometry
  sVar1 = (short)*(int *)(&DAT_800845a0 + (param_3 & 0x3ff) * 4);
  iVar2 = *(int *)(&DAT_800845a0 + (param_3 & 0x3ff) * 4) >> 0x10;

  // if (0 < angle < 90) or (180 < angle < 270)
  if ((param_3 & 0x400) == 0)
  {
    iVar7 = (int)sVar1;

	// if (0 < angle < 90)
    if ((param_3 & 0x800) == 0) goto LAB_8005f934;

	// if (180 < angle < 270)
	// make X and Y values negative
	iVar8 = -iVar2;
  }

  // if (90 < angle < 180) or (270 < angle < 360)
  else
  {
    iVar8 = (int)sVar1;
    iVar7 = iVar2;

	// if (90 < angle < 180)
    if ((param_3 & 0x800) == 0) {
      iVar2 = -iVar8;
      goto LAB_8005f934;
    }

	// if (270 < angle < 360)
		// proceed without "goto"
  }

  iVar7 = -iVar7;
  iVar2 = iVar8;

  LAB_8005f934:
  iVar16 = iVar11 * iVar11;
  iVar17 = iVar10 * iVar10;
  iVar18 = iVar11 * -iVar10;
  iVar6 = iVar16 + iVar17;
  iVar13 = iVar7 * sVar9 >> 0xc;
  sVar1 = (short)iVar13;
  iVar8 = iVar2 * sVar9 >> 0xc;
  sVar9 = (short)iVar8;
  
  gte_ldLZCS(iVar6);
  iVar3 = gte_stLZCR();

  if (iVar6 == 0)
  {
    iVar2 = iVar7 * iVar11 + iVar2 * iVar10;

	// if normalY is negative
	if (param_2[1] < 0)
	{
	  // flip
      sVar1 = -sVar1;
    }
  }
  else {
    uVar4 = 0x14 - iVar3;
    if (0 < (int)uVar4) {
      iVar16 = iVar16 >> (uVar4 & 0x1f);
      iVar17 = iVar17 >> (uVar4 & 0x1f);
      iVar18 = iVar18 >> (uVar4 & 0x1f);
      iVar6 = iVar6 >> (uVar4 & 0x1f);
    }
    iVar13 = iVar7 - iVar13;
    iVar8 = iVar2 - iVar8;
    iVar3 = iVar13 * iVar17 + iVar8 * iVar18;
    if (iVar6 == 0) {
      trap(0x1c00);
    }
    if ((iVar6 == -1) && (iVar3 == -0x80000000)) {
      trap(0x1800);
    }
    iVar8 = iVar13 * iVar18 + iVar8 * iVar16;
    if (iVar6 == 0) {
      trap(0x1c00);
    }
    if ((iVar6 == -1) && (iVar8 == -0x80000000)) {
      trap(0x1800);
    }
    sVar1 = sVar1 + (short)(iVar3 / iVar6);
    iVar2 = iVar7 * iVar11 + iVar2 * iVar10;
    sVar9 = sVar9 + (short)(iVar8 / iVar6);
  }

  // write to matrix
  param_1[2] = sVar1;
  sVar5 = (short)(-iVar2 >> 0xc);
  param_1[5] = sVar5;
  param_1[8] = sVar9;

  // axis to rotate on
  gte_ldopv1SV(param_2);


  // new GTE calls this 
  // gte_ldopv2SV(r0);
  setCopReg(2,0x4800,(int)sVar1);
  setCopReg(2,0x5000,(int)sVar5);
  setCopReg(2,0x5800,(int)sVar9);


  gte_op12();
  read_mt(uVar12,uVar14,uVar15);
  

  // write to matrix
  *param_1 = (short)uVar12;
  param_1[3] = (short)uVar14;
  param_1[6] = (short)uVar15;

  return;
}


// CameraSlack_PhysAngular
// param1 - driver object
// called from:
//		VehPtr_Driving_PhysAngular
//		VehPtr_Drifting_PhysAngular
uint FUN_8005fb4c(int param_1)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  undefined4 uVar5;

  // speed
  iVar1 = (int)*(short *)(param_1 + 0x38e);

  // erase accel X,Y,Z
  *(undefined2 *)(param_1 + 0x3cc) = 0;
  *(undefined2 *)(param_1 + 0x3ce) = 0;
  *(undefined2 *)(param_1 + 0x3d0) = 0;
  
  if (iVar1 < 0) {
    iVar1 = -iVar1;
  }

  // low speed (useless? shoould just be '= 0;')
  uVar2 = (uint)(iVar1 < 0x301);

  if (
		// high speed
		(iVar1 >= 0x301) &&

		(
			// high speed
			uVar2 = 1,

			// if not crashing
			*(char *)(param_1 + 0x376) != '\x01'
		)
	  )
  {
	// check if driver is in warppad
    uVar2 = *(uint *)(param_1 + 0x2c8) & 0x4000;

	if (
		// if driver is not being warped
		(uVar2 == 0) &&
		(
			(
				(
					// if driver is on quadblock
					uVar2 = *(uint *)(param_1 + 0x2c8) & 1,

					*(short *)(param_1 + 0x3fe) == 0 &&

					// if driver is on quadblock
					(uVar2 != 0)
				)
				&&
				(
					// driver -> terrain meta -> ???
					// 0x100 for everything except:
					// 0x000 for "ice" and "none" (mid-air)
					uVar2 = *(uint *)(*(int *)(param_1 + 0x358) + 0x10),

					// not on ice, not mid-air
					uVar2 != 0
				)
			)
		)
	   )
	{

	  // angleCurr - anglePrev
	  uVar4 = (int)*(short *)(param_1 + 0x3c6) - (int)*(short *)(param_1 + 0x3c8);

	  // set 0x457 to zero, to remove all camera slack,
	  // with no slack, steering locks camera to driver
	  
	  // kart angle cap from 'straight to camera'
	  uVar3 = (uint)*(byte *)(param_1 + 0x457);

	  // clamp to min cap or max cap
	  if ((int)uVar3 < (int)uVar4) uVar4 = uVar3;
      if ((int)uVar4 < (int)-uVar3) uVar4 = -uVar3;

	  // approximate trigonometry
      iVar1 = *(int *)(&DAT_800845a0 + (uVar4 & 0x3ff) * 4);

	  if ((uVar4 & 0x400) == 0) {
        iVar1 = iVar1 << 0x10;
      }
      iVar1 = iVar1 >> 0x10;
      if ((uVar4 & 0x800) != 0) {
        iVar1 = -iVar1;
      }

	  // before this function is called, there is always
	  // gte_SetRotMatrix, AxisAngle, driver -> 0x310

      uVar2 = ((int)(uVar2 * -8000) >> 8) * iVar1 >> 0xc & 0xffff;
      gte_ldVXY0(uVar2);
      gte_ldVZ0(0);
      gte_rtv0();
	  
	  // new acceleration vector
	  
      uVar5 = gte_stMAC1();
      *(short *)(param_1 + 0x3cc) = (short)uVar5;
      uVar5 = gte_stMAC2();
      *(short *)(param_1 + 0x3ce) = (short)uVar5;
      uVar5 = gte_stMAC3();
      *(short *)(param_1 + 0x3d0) = (short)uVar5;
    }
  }

  // does not really "return" anything, it just
  // sees something in r2 and assumes. Stupid ghidra
  return uVar2;
}


// VehPtr_Driving_PhysAngular
void FUN_8005fc8c(undefined4 param_1,int param_2)

{
  bool bVar1;
  bool bVar2;
  undefined2 uVar3;
  short sVar4;
  int iVar5;
  int iVar6;
  undefined4 uVar7;
  int iVar8;
  int iVar9;
  uint uVar10;
  int iVar11;
  int iVar12;
  short sVar13;
  int iVar14;
  int iVar15;
  int iVar16;
  short sVar17;
  int iVar18;
  int iVar19;
  uint local_38;

  // get camera rotation
  iVar14 = (int)*(short *)(param_2 + 0x2f2);

  // copy the variable
  iVar5 = iVar14;

  // make sure the camera is not negative; ie. get camera angle absolute
  if (iVar14 < 0) {
    iVar5 = -iVar14;
  }

  // elapsed milliseconds per frame, ~32
  iVar8 = *(int *)(PTR_DAT_8008d2ac + 0x1d04);

  uVar10 = iVar5 >> 3;
  if (uVar10 == 0) {
    uVar10 = 1;
  }
   // meta behaviour
  if ((int)(uint)*(byte *)(param_2 + 0x46a) < (int)uVar10) {
    uVar10 = (uint)*(byte *)(param_2 + 0x46a);
  }

  // Interpolate rotation by speed 
  // Rotation_Interpolation(rotPrev.w, 8, uVar10)
  iVar5 = FUN_80058f54((int)*(short *)(param_2 + 0x2fa),8,uVar10);

  // rotPrev.w = iVar5
  *(undefined2 *)(param_2 + 0x2fa) = (short)iVar5;

  // Interpolate rotation by speed
  // Rotation_Interpolation( abs(camerarotation), rotPrev.w * elapsedTimeInMS >> 5, 0)
  uVar3 = FUN_80058f54(iVar14,iVar5 * iVar8 >> 5,0);

  local_38 = *(uint *)(param_2 + 0x2c8);
  // sVar4 = numFramesSpentSteering
  sVar4 = *(short *)(param_2 + 1000);

  // set camera rotation (rotCurr.W)
  *(undefined2 *)(param_2 + 0x2f2) = uVar3;

  // speedApprox
  iVar14 = (int)*(short *)(param_2 + 0x38e);
  
  // int simpTurnState256 = simpTurnState * 0x100
  iVar5 = (int)*(char *)(param_2 + 0x4b) * 0x100;
  
  // if speedApprox is negative
  if (iVar14 < 1) 
  {
	// baseSpeed is negative
    if (*(short *)(param_2 + 0x39c) < 0) 
	{
	  // forwardDir (0x3e8)
      sVar4 = -1;
      *(undefined2 *)(param_2 + 1000) = 0xffff; // -1
    }
    if (-1 < iVar14) goto LAB_8005fd74;
  }
  
  // if speedApprox is positive
  else {
	  
LAB_8005fd74:
    
	// baseSpeed is positive
	if (-1 < *(short *)(param_2 + 0x39c)) 
	{
	  // forwardDir (0x3e8)
      sVar4 = 1;
      *(undefined2 *)(param_2 + 1000) = 1;
    }
  }
  if (sVar4 < 0) {
    // simpTurnState256 = simpTurnState * -0x100;
    iVar5 = (int)*(char *)(param_2 + 0x4b) * -0x100;
    // ActionsFlagSet = ActionsFlagSet ^ 0x10
    local_38 = local_38 ^ 0x10;
  }
  if (iVar14 < 0) {
    iVar14 = -iVar14;
  }
  if (
		((local_38 & 1) != 0) &&

		// if you're not on any turbo pad
		((*(uint *)(param_2 + 0xbc) & 3) == 0)
	  )
  {

    // Map value from [oldMin, oldMax] to [newMin, newMax]
    // inverting newMin and newMax will give an inverse range mapping
    iVar5 = FUN_80058f9c(iVar14,0x10,0x300,0,iVar5);
  }
  
  //terrainMeta1
  iVar12 = *(int *)(param_2 + 0x358);
  
  // rotationSpinRate = driver.rotationSpinRate;
  iVar9 = (int)*(short *)(param_2 + 0x3b4);
  
  if (iVar5 == 0)
  {
	// Interpolate rotation by speed
    //
    sVar4 = FUN_80058f54(iVar9,((int)*(short *)(param_2 + 0x43e) +
                               (int)*(char *)(param_2 + 0x34) * 0x32) * *(int *)(iVar12 + 0x28) >> 8
                         ,0);
  }
  else {
    bVar1 = iVar5 < 0;
    if (bVar1) {
      iVar5 = -iVar5;
      iVar9 = -iVar9;
    }
    sVar4 = (short)iVar9;
    //if (rotationSpinRate < simpTurnState256) {
    if (iVar9 < iVar5) {
      //rotationSpinRate = rotationSpinRate + ((TurningInputResponseStat + TurnConst * 100) * (terrainMeta1 + 0x28) >> 8);
        // 100%
      iVar9 = iVar9 + (((int)*(short *)(param_2 + 0x43e) + (int)*(char *)(param_2 + 0x34) * 100) *
                       *(int *)(iVar12 + 0x28) >> 8);
      //rotationSpinRateS16 = (short)rotationSpinRate;
      sVar4 = (short)iVar9;

      /*if (simpTurnState256 < rotationSpinRate) {
         rotationSpinRateS16 = (short)simpTurnState256;
      }*/
      bVar2 = iVar5 < iVar9;
LAB_8005fee4:
      if (bVar2) {
        sVar4 = (short)iVar5;
      }
    }
    else {
      //if (simpTurnState256 < rotationSpinRate)
      if (iVar5 < iVar9) {
        //rotationSpinRate = rotationSpinRate - ((TurningInputResponseStat + TurnConst * 0x32) * (terrainMeta1 + 0x28) >> 8)
        // 50%
        iVar9 = iVar9 - (((int)*(short *)(param_2 + 0x43e) + (int)*(char *)(param_2 + 0x34) * 0x32)
                         * *(int *)(iVar12 + 0x28) >> 8);
        //rotationSpinRateS16 = (short)rotationSpinRate;
        sVar4 = (short)iVar9;

        /*if (rotationSpinRate < simpTurnState256) {
            rotationSpinRateS16 = (short)simpTurnState256;
        }*/
        bVar2 = iVar9 < iVar5;
        goto LAB_8005fee4;
      }
    }
    //if (isforwardDirNegative)
    if (bVar1) {
        //rotationSpinRateS16 = -rotationSpinRateS16
      sVar4 = -sVar4;
    }
  }
  
  iVar5 = (int)*(short *)(param_2 + 0x3ec);

  //rotationSpinRate = rotationSpinRateS16;
  iVar9 = (int)sVar4;
  
  // driver.rotationSpinRate = rotationSpinRateS16
  *(short *)(param_2 + 0x3b4) = sVar4;

  if (iVar5 != 0) 
  {  
    uVar3 = (undefined2)(iVar5 - iVar8);

    // map [0-0x140] to [0-???]
    // deltaRotation = Misc.MapToRange(timeUntilDriftSpinout,0,0x140,0,previousFrameMultDrift);
    iVar6 = FUN_80058f9c(iVar5,0,0x140,0,(int)*(short *)(param_2 + 0x3ea));
    
	// rotationSpinRate = rotationSpinRate + deltaRotation;
    iVar9 = iVar9 + iVar6;
    
	// if (deltaTime < 0)
    if (iVar5 - iVar8 < 0) {
      uVar3 = 0;
    }
	
    *(undefined2 *)(param_2 + 0x3ec) = uVar3;
  }
  
  // character_Speed
  iVar11 = (uint)*(ushort *)(param_2 + 0x42c) << 0x10;
  iVar6 = iVar11 >> 0x10;
  
  // turnResistMax = MetaPhys.turnResistMax * iVar6
  iVar19 = (uint)*(byte *)(param_2 + 0x45d) * iVar6;
  
  // turnResistMin = MetaPhys.turnResistMin * iVar6
  iVar6 = (uint)*(byte *)(param_2 + 0x45c) * iVar6;
  
  sVar4 = *(short *)(param_2 + 0x3d2);
  
  // const_ModelRotationSpeed
  iVar5 = (int)*(short *)(param_2 + 0x452);
  
  iVar18 = iVar19 >> 8;
  iVar16 = iVar6 >> 8;
  
  // gas and break together
  if ((local_38 & 0x20) != 0) 
  {
    iVar18 = iVar19 >> 9;
	
    if (0x300 < iVar14)
	{
	  // driver is leaving skids
      *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) | 0x800;
    }
    iVar16 = iVar6 >> 9;
    if (*(short *)(param_2 + 0x39c) == 0) {
      iVar5 = (int)*(short *)(param_2 + 0x454);
    }
    else 
	{
	  // speed
      iVar6 = (int)*(short *)(param_2 + 0x38c);
      
	  if (iVar6 < 0) {
        iVar6 = -iVar6;
      }

      // Map "speed" from 
	  //	- [0x300, characterSpeed] 
	  //	to 
	  //	- [const_modelRotVelMin, const_modelRotVelMax]
	  
	  // Rotating the model to exaggerate the steering animation,
	  // only do this if driver speed is more than 0x300
      iVar5 = FUN_80058f9c(iVar6,0x300,iVar11 >> 0x11,(int)*(short *)(param_2 + 0x454),iVar5);
    }
  }
  
  // speed
  iVar6 = (int)*(short *)(param_2 + 0x38c);
  
  if (iVar6 < 0) {
    iVar6 = -iVar6;
  }
  iVar19 = ((uint)*(byte *)(param_2 + 0x43a) + ((int)*(char *)(param_2 + 0x34) << 1) / 5) * 0x100;

  // Map "speed" from 
  //	- [turnResistMin*iVar6>>8(or9), turnResistMax*iVar6>>8(or9)] 
  //	to 
  //	- [turnResistMax*iVar6, 0]
  
  // if iVar11 is zero, no turn-resist
  // if iVar11 is 0x7FFF, high turn-resist
  // this prevents you from steering sharp at low speeds
  
  // get turn resistance, given speed, and range maps
  iVar11 = FUN_80058f9c(iVar6,iVar16,iVar18,iVar19,0);
  
  iVar6 = 0;
  if (iVar16 <= iVar14) {
    iVar15 = iVar9;
    if (iVar9 < 0) {
      iVar15 = -iVar9;
    }
    if (iVar11 < iVar15) 
	{
	  // fire speed
      iVar6 = (int)*(short *)(param_2 + 0x39e);
      if (iVar6 < 0) {
        iVar6 = -iVar6;
      }

	  // same input-range as the previous map

	  // Map "fire speed" from 
	  //	- [turnResistMin*iVar6>>8(or9), turnResistMax*iVar6>>8(or9)] 
	  //	to 
	  //	- [0, ???]
      uVar7 = FUN_80058f9c(iVar6,iVar16,iVar18,0,iVar5);

      // Map "rotation rate" from
	  //	- [unk to unk]
	  //	to
	  //	- [0, mappedFireSpeed]
      iVar6 = FUN_80058f9c(iVar15,iVar11,iVar19,0,uVar7);
	  
	  // absolute value,
	  // then use this for LerpToForwards
      if (iVar9 < 0) {
        iVar6 = -iVar6;
      }
    }
  }
  sVar13 = *(short *)(param_2 + 0x3c6);

  // Player_Driving_LerpToForwards
  sVar4 = FUN_80060488(param_2,(int)sVar13,(int)sVar4,iVar6);
  *(short *)(param_2 + 0x3d2) = sVar4;
  
  iVar6 = (int)sVar4;
  
  // terrain related
  if (*(int *)(iVar12 + 0x24) != 0x100) {
    iVar6 = *(int *)(iVar12 + 0x24) * iVar6 >> 8;
  }
  
  iVar16 = (int)sVar13 + (iVar6 * iVar8 >> 5);
  *(short *)(param_2 + 0x3c6) = (short)iVar16;
  iVar11 = iVar9;
  
  // if [???] && touching quadblock
  if ((0x2ff < iVar14) && ((local_38 & 1) != 0))
  {
	// number of frames spent steering
    sVar4 = *(short *)(param_2 + 0x3e6);

	// Player_SteerAccel
	// all these offsets are MetaPhys, and each one is only used here
    iVar18 = FUN_8005900c(

		// frames spent steering
		(int)sVar4,

		// SteerAccel_Stage2_FirstFrame
		(int)*(char *)(param_2 + 0x447),
		
		// SteerAccel_Stage2_FrameLength
		(int)*(char *)(param_2 + 0x448),
		
		// SteerAccel_Stage4_FirstFrame
		(int)*(char *)(param_2 + 0x446),

		// SteerAccel_Stage1_MinSteer
		(int)*(short *)(param_2 + 0x44c),

		// SteerAccel_Stage1_MaxSteer
        (int)*(short *)(param_2 + 0x44a)
	);

    if (iVar9 < 0) {
      iVar11 = -iVar9;
    }
	
	// 0x44e is const val 0x80
    iVar11 = *(short *)(param_2 + 0x44e) * iVar11 >> 8;

	// increment frame counter
    *(short *)(param_2 + 0x3e6) = sVar4 + 1;

	// the higher the value of iVar18,
	// the more steering is "locked up",
	// try setting mov r3, xxxx at 80060170 for proof

    if (iVar11 < iVar18) {
      iVar18 = iVar11;
    }
	
	// steering left or right
    if ((local_38 & 0x10) != 0) {
      iVar18 = -iVar18;
    }
	
	// constant value zero, for all classes
    iVar19 = (int)*(short *)(param_2 + 0x450);
	
    if ((iVar9 < 1) || (iVar11 = -iVar19, iVar11 <= iVar9 + iVar18)) {
      if (iVar9 < 0) {
        iVar11 = iVar9 + iVar18;
        if (iVar19 < iVar9 + iVar18) {
          iVar11 = iVar19;
        }
      }
      else {
        iVar11 = iVar9 + iVar18;
      }
    }
  }
  iVar9 = (int)*(short *)(param_2 + 0x3d4);
  sVar4 = *(short *)(param_2 + 0x3d8);
  sVar13 = *(short *)(param_2 + 0x3d6);
  
  // terrain related, and touching quadblock
  if (((*(uint *)(iVar12 + 4) & 0x10) == 0) && ((local_38 & 1) != 0)) {
    iVar18 = iVar16;
    if (iVar16 < 0) {
      iVar18 = -iVar16;
    }
    if (iVar5 * 3 >> 2 < iVar18) {
      iVar5 = iVar6;
      if (iVar6 < 0) {
        iVar5 = -iVar6;
      }
      if (iVar5 < 3) {
        iVar5 = iVar9;
        if (iVar9 < 0) {
          iVar5 = -iVar9;
        }
        if (iVar5 < 10) {
          sVar4 = 8;
          sVar13 = 0x14;
          if (iVar16 < 0) {
            sVar13 = -0x14;
          }
        }
      }
      goto LAB_80060284;
    }
  }
  sVar4 = 0;
LAB_80060284:
  iVar5 = iVar9;
  if (iVar9 < 0) {
    iVar5 = -iVar9;
  }
  if (0x32 < iVar5) {
    sVar4 = 0;
  }
  if (sVar4 == 0) {
    iVar5 = 10;
    if (0 < iVar9) {
      iVar5 = -10;
    }
    sVar13 = (short)iVar5;
    if (iVar5 < 0) {
      iVar5 = -iVar5;
    }

	// Interpolate rotation by speed
    sVar17 = FUN_80058f54(iVar9,iVar5,0);
  }
  else {
    sVar4 = sVar4 + -1;
    sVar17 = *(short *)(param_2 + 0x3d4) + sVar13;
  }
  uVar10 = SEXT24(*(short *)(param_2 + 0x39a));
  *(short *)(param_2 + 0x3d8) = sVar4;
  *(short *)(param_2 + 0x3d4) = sVar17;
  *(short *)(param_2 + 0x3d6) = sVar13;

  // Map value from [oldMin, oldMax] to [newMin, newMax]
  // inverting newMin and newMax will give an inverse range mapping
  iVar5 = FUN_80058f9c(iVar14,0,0x600,iVar6,0);
  iVar14 = iVar5 * iVar8 >> 5;
  iVar5 = iVar14;
  if (iVar14 < 0) {
    iVar5 = -iVar14;
  }
  if (1 < iVar5) {
    uVar10 = uVar10 - iVar14 & 0xfff;
  }
  *(undefined2 *)(param_2 + 0xc0) = (short)iVar11;
  uVar10 = uVar10 + (iVar11 * iVar8 >> 0xd) & 0xfff;
  sVar4 = (short)uVar10;
  *(short *)(param_2 + 0x39a) = sVar4;
  *(short *)(param_2 + 0x2ee) = sVar4 + (short)iVar16 + sVar17;
  
  // if not holding break, and not mashing X
  if (((local_38 & 8) == 0) && (*(short *)(param_2 + 0x3c2) < 7)) 
  {
	// terrain related
    if (*(int *)(iVar12 + 0x14) != 0x100) 
	{
      iVar11 = iVar11 * *(int *)(iVar12 + 0x14) >> 8;
    }
  }
  
  // holding break, or mashing X
  else {
    iVar11 = iVar11 * 10 >> 8;
  }
  
  // axisRotationX
  *(ushort *)(param_2 + 0x396) =
       *(short *)(param_2 + 0x396) + (short)(iVar11 * iVar8 >> 0xd) & 0xfff;

  // Rot_AxisAngle
  FUN_8005f89c((undefined4 *)(param_2 + 0x310),param_2 + 0x360,uVar10);
  gte_SetRotMatrix((MATRIX *)(param_2 + 0x310));

  // CameraSlack_PhysAngular
  FUN_8005fb4c(param_2);
  return;
}



int FUN_80060458(int param_1,int param_2)

{
  // desired != 0
  if (param_2 != 0)
  {	
	// desired /= 4
	param_2 = param_2 >> 2,

	// if desired == 0
	if (param_2 == 0)
	{
		// desired = 1
		param_2 = 1;
	}
  }

  // if current >= desired/4
  if (param_2 <= param_1)
  {
	// current = desired/4
    param_1 = param_2;
  }

  return param_1;
}


// Player_Driving_LerpToForwards
// "return 0;" will make car stay in "drift steer" rotation,
// and not interpolate to rotate a forwards direction
int FUN_80060488(int param_1,int param_2,int param_3,int param_4)

{
  bool bVar1;
  uint uVar2;
  int iVar3;

  bVar1 = false;
  *(undefined2 *)(param_1 + 0x3ca) = 0;
  if ((param_4 < 0) || ((param_4 == 0 && (param_2 < 0)))) {
    bVar1 = true;
    param_2 = -param_2;
    param_3 = -param_3;
    param_4 = -param_4;
  }
  iVar3 = 0;
  
  // if not rubbing on wall
  if (*(short *)(param_1 + 0x3fe) != 0xf0) 
  {
    if (param_4 < param_2) {
      if (*(short *)(param_1 + 0x452) < param_2) {
        uVar2 = (uint)*(byte *)(param_1 + 0x458) * 0xf;
      }
      else {
        uVar2 = (uint)*(byte *)(param_1 + 0x458);
      }
      iVar3 = FUN_80060458(uVar2,param_2 - param_4,0);
      iVar3 = -iVar3;
    }
    else {
      if (param_2 < param_4) {
        if (param_2 < 0) {
          iVar3 = FUN_80060458((uint)*(byte *)(param_1 + 0x459),param_4 - param_2,0);
        }
        else {
          iVar3 = FUN_80060458((uint)*(byte *)(param_1 + 0x457),param_4 - param_2,0);
          *(undefined2 *)(param_1 + 0x3ca) = (short)param_4;
        }
      }
    }
  }

  // Interpolate rotation by speed
  iVar3 = FUN_80058f54(param_3,(uint)*(byte *)(param_1 + 0x45a),iVar3);
  if (bVar1) {
    iVar3 = -iVar3;
  }
  return iVar3;
}


// Driver_RampVelY
// param_1: normalVec (driver 0x360, 0x368, 0x378)
// param_2: speedCoord (driver 0x88)
// if "return 0;" then you jump off a ramp and get no height
int FUN_800605a0(short *param_1,int *param_2)

{
  int iVar1;
  int iVar2;

  // y1 (normal vector Y)
  iVar2 = (int)param_1[1];

  iVar1 = iVar2;
  if (iVar2 < 0) {
    iVar1 = -iVar2;
  }

  if (0x14 < iVar1)
  {
	// this determines if you fly off a ramp or not,
	// regardless if you press L1 or R1
	
	// if quadblock is flat, normalvec x and z are zero,
	// causing the multiply product to also be zero (no fly)
	
	// if X points up, and you drive along the X,
	// then you get a high number to fly off the ramp

    iVar1 =

		// x2 * x1
		*param_2 * (int)*param_1 +

		// z2 * z1
		param_2[2] * (int)param_1[2];

	// alert debugger on error
	if (iVar2 == 0) trap(0x1c00);
    if ((iVar2 == -1) && (iVar1 == -0x80000000)) trap(0x1800);

    return iVar1 / iVar2;
  }
  return 0;
}


 // Player_JumpAndFriction
void FUN_80060630(undefined4 param_1,int param_2)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  short sVar6;
  int iVar7;
  short sVar8;
  short sVar9;
  int iVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  int local_28;
  uint local_24;
  int local_20;

  // driver -> 0x310
  gte_SetRotMatrix((MATRIX *)(param_2 + 0x310));

  if (
		(
			// if driver is not drifting
			(*(char *)(param_2 + 0x376) != '\x02') &&

			//if driver is not using mask weapon
			((*(uint *)(param_2 + 0x2c8) & 0x800000) == 0)
		) &&

		// no reserves
		(*(short *)(param_2 + 0x3e2) == 0)
	 )
  {
    iVar7 = (int)((uint)*(ushort *)(param_2 + 0xc0) << 0x10) >> 0x18;
    if (iVar7 < 0) {
      iVar7 = -iVar7;
    }

    // Map value from [oldMin, oldMax] to [newMin, newMax]
    // inverting newMin and newMax will give an inverse range mapping
    iVar2 = FUN_80058f9c(iVar7,0,(uint)*(byte *)(param_2 + 0x43b),0,(int)*(short *)(param_2 + 0x43c)
                        );
    iVar10 = (int)*(short *)(param_2 + 0x39c);
    iVar7 = iVar10;
    if (iVar10 < 0) {
      iVar7 = -iVar10;
    }
    sVar6 = (short)iVar2;
    if (iVar7 < iVar2) {
      sVar6 = (short)iVar7;
    }
    sVar8 = -sVar6;
    if (iVar10 < 0) {
      sVar8 = sVar6;
    }
    *(short *)(param_2 + 0x39c) = *(short *)(param_2 + 0x39c) + sVar8;
  }
  
  // if rubbing on wall now, or recenlty
  if (*(short *)(param_2 + 0x3fe) != 0) 
  {
    if (*(short *)(param_2 + 0x38a) < *(short *)(param_2 + 0x39c)) {
      *(undefined2 *)(param_2 + 0x39c) = *(undefined2 *)(param_2 + 0x38a);
    }
    if ((int)*(short *)(param_2 + 0x39c) < -(int)*(short *)(param_2 + 0x38a)) {
      *(short *)(param_2 + 0x39c) = -*(short *)(param_2 + 0x38a);
    }
  }
  local_28 = *(int *)(param_2 + 0x88);
  local_24 = *(uint *)(param_2 + 0x8c);
  local_20 = *(int *)(param_2 + 0x90);
  uVar13 = 0;
  iVar7 = 0;

  // if driver is not on quadblock, or if not forced to jump (via GOTO)
  if ((*(uint *)(param_2 + 0x2c8) & 1) == 0) {
LAB_80060ab0:

	if (
			// If you want to fire a weapon
			((*(uint *)(param_2 + 0x2c8) & 0x8000) != 0) &&

			// If that weapon is a spring
			(*(char *)(param_2 + 0x36) == '\x05')
		)
	{
		// Remove the request to fire a weapon, since we will use it now
      *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) & 0xffff7fff;

	  // if coyoteTimerMS has not expired, and cooldownMS is over
      if ((*(short *)(param_2 + 0x3f4) != 0) && (*(short *)(param_2 + 0x3f2) == 0))
	  {
		// driver is now forced to jump
        *(undefined2 *)(param_2 + 0x3f6) = 0xa0;

		// const_Jump * 9
        iVar7 = (int)*(short *)(param_2 + 0x418) * 9;

		// always true
        if (iVar7 < 0)
		{
		  // add 3
          iVar7 = iVar7 + 3;
        }

		// jump_InitialVelY = big jump from spring
        *(undefined2 *)(param_2 + 0x3f8) = (short)(iVar7 >> 2);

		// OtherFX_Play_Echo
		// spring weapon sound
        FUN_80028494(9,1,(uint)*(ushort *)(param_2 + 0x2ca) & 1);

        *(undefined2 *)(param_2 + 0x3fa) = 0x180;
        goto LAB_80060c30;
      }
      *(undefined2 *)(param_2 + 0x3c) = 0;
    }

	// if not being forced to jump (turtles), this should cause the tiny jumps on top of walls.
	if (*(char *)(param_2 + 0x366) == '\0')
	{
      if (
			(
				// if driver left quadblock more than 0.16s ago
				(*(short *)(param_2 + 0x3f4) == 0) ||

				// if haven't jumped in last 10 frames
				(*(short *)(param_2 + 0x3f0) == 0)
			) ||

			// jump_CooldownMS not over (so can't jump again)
			(*(short *)(param_2 + 0x3f2) != 0)
		 )
	  {
        if (
			(
			 // if player is touching ground
			 ((*(uint *)(param_2 + 0x2c8) & 1) != 0) &&

			 // if player is over a quadblock
			 (*(int *)(param_2 + 0x350) != 0)
			) &&
            (
			 // unknown quadblock variable
			 iVar7 = (int)*(char *)(*(int *)(param_2 + 0x350) + 0x3b),
			 iVar7 != 0
			)
		   )
		{
		  // player speed
          iVar2 = (int)*(short *)(param_2 + 0x38e);
          if (iVar2 < 0) { // change sign of player speed
            iVar2 = -iVar2;
          }
		  
          gte_ldVXY0((iVar7 * iVar2 >> 8) << 0x10);
          gte_ldVZ0(0);
          gte_rtv0();
          read_mt(iVar7,iVar2,iVar10);

          local_28 = local_28 + iVar7;
          local_20 = local_20 + iVar10;
          local_24 = local_24 + iVar2;
        }
        goto LAB_80060e1c;
      }
      
	  // implied "else",
	  // if (jump_cooldownMS is over) &&
	  // 	(haven't left quadblock || no jump in over 10 frames)
	  
	  // force driver to jump
	  *(undefined2 *)(param_2 + 0x3f6) = 0xa0;
	  
	  // increment jump counter
      *(short *)(param_2 + 0x554) = *(short *)(param_2 + 0x554) + 1;

	  // jump_InitialVelY = const_Jump
      *(undefined2 *)(param_2 + 0x3f8) = *(undefined2 *)(param_2 + 0x418);

	  // OtherFX_Play_Echo
	  // play jump sound
      FUN_80028494(8,1,(uint)*(ushort *)(param_2 + 0x2ca) & 1);
    }

	// if being forced to jump (by turtles)
    else
	{
	  // if first frame (basically)
      if (
			// if not currently airborne from forced jump
			(*(short *)(param_2 + 0x3f6) == 0) ||

		 // if jump_InitialVelY was just now set to const_jump
         (*(short *)(param_2 + 0x3f8) == *(short *)(param_2 + 0x418)))
	  {
		// OtherFX_Play
        FUN_80028468(0x7e,1);
      }

	  // currently forced airborne
      *(undefined2 *)(param_2 + 0x3f6) = 0xa0;

	  // if big force jump (turtles)
      if (*(char *)(param_2 + 0x366) == '\x02')
	  {
        *(undefined2 *)(param_2 + 0x3fa) = 0x180;

		// const_Jump * 3
        *(short *)(param_2 + 0x3f8) = *(short *)(param_2 + 0x418) * 3;
      }

	  // if small force jump (turtles)
      else
	  {
		// jump_InitialVelY = const_Jump * 1.5
        *(undefined2 *)(param_2 + 0x3f8) = (short)(((int)*(short *)(param_2 + 0x418) * 3) / 2);
      }

	  // remove force jump (turtles)
      *(undefined *)(param_2 + 0x366) = 0;
    }
  }

  // if driver is on a quadblock
  else
  {
    if (
			// if driver is not on any turbo pad
			((*(uint *)(param_2 + 0xbc) & 3) == 0) ||

			(*(short *)(param_2 + 0x39c) < 1)
		)
	{
      if (*(short *)(param_2 + 0x39c) != 0) 
	  {
		// terrain related
        if ((((*(uint *)(*(int *)(param_2 + 0x358) + 4) & 4) == 0) ||
            (*(short *)(param_2 + 0x39c) < 1)) || (-1 < *(short *)(param_2 + 0x38e))) 
		{
          iVar10 = (int)*(short *)(param_2 + 0x38e);
          iVar2 = iVar10;
          if (iVar10 < 0) {
            iVar2 = -iVar10;
          }
          if (((0x2ff < iVar2) && ((*(short *)(param_2 + 0x39c) < 1 || (iVar10 < 1)))) &&
             ((-1 < *(short *)(param_2 + 0x39c) || (-1 < iVar10)))) goto LAB_800608fc;
        }

		// const_accel_noReserves + driver-specific acceleration
        iVar7 = (int)*(short *)(param_2 + 0x428) + ((int)*(char *)(param_2 + 0x33) << 5) / 5;

		// if you're not on any turbo pad
        if ((*(uint *)(param_2 + 0xbc) & 3) == 0)
		{
          if (
				// if reserves are not zero
				(*(short *)(param_2 + 0x3e2) != 0) &&

				(0 < *(short *)(param_2 + 0x39c))
			  )
		  {
			// const_accel_withReserves
            iVar7 = (int)*(short *)(param_2 + 0x42a);
          }

		  // driver -> terrain meta -> slowUntilSpeed,
		  // if 0, driver will slow down until completely stuck
		  iVar2 = *(int *)(*(int *)(param_2 + 0x358) + 0xc);

          if (
				(iVar2 != 0x100) &&

				// if driver is not using mask weapon
				((*(uint *)(param_2 + 0x2c8) & 0x800000) == 0)
			 )
		  {
            iVar7 = iVar2 * iVar7 >> 8;
          }
        }
        else {
          if (0 < *(short *)(param_2 + 0x39c)) goto LAB_8006089c;
        }
      }
    }

	// if driver is on a turbo pad
	else
	{
LAB_8006089c:

	  // high acceleration
      iVar7 = 8000;
    }
LAB_800608fc:
						// elapsed milliseconds per frame, ~32
    uVar11 = iVar7 * *(int *)(PTR_DAT_8008d2ac + 0x1d04) >> 5;
	
    gte_ldVXY0(0);
    gte_ldVZ0(uVar11 & 0xffff);
    gte_rtv0();
    read_mt(sVar6,sVar8,sVar9);
	
    if (*(short *)(param_2 + 0x39c) < 0) {
      *(short *)(param_2 + 0x3b2) = -(short)uVar11;
      iVar7 = -iVar7;
      iVar2 = -iVar2;
      iVar10 = -iVar10;
      *(short *)(param_2 + 0x3ac) = -sVar6;
      *(short *)(param_2 + 0x3ae) = -sVar8;
      *(short *)(param_2 + 0x3b0) = -sVar9;
    }
    else {
      *(short *)(param_2 + 0x3b2) = (short)uVar11;
      *(short *)(param_2 + 0x3ac) = sVar6;
      *(short *)(param_2 + 0x3ae) = sVar8;
      *(short *)(param_2 + 0x3b0) = sVar9;
    }
    local_20 = local_20 + iVar2;
    local_24 = local_24 + iVar10;
    local_28 = local_28 + iVar7;

    // uVar13 = sqrt(x2+y2+z2 << 0x10)
    uVar13 = FUN_80059070(local_28 * local_28 + local_24 * local_24 + local_20 * local_20,0x10);

    iVar7 = (int)*(short *)(param_2 + 0x39c);
    if (iVar7 < 0) {
      iVar7 = -iVar7;
    }
    uVar13 = (uVar13 >> 8) - iVar7;
    bVar1 = (int)uVar11 < (int)uVar13;
    if ((int)uVar13 < 0) {
      uVar13 = 0;
      bVar1 = (int)uVar11 < 0;
    }
    if (bVar1) {
      uVar13 = uVar11;
    }

	// if not on quadblock, or if not forced to jump
    if (((*(uint *)(param_2 + 0x2c8) & 1) == 0) || (*(short *)(param_2 + 0x3f6) == 0))
    goto LAB_80060ab0;

    if (*(short *)(param_2 + 0x3fa) != 0) {
      *(undefined2 *)(param_2 + 0x3fa) = 0x180;
    }

	// If you're "blasted", flipping around after hit by missile, bomb, etc
    if (*(char *)(param_2 + 0x376) == '\x06')
	{
	  // gamepad vibration
      FUN_80026440(param_2,8,0);
      FUN_800264c0(param_2,8,0x7f);
    }
  }
LAB_80060c30:
  iVar7 = 0;
  iVar10 = 0x378;

  // jump timer
  *(undefined2 *)(param_2 + 0x3f2) = 0x180;

  *(undefined2 *)(param_2 + 0x3f0) = 0;
  *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) | 0x480;

  // this loop has one iteration
  iVar2 = iVar7;
  do
  {
	// Driver_RampVelY
    iVar3 = FUN_800605a0(param_2 + iVar10,&local_28);

    iVar5 = iVar3;
    if (iVar3 < 0) {
      iVar5 = -iVar3;
    }
    iVar4 = iVar7;
    if (iVar7 < 0) {
      iVar4 = -iVar7;
    }
    if (iVar4 < iVar5) {
      iVar7 = iVar3;
    }
    iVar2 = iVar2 + 1;
    iVar10 = iVar10 + 8;
  } while (iVar2 < 1);

  iVar2 = param_2 + 0x360;
  if ((*(uint *)(param_2 + 0x2c8) & 1) == 0) {
    iVar2 = param_2 + 0x368;
  }

  // Driver_RampVelY
  iVar10 = FUN_800605a0(iVar2,&local_28);

  iVar2 = iVar10;
  if (iVar10 < 0) {
    iVar2 = -iVar10;
  }
  iVar5 = iVar7;
  if (iVar7 < 0) {
    iVar5 = -iVar7;
  }
  iVar3 = iVar7 * iVar7;
  if (iVar5 < iVar2) {
    iVar3 = iVar10 * iVar10;
    iVar7 = iVar10;
  }

  // iVar2 = sqrt( (ramp+jump*jump>>8) << 8),
  // iVar2 = sqrt( "basically" ramp+jump*jump )
  // last byte is cleared cause only 3 bytes in driver->0x2D4
  // are rendered, and the last byte is sub-pixel percision
  
  // iVar2 = sqrt(ramp+jump*jump)
  iVar2 = FUN_80059070(
							// param_1
							iVar3 + 
							(int)*(short *)(param_2 + 0x3f8) * 
							(int)*(short *)(param_2 + 0x3f8) >> 8,
							
							// param_2
							8);

  // zero in all arcade maps, idk adv, battle, cutscene, or credits
  uVar11 = (uint)*(byte *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x18c) << 8;
  
  if (*(byte *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x18c) == 0) 
  {
    uVar11 = 0x3700;
  }
  else 
  {
    if (0x5000 < uVar11) 
	{
      uVar11 = 0x5000;
    }
  }
  
  uVar12 = iVar2 - iVar7;
  if ((int)uVar11 < iVar2 - iVar7) {
    uVar12 = uVar11;
  }
  
  // max value for movementY (on stack)
  if ((int)local_24 < (int)uVar12) 
  {
	// set movementY to the speed that 
	// you should have, on first frame of jump
    local_24 = uVar12;
  }

// [end of the first frame of jump]
  
// skip here if not jumping
LAB_80060e1c:
  
  // Driver_ConvertVectorsToSpeed
  FUN_8005cd1c(param_2,&local_28,0);
  
  // decrease speed
  iVar7 = *(ushort *)(param_2 + 0x38c) - uVar13;
  *(undefined2 *)(param_2 + 0x38c) = (short)iVar7;
  if (iVar7 * 0x10000 < 0) {
    *(undefined2 *)(param_2 + 0x38c) = 0;
  }
  
  iVar7 = (int)*(short *)(param_2 + 0x38e);
  
  if (iVar7 < 0) {
    if (iVar7 < 0) {
      iVar7 = -iVar7;
    }
    if (iVar7 < 0x100) {
      sVar6 = *(short *)(param_2 + 0x36e) - (*(short *)(param_2 + 0x36e) >> 3);
    }
    else {
      sVar6 = (short)((int)*(short *)(param_2 + 0x36e) * 0xd +
                      (*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 7) * 0x300 >> 4);
    }
  }
  else {
    sVar6 = (short)((int)*(short *)(param_2 + 0x36e) * 0xd + iVar7 * 3 >> 4);
  }
  *(short *)(param_2 + 0x36e) = sVar6;
  return;
}


// Player_SetHeldItem
void FUN_80060f0c(int param_1)
//Select a random Item for driver
//param_1 = Driver struct
{
  char cVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  
  // refer to chart
  // https://media.discordapp.net/attachments/637616020177289236/982513721354092564/unknown.png?width=602&height=431

  //iVar4 = Place division
  iVar4 = -1;

  // If you're not in Battle Mode
  if ((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0) {
    // If you're not in Crystal Challenge (in adventure mode)
    if ((*(uint *)PTR_DAT_8008d2ac & 0x8000000) == 0) {
      // number of Drivers + number of AIs
      switch((uint)(byte)PTR_DAT_8008d2ac[0x1ca8] + (uint)(byte)PTR_DAT_8008d2ac[0x1cab]) {
      // 2P VS
      // 1P Boss Race
      case 2:
        //if racer is 2nd, give 7th Place division
        iVar4 = 7;

        //if racer is 1st, give 1st Place division
        if (*(short *)(param_1 + 0x482) == 0) {
LAB_80061060:
          iVar4 = 0;
        }
        break;

      // 3P Splitscreen
      // 3 Players
      case 3:
        //if driver is 1st, give 1st Place division
        if (*(short *)(param_1 + 0x482) == 0) goto LAB_80061060;

        //if driver is 3rd, give 4th Place division
        iVar4 = 3;

        //if driver is 2nd, give 2nd or 3rd Place division (~50% chance)
        if (*(short *)(param_1 + 0x482) == 1) {
          //iVar4 = 3rd Place division
          iVar4 = 2;

          //Get random number to decide Place division
          uVar3 = FUN_8003ea28();

          //if the number is odd (~50% chance)
          if ((uVar3 & 1) != 0)
		      {
            //iVar4 = 2nd Place division
            goto LAB_80061040;
          }
        }
        break;

      // 4P Splitscreen
      // 4 Players
      case 4:
        //give (place in race)th Place division
        iVar4 = (int)*(short *)(param_1 + 0x482);
        break;

      // Purple Gem Cup
      // 1 player, 4 AIs
      case 5:
        //give (place in race)th Place division
        iVar4 = (int)*(short *)(param_1 + 0x482);

        //if racer is 5th
        if (iVar4 == 4) {
          //make 5th count in 4th Place division
          iVar4 = 3;
        }
        break;

      // 2P Splitscreen
      // 2 players, 4 AIs
      case 6:
        //give (place in race)th Place division
        iVar4 = (int)*(short *)(param_1 + 0x482);

        //if racer is in 1st place, give 1st Place division
        if (iVar4 == 0) goto LAB_80061060;

        //if racer is 6th
        if (iVar4 == 5) {
          //make it count in 4th Place division
          iVar4 = 3;
        }
        // if racer is not 1st or 6th
        else {
          //give Place division 2nd / 3rd
          iVar4 = (iVar4 + -1) / 2 + 1;
        }
        break;

      // 1P Arcade, Adventure
      // 1 player, 7 AIs
      case 8:
        //iVar2 = place in race * 0x10000
        iVar2 = (uint)*(ushort *)(param_1 + 0x482) << 0x10;
        //iVar4 = place in race
        iVar4 = iVar2 >> 0x10;
        //if racer is second
        if (iVar4 == 1) {
LAB_80061040:
          //give 2nd Place division
          iVar4 = 1;
        }
        else {
          //give Place division 1st to 4th
          iVar4 = iVar4 - (iVar2 >> 0x1f) >> 1;
        }
      }
    }
    // if you are in Crystal Challenge
    else {
      iVar4 = 6;
    }
  }
  // If you are in Battle Mode
  else
  {
	// battle, custom weapon set
    iVar4 = 5;

	// battle, default set
    if (*(int *)(PTR_DAT_8008d2ac + 0x1da0) == 0x34de) {
      iVar4 = 4;
    }
  }

  //simulate you're in 3rd Place division instead of 4th in first lap
  if ((iVar4 == 3) && (*(char *)(param_1 + 0x44) == '\0')) {
    iVar4 = 2;
  }

  // Get random number to decide item
  iVar2 = FUN_8003ea28();
  // Reduce random number to a range of 0 - 199
  uVar3 = (iVar2 >> 3) % 200;

  //based on Place division and a 1-200 number, give item
  switch(iVar4)
  {

  //if you're in 1st Place division
  case 0:
	// weapon = RNG/10 (range of 0 - 19)
    *(undefined *)(param_1 + 0x36) = (&DAT_80089b6c)[uVar3 / 10];
    break;

  //if you're in 2nd Place division
  case 1:
	// weapon = (range of 0 - 52)
    *(undefined *)(param_1 + 0x36) = (&DAT_80089b80)[(uVar3 * 0x34) / 200];
    break;

  //if you're in 3rd Place division
  case 2:
    // weapon = RNG/10 (range of 0 - 19)
    *(undefined *)(param_1 + 0x36) = (&DAT_80089bb4)[uVar3 / 10];
    break;

  //if you're in 4th Place division (last place: arcade, VS, not Boss, etc)
  case 3:
    // weapon = (range of 0 - 18)
    *(undefined *)(param_1 + 0x36) = (&DAT_80089bc8)[(uVar3 * 0x13) / 200];
    break;

  // Battle, default set
  case 4:
	// weapon = RNG/10 (range of 0 - 19)
    *(undefined *)(param_1 + 0x36) = (&DAT_80089bf0)[uVar3 / 10];
    break;

  // Battle, custom set
  case 5:
	// weapon = RNG out of custom (int) array
    *(undefined *)(param_1 + 0x36) =
         PTR_DAT_8008d2ac[((int)(uVar3 * *(int *)(PTR_DAT_8008d2ac + 0x1df0)) / 200) * 4 + 0x1df4];
    break;

  // If you are in Crystal Challenge
  case 6:
		// Only true at Rocky Road and Nitro Court
    if (
			// if Level ID is not 21 (Skull Rock)
			(*(int *)(PTR_DAT_8008d2ac + 0x1a10) != 0x15) &&
			(
				// Item = Bomb
				cVar1 = '\x01',
				// if Level ID is not 19 (Rampage Ruins)
				*(int *)(PTR_DAT_8008d2ac + 0x1a10) != 0x13
			)
		) goto LAB_800612c4;
    // Only true at Skull Rock and Rampage Ruins
    //set held Item to Turbo
    *(undefined *)(param_1 + 0x36) = 0;
    break;

  //if racer is 2nd in a 2 racer race
  //7th Place division
  case 7:
    *(undefined *)(param_1 + 0x36) = (&DAT_80089bdc)[uVar3 / 10];
    break;

  //-1st Place division (place in race is 0xFFFF when not decided)
  default:
    // Get random number
    iVar4 = FUN_8003ea28();
    // Pick a random Item
    cVar1 = (char)iVar4 + ((char)(iVar4 / 6 + (iVar4 >> 0x1f) >> 1) - (char)(iVar4 >> 0x1f)) * -0xc;
LAB_800612c4:
  	// Give racer said Item
    *(char *)(param_1 + 0x36) = cVar1;
  }

  // If you're in a Boss Race
  // 0x80000000
  if (*(int *)PTR_DAT_8008d2ac < 0)
  {
    //cVar1 = Times lost against boss
    cVar1 = (&DAT_8008fbeb)[*(int *)(PTR_DAT_8008d2ac + 0x1eb8)];

    if (cVar1 < '\x03')
    {
      //if Held item is Mask, Clock or Warpball
      if ((uint)*(byte *)(param_1 + 0x36) - 7 < 3)
      {
        //replace Held item with 3 Missiles
        *(undefined *)(param_1 + 0x36) = 0xb;
      }
    }
    else
    {
      if (cVar1 < '\x04')
      {
        //if Held item is Mask or Clock
        if ((uint)*(byte *)(param_1 + 0x36) - 7 < 2)
        {
		      //replace Held item with 3 Missiles
          *(undefined *)(param_1 + 0x36) = 0xb;
        }
      }
      else
      {
        if (
				  (cVar1 < '\x05') &&
				  //if Held item is Clock (\b = Backspace, 0x8 in ASCII)
				  (*(char *)(param_1 + 0x36) == '\b')
        )
        {
		      //replace Held item with 3 Missiles
          *(undefined *)(param_1 + 0x36) = 0xb;
        }
      }
    }

    // If Level ID is 1
    // If you're at Dragon Mines
    if (*(int *)(PTR_DAT_8008d2ac + 0x1a10) == 1)
    {
      // Get your current Item
      cVar1 = *(char *)(param_1 + 0x36);

      //if Held item is not 3 Missiles
      //skip next 2 lines of code
      if (cVar1 != '\v') goto LAB_800613a4;
      //if Held item is 3 Missiles
      //replace it with 1 Missile
      *(undefined *)(param_1 + 0x36) = 2;
    }
  }

  // Get your current Item
  cVar1 = *(char *)(param_1 + 0x36);
LAB_800613a4:

  // If Item ID is unused Spring powerup
  if (cVar1 == '\x05')
  {
    // Change Item to Turbo
    *(undefined *)(param_1 + 0x36) = 0;
  }

  // if Item is warpball
  // Make sure Warpball is only used once per race
  if (*(char *)(param_1 + 0x36) == '\t')
  {
    //if 13th flag of 0x96B20 is off (means there isn't a warpball held / waddling around)
    if ((*(uint *)PTR_DAT_8008d2ac & 0x1000) == 0)
    {
      //turn 13th flag of 0x96B20 on (means warpball is active)
      *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac | 0x1000;
    }
    // if warpball is held or waddling around
    else
    {
      //change Item to 3 missiles to prevent having two warpballs waddling around at once
      *(undefined *)(param_1 + 0x36) = 0xb;
    }
  }

  // To prevent having too many missiles,
  // If you are in 3P or 4P mode, make it
  // so a maximum of 2 players can have
  // multiple missiles, during "normal race"

  if (
		(
			// If numPlyrCurrGame is more than 2 and
			(2 < (byte)PTR_DAT_8008d2ac[0x1ca8]) &&

			// you're not in Battle Mode, and
			((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0)
		) &&
		// racer has 3 missiles
		(*(char *)(param_1 + 0x36) == '\v')
	)
	{
		// If there aren't already 2 players with 3 missiles
		if (*(int *)(PTR_DAT_8008d2ac + 0x1ec4) < 2)
		{
			// increment number of players with 3 missiles
			*(int *)(PTR_DAT_8008d2ac + 0x1ec4) = *(int *)(PTR_DAT_8008d2ac + 0x1ec4) + 1;
		}

		// if 2 players already have 3 missiles
		else
		{
			// Change Item to one missile
			*(undefined *)(param_1 + 0x36) = 2;
		}
  }

  //if Held item is either 3 Bombs or 3 Missiles
  //- 10 < 2 is intended in the formula because unsigned negatives are not < 2
  //(Items available excluding Invisibility and Super Engine)
  if ((uint)*(byte *)(param_1 + 0x36) - 10 < 2) {
    //set Held item Quantity to 3
    *(undefined *)(param_1 + 0x37) = 3;
  }
  return;
}



//returns Base Speed for specified Racer
int FUN_80061488(int param_1)
//param_1 = Racer struct Pointer
{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;

  //iVar3 = Wumpa count, assume max of 9
  iVar3 = (int)*(char *)(param_1 + 0x30);
  if (9 < iVar3) {
    iVar3 = 9;
  }

  // Turbo multiplier, limit to 5,
  // part of Super Engine from beta builds
  // still used?
  iVar4 = (int)*(char *)(param_1 + 0x35);
  if (5 < iVar4) {
    iVar4 = 5;
  }

  //iVar2 = Character's Speed stat
  iVar2 = (int)*(short *)(param_1 + 0x42c);

  //iVar1 = Net Speed stat
  //iVar1 = (((Negative Speedometer offset - Character's Speed stat) * 0x1000) / 5) - 1
  iVar1 = ((*(short *)(param_1 + 0x42e) - iVar2) * 0x1000) / 5 + -1;

  //iVar3 = Speed Additional
  //iVar3 = ((Wumpa count * Net Speed stat) / 10) + (Speed multiplier * Net Speed stat) >> 0xC
  iVar3 = (iVar3 * iVar1) / 10 + iVar4 * iVar1 >> 0xc;

  //if racer is using mask weapon
  if ((*(uint *)(param_1 + 0x2c8) & 0x800000) != 0) {
    //add Mask speed Constant to Speed Additional
    iVar3 = iVar3 + *(short *)(param_1 + 0x436);
  }

  //if racer has reserves
  if (*(short *)(param_1 + 0x3e2) != 0) {
    //iVar4 = Net Speed cap
    //iVar4 = (Sacred fire Cap * 2 - Single turbo Cap) - Current Speed cap
    iVar4 = ((int)*(short *)(param_1 + 0x432) * 2 - (int)*(short *)(param_1 + 0x430)) -
            (int)*(short *)(param_1 + 0x3e4);

    //iVar2 = Stat Additional
    //iVar2 = Gross Speed stat + Current Speed cap
    iVar2 = iVar2 + (int)*(short *)(param_1 + 0x3e4);

    //prevent Net Speed cap from going negative
    if (iVar4 < 0) {
      iVar4 = 0;
    }

    //prevent Speed from going above Speed cap
    //if Speed Additional > Net Speed cap
    if (iVar4 < iVar3) {
      //Speed Additional = Net Speed cap
      iVar3 = iVar4;
    }
  }
  //iVar4 is not Net Speed cap anymore
  //iVar4 will now be some form of Damaged speed Constant
  iVar4 = 0;

  //if racer has TNT over them
  if (*(int *)(param_1 + 0x18) != 0) {
    //iVar4 = (Damaged speed Constant u<< 0x10) s>> 0x11
    //iVar4 = (0x1000 u<< 0x10) s>> 0x11 = 0x10000000 s>> 0x11 = 0x800
    iVar4 = (int)((uint)*(ushort *)(param_1 + 0x438) << 0x10) >> 0x11;
  }

  //if racer is burnt or squished, or 0x50A = 0
  if (((*(short *)(param_1 + 0x402) != 0) || (*(short *)(param_1 + 0x404) != 0)) ||
     (*(short *)(param_1 + 0x50a) == 0)) {
    //iVar4 = Damaged speed Constant
    //iVar4 = 0x1000
    iVar4 = (int)*(short *)(param_1 + 0x438);
  }

  //if racer is affected by Clock item and
    //definition: iVar1 = Damaged speed Constant * ((0x14 - Place in race) >> 4)
    //(iVar1 = Damaged speed Constant (0x1000) when racer is 1st to 5th, iVar1 = 0 when 6th to 8th),
  //iVar4 < iVar1 (if racer has a TNT over them)
  if ((*(short *)(param_1 + 0xc) != 0) && (iVar1 = (int)*(short *)(param_1 + 0x438) *
    (0x14 - (int)*(short *)(param_1 + 0x482)) >> 4, iVar4 < iVar1)) {
    //correct 0x800 to 0x1000
    iVar4 = iVar1;
  }

  //iVar4 = Net Speed
  //iVar4 = (Stat Additional + Speed Additional) - Damaged speed Constant
  iVar4 = (iVar2 + iVar3) - iVar4;

  //if Net Speed is higher than USF Speed
  if (0x6400 < iVar4) {
    //prevent Speed from going over USF Speed
    iVar4 = 0x6400;
  }
  //return Net Speed for racer
  return iVar4;
}


// Player_StickReturnToRest
int FUN_8006163c(int param_1,undefined4 param_2,short *param_3)

{
  int iVar1;
  int iVar2;
  int iVar3;

  // if not using racing wheel
  if (param_3 == (short *)0x0)
  {
	// deadzone
    iVar2 = 0x30;

	// range
    iVar3 = 0x7f;

	// center of wheel
    iVar1 = 0x80;
  }

  // if using racing wheel
  else
  {
	// deadzone
    iVar2 = (int)param_3[1];

	// range
    iVar3 = (int)param_3[2];

	// center of wheel
    iVar1 = (int)*param_3;
  }

  // convert from [0,0xff] to [-0x7f,0x7f]
  param_1 = param_1 - iVar1;

  // negative strength
  if (param_1 < 0) 
  {
	// map value
    iVar1 = FUN_80058f9c(
				-param_1,iVar2, // [stickVal, deadzone]
				iVar3,0,		// [range, 0]
				param_2			// const 0x80 (halfway lerp)
			);
    iVar1 = -iVar1;
  }
  
  // positive strength
  else 
  {
	// map value
    iVar1 = FUN_80058f9c(
				param_1,iVar2, 	// [stickVal, deadzone]
				iVar3,0,		// [range, 0]
				param_2			// const 0x80 (halfway lerp)
			);
  }
  return iVar1;
}


// param_1 is desired steer strength
// param_2 is max possible steer
// param_3 RacingWheelData struct

// Player_StickGetStrength
// can only be positive (negated elsewhere)
int FUN_800616b0(int param_1,int param_2,int param_3)

{
  int iVar1;
  int iVar2;
  int iVar3;

  // dead zone
  iVar1 = 0x30;

  // if not using a racing wheel
  if (param_3 == 0)
  {
	// range of steering
    iVar2 = 0x7f;

	// RangeMinusDeadzone
    iVar3 = 0x5e;
  }

  // if using a racing wheel
  else
  {
	// dead zone
    iVar1 = (int)*(short *)(param_3 + 2);

	// range
	iVar2 = (int)*(short *)(param_3 + 4);

	// RangeMinusDeadzone
	iVar3 = iVar2 - iVar1;
  }

  // if desired steer < Deadzone
  if (param_1 < iVar1)
  {
	// dont steer
    return 0;
  }

  // SteerMinusDeadzone
  iVar1 = param_1 - iVar1;

  // if desired steer > Range
  if (iVar2 <= param_1)
  {
	// default to max desired steer
    return param_2;
  }

  // if SteerMinusDeadzone >= Half RangeMinusDeadzone
  if (iVar3 / 2 <= iVar1) 
  {
    iVar1 = (iVar1 - iVar3 / 2) * (param_2 - param_2 / 5) * 2;
    
	// check error
	if (iVar3 == 0) trap(0x1c00);
    if ((iVar3 == -1) && (iVar1 == -0x80000000)) trap(0x1800);
    
    return iVar1 / iVar3 + param_2 / 5;
  }
  
  // if SteerMinusDeadzone < Half RangeMinusDeadzone
  
  iVar1 = iVar1 * (param_2 / 5) * 2;
  
  // check error
  if (iVar3 == 0) trap(0x1c00);
  if ((iVar3 == -1) && (iVar1 == -0x80000000)) trap(0x1800);
  
  // xxx / RangeMinusDeadzone
  return iVar1 / iVar3;
}


// param_1 is steer
//		DPAD: 00 for left, 80 for neutral, FF for right
//		Analog: anything 00 - FF
// param_2 is max possible steer
// param_3 RacingWheelData struct

// Player_StickGetStrengthAbsolute
// can be positive or negative
int FUN_800617cc(int param_1,undefined4 param_2,short *param_3)

{
  int iVar1;

  // center steering
  iVar1 = 0x80;

  // if racing wheel data exists
  if (param_3 != (short *)0x0)
  {
	// get center of wheel
    iVar1 = (int)*param_3;
  }

  // if steering right
  if (param_1 - iVar1 < 0)
  {
	// Player_StickGetStrength
    iVar1 = FUN_800616b0(-(param_1 - iVar1), param_2, param_3);

	// negate result to steer right
	iVar1 = -iVar1;
  }

  // if steer left
  else
  {
	// Player_StickGetStrength
    iVar1 = FUN_800616b0(param_1 - iVar1, param_2, param_3);
  }

  // steer result
  return iVar1;
}



// VehPtr_Driving_PhysLinear
void FUN_8006181c(int param_1,int param_2)
{
  char cVar1;
  char cVar2;
  short sVar3;
  bool bVar4;
  undefined *puVar5;
  ushort uVar6;
  undefined2 uVar7;
  int iVar8;
  uint uVar9;
  int iVar10;
  int iVar11;
  undefined4 *puVar12;
  short sVar13;
  int iVar14;
  uint uVar15;
  undefined4 uVar16;
  undefined uVar17;
  ushort uVar18;
  int iVar19;
  uint uVar20;
  int iVar21;
  uint uVar22;
  int iVar23;
  undefined *puVar24;
  uint local_38;
  uint local_34;

  // If race timer is not supposed to stop for this racer
  if ((*(uint *)(param_2 + 0x2c8) & 0x40000) == 0)
  {
	// set racer's timer to the time on the clock
    *(undefined4 *)(param_2 + 0x514) = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1d10);
  }

  // elapsed milliseconds per frame, ~32
  iVar14 = *(int *)(PTR_DAT_8008d2ac + 0x1d04);

  // negative elapsed milliseconds per frame
  iVar8 = -iVar14;

  if (
		// time on the clock
		(*(int *)(PTR_DAT_8008d2ac + 0x1d10) < 0x8ca00) &&

		// race timer is not frozen for this player
		((*(uint *)(param_2 + 0x2c8) & 0x40000) == 0)
	  )
  {
	// increment timer by (speed * time)
    *(int *)(param_2 + 0x518) =
    *(int *)(param_2 + 0x518) + 
		(*(short *)(param_2 + 0x38e) * iVar14 >> 8);
  }

  // Next 7 lines are repetitive, this time for Reserves (0x3e2)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x3e2) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x3e2)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x3e2) = uVar7;

    //adds *spent* Reserves to cumulative counter
    *(int *)(param_2 + 0x534) = *(int *)(param_2 + 0x534) + iVar14;
  }

  // Next 7 lines are repetitive, this time for Outside Turbo Timer (0x3de)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x3de) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x3de)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x3de) = uVar7;
  }

  // Next 7 lines are repetitive, this time for Outside Turbo Sound (0x3e0)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x3e0) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x3e0)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x3e0) = uVar7;
  }

  // Next 7 lines are repetitive, this time for Collision (0x3fe)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x3fe) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x3fe)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x3fe) = uVar7;

	// Add elapsed time to a counter for how long you've driven against a wall
    *(int *)(param_2 + 0x530) = *(int *)(param_2 + 0x530) + iVar14;
  }

  // Next 7 lines are repetitive, this time for Jump Animation (0x3f6)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x3f6) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x3f6)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x3f6) = uVar7;
  }

  // Next 7 lines are repetitive, this time for Unknown (0x3f2)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x3f2) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x3f2)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x3f2) = uVar7;
  }

  // Next 7 lines are repetitive, this time for Unknown (0x3fa)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x3fa) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x3fa)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x3fa) = uVar7;
  }

  // Next 7 lines are repetitive, this time for Burnt Effect Timer (0x402)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x402) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x402)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x402) = uVar7;

	// increment timer for total frames burnt
    *(int *)(param_2 + 0x54c) = *(int *)(param_2 + 0x54c) + iVar14;
  }

  // Next 7 lines are repetitive, this time for Squished Effect Timer (0x404)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x404) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x404)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x404) = uVar7;

	// increment timer for total frames squished
    *(int *)(param_2 + 0x544) = *(int *)(param_2 + 0x544) + iVar14;
  }

  // Next 7 lines are repetitive, this time for Unknown (0x406)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x406) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x406)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x406) = uVar7;
  }

  // Next 7 lines are repetitive, this time for Unknown (0x408)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x408) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x408)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x408) = uVar7;
  }

  // If Super Engine Cheat is not enabled
  if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x10000) == 0)
  {
	// Next 7 lines are repetitive, this time for Super Engine Timer (0x38)
	// Make "desired" amount by subtracting elapsed time from "current" amount,
	// store desired into iVar11, then copy it into iVar7. If current is more than 0,
	// then handle subtraction. In subtraction, make sure desired is not negative,
	// then set current to desired

    iVar11 = (int)*(short *)(param_2 + 0x38) + iVar8;
    uVar7 = (undefined2)iVar11;
    if (0 < (int)*(short *)(param_2 + 0x38)) {
      if (iVar11 < 0) {
        uVar7 = 0;
      }
      *(undefined2 *)(param_2 + 0x38) = uVar7;
    }
  }

  // Next 7 lines are repetitive, this time for Clock Weapon Timer (0xC)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0xc) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0xc)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0xc) = uVar7;
  }

  // Next 7 lines are repetitive, this time for "Mashing X makes it big" (0x3c0)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x3c0) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x3c0)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x3c0) = uVar7;
  }

  // This one is a frame timer, not a millisecond timer,
  // Decrease one frame from Jump Buffering as long as timer is more than zero
  if (0 < *(short *)(param_2 + 0x3f0)) {
    *(short *)(param_2 + 0x3f0) = *(short *)(param_2 + 0x3f0) + -1;
  }

  //keep track of time spent with full wumpa
  if ('\t' < *(char *)(param_2 + 0x30)) {
    *(int *)(param_2 + 0x52c) = *(int *)(param_2 + 0x52c) + iVar14;
  }

  //keep track of time spent in mud
  if (*(char *)(param_2 + 0xc2) == '\x0e') {
    *(int *)(param_2 + 0x524) = *(int *)(param_2 + 0x524) + iVar14;
  }

  // Get placement of racer (1st place, 2nd, 3rd, etc)
  sVar13 = *(short *)(param_2 + 0x482);

  // Basically, if racer is in last place in any possible race scenario
  if (
		(
			(
				(
					// If racer is in 8th place
					(sVar13 == 7) &&

					// If numPlyrCurrGame is 1
					(PTR_DAT_8008d2ac[0x1ca8] == '\x01')
				) ||

				(
					(
						// If racer is in 6th place
						sVar13 == 5 &&

						// if numPlyrCurrGame is 2
						(PTR_DAT_8008d2ac[0x1ca8] == '\x02')
					)
				)
			) ||
			(
				(
					// if racer is in 4th place
					sVar13 == 3 &&

					// if numPlyrCurrGame is more than 2
					(2 < (byte)PTR_DAT_8008d2ac[0x1ca8])
				)
			)
		) &&
		(
			// race timer is not frozen for this player
			(*(uint *)(param_2 + 0x2c8) & 0x40000) == 0)
		)
  {
	// Increase the time racer has been in last place by elapsed milliseconds
    *(int *)(param_2 + 0x528) = *(int *)(param_2 + 0x528) + iVar14;
  }

  sVar13 = 4;

  // if you have a raincloud over your head from potion
  if (*(int *)(param_2 + 0x4a0) != 0) {
    sVar13 = *(short *)(*(int *)(*(int *)(param_2 + 0x4a0) + 0x30) + 6);
  }

  // get approximate speed
  iVar11 = (int)*(short *)(param_2 + 0x38e);

  // Action flags (isRaceOver, isTimeFrozen, etc)
  uVar22 = *(uint *)(param_2 + 0x2c8);

  // driver->clockReceive
  iVar19 = (int)*(short *)(param_2 + 0xc);

  *(short *)(param_2 + 0x50a) = sVar13;

  // absolute value of speed
  if (iVar11 < 0) {
    iVar11 = -iVar11;
  }

  if (
		(
			// if you are not impacted by clock weapon
			(iVar19 == 0) &&
			(
				// get squished timer
				iVar19 = (int)*(short *)(param_2 + 0x404),

				// if you are not squished
				iVar19 == 0
			)
		) &&
		(
			(
				sVar13 != 0 ||
				(
					// if time on the clock is zero
					iVar19 = *(int *)(PTR_DAT_8008d2ac + 0x1d10),
					iVar19 == 0
				)
			)
		)
	  )
  {
  	//uVar20 = Hazard Timer (sign extended 2 to 4 bytes)
    uVar20 = SEXT24(*(short *)(param_2 + 0xe));

	// hazard timer will not go
	// down unless you keep moving,
	// is this for red potion raincloud?

	// if you have high speed
    if (0x100 < iVar11)
	{
	  // decrease hazard by elapsed time
      uVar20 = uVar20 + iVar8;
    }

    uVar7 = (undefined2)(uVar20 & 0xfffffffe);
    if (-1 < (int)(uVar20 & 0xfffffffe)) {
      uVar7 = 0xfffe;
    }

    //Hazard Timer = uVar7
    *(undefined2 *)(param_2 + 0xe) = uVar7;
  }

  // if you are not impacted by hazard (other than clock)
  else {
    uVar18 = (ushort)iVar19;

	// if you are not touching the ground
    if ((uVar22 & 1) == 0)
	{
	  // if speed is low
      if (iVar11 < 0x101) goto LAB_80061cf8;

	  // if speed is high...

	  // absolute value of clock hazard
      if (iVar19 < 0) {
        uVar18 = -uVar18;
      }

LAB_80061d0c:
      uVar6 = -uVar18 | 1;
    }

	// if you are touching the ground
    else
	{
	  // if speed is low
      if (iVar11 < 0x101)
	  {
LAB_80061cf8:
				//uVar18 = Hazard Timer
        uVar18 = *(ushort *)(param_2 + 0xe);
        uVar6 = uVar18 | 1;
        if (0 < (short)uVar18) goto LAB_80061d0c;
      }

	  // if speed is high
      else
	  {
	    // absolute value of clock hazard
        if (iVar19 < 0) {
          uVar18 = -uVar18;
        }

		// Use trigonometry with speed and
		// clock timer to make the car waddle

        //iVar8 = Clock Item (Receive) Timer << 0x10
        iVar8 = (uint)*(ushort *)(param_2 + 0xc) << 0x10;

        iVar19 = iVar8 >> 0x16;
        if (0x40 < iVar19) {
          iVar19 = 0x40;
        }

        uVar20 = (iVar8 >> 0x10) << 4;

		// approximate trigonometry
        iVar8 = *(int *)(&DAT_800845a0 + (uVar20 & 0x3ff) * 4);

        if ((uVar20 & 0x400) == 0) {
          iVar8 = iVar8 << 0x10;
        }
        iVar8 = iVar8 >> 0x10;
        if ((uVar20 & 0x800) != 0) {
          iVar8 = -iVar8;
        }
        iVar21 = iVar11 >> 8;
        if (0x20 < iVar21) {
          iVar21 = 0x20;
        }

		// gamepad vibration
		FUN_800264c0(param_2,4,iVar19 + (iVar8 >> 5) + iVar21 + 0x18);

        uVar6 = uVar18 | 1;
      }
    }
    //Hazard Timer = uVar6
    *(ushort *)(param_2 + 0xe) = uVar6;
  }

  //trigger Item roll / selection
  //if Held Item = None
  if (*(char *)(param_2 + 0x36) == '\x10') {

	//if Item roll is done
    if (*(short *)(param_2 + 0x3a) == 0)
		{
	  // Select a random weapon for driver
      FUN_80060f0c(param_2);

	  	// if 9 < number of wumpa
	  	// if wumpa is 10
      bVar4 = '\t' < *(char *)(param_2 + 0x30);

	  // if you have less than 10 wumpa

	  // "ding" sound
      uVar16 = 0x5e;

	  // if you have 10 wumpa
      if (bVar4)
	  {
		// "ka-ching" sound
        uVar16 = 0x41;
      }

      // OtherFX_Play of getting weapon
      FUN_80028468(uVar16,(uint)bVar4);
    }

	//if Item roll is not done
    else
	{
    	//Item roll Timer--
      *(short *)(param_2 + 0x3a) = *(short *)(param_2 + 0x3a) + -1;
    }
  }

  //sVar3 = No Item Timer
  sVar3 = *(short *)(param_2 + 0x3c);

  //if Item is going away
  if (sVar3 != 0) {

	//if Item is about to be gone and Number of Items = 0
    if ((sVar3 == 1) && (*(char *)(param_2 + 0x37) == '\0')) {

	  // if numPlyrCurrGame is > 2
	  if ((2 < (byte)PTR_DAT_8008d2ac[0x1ca8]) &&

		  // If you're not in Battle Mode
         ((((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0 &&

		 // your weapon is 3 missiles
		 (*(char *)(param_2 + 0x36) == '\v')) &&

		  // If there are racers that had 3 missiles
          (0 < *(int *)(PTR_DAT_8008d2ac + 0x1ec4)))))
	  {
		// decrement the number of players that had 3 missiles
        *(int *)(PTR_DAT_8008d2ac + 0x1ec4) = *(int *)(PTR_DAT_8008d2ac + 0x1ec4) + -1;
      }

	  // take away weapon
      *(undefined *)(param_2 + 0x36) = 0xf;
    }

    //No Item Timer--
    *(short *)(param_2 + 0x3c) = sVar3 + -1;
  }

  // If Invinsibility effect is active (timer at 0x24)
  // Make "desired" timer by subtracting elapsed time from "current",
  // set "current" to "desired", then set "current" to zero if "desired" is negative

  if ((*(int *)(param_2 + 0x24) != 0) &&
     (iVar8 = *(int *)(param_2 + 0x24) - *(int *)(PTR_DAT_8008d2ac + 0x1d04),
     *(int *)(param_2 + 0x24) = iVar8, iVar8 < 0)) {
    *(undefined4 *)(param_2 + 0x24) = 0;
  }

  // If Invincibility effect is active (timer at 0x28) and if Cheat Code is Disabled
  // Make "desired" timer by subtracting elapsed time from "current",
  // set "current" to "desired", then set "current" to zero if "desired" is negative

  if (
		// if driver is invisible
		(*(int *)(param_2 + 0x28) != 0) &&

		// If Permanent Invisibility Cheat is Disabled
		((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x8000) == 0)
	)
  {
	// decrease invisibility timer,
	// can not go below zero
    iVar8 = *(int *)(param_2 + 0x28) - *(int *)(PTR_DAT_8008d2ac + 0x1d04);
    *(int *)(param_2 + 0x28) = iVar8;
    if (iVar8 < 0) {
      *(undefined4 *)(param_2 + 0x28) = 0;
    }

	// If the timer expires, make yourself visible
    if (*(int *)(param_2 + 0x28) == 0)
	{
	  // restore backup of instance flags
      *(undefined4 *)(*(int *)(param_2 + 0x1c) + 0x28) = *(undefined4 *)(param_2 + 0x2c);

	  // set instance transparency to zero
      *(undefined2 *)(*(int *)(param_2 + 0x1c) + 0x22) = 0;

	  // OtherFX_Play
      FUN_80028468(0x62,1);
    }
  }

  // Random guess, this next block is probably for making a backup
  // of current position and rotation, to calculate linear + angular
  // velocity by comparing two frames

  *(undefined4 *)(param_2 + 0x2f4) = *(undefined4 *)(param_2 + 0x2ec);
  puVar24 = PTR_DAT_8008d2ac;
  
  // action flags
  *(uint *)(param_2 + 0x2cc) = uVar22;
  
  *(undefined4 *)(param_2 + 0x2e4) = *(undefined4 *)(param_2 + 0x2d8);
  *(undefined4 *)(param_2 + 0x2e8) = *(undefined4 *)(param_2 + 0x2dc);
  *(undefined2 *)(param_2 + 0x2f8) = *(undefined2 *)(param_2 + 0x2f0);
  *(undefined2 *)(param_2 + 0x392) = *(undefined2 *)(param_2 + 0x390);
  *(undefined2 *)(param_2 + 0x3c8) = *(undefined2 *)(param_2 + 0x3c6);
  *(undefined4 *)(param_2 + 0x2e0) = *(undefined4 *)(param_2 + 0x2d4);

  uVar20 = uVar22 & 0x7f1f83d5;
  
  // disable input if opening adv hub door with key
  if ((*(uint *)(puVar24 + 8) & 0x4004) != 0) goto LAB_800629f8;
  
  iVar19 = (uint)*(byte *)(param_2 + 0x380) + 1;
  uVar17 = (undefined)iVar19;
  
  // this is always zero, there's no possible
  // way for it not to be, so AxisAngle4
  iVar8 = iVar19 * 8;
  
  if (iVar19 != 0) {
    uVar17 = 0;
    iVar8 = 0;
  }
  
  // always AxisAngle4
  puVar12 = (undefined4 *)(param_2 + iVar8 + 0x378);
  
  // if not touching ground
  if ((uVar22 & 1) == 0) 
  {
	// AngleAxis2_NormalVec
    *puVar12 = *(undefined4 *)(param_2 + 0x368);
    *(undefined2 *)(puVar12 + 1) = *(undefined2 *)(param_2 + 0x36c);
  }
  
  // if touching ground
  else 
  {
	// AngleAxis1_NormalVec
    *puVar12 = *(undefined4 *)(param_2 + 0x360);
    *(undefined2 *)(puVar12 + 1) = *(undefined2 *)(param_2 + 0x364);
  }
  
  *(undefined *)(param_2 + 0x380) = uVar17;

  // driver -> instBubble
  iVar8 = *(int *)(param_1 + 0x14);

  uVar22 = uVar20;

  // loop through all, find mask if it exists
  while (iVar8 != 0)
  {
	// If thread->modelIndex is Aku or Uka
    if ((*(short *)(iVar8 + 0x44) == 0x3a) || (*(short *)(iVar8 + 0x44) == 0x39)) {
      uVar22 = uVar20 | 0x800000;
      break;
    }

	// check next bubble in linked list
    iVar8 = *(int *)(iVar8 + 0x10);
  }

  // pointer to gamepad input of current player (param_2)
  puVar24 = PTR_DAT_8008d2b0 + (uint)*(byte *)(param_2 + 0x4a) * 0x50;

  // by default, hold no buttons
  uVar20 = 0;

  // If you're not in End-Of-Race menu
  if ((*(uint *)PTR_DAT_8008d2ac & 0x200000) == 0)
  {
	// Get which button is held
    uVar20 = *(uint *)(puVar24 + 0x10);
  }

  // by default, tap no buttons
  uVar15 = 0;

  // If you're not in End-Of-Race menu
  if ((*(uint *)PTR_DAT_8008d2ac & 0x200000) == 0)
  {
	// Get which button is tapped
    uVar15 = *(uint *)(puVar24 + 0x14);
  }

  // If you hold Cross
  local_38 = uVar20 & 0x10;

  // If you hold Square
  local_34 = uVar20 & 0x20;

  // state of kart
  cVar1 = *(char *)(param_2 + 0x376);

  if (
		(
			// If you press circle
			((uVar15 & 0x40) != 0) &&


			(
				// if neutral driving
				((cVar1 == '\0' ||

				// or sliding
				(cVar1 == '\x02')) ||

				// or ???
				(cVar1 == '\t'))
			)
		) &&

		// if there is no tnt on your head
		(*(int *)(param_2 + 0x18) == 0)
	  )
  {
	// If there is no Bomb pointer
    if (*(int *)(param_2 + 0x10) == 0) {

	  // If there is no Bubble pointer
      if (*(int *)(param_2 + 0x14) == 0) {

		// If there is no "weapon roulette" animation
        sVar3 = *(short *)(param_2 + 0x3a);
        if (sVar3 == 0) {

		  // If you dont have "roulette" weapon (0x10), and if you dont have "no weapon" (0xf)
		  // and if you did not have a weapon last frame (0x3c->0),
		  // and if (unknown sVar13 related to 0x4a0),
		  // and if you are not being effected by Clock Weapon
          cVar2 = *(char *)(param_2 + 0x36);
          if (((cVar2 != '\x0f') && (cVar2 != '\x10')) &&
             ((*(short *)(param_2 + 0x3c) == 0 &&
              ((sVar13 != 1 && (*(short *)(param_2 + 0xc) == 0))))))
		  {
			// This driver wants to fire a weapon (0x2c8 flags)
            uVar22 = uVar22 | 0x8000;

			// If "held item quantity" is zero
            if (*(char *)(param_2 + 0x37) == '\0') 
			{
              *(undefined2 *)(param_2 + 0x3c) = 0x1e;
              goto LAB_800621cc;
            }

			// If you have the Spring weapon
            if (cVar2 == '\x05') 
			{
              if (*(short *)(param_2 + 0x3f4) != 0) {
                uVar9 = SEXT24(*(short *)(param_2 + 0x3f2));
                goto LAB_80062188;
              }
            }
            
			// any other weapon
			else 
			{
			  // CHEAT_MASK, CHEAT_TURBO, or CHEAT_BOMBS
              uVar9 = *(uint *)(PTR_DAT_8008d2ac + 8) & 0x400c00;
LAB_80062188:
			  // if cheats aren't enabled
              if (uVar9 == 0) 
			  {
				// reduce number of items held
                *(char *)(param_2 + 0x37) = *(char *)(param_2 + 0x37) + -1;
              }
            }
			
			// 5-frame cooldown before next weapon
            *(undefined2 *)(param_2 + 0x3c) = 5;
			
            goto LAB_800621cc;
          }
          sVar3 = *(short *)(param_2 + 0x3a);
        }

		// if there are less than 70 frames (2.3 sec remaining)
        if (sVar3 < 0x46)
		{
		  // skip to the end of the countdown
          *(undefined2 *)(param_2 + 0x3a) = 0;
        }
      }

	  // If there is a Bubble Pointer
      else
	  {
		// Shoot the bubble

		// We can see the bubble pointer (driver + 0x14)

		// instance -> thread -> object
        iVar8 = *(int *)(*(int *)(*(int *)(param_2 + 0x14) + 0x6c) + 0x30);

        *(ushort *)(iVar8 + 6) = *(ushort *)(iVar8 + 6) | 2;

		// Reset to nullptr
	   *(undefined4 *)(param_2 + 0x14) = 0;
      }
    }

	// If there is a Bomb Pointer
    else
	{
	  // Detonate the bomb

	  // We can see the bomb pointer (driver + 0x10)

	  // instance -> thread -> object
      iVar8 = *(int *)(*(int *)(*(int *)(param_2 + 0x10) + 0x6c) + 0x30);

	  // always face camera
	  *(ushort *)(iVar8 + 0x16) = *(ushort *)(iVar8 + 0x16) | 2;

	  // Reset to nullptr
      *(undefined4 *)(param_2 + 0x10) = 0;
    }
  }
LAB_800621cc:

  // Check for Tapping L1 and R1
  uVar15 = uVar15 & 0xc00;

  if (
		//if you're not pressing L1 or R1
		(uVar15 == 0) ||
		
		// or you are sliding
		(*(char *)(param_2 + 0x376) == '\x02')
	)
  {
    if (
			// If you are holding L1 or R1 and
			((uVar20 & 0xc00) != 0) &&
			(sVar13 != 3)
	  )
    {
      if ((uVar22 & 4) == 0)
	  {
		// 10 frame jump buffer
        *(undefined2 *)(param_2 + 0x3f0) = 10;
      }
      goto LAB_8006222c;
    }
    uVar22 = uVar22 & 0xfffffffb;
    if (0 < *(short *)(param_2 + 0x3f0)) {
      *(undefined2 *)(param_2 + 0x3f0) = 0;
    }
  }

  //if you're pressing jump buttons and not sliding
  else
  {
    //if L1 and R1 were being tapped at once
    if (uVar15 == 0xc00)
	{
      //set Last Jump button pressed to R1
      *(undefined2 *)(param_2 + 0x382) = 0x400;
    }

    //if you're not tapping L1 and R1 at once
    else
	{
      //Last Jump button pressed = uVar15
      *(undefined2 *)(param_2 + 0x382) = (short)uVar15;
    }

    if (sVar13 != 3)
	{
	  // 10 frame jump buffer
      *(undefined2 *)(param_2 + 0x3f0) = 10;
LAB_8006222c:
      uVar22 = uVar22 | 4;
    }
  }

  if (
		// If you are holding Square
		(local_34 != 0) &&

		// if you're not on any turbo pad
		((*(uint *)(param_2 + 0xbc) & 3) == 0)
	)
  {
	// Set Reserves to zero
    *(undefined2 *)(param_2 + 0x3e2) = 0;
  }

  // assume normal gas pedal
  iVar8 = 0x80;

  // If you're not in End-Of-Race menu
  if ((*(uint *)PTR_DAT_8008d2ac & 0x200000) == 0)
  {
	// gamepadBuffer -> stickRY (for gas or reverse)
    iVar8 = (int)*(short *)(puVar24 + 0xe);
  }

  if (
		// If Reserves are not zero
		(*(short *)(param_2 + 0x3e2) != 0) ||

		(sVar13 == 6)
	 )
  {
    if (
			// If you are not holding Cross
			(local_38 == 0) &&

			// Player_StickReturnToRest
			(iVar19 = FUN_8006163c(iVar8,0x80,0), -1 < iVar19)
		)
	{
      uVar22 = uVar22 | 0x400000;
    }


    if (
			// If are holding Square
			(local_34 != 0) &&

			(0x300 < iVar11)
		)
	{
      uVar22 = uVar22 | 0x800;
    }

	// if you're on any turbo pad
    if ((*(uint *)(param_2 + 0xbc) & 3) != 0)
	{
	  // assume not holding square until boost is over
      local_34 = 0;
    }

	// Assume you're holding Cross, because
	// you have Reserves and you aren't slowing down
    local_38 = 0x10;
  }

  iVar19 = 0x80;

  // If you're not in End-Of-Race menu
  if ((*(uint *)PTR_DAT_8008d2ac & 0x200000) == 0) {
    iVar19 = (int)*(short *)(puVar24 + 6);
  }

  if ((*(char *)(param_2 + 0x4b) < '\0') ||
     (uVar22 = uVar22 & 0xdfffffff, *(char *)(param_2 + 0x4b) < '\x01')) {
    uVar22 = uVar22 & 0xbfffffff;
  }
  iVar21 = (int)*(short *)(param_2 + 0x38e);
  if (iVar21 < 0) {
    iVar21 = -iVar21;
  }
  if (iVar21 < 0x300) {
    uVar22 = uVar22 & 0x9fffffff;
  }
  iVar21 = 0;
  //iVar10 = Racer's Base Speed (4s)
  iVar10 = FUN_80061488(param_2);
  //uVar7 = Racer's Base Speed (2u)
  uVar7 = (undefined2)iVar10;

  // If you are not holding Square
  if (local_34 == 0) {
    //iVar23 = Racer's Base Speed
    iVar23 = iVar10;

    // If you are holding Cross, or if you have Reserves
    if (local_38 != 0) {
LAB_8006253c:
      uVar22 = uVar22 & 0xfffdffff;
      goto LAB_80062548;
    }

    // if you are not holding cross, or have no Reserves...
    //iVar23 is replaced

	// Player_StickReturnToRest
    iVar23 = FUN_8006163c(iVar8,0x80,0);

	iVar8 = -iVar23;
    if (iVar23 < 1) {
      if ((iVar8 == 0) &&

		  // Player_StickReturnToRest
         ((iVar19 = FUN_8006163c(iVar19,0x80,0), 99 < iVar19 ||

		  ((0 < iVar19 && ((uVar22 & 0x20000) != 0))))))
	  {
		// driver is steering?
        uVar22 = uVar22 | 0x20000;
		
        iVar23 = -(int)*(short *)(param_2 + 0x434);
        goto LAB_80062548;
      }
      iVar8 = iVar10 * iVar8;
      iVar23 = iVar8 >> 7;
      if (iVar8 < 0) {
        iVar23 = iVar8 + 0x7f >> 7;
      }
      goto LAB_8006253c;
    }
    if ((*(short *)(param_2 + 0x38e) < 0x301) && ((uVar22 & 0x60000000) == 0)) {
      iVar8 = *(short *)(param_2 + 0x434) * iVar8;
      if (iVar8 < 0) {
        iVar8 = iVar8 + 0x7f;
      }
      iVar21 = iVar8 >> 7;
      uVar15 = 0x20000;
LAB_800625c4:
      uVar20 = uVar22 | uVar15;
    }
    else {
      uVar20 = uVar22 | 8;
      if ('\0' < *(char *)(param_2 + 0x4b)) {
        uVar20 = uVar22 | 0x40000008;
      }
      if (*(char *)(param_2 + 0x4b) < '\0') {
        uVar15 = 0x20000000;
        uVar22 = uVar20;
        goto LAB_800625c4;
      }
    }
  }
  // If you are holding Square
  else
  {
	// Player_StickReturnToRest
    iVar19 = FUN_8006163c(iVar19,0x80,0);

	if ((iVar19 < 100) && ((iVar19 < 1 || ((uVar22 & 0x20000) == 0))))
	{
	  // if you are not holding cross, and you have no Reserves
      if (local_38 == 0)
	  {
        // Player_StickReturnToRest
		iVar8 = FUN_8006163c(iVar8,0x80,0);

		iVar23 = iVar10 * -iVar8;
        if (iVar8 < 0) {
          if (iVar23 < 0) {
            iVar23 = iVar23 + 0xff;
          }
          iVar23 = iVar23 >> 8;
          uVar22 = uVar22 | 0x20;
          goto LAB_80062548;
        }
        if (0 < iVar8) {
          iVar8 = (int)*(short *)(param_2 + 0x434) * -iVar8;
          iVar23 = iVar8 >> 8;
          if (iVar8 < 0) {
            iVar23 = iVar8 + 0xff >> 8;
          }
          goto LAB_8006248c;
        }
        uVar22 = uVar22 | 8;
        iVar23 = iVar21;
      }
      // If you are holding cross, or you have Reserves
      else {
        uVar22 = uVar22 | 0x20;
        iVar23 = iVar10 / 2;
      }
      goto LAB_8006253c;
    }
    iVar8 = (int)*(short *)(param_2 + 0x434) * -3;
    iVar23 = iVar8 >> 2;
    if (iVar8 < 0) {
      iVar23 = iVar8 + 3 >> 2;
    }
LAB_8006248c:
    uVar22 = uVar22 | 0x20020;
LAB_80062548:
    uVar20 = uVar22 & 0x9fffffff;
    //iVar21 = Racer's Base Speed
    iVar21 = iVar23;
  }
  
  if ((uVar20 & 0x20000) == 0) 
  {
    uVar22 = uVar20 & 8;
    if (*(short *)(param_2 + 0x38) != 0) {
      //if Racer is moving
      if (0 < iVar21) {
        uVar22 = uVar20 & 8;
        if ((uVar20 & 0x400020) != 0) goto LAB_80062648;

        // if you have less than 10 wumpa
        uVar16 = 0x80;

        *(uint *)(param_2 + 0x2c8) = uVar20;

		// if 9 < number of wumpa
        // if wumpa is 10
        if ('\t' < *(char *)(param_2 + 0x30)) {
          uVar16 = 0x100;
        }

		// Turbo_Increment
		// add 0.12s reserves
		FUN_8005abfc(param_2,0x78,0x14,uVar16);

        uVar20 = *(uint *)(param_2 + 0x2c8);
      }
      goto code_r0x80062644;
    }
  }

  else
  {
	// Increase amount of time reversing,
	// counts whenever holding "down" on d-pad
    *(int *)(param_2 + 0x520) = *(int *)(param_2 + 0x520) + iVar14;
code_r0x80062644:
    uVar22 = uVar20 & 8;
  }

LAB_80062648:
  if (uVar22 != 0) {
    iVar8 = (int)*(short *)(param_2 + 0x38e);
    if (iVar8 < 0) {
      iVar8 = -iVar8;
    }
    
	if (0x300 < iVar8) 
	{
	  // record amount of time with high speed
      *(int *)(param_2 + 0x51c) = *(int *)(param_2 + 0x51c) + iVar14;
    }
  }

  if ((*(short *)(param_2 + 0x3c0) == 0) ||

	  // kart state not 0, and kart state not 9
     ((*(char *)(param_2 + 0x376) != '\0' && (*(char *)(param_2 + 0x376) != '\t'))))
  {
	*(undefined2 *)(param_2 + 0x3c2) = 0;
  }

  if (*(short *)(param_2 + 0x39e) < 1) {
    //if Racer is moving, skip next 4 lines of code
    if (0 < iVar21) goto LAB_800626d4;
LAB_800626fc:
    //Racer struct + 0x39E = Racer's Base Speed
    *(undefined2 *)(param_2 + 0x39e) = (short)iVar21;
  }
  else {
    //if Racer is not moving
    if (iVar21 < 1) {
LAB_800626d4:
      if (*(short *)(param_2 + 0x3c0) != 0) {
        *(short *)(param_2 + 0x3c2) = *(short *)(param_2 + 0x3c2) + 1;
      }
      *(undefined2 *)(param_2 + 0x3c0) = 0x100;
      goto LAB_800626fc;
    }
    //Racer struct + 0x39E = Racer's Base Speed
    *(undefined2 *)(param_2 + 0x39e) = (short)iVar21;
  }
  if ((uVar20 & 0x800020) == 0) {
    iVar8 = *(int *)(*(int *)(param_2 + 0x35c) + 8);
    //if racer is out of normal driving conditions?
    //for example, 0x35C[0x8] is 0xB4 when in water at Cove
    //and the value of 0x39C fits the result perfectly
    if (iVar8 != 0x100) {
      //Base Speed = 0xB4 (at Cove water) * Base Speed >> 8
      iVar21 = iVar8 * iVar21 >> 8;
      uVar7 = (undefined2)((uint)(iVar8 * iVar10) >> 8);
    }
  }
  *(undefined2 *)(param_2 + 0x3c4) = uVar7;
  //Basic Speed = iVar21
  *(undefined2 *)(param_2 + 0x39c) = (short)iVar21;

  // assume neutral steer (drive straight)
  iVar8 = 0x80;

  puVar5 = PTR_DAT_8008d2ac;

  // If you're not in End-Of-Race menu
  if ((*(uint *)puVar5 & 0x200000) == 0)
  {
	// gamepadBuffer -> stickLX
    iVar8 = (int)*(short *)(puVar24 + 4);
  }

  iVar14 = (uint)*(byte *)(param_2 + 0x43a) + ((int)*(char *)(param_2 + 0x34) << 1) / 5;
  if ((*(short *)(param_2 + 0x3c2) < 7) || (0x25ff < iVar11)) {
    if (*(short *)(param_2 + 0x3fe) == 0) {
      if ((uVar20 & 0x28) == 0)
	  {
		// gamepadBuffer -> racingWheelData
        uVar16 = *(undefined4 *)(puVar24 + 0x4c);
      }
      else
	  {
		// if you are not holding cross
        if (local_38 == 0)
		{
          // gamepadBuffer -> racingWheelData
		  uVar16 = *(undefined4 *)(puVar24 + 0x4c);

		  iVar14 = 0x40;
        }

		// if you are holding cross
        else
		{
		  // get speed
          iVar19 = (int)*(short *)(param_2 + 0x38c);

		  // set speed to absolute value
          if (iVar19 < 0) {
            iVar19 = -iVar19;
          }

          // Map value from [oldMin, oldMax] to [newMin, newMax]
          // inverting newMin and newMax will give an inverse range mapping
          iVar14 = FUN_80058f9c(iVar19,0x300,
                                (int)((uint)*(ushort *)(param_2 + 0x42c) << 0x10) >> 0x11,0x40,
                                iVar14);

		  // gamepadBuffer -> racingWheelData
		  uVar16 = *(undefined4 *)(puVar24 + 0x4c);
        }
      }
    }
    else
	{
	  // gamepadBuffer -> racingWheelData
      uVar16 = *(undefined4 *)(puVar24 + 0x4c);
      iVar14 = 0x30;
    }
  }
  else
  {
	// gamepadBuffer -> racingWheelData
    uVar16 = *(undefined4 *)(puVar24 + 0x4c);

    iVar14 = 0x5a;
  }

  // Steer
  iVar14 = FUN_800617cc(iVar8,iVar14,uVar16);

  if (-iVar14 == 0) {
    *(undefined2 *)(param_2 + 0x3e6) = 10000;
  }
  else {
    if ((iVar14 < 1) || (*(char *)(param_2 + 0x4b) < '\0')) {
      if ((-1 < iVar14) || ('\0' < *(char *)(param_2 + 0x4b))) goto LAB_800628b0;
      uVar20 = uVar20 | 0x10;
    }
    else {
      uVar20 = uVar20 & 0xffffffef;
    }
    *(undefined2 *)(param_2 + 0x3e6) = 0;
  }
LAB_800628b0:
  *(undefined *)(param_2 + 0x4b) = (char)-iVar14;

  // Steer
  iVar8 = FUN_800617cc(iVar8,0x40,*(undefined4 *)(puVar24 + 0x4c));

  // Interpolate rotation by speed
  uVar7 = FUN_80058f54((int)*(short *)(param_2 + 6),0x18,-iVar8);

  iVar8 = (int)*(short *)(param_2 + 0x39e);
  *(undefined2 *)(param_2 + 6) = uVar7;
  if (iVar8 < 0) {
    iVar8 = -iVar8;
  }
  if (((*(uint *)(param_2 + 0x2cc) & 1) == 0) || (cVar1 == '\x02')) {
    iVar8 = iVar8 + 0xf00;
  }
  else {
    iVar8 = iVar8 + iVar11 >> 1;
  }
  sVar13 = (short)((iVar8 * 0x89 + (int)*(short *)(param_2 + 0x3be) * 0x177) * 8 >> 0xc);
  *(short *)(param_2 + 0x3be) = sVar13;
  if ((*(uint *)(param_2 + 0x2cc) & 8) == 0) {
    //prevent Basic Speed from being negative
    if (iVar21 < 0) {
      iVar21 = -iVar21;
    }
    //if Base Speed > 0x200 or iVar11 = 0x200 (?)
    if ((0x200 < iVar21) || (0x200 < iVar11)) {
      *(short *)(param_2 + 0x3bc) = *(short *)(param_2 + 0x3bc) - sVar13;
    }
  }
  //if 0x3BC <= 0 and last bit of jittery number 2 is off and
  if (((*(short *)(param_2 + 0x3bc) < 1) && ((*(uint *)(param_2 + 8) & 1) == 0)) &&
     (cVar1 != '\x04')) {
  	//reset 0x3BC
    *(undefined2 *)(param_2 + 0x3bc) = 0x1e00;
    //Jittery number 1
    *(undefined4 *)(param_2 + 8) = 0x2e606061;
  }
  else {
  	//jittery number 2
    *(undefined4 *)(param_2 + 8) = 0x2e808080;
  }
LAB_800629f8:
  *(uint *)(param_2 + 0x2c8) = uVar20;
  return;
}


// VehPtr_Driving_Audio (universal)
// param1 = thread, param2 = driver
void FUN_80062a2c(undefined4 param_1,undefined4 param_2)
{
  // EngineSound_Player
  FUN_8002f5f4(param_2);
  return;
}


// VehPtr_Driving_Update
// param1 = thread, param2 = driver
void FUN_80062a4c(undefined4 param_1,int param_2)
{
  int iVar1;

  //if racer touched the ground in this frame
  if ((*(uint *)(param_2 + 0x2c8) & 2) != 0) 
  {
    //iVar1 = Simplified Turning state
    iVar1 = (int)*(char *)(param_2 + 0x4b);

    //set Simplified Turning state to its own absolute value
    if (iVar1 < 0) {
      iVar1 = -iVar1;
    }

    if (
		(
			(
				// if steering hard enough to start a drift
				(
					// (Character's Turn stat + (Turning multiplier? << 1) / 5) >> 1)
					(int)((uint)*(byte *)(param_2 + 0x43a) +
					((int)*(char *)(param_2 + 0x34) << 1) / 5) >> 1
					
					// < Simplified turning state
					< iVar1
				) &&

				(
					//player has jump buttons held
					(*(uint *)(PTR_DAT_8008d2b0 + (uint)*(byte *)(param_2 + 0x4a) * 0x50 + 0x10) &
					(int)*(short *)(param_2 + 0x382)) != 0
				)
			) &&

			//player is not in accel prevention or braking and
			((*(uint *)(param_2 + 0x2c8) & 8) == 0)
		) &&

		//Character's Speed stat (divided by 2?) <= Speed Approximate
		(
			(int)((uint)*(ushort *)(param_2 + 0x42c) << 0x10) >> 0x11 <=
			(int)*(short *)(param_2 + 0x38e)
		)
	   )
    {
      // VehPtr_Drifting_Init
      FUN_80063934(param_1);

      //exit the function
      return;
    }
  }

  // at this point, assume driver is not touching ground

  if (
		// if driver has been "Player_Driving" more than 0.1 seconds?
		(*(short *)(param_2 + 0x406) == 0) &&

		// if V_Shift happened too many times,
		// meaning you jitter between two quadblocks
		// in a "V" shape
		(4 < *(short *)(param_2 + 0x40a))
	 )
  {

	// Stop driving, until you press X, prevents jitters
	  
    // VehPtr_AntiVShift_Init
    FUN_80062e94(param_1);
  }

  else {

	// if driver has been "rolling backwards" more than 0.64 seconds
    if (*(short *)(param_2 + 0x408) == 0)
	{
      // wipe
      *(undefined2 *)(param_2 + 0x40a) = 0;
    }
  }
  return;
}



// VehPtr_Driving_Init
// param1 = thread, param2 = driver
void FUN_80062b74(undefined4 param_1,int param_2)
{
	// spawn function that gives you immediate control,
	// used for adventure spawn, and dropping a mask-grab

  int iVar1;

  // This if-statement prevents driving in Main Menu,
  // Cutscenes, Naughty Dog Box Scene, etc

  if (
		// if Level ID is not an adv hub
		(4 < *(int *)(PTR_DAT_8008d2ac + 0x1a10) - 0x19U) ||
		(
			// or, this is an adv hub, and 232 is loaded

			//if 232 dll is loaded
		    iVar1 = FUN_80034920(),
			iVar1 != 0
		)
	)
  {
    if (
			// If you're in Battle Mode and
			((*(uint *)PTR_DAT_8008d2ac & 0x20) != 0) &&

			//player is blasted
			(*(char *)(param_2 + 0x376) == '\x06')
		)
    {
      //set Invincibility Timer to 0xB40
      *(undefined4 *)(param_2 + 0x24) = 0xb40;
    }

    *(undefined2 *)(param_2 + 0x406) = 0x60;
    *(undefined2 *)(param_2 + 0x408) = 0x280;

	// VehPtr_Driving_Update
    *(undefined4 *)(param_2 + 0x58) = 0x80062a4c;

	// VehPtr_Driving_PhysLinear
    *(undefined4 *)(param_2 + 0x5c) = 0x8006181c;

	*(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
    *(undefined4 *)(param_2 + 100) = 0x8005fc8c; // OnPhysAngular
    *(undefined4 *)(param_2 + 0x68) = 0x8005ea60; // OnApplyForces
	*(undefined4 *)(param_2 + 0x6c) = 0x80020410; // OnCollide_QuadblockTouch
	*(undefined4 *)(param_2 + 0x70) = 0x8005ebac; // OnCollide_Drivers
	*(undefined4 *)(param_2 + 0x74) = 0x8001d944; // OnCollide_QuadblockNear
    *(undefined4 *)(param_2 + 0x78) = 0x80060630; // JumpAndFriction
    *(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix
    *(undefined4 *)(param_2 + 0x80) = 0x8005b178; // OnAnimate_Driving

    //Kart state = normal
    *(undefined *)(param_2 + 0x376) = 0;

	//Turbo meter = full
    *(undefined2 *)(param_2 + 0x3dc) = 0;

	*(undefined2 *)(param_2 + 0x40a) = 0;
    *(undefined4 *)(param_2 + 0x54) = 0;

	// VehParticle_DriverMain
    *(undefined4 *)(param_2 + 0x84) = 0x80059a18;
  }
  return;
}


// VehPtr_Freeze_PhysLinear
void FUN_80062ca8(undefined4 param_1,int param_2)
{
  uint uVar1;

  // VehPtr_Driving_PhysLinear
  FUN_8006181c();

  // get flags
  uVar1 = *(uint *)(param_2 + 0x2c8);

  // reset two speed variables
  *(undefined2 *)(param_2 + 0x39c) = 0;
  *(undefined2 *)(param_2 + 0x39e) = 0;

  // reset amplified turn state
  *(undefined2 *)(param_2 + 0xc0) = 0;

  // reset turn state
  *(undefined *)(param_2 + 0x4b) = 0;

  // reset wheel Y rotation
  *(undefined2 *)(param_2 + 6) = 0;

  // edit flags
  *(uint *)(param_2 + 0x2c8) = uVar1 | 8;
  *(uint *)(param_2 + 0x2c8) = uVar1 & 0xfffffffb | 8;

  if (0 < *(short *)(param_2 + 0x3f0)) {
    *(undefined2 *)(param_2 + 0x3f0) = 0;
  }
  return;
}

// VehPtr_Freeze_Init
// param1 = thread, param2 = driver
void FUN_80062d04(undefined4 param_1,int param_2)

{
  if (*(char *)(param_2 + 0x376) != '\v')
  {
	// VehPtr_Freeze_PhysLinear
    *(undefined4 *)(param_2 + 0x5c) = 0x80062ca8;

	*(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
    *(undefined4 *)(param_2 + 100) = 0x8005fc8c; // OnPhysAngular
    *(undefined4 *)(param_2 + 0x68) = 0x8005ea60; // OnApplyForces
	*(undefined4 *)(param_2 + 0x6c) = 0x80020410; // OnCollide_QuadblockTouch
	*(undefined4 *)(param_2 + 0x70) = 0x8005ebac; // OnCollide_Drivers
	*(undefined4 *)(param_2 + 0x74) = 0x8001d944; // OnCollide_QuadblockNear
    *(undefined4 *)(param_2 + 0x78) = 0x80060630; // JumpAndFriction
    *(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix
    *(undefined4 *)(param_2 + 0x80) = 0x8005b178; // OnAnimate_Driving

	// kart state = 11
    *(undefined *)(param_2 + 0x376) = 0xb;

    *(undefined2 *)(param_2 + 0x38c) = 0;
    *(undefined2 *)(param_2 + 0x38e) = 0;
    *(undefined4 *)(param_2 + 0x54) = 0;
    *(undefined4 *)(param_2 + 0x58) = 0;

	// VehParticle_DriverMain
    *(undefined4 *)(param_2 + 0x84) = 0x80059a18;
  }
  return;
}

// VehPtr_AntiVShift_Update
// param1 = thread, param2 = driver
void FUN_80062db0(undefined4 param_1,int param_2)
//seems to handle end of blasted effect
{
  //if 0x39E of player struct = 0 and
  //(player is not in accel prevention (4),
  //not pressing Square (4, 6),
  if (
		(*(short *)(param_2 + 0x39e) == 0) &&

		// not in player-on-player collision
		((*(uint *)(param_2 + 0x2c8) & 0x10000028) == 0)
	 )
  {
    //player's speed = 0
    *(undefined2 *)(param_2 + 0x38c) = 0;

    //player's speed approximate = 0
    *(undefined2 *)(param_2 + 0x38e) = 0;
  }
  else
  {
	// VehPtr_Driving_Init
    FUN_80062b74();
  }
  return;
}


// VehPtr_AntiVShift_ReverseOneFrame
// param1 = thread, param2 = driver
// reverse one frame of position
void FUN_80062e04(undefined4 param_1,int param_2)

{
   // Player_JumpAndFriction
  FUN_80060630();

  // if player did not start jumping this frame
  if ((*(uint *)(param_2 + 0x2c8) & 0x400) == 0)
  {
	// if there are not two humans colliding
    if ((*(uint *)(param_2 + 0x2c8) & 0x10000000) == 0)
	{
	  // remove speed (x, y, z)
      *(undefined4 *)(param_2 + 0x3a0) = 0;
      *(undefined4 *)(param_2 + 0x3a4) = 0;
      *(undefined4 *)(param_2 + 0x3a8) = 0;

	  // remove speed and speedApprox
      *(undefined2 *)(param_2 + 0x38c) = 0;
      *(undefined2 *)(param_2 + 0x38e) = 0;

	  // set position to previous position
      *(undefined4 *)(param_2 + 0x2d4) = *(undefined4 *)(param_2 + 0x2e0);
      *(undefined4 *)(param_2 + 0x2d8) = *(undefined4 *)(param_2 + 0x2e4);
      *(undefined4 *)(param_2 + 0x2dc) = *(undefined4 *)(param_2 + 0x2e8);
    }
  }

  // if player did start jumping this frame
  else
  {
	// VehPtr_Driving_Init
    FUN_80062b74(param_1,param_2);
  }

  return;
}


// VehPtr_AntiVShift_Init
// param1 = thread, param2 = driver
void FUN_80062e94(undefined4 param_1,int param_2)
{
  // kart state 9
  *(undefined *)(param_2 + 0x376) = 9;

  // OnUpdate
  *(undefined4 *)(param_2 + 0x58) = 0x80062db0;

  // VehPtr_Driving_PhysLinear
  *(undefined4 *)(param_2 + 0x5c) = 0x8006181c;

  *(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
  *(undefined4 *)(param_2 + 100) = 0x8005fc8c; // OnPhysAngular
  *(undefined4 *)(param_2 + 0x68) = 0x8005ea60; // OnApplyForces
  *(undefined4 *)(param_2 + 0x6c) = 0x80020410; // OnCollide_QuadblockTouch
  *(undefined4 *)(param_2 + 0x70) = 0x8005ebac; // OnCollide_Drivers
  *(undefined4 *)(param_2 + 0x74) = 0x8001d944; // OnCollide_QuadblockNear
  *(undefined4 *)(param_2 + 0x78) = 0x80062e04; // alter jump mechanics
  *(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix
  *(undefined4 *)(param_2 + 0x80) = 0x8005b178; // OnAnimate_Driving

  //Turbo meter = full
  *(undefined2 *)(param_2 + 0x3dc) = 0;

  *(undefined4 *)(param_2 + 0x54) = 0;

	// VehParticle_DriverMain
  *(undefined4 *)(param_2 + 0x84) = 0x80059a18;

  //turn off 29th flag of actions flag set (means players dont collide anymore)
  *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) & 0xefffffff;
  return;
}

// VehPtr_Drifting_PhysAngular
// param1 = thread, param2 = driver
void FUN_80062f4c(undefined4 param_1,int param_2)

{
  char cVar1;
  bool bVar2;
  bool bVar3;
  undefined *puVar4;
  short sVar5;
  undefined2 uVar6;
  ushort uVar7;
  int iVar8;
  int iVar9;
  uint uVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  uint uVar14;
  int iVar15;

  iVar12 = (((int)*(short *)(param_2 + 0x396) - (int)*(short *)(param_2 + 0x39a)) + 0x800U & 0xfff)
           - 0x800;
  iVar13 = iVar12 >> 3;
  if (iVar12 != 0) {
    if (iVar13 == 0) {
      iVar13 = 1;
    }

				// elapsed milliseconds per frame, ~32
    iVar12 = (*(int *)(PTR_DAT_8008d2ac + 0x1d04) << 6) >> 5;

    if (iVar12 < iVar13) {
      iVar13 = iVar12;
    }
    sVar5 = (short)iVar13;
    if (iVar13 < -iVar12) {
      sVar5 = (short)-iVar12;
    }

	// change player rotation
    *(short *)(param_2 + 0x39a) = *(short *)(param_2 + 0x39a) + sVar5;

	*(ushort *)(param_2 + 0x396) = *(short *)(param_2 + 0x396) - sVar5 & 0xfff;
  }
  
  if (*(short *)(param_2 + 0x3da) < 0) 
  {
	// negative cam spin rate
    iVar13 = -(int)*(short *)(param_2 + 0x468);
  }
  else 
  {
	// positive cam spin rate
    iVar13 = (int)*(short *)(param_2 + 0x468);
  }

  // get camera rotation
  iVar12 = *(short *)(param_2 + 0x2f2) - iVar13;

  // make sure it's not negative
  if (iVar12 < 0) {
    iVar12 = -iVar12;
  }

  uVar14 = iVar12 >> 3;
  if (uVar14 == 0) {
    uVar14 = 1;
  }
  uVar10 = (uint)*(byte *)(param_2 + 0x46a);
  if ((int)uVar14 < (int)(uint)*(byte *)(param_2 + 0x46a)) {
    uVar10 = uVar14;
  }

  // Interpolate rotation by speed
  sVar5 = FUN_80058f54((int)*(short *)(param_2 + 0x2fa),8,uVar10);
  puVar4 = PTR_DAT_8008d2ac;
  *(short *)(param_2 + 0x2fa) = sVar5;

  // Interpolate rotation by speed
  uVar6 = FUN_80058f54((int)*(short *)(param_2 + 0x2f2),(int)sVar5 * *(int *)(puVar4 + 0x1d04) >> 5,
                       iVar13);

  // turning rate
  iVar12 = (int)*(short *)(param_2 + 0x3b4);
  
  // drift direction
  iVar15 = (int)*(short *)(param_2 + 0x3da);
  
  bVar3 = false;

  // set new rotation variable
  *(undefined2 *)(param_2 + 0x2f2) = uVar6;

  // simpTurningState
  iVar9 = (int)*(char *)(param_2 + 0x4b);
  
  iVar13 = iVar9 * 0x100;
  
  // if drifting to the right
  if (iVar15 < 0) 
  {
	// if steering to the right
    if (iVar13 < 1) 
	{
      iVar13 = iVar9 * -0x100;
	  
	  // const_SteerVel_DriftStandard
      iVar9 = -(int)*(char *)(param_2 + 0x45f);
    }
	
	// if steering to the left
    else 
	{
	  // const_SteerVel_DriftSwitchWay
      iVar9 = -(int)*(char *)(param_2 + 0x45e);
    }
  }
  
  // if drifting to the left
  else 
  {
	// if steering to the right
    if (iVar13 < 0) 
	{
      iVar13 = iVar9 * -0x100;
      
	  // const_SteerVel_DriftSwitchWay
	  cVar1 = *(char *)(param_2 + 0x45e);
    }
	
	// if steering to the left
    else 
	{
	  // const_SteerVel_DriftStandard
      cVar1 = *(char *)(param_2 + 0x45f);
    }
	
    iVar9 = (int)cVar1;
  }

  // Map "simpTurnState" from [0, const_TurnRate] to [0, driftDirection]
  iVar13 = FUN_80058f9c(iVar13,0,((uint)*(byte *)(param_2 + 0x43a) +
                                 ((int)*(char *)(param_2 + 0x34) << 1) / 5) * 0x100,0,iVar9 << 8);
								 
  if (
		(iVar13 < 0) || 
		(
			(
				// compare two turning rates
				bVar2 = iVar13 < iVar12,
				
				iVar13 == 0 && (iVar12 < 0)
			)
		)
	) 
  {
    bVar3 = true;
    iVar13 = -iVar13;
    iVar12 = -iVar12;
    iVar15 = -iVar15;
    bVar2 = iVar13 < iVar12;
  }

  // 0x464 and 0x466 impact turning somehow

  if (bVar2)
  {
														// elapsed milliseconds per frame, ~32
    iVar12 = iVar12 - ((int)*(short *)(param_2 + 0x466) * *(int *)(PTR_DAT_8008d2ac + 0x1d04) >> 5);
    bVar2 = iVar12 < iVar13;
  }
  else
  {
														// elapsed milliseconds per frame, ~32
    iVar12 = iVar12 + ((int)*(short *)(param_2 + 0x464) * *(int *)(PTR_DAT_8008d2ac + 0x1d04) >> 5);
    bVar2 = iVar13 < iVar12;
  }
  
  if (bVar2) {
    iVar12 = iVar13;
  }
  
  // if not steering,
  // then interpolate to "neutral" drift
  if (iVar13 == 0) 
  {
LAB_80063244:

	// Interpolate by 1 unit, until zero
    uVar6 = FUN_80058f54((int)*(short *)(param_2 + 0x580),1,0);
    *(undefined2 *)(param_2 + 0x580) = uVar6;
  }
  
  // if steering
  else 
  {
	// if drifting right
    if (iVar15 < 1) 
	{
	  // if less than zero, reset to zero
      if (-1 < iVar15) goto LAB_80063244;
	  
	  // decrease positive number
      uVar7 = *(short *)(param_2 + 0x580) - 1;
      *(ushort *)(param_2 + 0x580) = uVar7;
	  
	  // skip to zero if already positive
      if (0 < (int)((uint)uVar7 << 0x10)) {
        *(undefined2 *)(param_2 + 0x580) = 0;
      }
    }
    
	// if drifting left
	else 
	{
	  // increase number
      uVar7 = *(short *)(param_2 + 0x580) + 1;
      *(ushort *)(param_2 + 0x580) = uVar7;
	  
	  // skip to zero if already negative
      if ((int)((uint)uVar7 << 0x10) < 0) {
        *(undefined2 *)(param_2 + 0x580) = 0;
      }
    }
  }
  if (bVar3) {
    iVar12 = -iVar12;
    iVar15 = -iVar15;
  }

  // Map value from [oldMin, oldMax] to [newMin, newMax]
  // inverting newMin and newMax will give an inverse range mapping
  iVar13 = FUN_80058f9c((int)*(short *)(param_2 + 0x584),0,(uint)*(byte *)(param_2 + 0x462) << 5,
                        (int)*(char *)(param_2 + 0x461) * (int)*(short *)(param_2 + 0x3da) >> 8,
                        iVar15);
  if (-1 < iVar13) {
    if (iVar12 < -iVar13) {
      iVar12 = -iVar13;
    }
    sVar5 = (short)iVar12;
    if (0 < iVar13) goto LAB_800632cc;
  }
  sVar5 = (short)iVar12;
  if (-iVar13 < iVar12) {
    sVar5 = (short)-iVar13;
  }
LAB_800632cc:
  iVar12 = iVar13;
  if (iVar13 < 0) {
    iVar12 = -iVar13;
  }
  *(short *)(param_2 + 0x3b4) = sVar5;
  iVar9 = (int)sVar5;

  // Map value from [oldMin, oldMax] to [newMin, newMax]
  // inverting newMin and newMax will give an inverse range mapping
  iVar12 = FUN_80058f9c(iVar12,0,(int)*(char *)(param_2 + 0x460) +
                                 ((int)*(char *)(param_2 + 0x34) << 2) / 5,0,
                        (int)*(short *)(param_2 + 0x474));
  
  iVar15 = iVar9;
  
  if (iVar13 < 0) 
  {
    iVar12 = -iVar12;
    
	if (iVar9 < 0) 
	{
      if (iVar9 < 0) {
        iVar15 = -iVar9;
      }
	  
	  // const_SteerVel_DriftStandard
      iVar11 = (int)*(char *)(param_2 + 0x45f) << 8;
	  
      iVar8 = -(int)*(short *)(param_2 + 0x470);
    }
	
    else 
	{
	  // const_SteerVel_DriftSwitchWay
      iVar11 = (int)*(char *)(param_2 + 0x45e) << 8;
	  
      iVar8 = -(int)*(short *)(param_2 + 0x472);
    }
  }
  
  else 
  {
    if (iVar9 < 0) 
	{
      if (iVar9 < 0) 
	  {
        iVar15 = -iVar9;
      }
	  
	  // const_SteerVel_DriftSwitchWay
      cVar1 = *(char *)(param_2 + 0x45e);
	  
      sVar5 = *(short *)(param_2 + 0x472);
    }
    
	else 
	{
	  // const_SteerVel_DriftStandard
      cVar1 = *(char *)(param_2 + 0x45f);
	  
      sVar5 = *(short *)(param_2 + 0x470);
    }
    iVar8 = (int)sVar5;
    iVar11 = (int)cVar1 << 8;
  }

  // Map value from [oldMin, oldMax] to [newMin, newMax]
  // inverting newMin and newMax will give an inverse range mapping
  iVar15 = FUN_80058f9c(iVar15,0,iVar11,0,iVar8);
  iVar12 = (iVar12 + iVar15) - (int)*(short *)(param_2 + 0x3c6);
  iVar15 = iVar12 >> 3;
  sVar5 = (short)iVar15;
  if (iVar12 != 0) {
    if (iVar15 == 0) {
      sVar5 = 1;
    }
    *(short *)(param_2 + 0x3c6) = *(short *)(param_2 + 0x3c6) + sVar5;
  }
  iVar12 = (int)*(short *)(param_2 + 0x580);
  if (iVar12 < 0) {
    iVar12 = -iVar12;
  }

  // get half of spin-out constant, this determines
  // when to start making tire sound effects, after the
  // turbo meter finishes filling past it's max capacity

  // if you drift beyond the limit of the turbo meter
  if ((int)(uint)(*(byte *)(param_2 + 0x463) >> 1) < iVar12)
  {
    iVar12 = (int)*(short *)(param_2 + 0x3d4);
    if (iVar12 < 0) {
      iVar12 = -iVar12;
    }
    if (iVar12 < 10) {
      *(undefined2 *)(param_2 + 0x3d8) = 8;
      *(undefined2 *)(param_2 + 0x3d6) = 0x14;
      if (iVar13 < 0) {
        *(undefined2 *)(param_2 + 0x3d6) = 0xffec;
      }
    }
  }
  else {
    *(undefined2 *)(param_2 + 0x3d8) = 0;
  }
  iVar12 = (int)*(short *)(param_2 + 0x3d4);
  if (iVar12 < 0) {
    iVar12 = -iVar12;
  }
  if (0x32 < iVar12) {
    *(undefined2 *)(param_2 + 0x3d8) = 0;
  }
  if (*(short *)(param_2 + 0x3d8) == 0) {
    *(undefined2 *)(param_2 + 0x3d6) = 10;
    if (0 < *(short *)(param_2 + 0x3d4)) {
      *(undefined2 *)(param_2 + 0x3d6) = 0xfff6;
    }
    iVar12 = (int)*(short *)(param_2 + 0x3d6);
    if (iVar12 < 0) {
      iVar12 = -iVar12;
    }

	// Interpolate rotation by speed
    sVar5 = FUN_80058f54((int)*(short *)(param_2 + 0x3d4),iVar12,0);
  }
  else {
    *(short *)(param_2 + 0x3d8) = *(short *)(param_2 + 0x3d8) + -1;
    sVar5 = *(short *)(param_2 + 0x3d4) + *(short *)(param_2 + 0x3d6);
  }
  *(short *)(param_2 + 0x3d4) = sVar5;
  puVar4 = PTR_DAT_8008d2ac;
  *(undefined2 *)(param_2 + 0xc0) = (short)(iVar9 + iVar13);
  *(ushort *)(param_2 + 0x39a) =
       *(short *)(param_2 + 0x39a) + (short)((iVar9 + iVar13) * *(int *)(puVar4 + 0x1d04) >> 0xd) &
       0xfff;
  
  if (*(short *)(param_2 + 0x582) != 0) 
  {  
	// decrease by elpased time
	iVar13 = (uint)*(ushort *)(param_2 + 0x582) - (uint)*(ushort *)(puVar4 + 0x1d04);
    *(undefined2 *)(param_2 + 0x582) = (short)iVar13;
    if (iVar13 * 0x10000 < 0) {
      *(undefined2 *)(param_2 + 0x582) = 0;
    }
															
    sVar5 = (short)((int)((uint)*(byte *)(param_2 + 0x47a) * 
				
				// elapsed milliseconds per frame, ~32
				*(int *)(PTR_DAT_8008d2ac + 0x1d04)) >> 5);
				
    if (*(short *)(param_2 + 0x3c6) < 0) {
      sVar5 = -sVar5;
    }
    *(ushort *)(param_2 + 0x396) = *(short *)(param_2 + 0x396) + sVar5 & 0xfff;
  }
  
  puVar4 = PTR_DAT_8008d2ac;
  *(short *)(param_2 + 0x2ee) =
       *(short *)(param_2 + 0x3d4) + *(short *)(param_2 + 0x39a) + *(short *)(param_2 + 0x3c6);

  // increment this by milliseconds
  sVar5 = *(short *)(param_2 + 0x584) + *(short *)(puVar4 + 0x1d04);
  *(short *)(param_2 + 0x584) = sVar5;

  if ((int)((uint)*(byte *)(param_2 + 0x462) << 5) < (int)sVar5) {
    *(short *)(param_2 + 0x584) = (ushort)*(byte *)(param_2 + 0x462) << 5;
  }

  // Rot_AxisAngle
  FUN_8005f89c((undefined4 *)(param_2 + 0x310),param_2 + 0x360,(int)*(short *)(param_2 + 0x39a));
  gte_SetRotMatrix((MATRIX *)(param_2 + 0x310));

  // CameraSlack_PhysAngular
  FUN_8005fb4c(param_2);
  return;
}


// VehPtr_Drifting_Finalize
void FUN_80063634(int param_1)

{
  *(undefined2 *)(param_1 + 0x3ea) = *(undefined2 *)(param_1 + 0x3da);
  *(short *)(param_1 + 0x3ec) = (ushort)*(byte *)(param_1 + 0x46b) << 5;
  return;
}


// VehPtr_Drifting_Update
// param1 = thread, param2 = driver
void FUN_8006364c(undefined4 param_1,int param_2)

{
  char cVar1;
  undefined2 uVar2;
  undefined4 uVar3;
  int iVar4;
  int iVar5;

  // If you do not press L1 or R1
  if ((*(uint *)(PTR_DAT_8008d2b0 + (uint)*(byte *)(param_2 + 0x4a) * 0x50 + 0x14) & 0xc00) == 0) {

	// If there is no room in the turbo meter left to fill
	if (*(short *)(param_2 + 0x3dc) == 0) {

	  // If you have not attempted to boost 3 times in a row
      if (*(char *)(param_2 + 0x586) < '\x03')
	  {
		// set turbo meter to empty
        *(short *)(param_2 + 0x3dc) = (ushort)*(byte *)(param_2 + 0x476) << 5;
      }
    }

	// If the turbo meter is not full
	else
	{
	  // decreaes the amoutn of room remaining, by elapsed milliseconds per frame, ~32
      iVar4 = (uint)*(ushort *)(param_2 + 0x3dc) - (uint)*(ushort *)(PTR_DAT_8008d2ac + 0x1d04);
      *(undefined2 *)(param_2 + 0x3dc) = (short)iVar4;

	  // if the bar goes beyond full
      if (iVar4 * 0x10000 < 0)
	  {
		// set bar to full
        *(undefined2 *)(param_2 + 0x3dc) = 0;
      }

	  // If bar is full
      if (*(short *)(param_2 + 0x3dc) == 0)
	  {
		// Make a sound
        FUN_80028494(0xf,1,(uint)*(ushort *)(param_2 + 0x2ca) & 1);

		// Add to your number of boost attempts, this makes it
		// so you can't attempt to boost again until you release L1 + R1
        *(char *)(param_2 + 0x586) = *(char *)(param_2 + 0x586) + '\x03';
      }
    }
  }

  // If you do press L1 or R1
  else {

	// Get P1's turbo meter
	// This is the distance remaining that can be filled
    iVar4 = (int)*(short *)(param_2 + 0x3dc);

	// Set drift timer to zero, start the drift
    *(undefined2 *)(param_2 + 0x580) = 0;

	// If turbo meter is not empty
	if (iVar4 != 0) {

	  // const_turboLowRoomWarning
	  // get length where turbo turns from green to red
      iVar5 = (uint)*(byte *)(param_2 + 0x477) << 5;

	  // If distance remaining to be filled in turbo bar, is less than,
	  // the distance remaining from the red/green "turning point" to the end,

	  // If meter is in the red
	  if (iVar4 < iVar5)
	  {
		// reserves_gain = map from old range to new range,
		// the more room remaining to fill, the less boost you get
		// old minMax: [zero -> const_turboLowRoomWarning]
		// new minMax: [const_turboFullBarReserveGain, -> zero]
        uVar3 = FUN_80058f9c(iVar4,0,iVar5,(uint)*(byte *)(param_2 + 0x478) << 5,0);

		// Turbo_Increment
		FUN_8005abfc(

			// driver
			param_2,

			// amount of reserves
			uVar3,

			2,

			// fire level, bigger boost for attempt number (1,2, or 3)
			(int)*(char *)(param_2 + 0x587) << 6);


		// increase the counter for number of times you've boosted in a row (0-3)
		cVar1 = *(char *)(param_2 + 0x587) + '\x01';
        *(char *)(param_2 + 0x587) = cVar1;

		// if you've boosted less than 3 times in a row
        if (cVar1 < '\x03')
		{
			// give a chance to boost again
          *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) | 0x80;
        }

		// drift boost meter = constant
        *(short *)(param_2 + 0x582) = (ushort)*(byte *)(param_2 + 0x479) << 5;
      }

	  // If meter is in the green
      else
	  {
		  // reset meter to beginning
        *(undefined *)(param_2 + 0x381) = 8;
      }

      *(undefined2 *)(param_2 + 0x3dc) = 0;

	  // increase number of boost attempts (both success and failure)
      *(char *)(param_2 + 0x586) = *(char *)(param_2 + 0x586) + '\x01';
    }
  }

  // 1.0 seconds
  uVar2 = 0x3c0;

  if (
		// If the "spin-out" constant is less than your drift counter
		((int)(uint)*(byte *)(param_2 + 0x463) < (int)*(short *)(param_2 + 0x580)) ||

		(
			(
				*(short *)(param_2 + 0x38e) < 0 &&
				(
					// 2.0 seconds
					uVar2 = 0x780,

					// if you're not on any turbo pad
					(*(uint *)(param_2 + 0xbc) & 3) == 0
				)
			)
		)
	 )
  {
	// Make the character spin out from too much drifting

	// Set amount of NoInput
    *(undefined2 *)(param_2 + 0x400) = uVar2;

	// VehPtr_Spinning_Init
    FUN_80063ec0(param_1,param_2);
  }

  // if you aren't spinning out
  else {

    if (
			// If your drift counter is less than the constant that makes you "spin out" from too much drift
			((int)*(short *)(param_2 + 0x580) < (int)-(uint)*(byte *)(param_2 + 0x463)) ||

			((
				// speed is less than half the driver's speed classStat
				((int)*(short *)(param_2 + 0x38c) < (int)((uint)*(ushort *)(param_2 + 0x42c) << 0x10) >> 0x11 ||
				
				((*(uint *)(param_2 + 0x2c8) & 0x2028) != 0)) ||

				// If the gamepad input is...
				((*(uint *)(PTR_DAT_8008d2b0 + (uint)*(byte *)(param_2 + 0x4a) * 0x50 + 0x10) &

				// does not include the jump button that you used to start drifting
				(int)*(short *)(param_2 + 0x382)) == 0)
			))
		)
	{
	  // Stop drifting, just drive

	  // VehPtr_Drifting_Finalize
      FUN_80063634(param_2);

	  // VehPtr_Driving_Init
      FUN_80062b74(param_1,param_2);
    }
  }
  return;
}


// VehPtr_Drifting_PhysLinear
void FUN_800638d4(undefined4 param_1,int param_2)

{
  undefined *puVar1;

  // VehPtr_Driving_PhysLinear
  FUN_8006181c();

  puVar1 = PTR_DAT_8008d2ac;

  // driver is drifting (0x1000)
  // driver is skidding (0x800)
  *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) | 0x1800;

  // drift timer += elapsed time
  *(int *)(param_2 + 0x538) = *(int *)(param_2 + 0x538) + *(int *)(puVar1 + 0x1d04);
  return;
}

// VehPtr_Drifting_InitSetUpdate
// param1 = thread, param2 = driver
void FUN_80063920(undefined4 param_1,int param_2)
{
  // This is so the update function
  // is not called on the first frame,
  // just like spinning

  *(undefined4 *)(param_2 + 0x54) = 0;

  // VehPtr_Drifting_Update
  *(undefined4 *)(param_2 + 0x58) = 0x8006364c;
  return;
}

// VehPtr_Drifting_Init
// param1 = thread, param2 = driver
void FUN_80063934(undefined4 param_1,int param_2)
//seems to handle start of drifts
{
  short sVar1;
  
  //kart is drifting
  *(undefined *)(param_2 + 0x376) = 2;
  
  //sVar1 = Character's Drift stat + ((Turning multiplier? << 2) / 5)
  sVar1 = (short)*(char *)(param_2 + 0x460) + (short)(((int)*(char *)(param_2 + 0x34) << 2) / 5);
  
  //Multiplied drift = sVar1 * 100
  *(short *)(param_2 + 0x3da) = sVar1 * 0x100;
  
  //if simplified turning state is negative (means you're turning right)
  if (*(char *)(param_2 + 0x4b) < '\0') 
  {
    //also make Multiplied drift negative
    *(short *)(param_2 + 0x3da) = sVar1 * -0x100;
  }

  // VehPtr_Drifting_InitSetUpdate
  *(undefined4 *)(param_2 + 0x54) = 0x80063920;

  // VehPtr_Drifting_PhysLinear
  *(undefined4 *)(param_2 + 0x5c) = 0x800638d4;

  *(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
  *(undefined4 *)(param_2 + 100) = 0x80062f4c; // OnPhysAngular
  *(undefined4 *)(param_2 + 0x68) = 0x8005ea60; // OnApplyForces
  *(undefined4 *)(param_2 + 0x6c) = 0x80020410; // OnCollide_QuadblockTouch
  *(undefined4 *)(param_2 + 0x70) = 0x8005ebac; // OnCollide_Drivers
  *(undefined4 *)(param_2 + 0x74) = 0x8001d944; // OnCollide_QuadblockNear
  *(undefined4 *)(param_2 + 0x78) = 0x80060630; // JumpAndFriction
  *(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix
  *(undefined4 *)(param_2 + 0x80) = 0x8005b178; // OnAnimate_Driving

  // erase union in driver struct
  *(undefined2 *)(param_2 + 0x580) = 0;
  *(undefined2 *)(param_2 + 0x584) = 0;
  *(undefined2 *)(param_2 + 0x582) = 0;
  *(undefined *)(param_2 + 0x586) = 0;
  *(undefined *)(param_2 + 0x587) = 0;
  
  *(undefined2 *)(param_2 + 0x3b4) = 0;
  *(undefined2 *)(param_2 + 0x3d2) = 0;
  *(undefined2 *)(param_2 + 0x3ec) = 0;
  *(undefined4 *)(param_2 + 0x58) = 0;

  // VehParticle_DriverMain
  *(undefined4 *)(param_2 + 0x84) = 0x80059a18;

  //Turbo meter space left to fill = Length of Turbo meter << 5
  *(short *)(param_2 + 0x3dc) = (ushort)*(byte *)(param_2 + 0x476) << 5;
  return;
}

// VehPtr_Crashing_PhysAngular
// param1 = thread, param2 = driver
void FUN_80063a44(undefined4 param_1,int param_2)
{
  undefined *puVar1;
  ushort uVar2;
  undefined2 uVar3;

  puVar1 = PTR_DAT_8008d2ac;

  // increase spin by (lastFrameSpinRate * elapsedTime)
  uVar2 = *(short *)(param_2 + 0x39a) +				// elapsed milliseconds per frame, ~32
          (short)((int)*(short *)(param_2 + 0xc0) * *(int *)(PTR_DAT_8008d2ac + 0x1d04) >> 0xd) &
          0xfff;
		  
  *(ushort *)(param_2 + 0x39a) = uVar2;
  
  // cameraRotY = spinRate + kart angle + drift angle,
  // spin rate is added so you're one frame ahead
  *(short *)(param_2 + 0x2ee) = *(short *)(param_2 + 0x3d4) + uVar2 + *(short *)(param_2 + 0x3c6);

  // Interpolate rotation by speed
  uVar3 = FUN_80058f54((int)*(short *)(param_2 + 0x2f2),(*(int *)(puVar1 + 0x1d04) << 5) >> 5,0);
  
  puVar1 = PTR_DAT_8008d2ac;

  // set camera rotation angle around player
  *(undefined2 *)(param_2 + 0x2f2) = uVar3;

  // Interpolate rotation by speed
  uVar3 = FUN_80058f54((int)*(short *)(param_2 + 0x3c6),(*(int *)(puVar1 + 0x1d04) << 7) >> 5,0);
  *(undefined2 *)(param_2 + 0x3c6) = uVar3;

  // Rot_AxisAngle
  FUN_8005f89c(param_2 + 0x310,param_2 + 0x360,(int)*(short *)(param_2 + 0x39a));
  return;
}

// VehPtr_Crashing_Update
void FUN_80063af8(void)

{
  return;
}

// VehPtr_Crashing_PhysLinear
// param1 = thread, param2 = driver
void FUN_80063b00(undefined4 param_1,int param_2)

{
  // VehPtr_Driving_PhysLinear
  FUN_8006181c();

  // reset two speed variables
  *(undefined2 *)(param_2 + 0x39c) = 0;
  *(undefined2 *)(param_2 + 0x39e) = 0;

  return;
}

// VehPtr_Crashing_Animate
// param1 = thread, param2 = driver
void FUN_80063b2c(int param_1,int param_2)

{
  short sVar1;
  undefined2 uVar2;
  int iVar3;
  int iVar4;

  // get instance from thread
  iVar4 = *(int *)(param_1 + 0x34);

  // increase animation frame
  *(short *)(iVar4 + 0x54) = *(short *)(iVar4 + 0x54) + 1;

  *(char *)(param_2 + 0x4d) = *(char *)(param_2 + 0x4d) + '\x01';

  // get animation frame
  sVar1 = *(short *)(iVar4 + 0x54);

  // get number of frames in animation
  iVar3 = FUN_8005b0f4(iVar4,(uint)*(byte *)(iVar4 + 0x52));

  // if animation is finished
  if (iVar3 + -1 <= (int)sVar1)
  {
	// get number of frames in anim #0
    iVar3 = FUN_8005b0f4(iVar4,0);

	// if it has frames
    if (0 < iVar3)
	{
	  // reset animation
      *(undefined *)(iVar4 + 0x52) = 0;

	  // Instance_GetStartFrame(midpoint, numFrames)
      uVar2 = FUN_8005b0c4(0,iVar3);

	  // set animation
      *(undefined2 *)(iVar4 + 0x54) = uVar2;

      *(undefined *)(param_2 + 0x4c) = 0;
      *(undefined *)(param_2 + 0x4d) = 0;
    }

	// VehPtr_Driving_Init
    *(undefined4 *)(param_2 + 0x54) = 0x80062b74;
  }
  return;
}


// VehPtr_Crashing_Init
// param1 = thread, param2 = driver
void FUN_80063bd4(int param_1,int param_2)

{
  int iVar1;

  // get instance from thread
  iVar1 = *(int *)(param_1 + 0x34);

  // Set state to crashing
  *(undefined *)(param_2 + 0x376) = 1;

  *(undefined2 *)(param_2 + 0x3e6) = 10000;
  *(undefined2 *)(param_2 + 0x3dc) = 0;
  *(undefined2 *)(param_2 + 0x3b4) = 0;
  *(undefined2 *)(param_2 + 0x3d2) = 0;
  *(undefined2 *)(param_2 + 0x3d4) = 0;
  *(undefined2 *)(param_2 + 0x3d6) = 0;
  *(undefined2 *)(param_2 + 0x3d8) = 0;
  *(undefined2 *)(param_2 + 0xc0) = 0;
  *(undefined2 *)(param_2 + 0x38c) = 0;
  *(undefined2 *)(param_2 + 0x38e) = 0;
  *(undefined4 *)(param_2 + 0x3a0) = 0;
  *(undefined4 *)(param_2 + 0x3a4) = 0;
  *(undefined4 *)(param_2 + 0x3a8) = 0;
  *(undefined4 *)(param_2 + 0x88) = 0;
  *(undefined4 *)(param_2 + 0x8c) = 0;
  *(undefined4 *)(param_2 + 0x90) = 0;
  *(undefined2 *)(param_2 + 0x36e) = 0;
  *(undefined2 *)(param_2 + 0x3e2) = 0;
  *(undefined2 *)(param_2 + 0x3de) = 0;
  *(undefined2 *)(param_2 + 0x3e0) = 0;
  *(undefined *)(param_2 + 0x377) = 0;
  *(undefined2 *)(param_2 + 0x3ee) = 0;
  *(undefined2 *)(param_2 + 0x40e) = 0;
  *(undefined2 *)(param_2 + 0x410) = 0;
  *(undefined2 *)(param_2 + 0x40c) = 0;
  *(undefined2 *)(param_2 + 0x39c) = 0;
  *(undefined2 *)(param_2 + 0x39e) = 0;

  // Set driver scale
  *(undefined2 *)(iVar1 + 0x1e) = 0xccc;
  *(undefined2 *)(iVar1 + 0x1c) = 0xccc;

  // VehPtr_Crashing_Update
  *(undefined4 *)(param_2 + 0x58) = 0x80063af8;

  // OnInit
  *(undefined4 *)(param_2 + 0x54) = 0;

  // VehPtr_Crashing_PhysLinear
  *(undefined4 *)(param_2 + 0x5c) = 0x80063b00;

  *(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
  *(undefined4 *)(param_2 + 100) = 0x80063a44; // OnPhysAngular
  *(undefined4 *)(param_2 + 0x68) = 0x8005ea60; // OnApplyForces
  *(undefined4 *)(param_2 + 0x6c) = 0x80020410; // OnCollide_QuadblockTouch
  *(undefined4 *)(param_2 + 0x70) = 0x8005ebac; // OnCollide_Drivers
  *(undefined4 *)(param_2 + 0x74) = 0x8001d944; // OnCollide_QuadblockNear
  *(undefined4 *)(param_2 + 0x78) = 0x80060630; // JumpAndFriction
  *(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix

  // VehPtr_Crashing_Animate
  *(undefined4 *)(param_2 + 0x80) = 0x80063b2c;


  // VehParticle_DriverMain
  *(undefined4 *)(param_2 + 0x84) = 0x80059a18;

  return;
}


// VehPtr_Spinning_Update
// param1 = thread, param2 = driver
void FUN_80063cf4(undefined4 param_1,int param_2)

{
  int iVar1;

  // If you are not done spinning out
  if (*(short *)(param_2 + 0x400) != 0)
  {
	// Get approximate speed
    iVar1 = (int)*(short *)(param_2 + 0x38e);

	// If your speed somehow goes negative
    if (iVar1 < 0)
	{
	  // Make it positive
      iVar1 = -iVar1;
    }

	// If you have not slown down from spinning
    if (0x2ff < iVar1)
	{
	  // End the function
      return;
    }
  }

  // If you have slown down enough

  // VehPtr_LastSpin_Init
  FUN_80064254(param_1, param_2);
  return;
}

// VehPtr_Spinning_PhysLinear
// param1 = thread, param2 = driver
void FUN_80063d44(undefined4 param_1,int param_2)

{
  undefined *puVar1;
  int iVar2;

  // NoInput timer = NoInput timer  -  elapsed milliseconds per frame, ~32
  iVar2 = (uint)*(ushort *)(param_2 + 0x400) - (uint)*(ushort *)(PTR_DAT_8008d2ac + 0x1d04);
  *(undefined2 *)(param_2 + 0x400) = (short)iVar2;

  // If timer is less than zero
  if (iVar2 * 0x10000 < 0)
  {
	// Set to zero
    *(undefined2 *)(param_2 + 0x400) = 0;
  }

  // VehPtr_Driving_PhysLinear
  FUN_8006181c(param_1,param_2);

  puVar1 = PTR_DAT_8008d2ac;

  // reset two speed variables
  *(undefined2 *)(param_2 + 0x39c) = 0;
  *(undefined2 *)(param_2 + 0x39e) = 0;

  // Driver flags
  *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) | 0x5808;

  // Increment amount of time spent spinning out
  *(int *)(param_2 + 0x540) = *(int *)(param_2 + 0x540) + *(int *)(puVar1 + 0x1d04);

  return;
}


// VehPtr_Spinning_PhysAngular
// param1 = thread, param2 = driver
void FUN_80063dc8(undefined4 param_1,int param_2)

{
  undefined *puVar1;
  ushort uVar2;
  undefined2 uVar3;

  *(undefined2 *)(param_2 + 0x3e6) = 10000;
  
  // decrease turn rate by 1/8 of itself
  *(short *)(param_2 + 0x3b4) = *(short *)(param_2 + 0x3b4) - (*(short *)(param_2 + 0x3b4) >> 3);
  
  puVar1 = PTR_DAT_8008d2ac;

  // Drift angle = (Drift angle + spinRate + 180 degrees) & 0xfff - 180 degrees
  *(short *)(param_2 + 0x3c6) =
       (*(short *)(param_2 + 0x3c6) + *(short *)(param_2 + 0x580) + 0x800U & 0xfff) - 0x800;

  *(short *)(param_2 + 0xc0) = *(short *)(param_2 + 0x3b4);
  *(short *)(param_2 + 0x3d4) = *(short *)(param_2 + 0x3d4) - (*(short *)(param_2 + 0x3d4) >> 3);

  // kart angle = (kart angle + (rotationSpinRate * time lapsed between frames)) & 0xFFF
  uVar2 = *(short *)(param_2 + 0x39a) +
          (short)((int)*(short *)(param_2 + 0x3b4) * *(int *)(puVar1 + 0x1d04) >> 0xd) & 0xfff;
  *(ushort *)(param_2 + 0x39a) = uVar2;
  
  // cameraRotY = ??? + kart angle + drift angle
  *(short *)(param_2 + 0x2ee) = *(short *)(param_2 + 0x3d4) + uVar2 + *(short *)(param_2 + 0x3c6);

  // Interpolate rotation by speed
  uVar3 = FUN_80058f54((int)*(short *)(param_2 + 0x2f2),(*(int *)(puVar1 + 0x1d04) << 5) >> 5,0);

  // set new rotation around player
  *(undefined2 *)(param_2 + 0x2f2) = uVar3;

  // Rot_AxisAngle
  FUN_8005f89c(param_2 + 0x310,param_2 + 0x360,(int)*(short *)(param_2 + 0x39a));
  return;
}

// VehPtr_Spinning_InitSetUpdate
// param1 = thread, param2 = driver
void FUN_80063eac(undefined4 param_1,int param_2)

{
  // This delays setting the
  // update function, by one frame

  // OnInit
  *(undefined4 *)(param_2 + 0x54) = 0;

  // VehPtr_Spinning_Update
  *(undefined4 *)(param_2 + 0x58) = 0x80063cf4;
  return;
}

// VehPtr_Spinning_Init
// param1 = thread, param2 = driver
void FUN_80063ec0(undefined4 param_1,int param_2)

{
  int iVar1;
  undefined4 uVar2;

  // Kart is now spinning out
  *(undefined *)(param_2 + 0x376) = 3;

  *(undefined2 *)(param_2 + 0x3d2) = 0;
  *(undefined2 *)(param_2 + 0x3dc) = 0;

  // Check if 231 dll is loaded
  iVar1 = FUN_800348e8();

  if (
		// if it is loaded
		(iVar1 != 0) &&

		// If you're not in Adventure Arena
		((*(uint *)PTR_DAT_8008d2ac & 0x100000) == 0)
	 )
  {
	// RB_Player_ModifyWumpa, -1
    FUN_800abefc(param_2,0xffffffff);
  }

  // Make driver talk
  FUN_8002cbe8(3,(int)(short)(&DAT_80086e84)[*(byte *)(param_2 + 0x4a)],0x10);

  // spin left
  *(undefined2 *)(param_2 + 0x582) = 1;

  // spin rate = 300
  *(undefined2 *)(param_2 + 0x580) = 300;

  // if you're spinning to the right
  if (*(short *)(param_2 + 0xc0) < 0)
  {
	// spin rate = -300
    *(undefined2 *)(param_2 + 0x580) = 0xfed4;
	
	// spin right (-1)
    *(undefined2 *)(param_2 + 0x582) = 0xffff;
  }

  // Set function pointers for spinning out
  *(undefined4 *)(param_2 + 0x54) = 0x80063eac // VehPtr_Spinning_InitSetUpdate
  *(undefined4 *)(param_2 + 0x5c) = 0x80063d44; // VehPtr_Spinning_PhysLinear
  *(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
  *(undefined4 *)(param_2 + 100) = 0x80063dc8;
  *(undefined4 *)(param_2 + 0x68) = 0x8005ea60; // OnApplyForces
  *(undefined4 *)(param_2 + 0x6c) = 0x80020410; // OnCollide_QuadblockTouch
  *(undefined4 *)(param_2 + 0x70) = 0x8005ebac; // OnCollide_Drivers
  *(undefined4 *)(param_2 + 0x74) = 0x8001d944; // OnCollide_QuadblockNear
  *(undefined4 *)(param_2 + 0x78) = 0x80060630; // JumpAndFriction
  *(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix

  // OnAnimate_Spinning
  *(undefined4 *)(param_2 + 0x80) = 0x8005b510;

  *(undefined4 *)(param_2 + 0x58) = 0;

  // VehParticle_DriverMain
  *(undefined4 *)(param_2 + 0x84) = 0x80059a18;

  if (*(char *)(param_2 + 0x4b) < '\x01') {
    uVar2 = 0x19;
  }
  else {
    uVar2 = 0x29;
  }

  // gamepad vibration
  FUN_800263a0(param_2,uVar2,0x60);

  return;
}


// VehPtr_LastSpin_Update
// param1 = thread, param2 = driver
void FUN_8006402c(undefined4 param_1,int param_2)
{
  // Transition from spinning to driving

  int iVar1;

  // Get Drift Angle
  iVar1 = (int)*(short *)(param_2 + 0x3c6);

  // Get absolute value
  if (iVar1 < 0) {
    iVar1 = -iVar1;
  }

  // If you're almost fully facing forward
  if (iVar1 < 0x10)
  {
	// Change all funcPtrs to transition
	// from LastSpin to Driving
	// VehPtr_StopSpin_Init
    FUN_800644d0(param_1, param_2);
  }
  return;
}

// VehPtr_LastSpin_PhysLinear
// param1 = thread, param2 = driver
void FUN_8006406c(undefined4 param_1,int param_2)

{
  // VehPtr_Driving_PhysLinear
  FUN_8006181c();

  // reset two speed variables
  *(undefined2 *)(param_2 + 0x39c) = 0;
  *(undefined2 *)(param_2 + 0x39e) = 0;

  *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) | 0x4008;
  return;
}

// VehPtr_LastSpin_PhysAngular
// param1 = thread, param2 = driver
void FUN_800640a4(undefined4 param_1,int param_2)

{
  undefined *puVar1;
  ushort uVar2;
  undefined2 uVar3;
  short sVar4;
  int iVar5;

  // Get drifting angle
  iVar5 = (int)*(short *)(param_2 + 0x3c6);

  // Set drift angle (temporarily)
  *(undefined2 *)(param_2 + 0x3e6) = 10000;

  // decrease rotationSpinRate by 1/8 of itself
  sVar4 = *(short *)(param_2 + 0x3b4) - (*(short *)(param_2 + 0x3b4) >> 3);
  *(short *)(param_2 + 0x3b4) = sVar4;
  
  // decrease [what]?
  *(short *)(param_2 + 0x3d4) = *(short *)(param_2 + 0x3d4) - (*(short *)(param_2 + 0x3d4) >> 3);
  
  *(short *)(param_2 + 0xc0) = sVar4;
  
  if (iVar5 < 1) 
  {
	// drifting right,
	// spinning out clockwise
    if (iVar5 < 0) 
	{
      if (
			(
				// if spinning hasn't stopped
				(0 < *(short *)(param_2 + 0x580)) && 
				(-400 < iVar5)
			) &&
			(
				// decrease spin rate
				iVar5 = iVar5 * -4 >> 3, 
				*(undefined2 *)(param_2 + 0x580) = (short)iVar5, 
				
				// if spin rate is too low
				iVar5 < 0x20
			)
		  ) 
	  {
		// set minimum spin rate if drops below minimum
        *(undefined2 *)(param_2 + 0x580) = 0x20;
      }

	  // Drift angle = (drift angle + spin rate + 180 degrees) & 0xfff - 180 degrees
      uVar2 = (*(short *)(param_2 + 0x3c6) + *(short *)(param_2 + 0x580) + 0x800U & 0xfff) - 0x800;
	  *(ushort *)(param_2 + 0x3c6) = uVar2;

	  // if you're almost facing forward while spinning at a slow rate
      if ((0 < *(short *)(param_2 + 0x580)) && (0 < (int)((uint)uVar2 << 0x10))) 
	  {
		// reset drift angle (but still spin until StopSpin)
        *(undefined2 *)(param_2 + 0x3c6) = 0;
      }
    }
  }
  
  // spinning the other way
  else 
  {
    if (
			(
				// if spinning hasn't stopped
				(*(short *)(param_2 + 0x580) < 0) && 
				(iVar5 < 400)
			) &&
       
			(
				// decrease spin rate
				iVar5 = iVar5 * -4 >> 3, 
				*(undefined2 *)(param_2 + 0x580) = (short)iVar5,
				
				// if spin rate is too low
				-0x20 < iVar5
			)
		) 
	{
	  // set minimum spin rate if drops below minimum (-0x20)
      *(undefined2 *)(param_2 + 0x580) = 0xffe0;
    }
	
	// Drift angle = (drift angle + spin rate + 180 degrees) & 0xfff - 180 degrees
    uVar2 = (*(short *)(param_2 + 0x3c6) + *(short *)(param_2 + 0x580) + 0x800U & 0xfff) - 0x800;
    *(ushort *)(param_2 + 0x3c6) = uVar2;
	
	// if you're almost facing forward while spinning at a slow rate
    if ((*(short *)(param_2 + 0x580) < 0) && ((int)((uint)uVar2 << 0x10) < 0)) 
	{
		// reset drift angle (but still spin until StopSpin)
      *(undefined2 *)(param_2 + 0x3c6) = 0;
    }
  }
  
  puVar1 = PTR_DAT_8008d2ac;
  
  // kart angle = (kart angle + 
  uVar2 = *(short *)(param_2 + 0x39a) +
			(short)
			(
				// ampTurnState
				(int)*(short *)(param_2 + 0xc0) * 
				
				// elapsed milliseconds per frame, ~32
			*(int *)(PTR_DAT_8008d2ac + 0x1d04) >> 0xd
			
			// clamp to [0x000-0xfff]
			) & 0xfff;

  // save
  *(ushort *)(param_2 + 0x39a) = uVar2;
  
  // cameraRotY = ??? + kart angle + drift angle
  *(short *)(param_2 + 0x2ee) = *(short *)(param_2 + 0x3d4) + uVar2 + *(short *)(param_2 + 0x3c6);

  // Interpolate rotation by speed
  uVar3 = FUN_80058f54((int)*(short *)(param_2 + 0x2f2),(*(int *)(puVar1 + 0x1d04) << 5) >> 5,0);

  // set new camera rotation around player
  *(undefined2 *)(param_2 + 0x2f2) = uVar3;

  // Rot_AxisAngle
  FUN_8005f89c(param_2 + 0x310,param_2 + 0x360,(int)*(short *)(param_2 + 0x39a));
  return;
}


// param1 = thread, param2 = driver
// VehPtr_LastSpin_Init
void FUN_80064254(undefined4 param_1,int param_2)
{
	// Transition out of spinning

  // VehPtr_LastSpin_Update
  *(undefined4 *)(param_2 + 0x58) = 0x8006402c;

  // VehPtr_LastSpin_PhysLinear
  *(undefined4 *)(param_2 + 0x5c) = 0x8006406c;

  *(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
  *(undefined4 *)(param_2 + 100) = 0x800640a4; // OnPhysAngular
  *(undefined4 *)(param_2 + 0x68) = 0x8005ea60; // OnApplyForces
  *(undefined4 *)(param_2 + 0x6c) = 0x80020410; // OnCollide_QuadblockTouch
  *(undefined4 *)(param_2 + 0x70) = 0x8005ebac; // OnCollide_Drivers
  *(undefined4 *)(param_2 + 0x74) = 0x8001d944; // OnCollide_QuadblockNear
  *(undefined4 *)(param_2 + 0x78) = 0x80060630; // JumpAndFriction
  *(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix

  // OnAnimate_LastSpin
  *(undefined4 *)(param_2 + 0x80) = 0x8005b5fc;

  *(undefined4 *)(param_2 + 0x54) = 0;

  // VehParticle_DriverMain
  *(undefined4 *)(param_2 + 0x84) = 0x80059a18;

  return;
}

// VehPtr_StopSpin_Update
void FUN_800642ec(void)
{
  return;
}

// VehPtr_StopSpin_PhysLinear
// param1 = thread, param2 = driver
void FUN_800642f4(undefined4 param_1,int param_2)
{
  // VehPtr_Driving_PhysLinear
  FUN_8006181c();

  // reset two speed variables
  *(undefined2 *)(param_2 + 0x39c) = 0;
  *(undefined2 *)(param_2 + 0x39e) = 0;

  return;
}

// VehPtr_StopSpin_PhysAngular
// param1 = thread, param2 = driver
void FUN_80064320(undefined4 param_1,int param_2)
{
  undefined *puVar1;
  ushort uVar2;
  undefined2 uVar3;

  puVar1 = PTR_DAT_8008d2ac;

  // increase spin by (lastFrameSpinRate * elapsedTime)
  uVar2 = *(short *)(param_2 + 0x39a) +
          (short)((int)*(short *)(param_2 + 0xc0) * *(int *)(PTR_DAT_8008d2ac + 0x1d04) >> 0xd) &
          0xfff;

  *(ushort *)(param_2 + 0x39a) = uVar2;
  
  // cameraRotY = spinRate + kart angle + drift angle,
  // spin rate is added so you're one frame ahead
  *(short *)(param_2 + 0x2ee) = *(short *)(param_2 + 0x3d4) + uVar2 + *(short *)(param_2 + 0x3c6);

  // Interpolate rotation by speed
  uVar3 = FUN_80058f54((int)*(short *)(param_2 + 0x2f2),(*(int *)(puVar1 + 0x1d04) << 5) >> 5,0);

  puVar1 = PTR_DAT_8008d2ac;

  // set new camera rotation around player
  *(undefined2 *)(param_2 + 0x2f2) = uVar3;

  // Interpolate rotation by speed
  uVar3 = FUN_80058f54((int)*(short *)(param_2 + 0x3c6),(*(int *)(puVar1 + 0x1d04) << 7) >> 5,0);
  *(undefined2 *)(param_2 + 0x3c6) = uVar3;

  // Rot_AxisAngle
  FUN_8005f89c(param_2 + 0x310,param_2 + 0x360,(int)*(short *)(param_2 + 0x39a));
  return;
}


// param1 = thread, param2 = driver
// VehPtr_StopSpin_Animate
void FUN_800643d4(int param_1,int param_2)

{
  ushort uVar1;
  short sVar2;
  int iVar3;
  int iVar4;

  // get instance from thread
  iVar4 = *(int *)(param_1 + 0x34);

  // get number of frames in animation
  iVar3 = FUN_8005b0f4(iVar4,(uint)*(byte *)(iVar4 + 0x52));

  // if there are frames
  if (0 < iVar3)
  {
	// if you are spinning right
    if (*(short *)(param_2 + 0x582) == -1) 
	{
	  // steer from left to right, to exaggerate
	  // the force when steering stops abruptly
      sVar2 = *(short *)(iVar4 + 0x54) + 5;
      *(short *)(iVar4 + 0x54) = sVar2;
	  
	  // if not finished, quit function
      if (sVar2 < iVar3) {
        return;
      }
	  
	  // last frame
      *(short *)(iVar4 + 0x54) = (short)iVar3 + -1;
      
	  // no spinDir anymore
	  *(undefined2 *)(param_2 + 0x582) = 0;
      
	  return;
    }

	// if you are spinning left
    if (*(short *)(param_2 + 0x582) == 1) 
	{
	  // steer from right to left, to exaggerate
	  // the force when steering stops abruptly
      uVar1 = *(short *)(iVar4 + 0x54) - 5;
      *(ushort *)(iVar4 + 0x54) = uVar1;
	  
	  // if not finished, quit function
      if (-1 < (int)((uint)uVar1 << 0x10)) {
        return;
      }
	  
	  // first frame
      *(undefined2 *)(iVar4 + 0x54) = 0;
	  
	  // no spinDir anymore
      *(undefined2 *)(param_2 + 0x582) = 0;
	  
      return;
    }

	// === spinning has stopped ===
	
	// return driver to center steering 
	// animation frame

	// Instance_GetStartFrame(midpoint, numFrames)
    iVar3 = FUN_8005b0c4(0,iVar3);

	// Interpolate rotation by speed
    sVar2 = FUN_80058f54((int)*(short *)(iVar4 + 0x54),2,iVar3);

	// set animation frame
    *(short *)(iVar4 + 0x54) = sVar2;

	// if you are not facing forward
    if ((int)sVar2 != iVar3)
	{
	  // keep spinning till you face forward
      return;
    }
  }

  // if you are facing forward

  // VehPtr_Driving_Init
  *(undefined4 *)(param_2 + 0x54) = 0x80062b74;
  return;
}

// param1 = thread, param2 = driver
// VehPtr_StopSpin_Init
void FUN_800644d0(undefined4 param_1,int param_2)

{
  // Transition from
  // LastSpin to Driving

  // VehPtr_StopSpin_Update,
  // "updating" happens in OnAnimate
  *(undefined4 *)(param_2 + 0x58) = 0x800642ec;

  // VehPtr_StopSpin_PhysLinear
  *(undefined4 *)(param_2 + 0x5c) = 0x800642f4;

  *(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
  *(undefined4 *)(param_2 + 100) = 0x80064320; // OnPhysAngular
  *(undefined4 *)(param_2 + 0x68) = 0x8005ea60; // OnApplyForces
  *(undefined4 *)(param_2 + 0x6c) = 0x80020410; // OnCollide_QuadblockTouch
  *(undefined4 *)(param_2 + 0x70) = 0x8005ebac; // OnCollide_Drivers
  *(undefined4 *)(param_2 + 0x74) = 0x8001d944; // OnCollide_QuadblockNear
  *(undefined4 *)(param_2 + 0x78) = 0x80060630; // JumpAndFriction
  *(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix

  // VehPtr_StopSpin_Animate, calls VehPtr_Driving_Init
  *(undefined4 *)(param_2 + 0x80) = 0x800643d4;

  *(undefined4 *)(param_2 + 0x54) = 0;

  // VehParticle_DriverMain
  *(undefined4 *)(param_2 + 0x84) = 0x80059a18;

  return;
}


// Player_ChangeState
// param1 - driverVictim
// param2 - damageType
// param3 - driverAttacker
// param4 - reason
undefined4 FUN_80064568(int param_1,int param_2,int param_3,undefined4 param_4)

{
  char cVar1;
  byte bVar2;
  undefined4 uVar3;
  undefined *puVar4;
  undefined4 in_zero;
  undefined4 in_at;
  undefined *puVar5;
  int iVar6;
  int iVar7;
  undefined4 local_30;
  uint local_2c;
  short local_28;
  short sStack38;

  // get kart state
  cVar1 = *(char *)(param_1 + 0x376);
  *(undefined *)(param_1 + 0x4ff) = 0;

  // if kart is being mask-grabbed
  if (cVar1 == '\x05') {
    return 0;
  }

  if (
		// If player is using mask weapon
		((*(uint *)(param_1 + 0x2c8) & 0x800000) != 0) ||

		// If player invincibility timer is active
		(*(int *)(param_1 + 0x24) != 0)
	 )
  {
	// Player / AI structure + 0x4a shows driver index (0-7)

	// which driver this is (0-7)
	bVar2 = *(byte *)(param_1 + 0x4a);

LAB_8006462c:

	// Theory
	// Play sound of character laughing because they
	// were hit by weapon while invincible, and therefore
	// they take no damage

	// Make driver talk
    FUN_8002cbe8(2,(int)(short)(&DAT_80086e84)[bVar2],0x10);
    return 0;
  }

  // if you have a shield weapon
  if (*(int *)(param_1 + 0x14) != 0)
  {
	// driver -> shield -> thread -> object
    iVar6 = *(int *)(*(int *)(*(int *)(param_1 + 0x14) + 0x6c) + 0x30);

    *(ushort *)(iVar6 + 6) = *(ushort *)(iVar6 + 6) | 1;

	// give invincibility
    *(undefined4 *)(param_1 + 0x24) = 0x2a0;

    bVar2 = *(byte *)(param_1 + 0x4a);

	// you no-longer have a shield
    *(undefined4 *)(param_1 + 0x14) = 0;

    goto LAB_8006462c;
  }

  // driving
  if (param_2 == 0) {
    return 1;
  }

  // driver -> instance -> thread
  iVar6 = *(int *)(*(int *)(param_1 + 0x1c) + 0x6c);

  // Squish
  if (param_2 == 3) {
    if (cVar1 != '\x03')
	{
	  // OtherFX_Play_Echo
	  // squish sound
      FUN_80028494(0x5a,1,*(uint *)(param_1 + 0x2c8) >> 0x10 & 1);

	  // Make driver talk
      FUN_8002cbe8(4,(int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)],0x10);
    }

	// squish the character, put them into squished
	// animation for 0xF00 amount of time (frames?)
    *(undefined2 *)(param_1 + 0x404) = 0xf00;

	// NoInput = 0.25s
    *(undefined2 *)(param_1 + 0x400) = 0xf0;
  }
  else {
    if (param_2 < 4) {

	  // Blast
      if (param_2 == 2) {

		// if kart is already being "blasted"
        if (cVar1 == '\x06') {
          return 0;
        }

		// if function pointer is already set to make the kart "blasted"
        if (*(code **)(param_1 + 0x54) == FUN_800682a4) {
          return 0;
        }

		// You are only here if the player is not being
		// blasted, but needs to be blasted after being hit

		// NoInput = 2.4 seconds
        *(undefined2 *)(param_1 + 0x400) = 0x960;

		// Player / AI structure + 0x4a shows driver index (0-7)


		// which driver this is (0-7)
        bVar2 = *(byte *)(param_1 + 0x4a);

		// Undo the "Squish" effect
		*(undefined2 *)(param_1 + 0x404) = 0;

		// VehPtr_Blasted_Init
        *(undefined4 *)(param_1 + 0x54) = 0x800682a4;

LAB_800646f0:

		// Make driver talk
		FUN_8002cbe8(1,(int)(short)(&DAT_80086e84)[bVar2],0x10);
        goto LAB_800647d8;
      }
    }
    else {

	  // Burn
      if (param_2 == 4) {

		// If player is not currently burned
        if (*(short *)(param_1 + 0x402) == 0)
		{
		  // OtherFX_Play "Just got Burned" sound
          FUN_80028468(0x69,1);

		  // Make driver talk
          FUN_8002cbe8(1,(int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)],0x10);
        }

		// Add to player's Burned timer
        *(undefined2 *)(param_1 + 0x402) = 0xf00;

		// NoInput set to 2.0 seconds
        *(undefined2 *)(param_1 + 0x400) = 0x780;

        goto LAB_800647c8;
      }

	  // mask grab
      if (param_2 == 5)
	  {
		// NoInput set to 3.36 seconds
        *(undefined2 *)(param_1 + 0x400) = 0xd20;

		// VehPtr_EatenByPlant_Init
        *(undefined4 *)(param_1 + 0x54) = 0x800677d0;

        bVar2 = *(byte *)(param_1 + 0x4a);
        goto LAB_800646f0;
      }
    }

	// NoInput set to 1.0 seconds
    *(undefined2 *)(param_1 + 0x400) = 0x3c0;

	// If you're spinning: if you hit a glass or spun out from drifting
    if (*(char *)(param_1 + 0x376) == '\x03') goto LAB_800647d8;
  }
LAB_800647c8:

  // VehPtr_Spinning_Init
  *(undefined4 *)(param_1 + 0x54) = 0x80063ec0;

LAB_800647d8:
  switch(param_4) {
  case 1:
  
	// number of times bomb hit you
    *(char *)(param_1 + 0x55e) = *(char *)(param_1 + 0x55e) + '\x01';
	
    if ((param_3 != 0) && (param_3 != param_1)) 
	{
      // number of times your bomb hit someone
	  *(char *)(param_3 + 0x55a) = *(char *)(param_3 + 0x55a) + '\x01';
      *(ushort *)(param_3 + 0x4f6) = *(ushort *)(param_3 + 0x4f6) | 1;
    }
    break;
	
  // hit by motionless potion
  case 2:
	// number of times motionless potion hit you
    *(char *)(param_1 + 0x55f) = *(char *)(param_1 + 0x55f) + '\x01';
    break;
  
  case 3:
    
	// number of times missile hit you
	*(char *)(param_1 + 0x55d) = *(char *)(param_1 + 0x55d) + '\x01';
    
	if ((param_3 != 0) && (param_3 != param_1)) {
      
	  // number of times you hit someone with missile
	  *(char *)(param_3 + 0x557) = *(char *)(param_3 + 0x557) + '\x01';
	  *(ushort *)(param_3 + 0x4f6) = *(ushort *)(param_3 + 0x4f6) | 2;
    }
    break;
	
  // hit by moving potion
  case 4:
    if ((param_3 != 0) && (param_3 != param_1)) 
	{
	  // number of times you hit someone with potion moving potion
      *(char *)(param_3 + 0x556) = *(char *)(param_3 + 0x556) + '\x01';
      *(ushort *)(param_3 + 0x4f6) = *(ushort *)(param_3 + 0x4f6) | 4;
    }
    break;
	
  // squished by other driver's turbo
  case 5:
    if ((param_3 != 0) && (param_3 != param_1)) 
	{
	  // number of times you squished someone
      *(char *)(param_3 + 0x55b) = *(char *)(param_3 + 0x55b) + '\x01';
    }
    break;
	
  // hit by a mask weapon
  case 6:
    if ((param_3 != 0) && (param_3 != param_1)) 
	{
	  // set flag to the driver that did the attacking with mask weapon
      *(ushort *)(param_3 + 0x4f6) = *(ushort *)(param_3 + 0x4f6) | 8;
    }
  }
  *(undefined *)(param_1 + 0x376) = 0;
  *(undefined2 *)(param_1 + 0x3e2) = 0;
  *(undefined2 *)(param_1 + 0x3de) = 0;
  *(undefined *)(param_1 + 0x4c) = 0;
  *(undefined *)(param_1 + 0x4d) = 0;

  // gamepad vibration
  FUN_80026440(param_1,8,0);
  FUN_800264c0(param_1,8,0x7f);

  puVar4 = PTR_DAT_8008d2ac;

  // If you're not in End-Of-Race menu
  if ((param_3 != 0) && ((*(uint *)PTR_DAT_8008d2ac & 0x200000) == 0))
  {
    local_30 = CONCAT22(*(undefined2 *)(*(int *)(param_3 + 0x1c) + 0x48),
                        *(undefined2 *)(*(int *)(param_3 + 0x1c) + 0x44));

    local_2c = local_2c & 0xffff0000 | (uint)*(ushort *)(*(int *)(param_3 + 0x1c) + 0x4c);

	// camera index depending on player
    puVar5 = PTR_DAT_8008d2ac + (uint)*(byte *)(param_3 + 0x4a) * 0x110;

	// tileView ViewProj
	gte_SetRotMatrix(puVar5 + 0x168 + 0x28);
	gte_SetTransMatrix(puVar5 + 0x168 + 0x28);
    
	// instance position on GTE
	setCopReg(2,in_zero,local_30);
    setCopReg(2,in_at,local_2c);

	// RTPS - Perspective Transformation (single)
	copFunction(2,0x180001);

	// get screenspace pos of driver
	uVar3 = getCopReg(2,0xe);
    local_28 = (short)uVar3;

	// set position of HUD element to position of driver (on screen)
	*(short *)(param_3 + 0x4d4) =
         local_28 + *(short *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_3 + 0x4a) * 0x110 + 0x184);
    sStack38 = (short)((uint)uVar3 >> 0x10);
    *(short *)(param_3 + 0x4d6) =
         sStack38 + *(short *)(puVar4 + (uint)*(byte *)(param_3 + 0x4a) * 0x110 + 0x186) + -0x14;

	// loop counter
	iVar7 = 0;

	// for iVar7 = 0; iVar7 < 1; iVar7++
    do
	{
	  // this only happens once

	  // RB_Player_KillPlayer
      FUN_800abbb4(param_3,param_1);

	  // If you're in End-Of-Race menu
      if ((*(uint *)PTR_DAT_8008d2ac & 0x200000) != 0) 
	  {
		// save something in the player that got the kill,
		// and the player that got killed
        *(undefined2 *)(param_3 + 0x4f0) = (short)param_4;
        *(undefined2 *)(param_1 + 0x4f4) = (short)param_4;
      }

	  // increment loop counter
      iVar7 = iVar7 + 1;
    } while (iVar7 < 1);

    if (
			// if attacked yourself
			(param_3 == param_1) &&

			// If you have a point limit (battle)
			((*(uint *)PTR_DAT_8008d2ac & 0x4000) != 0)
		)
	{
      if (*(int *)(param_1 + 0x4d0) == 5)
	  {
		// scoreDelta
        *(int *)(param_1 + 0x4dc) = *(int *)(param_1 + 0x4dc) + -1;
      }
      else
	  {
		// scoreDelta
        *(undefined4 *)(param_1 + 0x4dc) = 0xffffffff;
      }
    }
    
	// did not attack self
	else
	{
      if (*(int *)(param_3 + 0x4d0) == 5)
	  {
		// scoreDelta
        *(int *)(param_3 + 0x4dc) = *(int *)(param_3 + 0x4dc) + 1;
      }

      else
	  {
		// scoreDelta
        *(undefined4 *)(param_3 + 0x4dc) = 1;
      }
    }
	
	// cooldown
    *(undefined4 *)(param_3 + 0x4d0) = 5;
	
	// param_3 is attacker,
	// param_1 is attacked
    
	// count number of times attacked by this player
	// param_1->0x560[param_3->driverID]++
	iVar7 = param_1 + (uint)*(byte *)(param_3 + 0x4a);
    *(char *)(iVar7 + 0x560) = *(char *)(iVar7 + 0x560) + '\x01';
	
	// count number of times attacking this player
	// param_1->0x50c[param_3->driverID]++
    iVar7 = param_3 + (uint)*(byte *)(param_1 + 0x4a);
    *(char *)(iVar7 + 0x50c) = *(char *)(iVar7 + 0x50c) + '\x01';
    
	// if did not attack yourself
	if (param_3 != param_1) 
	{
	  // count number of times attacking
      *(char *)(param_3 + 0x559) = *(char *)(param_3 + 0x559) + '\x01';
    }
  }

  // enable collision for this thread
  *(uint *)(iVar6 + 0x1c) = *(uint *)(iVar6 + 0x1c) & 0xffffefff;

  // make visible
  *(uint *)(*(int *)(param_1 + 0x1c) + 0x28) =
  *(uint *)(*(int *)(param_1 + 0x1c) + 0x28) & 0xffffff7f;

  return 1;
}


// Weapon_Mask_boolGoodGuy
undefined4 FUN_80064be4(int param_1)

{
  // character ID (0 for crash, 1 for cortex, 2 for tiny, etc)
  short sVar1;

  // return (0 for uka, 1 for aku)
  undefined4 uVar2;

  // Player / AI structure + 0x4a shows driver index (0-7)


  // get character ID of current player (p1, p2, p3, etc)
  sVar1 = (&DAT_80086e84)[*(byte *)(param_1 + 0x4a)];

  // by default, player is bad guy and uses uka uka
  uVar2 = 0;

  // if you are crash, 		coco				polar			pura	or		penta
  if ((((sVar1 == 0) || (sVar1 == 3)) || (sVar1 == 6)) || ((sVar1 == 7 || (sVar1 == 0xd))))
  {
	// you are a good guy, use aku aku
    uVar2 = 1;
  }

  // return whether you use aku or uka
  return uVar2;
}


// Weapon_Mask_UseWeapon
// param1 is driver
// param2 (0 for mask grab, 1 for weapon)
undefined2 * FUN_80064c38(int param_1,int param_2)

{
  undefined2 uVar1;
  int iVar2;
  undefined2 *puVar3;
  uint uVar4;
  undefined4 uVar5;
  int iVar6;

  // Check if 231 dll is loaded
  iVar2 = FUN_800348e8();

  if (
		// if it is not loaded
		(iVar2 == 0) ||

		// If you're in Adventure Arena
		((*(uint *)PTR_DAT_8008d2ac & 0x100000) != 0)
	)
  {
	// return nullptr
	// no mask object in adv arena
    puVar3 = (undefined2 *)0x0;
  }
  else
  {
	// driver -> instance -> thread
    iVar6 = *(int *)(*(int *)(param_1 + 0x1c) + 0x6c);

	// thread -> childThread,
	// which gets mask thread from driver
    iVar2 = *(int *)(iVar6 + 0x14);

	// while pointer is not nullptr
    while (iVar2 != 0)
	{
	  // if thread->modelIndex is Aku or Uka
      if ((uint)*(ushort *)(iVar2 + 0x44) - 0x39 < 2)
	  {
		// RB_MaskWeapon_ThTick
        *(undefined4 *)(iVar2 + 0x2c) = 0x800afdbc;

		// short duration
        uVar1 = 0x1e00;

		// if wumpa is less than 10
        if (*(char *)(param_1 + 0x30) < '\n') {
          iVar6 = *(int *)(iVar2 + 0x30);
        }

		// if wumpa is 10
        else {
          iVar6 = *(int *)(iVar2 + 0x30);

		  // long duration
          uVar1 = 0x2d00;
        }

		// duration
        *(undefined2 *)(iVar6 + 6) = uVar1;

        if (
				// If this is human and not AI
				((*(uint *)(param_1 + 0x2c8) & 0x100000) == 0) &&

				// if this is not a mask grab
				(param_2 != 0)
			)
		{
		  // if thread->modelIndex == Uka
          if (*(short *)(iVar2 + 0x44) == 0x3a) {
            uVar5 = 0x54;
          }

		  // if it is not aku
          else
		  {
			// if thread->modelIndex == Aku
            if (*(short *)(iVar2 + 0x44) != 0x39) goto LAB_80064d4c;
            uVar5 = 0x53;
          }

		  // OtherFX_Play_Echo
		  // activate mask weapon
          FUN_80028494(uVar5,1,*(uint *)(param_1 + 0x2c8) >> 0x10 & 1);
        }
LAB_80064d4c:

		// thread -> flags
        *(uint *)(iVar2 + 0x1c) = *(uint *)(iVar2 + 0x1c) & 0xfffff7ff;

		// return object attached to thread
        return (undefined2 *)*(undefined4 *)(iVar2 + 0x30);
      }

	  // go to next pointer
      iVar2 = *(int *)(iVar2 + 0x10);
    }

	// Weapon_Mask_boolGoodGuy
    uVar4 = FUN_80064be4(param_1);

	// If player uses Uka weapon
    if ((uVar4 & 0xffff) == 0)
	{
	  // s_doctor1_8008d62c
	  // "doctor1"

	  // 0x3a is index of model pointer array
	  // for uka head model

	  // 0x300 flag = SmallStackPool
	  // 0xd = "other" thread bucket
      iVar2 = FUN_800309a4(0x3a,s_doctor1_8008d62c,0x300,0xd,&DAT_800afdbc,0x14,iVar6);

	  // If this is human and not AI
      if (((*(uint *)(param_1 + 0x2c8) & 0x100000) == 0) &&

		  // OtherFX_Play_Echo
		  // uka activate
         (FUN_80028494(0x54,1,*(uint *)(param_1 + 0x2c8) >> 0x10 & 1),

         1 < (uint)*(byte *)(param_1 + 0x376) - 4))
	  {
		// Start playing uka uka mask song
        *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac & 0xfeffffff | 0x2000000;
      }

	  // get thread
      iVar6 = *(int *)(iVar2 + 0x6c);

	  // model pointer to uka beam
      uVar5 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x2260);
    }

	// If player uses Aku weapon
    else
	{
	  // s_doctor1_8008d62c
	  // "doctor1"

	  // 0x3a is index of model pointer array
	  // for aku head model

	  // 0x300 flag = SmallStackPool
	  // 0xd = "other" thread bucket
      iVar2 = FUN_800309a4(0x39,s_doctor1_8008d62c,0x300,0xd,&DAT_800afdbc,0x14,iVar6);

	  // If this is human and not AI
      if (((*(uint *)(param_1 + 0x2c8) & 0x100000) == 0) &&

		  // OtherFX_Play_Echo
		  // aku mask grab
         (FUN_80028494(0x53,1,*(uint *)(param_1 + 0x2c8) >> 0x10 & 1),
         1 < (uint)*(byte *)(param_1 + 0x376) - 4))
	  {
		// Start playing aku aku mask song
        *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac & 0xfdffffff | 0x1000000;
      }

	  // get thread from instance
      iVar6 = *(int *)(iVar2 + 0x6c);

	  // model pointer for aku beam
      uVar5 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x2258);
    }

	// get mask head object from thread
    puVar3 = *(undefined2 **)(iVar6 + 0x30);

	// INSTANCE_Birth3D -- ptrModel, name, thread
    uVar5 = FUN_8003086c(uVar5,"akubeam1",iVar6);

	// give beam instance to mask head object
    *(undefined4 *)(puVar3 + 4) = uVar5;

	// set funcThDestroy to remove instance from instance pool
    *(undefined4 *)(iVar6 + 0x24) = 0x80041dfc;

	// allow this thread to ignore all collisions
    *(uint *)(iVar6 + 0x1c) = *(uint *)(iVar6 + 0x1c) | 0x1000;

	// make mask head invisible
    *(uint *)(iVar2 + 0x28) = *(uint *)(iVar2 + 0x28) | 0x80;

	// make mask beam invisible
    *(uint *)(*(int *)(puVar3 + 4) + 0x28) = *(uint *)(*(int *)(puVar3 + 4) + 0x28) | 0x80;

	// mask duration without 10 wumpa
	uVar1 = 0x1e00;

	// if 9 < number of wumpa
	// if wumpa is 10
	if ('\t' < *(char *)(param_1 + 0x30))
	{
	  // increased mask duration
      uVar1 = 0x2d00;
    }

	// duration
    puVar3[3] = uVar1;

	// rotX
    *puVar3 = 0x40;

	// rotY
    puVar3[1] = 0;

	// scale
    puVar3[9] = 0x1000;

	// rotZ
    puVar3[2] = 0;
  }

  // return mask object
  return puVar3;
}


// Weapon_Missile_GetTargetDriver
// param_1 driver who shot weapon
// return driver who will be chased
int FUN_80064f94(int param_1)

{
  int iVar1;
  int iVar2;
  MATRIX *pMVar3;
  int iVar4;
  int iVar5;
  long *r0;
  int iVar6;
  int iVar7;
  undefined *puVar8;
  undefined *puVar9;
  undefined auStack128 [16];
  undefined2 local_70;
  undefined2 local_6e;
  undefined2 local_6c;
  MATRIX MStack104;
  undefined auStack72 [48];

  puVar9 = auStack128;
  puVar8 = auStack128;

  // the ID of the player that the missile will chase
  iVar7 = 0;

  // set minimum distance from P1 to max possible distance
  iVar6 = 0x7fffffff;

  // if player shot missile
  // driver -> instance -> thread -> modelIndex == "player" of any kind
  if (*(short *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x44) == 0x18)
  {
	// tileView ViewProj
    pMVar3 = (MATRIX *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_1 + 0x4a) * 0x110 + 0x168 + 0x28);
    gte_SetRotMatrix(pMVar3);
    gte_SetTransMatrix(pMVar3);
    puVar9 = puVar8;
  }

  // if robotcar shot missile
  else
  {
	// get rotation of AI
    local_70 = *(undefined2 *)(param_1 + 0x2ec);
    pMVar3 = &MStack104;
    local_6e = *(undefined2 *)(param_1 + 0x2ee);
    local_6c = *(undefined2 *)(param_1 + 0x2f0);

	// convert 3 rotation shorts into rotation matrix
    FUN_8006c2a4(pMVar3,&local_70);

	// get position of AI
    MStack104.t[0] = *(int *)(param_1 + 0x2d4) >> 8;
    MStack104.t[1] = *(int *)(param_1 + 0x2d8) >> 8;
    MStack104.t[2] = *(int *)(param_1 + 0x2dc) >> 8;

	// output: matrix ???
	// input: missile matrix
	// MATH_HitboxMatrix
    FUN_8003d264(auStack72,pMVar3);

    gte_SetRotMatrix(pMVar3);
    gte_SetTransMatrix(pMVar3);
  }

  // loop counter
  iVar5 = 0;

  r0 = (long *)(puVar9 + 0x60);

  // for iVar6 = 0; iVar6 < 8; iVar6++
  do
  {
	// get pointer to current player's structure
    iVar4 = *(int *)(PTR_DAT_8008d2ac + iVar5 * 4 + 0x24ec);

    if (
			(
				// if you hit a player with a weapon that is not yourself
				(
					// if pointer is not nullptr
					(iVar4 != 0) &&

					// if pointer is not the same as param1
					(iVar4 != param_1)
				) &&

				// if player hit, is not being picked up by mask
				(*(char *)(iVar4 + 0x376) != '\x05')
			) &&

			(
				(
					(
						// If you're not in Battle Mode
						(*(uint *)PTR_DAT_8008d2ac & 0x20) == 0 ||

						// if you are in battle mode,
						// if one player hit another that is on a different team
						(*(int *)(iVar4 + 0x4e8) != *(int *)(param_1 + 0x4e8))
					) &&

					// if player is not invisible
					(*(int *)(iVar4 + 0x28) == 0)
				)
			)
		)

	// If you hard-code iVar5 + 0x376 to be 5,
	// player can't be hit, weapons go right through them

	// however, if player hits another player on the same team,
	// and if this block still does not execute, the player hit still
	// gets animated like any other player getting hit

    {
	  // set position to driver -> instSelf -> position
      *(undefined2 *)(puVar9 + 0x58) = *(undefined2 *)(*(int *)(iVar4 + 0x1c) + 0x44);
      *(undefined2 *)(puVar9 + 0x5a) = *(undefined2 *)(*(int *)(iVar4 + 0x1c) + 0x48);
      *(undefined2 *)(puVar9 + 0x5c) = *(undefined2 *)(*(int *)(iVar4 + 0x1c) + 0x4c);
      gte_ldv0((SVECTOR *)(puVar9 + 0x58));

	  // RTPS - Perspective Transformation (single)
      gte_rtps();

      gte_stsxy(r0);
      gte_stflg((long *)(puVar9 + 100));

      if (
			(
				((*(uint *)(puVar9 + 100) & 0x40000) == 0) &&
				(0x1e < *(short *)(puVar9 + 0x60))
			) &&
			(
				(
					(int)*(short *)(puVar9 + 0x60) <

					// tileView[driverID]->0x20 (rect.w)
					*(short *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_1 + 0x4a) * 0x110 + 0x188) + -0x1e &&

					(
						(
							(
								0x14 < *(short *)((int)r0 + 2) &&

								(
									(int)*(short *)((int)r0 + 2) <

									// tileView[driverID]->0x22 (rect.h)
									*(short *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_1 + 0x4a) * 0x110 + 0x18a) + -0x14
								)
							) &&

							(
								// get X distance between two players
								iVar1 = *(int *)(iVar4 + 0x2d4) - *(int *)(param_1 + 0x2d4) >> 8,

								// get Z distance between two players
								iVar2 = *(int *)(iVar4 + 0x2dc) - *(int *)(param_1 + 0x2dc) >> 8,

								// if player is closer to missile than previous closest player
								iVar1 = iVar1 * iVar1 + iVar2 * iVar2, iVar1 < iVar6
							)
						)
					)
				)
			)
		)
	  {
		// set smallest distance to current distance
        iVar6 = iVar1;

		// set closest player to this player
        iVar7 = iVar4;
      }
    }

	// increment loop counter
    iVar5 = iVar5 + 1;

  } while (iVar5 < 8);

  // return address of player that missile will chase
  return iVar7;
}


// Weapon_Potion_Throw
// param1 is object
// param2 is instance
// param3 is flags (like throw forward potion)
undefined4 FUN_800652c8(int param_1,int param_2,uint param_3)

{
  short sVar1;
  uint uVar2;
  int iVar3;
  undefined2 uVar4;

  // For TNTs param3 != 0 shoots tnt up into air,
  // direction does not change (komodo joe)

  // For Potions
  // param3 & 1 shoots back a short distance
  // param3 & 2 shoots back a long distance
  // param3 & 4 shoots forward (hold up on d-pad)

  // if you dont want to throw forward
  if ((param_3 & 4) == 0)
  {
	// if you dont want to throw back long
    if ((param_3 & 2) == 0)
	{
	  // if you dont want to throw back short
      if ((param_3 & 1) == 0)
	  {
		// just quit and drop weapon as-is
        return 0;
      }

	  // if you want to throw back short

      uVar2 = FUN_8006c684(&DAT_8008d668);
      iVar3 = (uVar2 & 0x1f) - 0x10;
      *(undefined2 *)(param_1 + 0xc) = (short)(*(short *)(param_2 + 0x34) * iVar3 >> 0xc);
      sVar1 = *(short *)(param_2 + 0x40);
      *(undefined2 *)(param_1 + 0xe) = 0x30;
      *(undefined4 *)(param_1 + 8) = 0;
      *(ushort *)(param_1 + 0x28) = *(ushort *)(param_1 + 0x28) | 2;
      uVar4 = (undefined2)(sVar1 * iVar3 >> 0xc);
    }

	// if you want to throw back long
    else {
      *(undefined2 *)(param_1 + 0xc) = (short)((int)*(short *)(param_2 + 0x34) * -0x78 >> 0xc);
      sVar1 = *(short *)(param_2 + 0x40);
      *(undefined2 *)(param_1 + 0xe) = 0x30;
      *(undefined4 *)(param_1 + 8) = 0;
      *(ushort *)(param_1 + 0x28) = *(ushort *)(param_1 + 0x28) | 2;
      uVar4 = (undefined2)((int)sVar1 * -0x78 >> 0xc);
    }
  }

  // if you want to throw forward
  else {
    *(undefined2 *)(param_1 + 0xc) = (short)((int)*(short *)(param_2 + 0x34) * 0xf >> 9);
    sVar1 = *(short *)(param_2 + 0x40);
    *(undefined2 *)(param_1 + 0xe) = 0x30;
    *(undefined4 *)(param_1 + 8) = 0;
    *(ushort *)(param_1 + 0x28) = *(ushort *)(param_1 + 0x28) | 2;
    uVar4 = (undefined2)((int)sVar1 * 0xf >> 9);
  }
  *(undefined2 *)(param_1 + 0x10) = uVar4;
  return 1;
}


// Weapon_Shoot_Now
void FUN_8006540c(int param_1,undefined4 param_2,uint param_3)
// param1 is the address of the player/AI structure that fired the weapon
// param2 is weaponID
// param3 is "special" like throwing potions backward, or TNTs airborne
{
  undefined2 uVar1;
  short sVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  undefined4 uVar7;
  int iVar8;
  int iVar9;
  char *pcVar10;
  undefined2 *puVar11;
  undefined *puVar12;
  undefined4 local_48;
  undefined4 uVar13;
  int iVar14;
  int *piVar15;
  undefined4 *puVar16;
  undefined2 local_40;
  short local_3e;
  undefined2 local_3c;
  undefined2 local_38;
  short local_36;
  undefined2 local_34;
  undefined2 local_30;
  short local_2e;
  undefined2 local_2c;
  undefined2 local_28;
  short local_26;
  undefined2 local_24;

  // This function definitely handles the firing
  // of the weapons. I set the first instruction
  // of this function to "jr ra" to leave, and it
  // disabled the firing of all weapons

  // param1 is weapon ID
  switch(param_2)
  {

  // If your weapon is Turbo
  case 0:

	// small boost
    uVar7 = 0x80;

	// if 9 < number of wumpa
	// basically if wumpa < 10
    if ('\t' < *(char *)(param_1 + 0x30))
	{
	  // bigger boost
      uVar7 = 0x100;
    }

	// Turbo_Increment
	// 2.4 seconds reserve
    FUN_8005abfc(param_1,0x960,9,uVar7);

	break;

  // If your weapon is Missile
  case 2:

	// If there are more than 11 missiles on screen
    if (0xb < *(int *)(PTR_DAT_8008d2ac + 0x1ec0))
	{
	  // Quit, dont shoot more missiles
      return;
    }

	// set closest distance from missile-shooter to player, to max value,
	// so that we can loop through other players to find smaller distance
    iVar5 = 0x7fffffff;

	// number of missiles launched by player
    *(char *)(param_1 + 0x55c) = *(char *)(param_1 + 0x55c) + '\x01';

	// increment number of missiles that are on screen
    *(int *)(PTR_DAT_8008d2ac + 0x1ec0) = *(int *)(PTR_DAT_8008d2ac + 0x1ec0) + 1;

	// both gamepad vibration
    FUN_80026440(param_1,8,0);
    FUN_800264c0(param_1,8,0x7f);

	// Weapon_Missile_GetTargetDriver
    iVar8 = FUN_80064f94(param_1);

	// if a player was not found to chase
    if (iVar8 == 0)
	{
      iVar14 = 0;
      puVar12 = PTR_DAT_8008d2ac;

	  // If you're not in Battle Mode
      if ((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0)
	  {
        if (
			(
				// driver -> instance -> thread -> modelIndex
				(*(short *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x44) != 0x18) &&

				// if racer is not in first place
				((int)*(short *)(param_1 + 0x482) != 0)
			) &&

			// if time on clock is an odd number
			((*(uint *)(PTR_DAT_8008d2ac + 0x1d10) & 1) != 0)
		  )
		{
			// the missile chases the driver, one place ahead of the driver that fired the weapon
			iVar8 = *(int *)(PTR_DAT_8008d2ac + ((int)*(short *)(param_1 + 0x482) + -1) * 4 + 0x250c);
        }
      }

	  // if you are in battle
      else
	  {
		// loop through all players to find
		// the closest player that the missile can seek

		// for iVar14 = 0; iVar14 < 8; iVar14++
        do
		{
		  // get address of player structure
          iVar9 = *(int *)(puVar12 + 0x24ec);

          if (
				(
					(
						// if pointer is not nullptr
						(iVar9 != 0) &&

						// if player is not the missile shooter
						(iVar9 != param_1)
					) &&

					(
						(
							// if enemy player is being picked up by mask
							*(char *)(iVar9 + 0x376) != '\x05' &&

							(
								(
									// if two players are not on same team in battle mode
									*(int *)(iVar9 + 0x4e8) != *(int *)(param_1 + 0x4e8) &&

									// if player is not invisible
									(*(int *)(iVar9 + 0x28) == 0)
								)
							)
						)
					)
				) &&
				(
					// Get the X distance between two players
					iVar3 = *(int *)(iVar9 + 0x2d4) - *(int *)(param_1 + 0x2d4) >> 8,

					// Get the Z distance between two players
					iVar4 = *(int *)(iVar9 + 0x2dc) - *(int *)(param_1 + 0x2dc) >> 8,

					// Get the distance between two players
					iVar3 = iVar3 * iVar3 + iVar4 * iVar4,

					// if player is closer to missile shooter than previous closest player
					iVar3 < iVar5
				)
			  )
		  {
			// set smallest distance to current distance
            iVar5 = iVar3;

			// set closest player to this player
            iVar8 = iVar9;
          }

		  // increment loop iteration counter
          iVar14 = iVar14 + 1;

		  // increment pointer
          puVar12 = puVar12 + 4;
        } while (iVar14 < 8);

		// when this loop ends, iVar8 is the player that the missile is tracking

      }
    }

    if (
			// if weapon is bomb
			(*(char *)(param_1 + 0x36) == '\x02') ||
			(
				// bomb model
				uVar7 = 0x3b,

				// if weapon is three missiles
				*(char *)(param_1 + 0x36) == '\v'
			)
		)
    {
	  // missile model
      uVar7 = 0x29;

      pcVar10 = "bombtracker1";

	  // 6 = "tracking" thread bucket
      uVar13 = 6;

      local_48 = 0;
    }
    else
	{
	  // s_bomb1_8008d634
	  // "bomb1"
      pcVar10 = s_bomb1_8008d634;

	  // driver -> instane -> thread
      local_48 = *(undefined4 *)(*(int *)(param_1 + 0x1c) + 0x6c);

	  // 0xd = "other" thread bucket
      uVar13 = 0xd;
    }

	// make thread for bomb or missile
	// 0x200 flag = MediumStackPool
    iVar5 = FUN_800309a4(uVar7,pcVar10,0x200,uVar13,FUN_800adb50,0x58,local_48);

	// driver instance
	iVar14 = *(int *)(param_1 + 0x1c);

	// copy driver position, rotation, and scale
	// into missile position, rotation, and scale
    uVar7 = *(undefined4 *)(iVar14 + 0x34);
    local_48 = *(undefined4 *)(iVar14 + 0x38);
    uVar13 = *(undefined4 *)(iVar14 + 0x3c);
    *(undefined4 *)(iVar5 + 0x30) = *(undefined4 *)(iVar14 + 0x30);
    *(undefined4 *)(iVar5 + 0x34) = uVar7;
    *(undefined4 *)(iVar5 + 0x38) = local_48;
    *(undefined4 *)(iVar5 + 0x3c) = uVar13;
    uVar7 = *(undefined4 *)(iVar14 + 0x44);
    local_48 = *(undefined4 *)(iVar14 + 0x48);
    uVar13 = *(undefined4 *)(iVar14 + 0x4c);
    *(undefined4 *)(iVar5 + 0x40) = *(undefined4 *)(iVar14 + 0x40);
    *(undefined4 *)(iVar5 + 0x44) = uVar7;
    *(undefined4 *)(iVar5 + 0x48) = local_48;
    *(undefined4 *)(iVar5 + 0x4c) = uVar13;

	// Rot_AxisAngle
	// rotation matrix of weapon,
	// face direction of driver facing, even with drift applied
    FUN_8005f89c(iVar5 + 0x30,param_1 + 0x360,(int)*(short *)(param_1 + 0x2ee));

	// THREAD_DestroyTracker
	// when missile needs to be destroyed,
	// decrease number of missiles,
    *(undefined4 *)(*(int *)(iVar5 + 0x6c) + 0x24) = 0x80041dc0;

	// RB_Hazard_ThCollide_Missile, remove 2D target being drawn on them
    *(undefined4 *)(*(int *)(iVar5 + 0x6c) + 0x28) = 0x800ac42c;

	// instance -> thread -> object
    piVar15 = *(int **)(*(int *)(iVar5 + 0x6c) + 0x30);

    *(undefined2 *)((int)piVar15 + 0x16) = 0;

	// record pointer that shot the missile
    piVar15[1] = param_1;

    piVar15[0x12] = 0;
    piVar15[0x15] = 0;
    piVar15[9] = 0;

	// if weapon is one bowling bomb or three bowling bombs
    if ((*(char *)(param_1 + 0x36) == '\x01') || (*(char *)(param_1 + 0x36) == '\n'))
	{
	  // CTR_MatrixToRot
	  // iVar5+0x30 is weapon inst->matrix
      FUN_80021edc(&local_40,iVar5 + 0x30,0x11);

	  // 6*4 = 0x18, missile->dir[x]
	  *(short *)(piVar15 + 6) = local_3e;

	  // missile->dir[y]
      *(undefined2 *)((int)piVar15 + 0x1a) = local_40;

	  // record "driver" pointer that bomb is chasing
	  *piVar15 = iVar8;

	  // 7*4 = 0x1C, missile->dir[z]
      *(undefined2 *)(piVar15 + 7) = local_3c;

      *(int *)(param_1 + 0x10) = iVar5;

	  // play sound of shooting bomb,
	  // the audio depends on distance
	  // from bomb to any human player
      FUN_8002f0dc(0x47,iVar5);

	  // get flags of driver that shot bombs
	  uVar6 = *(uint *)(param_1 + 0x2c8);

	  uVar7 = 10;
    }

	// if weapon is missile (should be every time)
    else
	{
	  // RB_Hazard_ThCollide_Missile, remove 2D target being drawn on them
      *(undefined4 *)(*(int *)(iVar5 + 0x6c) + 0x28) = 0x800ac42c;

	  // if missile does not have a target
	  if (iVar8 == 0)
	  {
		// set target to nullptr,
        *piVar15 = 0;
      }

	  // if missile has a target
      else
	  {
		// save address of player structure of target
        *piVar15 = iVar8;

		// if player is not aware a missile is chasing them
        if (*(int *)(iVar8 + 0x4a4) == 0)
		{
		  // RB_GetThread_ClosestTracker (missile or warpball)
          uVar7 = FUN_800b28c0(iVar8);

		  // Give the player a pointer to the missile chasing them
          *(undefined4 *)(iVar8 + 0x4a4) = uVar7;
        }
      }

	  // play sound of shooting missile,
	  // the audio depends on distance
	  // from missile to any human player
	  FUN_8002f0dc(0x4a,iVar5);

	  // get flags of the driver who shot the missile
      uVar6 = *(uint *)(param_1 + 0x2c8);

      uVar7 = 0xb;
    }

	// If driver shooting is human and not AI
    if ((uVar6 & 0x100000) == 0)
	{
	  // Make driver talk
      FUN_8002cbe8(uVar7,(int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)],0x10);
    }

    uVar1 = *(undefined2 *)(param_1 + 0x2ee);
    *(undefined2 *)((int)piVar15 + 0x12) = 0;
    *(undefined2 *)((int)piVar15 + 0x1e) = uVar1;

	// if weapon is one bowling bomb, or three bowling bombs
    if ((*(char *)(param_1 + 0x36) == '\x01') || (*(char *)(param_1 + 0x36) == '\n'))
	{
      *(short *)(piVar15 + 4) = (short)((int)*(short *)(iVar5 + 0x34) * 3 >> 7);
      *(short *)(piVar15 + 5) = (short)((int)*(short *)(iVar5 + 0x40) * 3 >> 7);

	  // if 9 < number of wumpa
	  // if wumpa is 10
      if ('\t' < *(char *)(param_1 + 0x30))
	  {
        *(ushort *)((int)piVar15 + 0x16) = *(ushort *)((int)piVar15 + 0x16) | 1;
      }

	  // If you press Down on D-Pad
      if (((*(uint *)(PTR_DAT_8008d2b0 + (uint)*(byte *)(param_1 + 0x4a) * 0x50 + 0x10) & 2) != 0)

		// or if you are pinstripe boss, I assume???
         || ((param_3 & 2) != 0))
	  {
		// roll bomb backwards
        *(ushort *)((int)piVar15 + 0x16) = *(ushort *)((int)piVar15 + 0x16) | 0x20;

		*(short *)(piVar15 + 4) =
             -(short)((((int)((uint)*(ushort *)(piVar15 + 4) << 0x10) >> 0x11) * 3) / 5);
        sVar2 = -(short)((((int)((uint)*(ushort *)(piVar15 + 5) << 0x10) >> 0x11) * 3) / 5);
        goto LAB_800659ec;
      }
    }

	// if weapon is not bowling bomb
    else
	{
	  // if wumpa < 10
      if (*(char *)(param_1 + 0x30) < '\n') {
        *(short *)(piVar15 + 4) = (short)((uint)((int)*(short *)(iVar5 + 0x34) * 5) >> 8);
        sVar2 = (short)((uint)((int)*(short *)(iVar5 + 0x40) * 5) >> 8);
      }

	  // if wumpa is 10
	  else
	  {
        *(short *)(piVar15 + 4) = (short)((int)*(short *)(iVar5 + 0x34) * 3 >> 7);
        sVar2 = *(short *)(iVar5 + 0x40);
        *(ushort *)((int)piVar15 + 0x16) = *(ushort *)((int)piVar15 + 0x16) | 1;
        sVar2 = (short)((int)sVar2 * 3 >> 7);
      }
LAB_800659ec:
      *(short *)(piVar15 + 5) = sVar2;
    }
    *(undefined2 *)(piVar15 + 8) = 0x3c;
    *(undefined2 *)((int)piVar15 + 0x22) = 0;

	// record the driver who shot the tracker
    piVar15[2] = *(int *)(param_1 + 0x1c);

    break;

  // if weapon ID is TNT / Nitro
  case 3:

	// If number of wumpa fruit is less than 10
	if (*(char *)(param_1 + 0x30) < '\n')
	{
      uVar7 = 0x27;

	  // DAT_8008d64c
	  // "tnt1"
      pcVar10 = &DAT_8008d64c;
    }

	// if you have 10 wumpa fruit
    else
	{
      uVar7 = 6;

	  // s_nitro1_8008d644
	  // "nitro1"
      pcVar10 = s_nitro1_8008d644;
    }

	// make TNT or Nitro thread
	// 0x300 flag = SmallStackPool
	// 4 = "mine" thread bucket
    iVar5 = FUN_800309a4(uVar7,pcVar10,0x300,4,&DAT_800acb60,0x2c,0);

	// get instance from driver
    iVar8 = *(int *)(param_1 + 0x1c);

	// copy rotation from driver, into weapon
    uVar7 = *(undefined4 *)(iVar8 + 0x34);
    local_48 = *(undefined4 *)(iVar8 + 0x38);
    uVar13 = *(undefined4 *)(iVar8 + 0x3c);
    *(undefined4 *)(iVar5 + 0x30) = *(undefined4 *)(iVar8 + 0x30);
    *(undefined4 *)(iVar5 + 0x34) = uVar7;
    *(undefined4 *)(iVar5 + 0x38) = local_48;
    *(undefined4 *)(iVar5 + 0x3c) = uVar13;

	// get position from player
    uVar7 = *(undefined4 *)(iVar8 + 0x44);
    local_48 = *(undefined4 *)(iVar8 + 0x48);
    uVar13 = *(undefined4 *)(iVar8 + 0x4c);

	// one more rotation variable
    *(undefined4 *)(iVar5 + 0x40) = *(undefined4 *)(iVar8 + 0x40);

	// set position of weapon
    *(undefined4 *)(iVar5 + 0x44) = uVar7;
    *(undefined4 *)(iVar5 + 0x48) = local_48;
    *(undefined4 *)(iVar5 + 0x4c) = uVar13;

	// set scale (x, y, z)
    *(undefined2 *)(iVar5 + 0x1c) = 0;
    *(undefined2 *)(iVar5 + 0x1e) = 0;
    *(undefined2 *)(iVar5 + 0x20) = 0;

	// set funcThDestroy to remove instance from instance pool
    *(undefined4 *)(*(int *)(iVar5 + 0x6c) + 0x24) = 0x80041dfc

	// set funcThCollide function
    *(undefined4 *)(*(int *)(iVar5 + 0x6c) + 0x28) = 0x800ac4b8;

	// Play potion sound,
	// volume depends on disatnce
	// between instance and nearest tileView
    FUN_8002f0dc(0x52,iVar5);

	// If this is human and not AI
    if ((*(uint *)(param_1 + 0x2c8) & 0x100000) == 0)
	{
	  // Make driver talk
      FUN_8002cbe8(0xf,(int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)],0x10);
    }

	// instance -> thread -> object
    puVar16 = *(undefined4 **)(*(int *)(iVar5 + 0x6c) + 0x30);

	// save the driver that dropped the weapon
    puVar16[1] = *(undefined4 *)(param_1 + 0x1c);

    *(undefined2 *)(puVar16 + 3) = 0;
    *(undefined2 *)((int)puVar16 + 0xe) = 0;
    *(undefined2 *)(puVar16 + 4) = 0;
    *(undefined2 *)(puVar16 + 9) = 10;
    *(undefined2 *)(puVar16 + 5) = 0;
    *(undefined2 *)((int)puVar16 + 0x26) = 0;
    *puVar16 = 0;
    puVar16[2] = 0;
    *(undefined2 *)(puVar16 + 10) = 0;

	// RB_MinePool_Add
	FUN_800ac13c(puVar16);

	// Weapon_Potion_Throw
    FUN_800652c8(puVar16,iVar5,param_3);

	// instancePos - Y
    local_40 = *(undefined2 *)(iVar5 + 0x44);
    local_3e = *(short *)(iVar5 + 0x48) + -400;
    local_3c = *(undefined2 *)(iVar5 + 0x4c);

	// instancePos + Y
    local_38 = *(undefined2 *)(iVar5 + 0x44);
    local_36 = *(short *)(iVar5 + 0x48) + 0x40;
    local_34 = *(undefined2 *)(iVar5 + 0x4c);

	// ground quadblock flags
    DAT_1f80012c = 0x1000;

	DAT_1f800130 = 0;
	
	// low-LOD collision (2 triangles)
    DAT_1f80012a = 1;

	// if numPlyrCurrGame is less than 3
    if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 3) 
	{
	  // high-LOD collision (8 triangles)
      DAT_1f80012a = 3;
    }

    DAT_1f800134 = **(undefined4 **)(PTR_DAT_8008d2ac + 0x160);

	// COLL_SearchTree_FindQuadblock_Touching
    FUN_8001eb0c(&local_40,&local_38,&DAT_1f800108,0x40);

	if (DAT_1f80014a == 0) {
      puVar16[2] = 0;
    }
    else {
      DAT_1f800114 = *(ushort *)(*(int *)(iVar5 + 0x18) + 0x10) | 0x8000;

	  // RB_Hazard_CollLevInst
      FUN_800ad9ac(&DAT_1f800108,*(undefined4 *)(iVar5 + 0x6c));

	  // InstDef -> modelID
	  sVar2 = *(short *)(*(int *)(DAT_1f800150 + 0x1c) + 0x3c);

	  // fruit crate or weapon crate
	  if ((sVar2 == 7) || (sVar2 == 8)) 
	  {
		// save mineWeapon->crateInst as...
		// InstDef -> ptrInstance
        puVar16[2] = *(undefined4 *)(*(int *)(DAT_1f800150 + 0x1c) + 0x2c);
      }
      else
	  {
		// RB_GenericMine_ThDestroy
        FUN_800ad250(*(undefined4 *)(iVar5 + 0x6c),iVar5,puVar16);
      }
	  
	  // low-LOD collision (2 triangles)
      DAT_1f80012a = 0;

	  // COLL_SearchTree_FindQuadblock_Touching
      FUN_8001eb0c(&local_40,&local_38,&DAT_1f800108,0);
    }

	// RB_MakeInstanceReflective
    FUN_800abab0(&DAT_1f800108,iVar5);

	// if quadblock was not found
	if (DAT_1f800146 == 0)
	{
      *(undefined2 *)((int)puVar16 + 0x12) = *(undefined2 *)(iVar5 + 0x48);

	  local_40 = 0;
      local_3e = 0x1000;
      local_3c = 0;

	  sVar2 = *(short *)(param_1 + 0x39a);
      puVar11 = &local_40;
    }

	// if quadblock was found
    else {
      *(undefined2 *)((int)puVar16 + 0x12) = DAT_1f800124._2_2_;
      sVar2 = *(short *)(param_1 + 0x39a);
      puVar11 = &DAT_1f800178;
    }

	// Rot_AxisAngle
	// generate TNT/Nitro rotation matrix,
	// with driver rotation, and quadblock rotation
    FUN_8005f89c(iVar5 + 0x30,puVar11,(int)sVar2);

	// instTntSend
	*(int *)(param_1 + 0x20) = iVar5;
	
    *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) | 0x80000000;

	if (param_3 == 0)
	{
	  // RB_Follower_Init
      FUN_800b6f00(param_1,*(undefined4 *)(iVar5 + 0x6c));
    }

	break;

  // if Weapon ID is beaker
  case 4:

    // if you have less than 10 wumpa fruit
    if (*(char *)(param_1 + 0x30) < '\n')
	{
	  // "beaker1"
	  // 0x47 = green beaker

	  // 0x300 flag = SmallStackPool
	  // 4 = "mine" thread bucket
      iVar5 = FUN_800309a4(0x47,s_beaker1_8008d654,0x300,4,&FUN_800acb60,0x2c,0);

	  // if thread failed, then quit
      if (iVar5 == 0) {
        return;
      }

	  // instance -> thread -> object
      iVar8 = *(int *)(*(int *)(iVar5 + 0x6c) + 0x30);

	  // green beaker, not red
      *(undefined2 *)(iVar8 + 0x28) = 0;
    }

	// if you have 10 wumpa fruit
    else
	{
	  // "beaker1"
	  // 0x46 = red beaker

	  // 0x300 flag = SmallStackPool
	  // 4 = "mine" thread bucket
      iVar5 = FUN_800309a4(0x46,s_beaker1_8008d654,0x300,4,&FUN_800acb60,0x2c,0);

	  // instance->thread->object
      iVar8 = *(int *)(*(int *)(iVar5 + 0x6c) + 0x30);

	  // red beaker
      *(undefined2 *)(iVar8 + 0x28) = 1;
    }

	// get instance from player
    iVar14 = *(int *)(param_1 + 0x1c);

	// get player rotation
    uVar7 = *(undefined4 *)(iVar14 + 0x34);
    local_48 = *(undefined4 *)(iVar14 + 0x38);
    uVar13 = *(undefined4 *)(iVar14 + 0x3c);

	// set potion rotation to player rotation (4 of 5)
    *(undefined4 *)(iVar5 + 0x30) = *(undefined4 *)(iVar14 + 0x30);
    *(undefined4 *)(iVar5 + 0x34) = uVar7;
    *(undefined4 *)(iVar5 + 0x38) = local_48;
    *(undefined4 *)(iVar5 + 0x3c) = uVar13;

	// get player position
    uVar7 = *(undefined4 *)(iVar14 + 0x44);
    local_48 = *(undefined4 *)(iVar14 + 0x48);
    uVar13 = *(undefined4 *)(iVar14 + 0x4c);

	// rotation (last of 5)
    *(undefined4 *)(iVar5 + 0x40) = *(undefined4 *)(iVar14 + 0x40);

	// set potion position to player position
    *(undefined4 *)(iVar5 + 0x44) = uVar7;
    *(undefined4 *)(iVar5 + 0x48) = local_48;
    *(undefined4 *)(iVar5 + 0x4c) = uVar13;

	// beakerInst -> model -> header
    iVar14 = *(int *)(*(int *)(iVar5 + 0x18) + 0x14);

	// header -> flag: always face camera
    *(ushort *)(iVar14 + 0x16) = *(ushort *)(iVar14 + 0x16) | 2;

	// set funcThDestroy to remove instance from instance pool
    *(undefined4 *)(*(int *)(iVar5 + 0x6c) + 0x24) = 0x80041dfc;

	// set funcThCollide
	*(undefined4 *)(*(int *)(iVar5 + 0x6c) + 0x28) = 0x800ac4b8;

	// get instance of driver
	uVar7 = *(undefined4 *)(param_1 + 0x1c);

    *(undefined2 *)(iVar8 + 0x24) = 10;
    *(undefined2 *)(iVar8 + 0x14) = 0;
    *(undefined4 *)(iVar8 + 8) = 0;

	// save the driver who placed the weapon
    *(undefined4 *)(iVar8 + 4) = uVar7;

	// Play potion sound,
	// volume depends on distance
	// between instance and nearest tileView
    FUN_8002f0dc(0x52,iVar5);

	// If this is human and not AI
    if ((*(uint *)(param_1 + 0x2c8) & 0x100000) == 0)
	{
	  // Make driver talk
      FUN_8002cbe8(0xf,(int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)],0x10);
    }

	// RB_MinePool_Add
    FUN_800ac13c(iVar8);

	// If you hold Up on D-Pad
    if ((*(uint *)(PTR_DAT_8008d2b0 + (uint)*(byte *)(param_1 + 0x4a) * 0x50 + 0x10) & 1) != 0)
	{
	  // Shoot potion forward
      param_3 = param_3 | 4;
    }

	// Weapon_Potion_Throw
    uVar6 = FUN_800652c8(iVar8,iVar5,param_3);

	// if mine is not "thrown", just "dropped"
    if ((uVar6 & 0xffff) == 0)
	{
	  // set scale to zero, thread will make it grow
      *(undefined2 *)(iVar5 + 0x1c) = 0;
      *(undefined2 *)(iVar5 + 0x1e) = 0;
      *(undefined2 *)(iVar5 + 0x20) = 0;

      *(undefined2 *)(iVar8 + 0xc) = 0;
      *(undefined2 *)(iVar8 + 0xe) = 0;
      *(undefined2 *)(iVar8 + 0x10) = 0;

	  // hit top
      local_30 = *(undefined2 *)(iVar5 + 0x44);
      local_2e = *(short *)(iVar5 + 0x48) + -400;
      local_2c = *(undefined2 *)(iVar5 + 0x4c);

	  // hit bottom
      local_28 = *(undefined2 *)(iVar5 + 0x44);
      local_26 = *(short *)(iVar5 + 0x48) + 0x40;
      local_24 = *(undefined2 *)(iVar5 + 0x4c);

	  // ground quadblock flags
      DAT_1f80012c = 0x1000;

	  DAT_1f800130 = 0;
	  
	  // low-LOD collision (2 triangles)
      DAT_1f80012a = 1;

	  // if numPlyrCurrGame is less than 3
      if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 3) 
	  {
		// high-LOD collision (8 triangles)
        DAT_1f80012a = 3;
      }

      DAT_1f800134 = **(undefined4 **)(PTR_DAT_8008d2ac + 0x160);

	  // COLL_SearchTree_FindQuadblock_Touching
	  FUN_8001eb0c(&local_30,&local_28,&DAT_1f800108,0x40);

      if (DAT_1f80014a == 0) {
        *(undefined4 *)(iVar8 + 8) = 0;
      }
      else {
        DAT_1f800114 = *(ushort *)(*(int *)(iVar5 + 0x18) + 0x10);

		// RB_Hazard_CollLevInst
        FUN_800ad9ac(&DAT_1f800108,*(undefined4 *)(iVar5 + 0x6c));

		sVar2 = *(short *)(*(int *)(DAT_1f800150 + 0x1c) + 0x3c);
        if ((sVar2 == 7) || (sVar2 == 8)) {
          *(undefined4 *)(iVar8 + 8) = *(undefined4 *)(*(int *)(DAT_1f800150 + 0x1c) + 0x2c);
        }
        else
		{
		  // RB_GenericMine_ThDestroy
          FUN_800ad250(*(undefined4 *)(iVar5 + 0x6c),iVar5,iVar8);
        }
		
		// low-LOD collision (2 triangles)
        DAT_1f80012a = 0;

		// COLL_SearchTree_FindQuadblock_Touching
        FUN_8001eb0c(&local_30,&local_28,&DAT_1f800108,0);
      }

	  // RB_MakeInstanceReflective
      FUN_800abab0(&DAT_1f800108,iVar5);

	  // if no collision,
	  if (DAT_1f800146 == 0)
	  {
        *(undefined2 *)(iVar8 + 0x12) = *(undefined2 *)(iVar5 + 0x48);

		// rotate on Y axis
		local_30 = 0;
        local_2e = 0x1000;
        local_2c = 0;

		// driver rotation
		sVar2 = *(short *)(param_1 + 0x39a);

		puVar11 = &local_30;
      }

	  else
	  {
        *(undefined2 *)(iVar8 + 0x12) = DAT_1f800124._2_2_;

		// driver rotation
		sVar2 = *(short *)(param_1 + 0x39a);

		// rotate on slanted axis from quadblock
		puVar11 = &DAT_1f800178;
      }

	  // Rot_AxisAngle
	  // rotation matrix of beaker, given driver rotation and quadblock
	  FUN_8005f89c(iVar5 + 0x30,puVar11,(int)sVar2);

	  // RB_Follower_Init
      FUN_800b6f00(param_1,*(undefined4 *)(iVar5 + 0x6c));

      *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) | 0x80000000;
    }
    break;

  // if weapon ID is Shield Bubble
  case 6:

	// make thread and instance, function returns instance
	// 0x200 flag = MediumStackPool
	// 0xd = "other" thread bucket
    iVar5 = FUN_800309a4(0x5a,"shielddark",0x200,0xd,&DAT_800b0454,0x18,

										// driver -> instance -> thread
                         *(undefined4 *)(*(int *)(param_1 + 0x1c) + 0x6c));

	// set scale (x, y, z)
    *(undefined2 *)(iVar5 + 0x1c) = 0x700;
    *(undefined2 *)(iVar5 + 0x1e) = 0x700;
    *(undefined2 *)(iVar5 + 0x20) = 0x700;

	// set funcThDestroy to remove instance from instance pool
    *(undefined4 *)(*(int *)(iVar5 + 0x6c) + 0x24) = 0x80041dfc;

	// OtherFX_Play Activate Shield sound
    FUN_80028468(0x57,1);

	// get object created with thread
    puVar16 = *(undefined4 **)(*(int *)(iVar5 + 0x6c) + 0x30);

	// if number of wumpa is less than 10
    if (*(char *)(param_1 + 0x30) < '\n')
	{
	  // Green shield model pointer (in instance)
      uVar7 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x22d8);
    }

	// if number of wumpa is 10
	else
	{
	  // Blue shield model pointer (in instance)
      uVar7 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x22b8);
    }

	// s_shield_8008d63c
	// "shield"

	// INSTANCE_Birth3D -- ptrModel, name, thread
	uVar7 = FUN_8003086c(uVar7,s_shield_8008d63c);

	// give instance to object
	puVar16[2] = uVar7;

    puVar12 = PTR_DAT_8008d2ac;

	// scale (x, y, z)
    *(undefined2 *)(puVar16[2] + 0x1c) = 0x700;
    *(undefined2 *)(puVar16[2] + 0x1e) = 0x700;
    *(undefined2 *)(puVar16[2] + 0x20) = 0x700;

	// INSTANCE_Birth3D -- ptrModel, name, thread
    iVar8 = FUN_8003086c(*(undefined4 *)(puVar12 + 0x22d4),"highlight",*(undefined4 *)(iVar5 + 0x6c));

	// give instance to object
	puVar16[3] = iVar8;

	// scale (x, y, z)
    *(undefined2 *)(iVar8 + 0x1c) = 0x700;
    *(undefined2 *)(puVar16[3] + 0x1e) = 0x700;
    *(undefined2 *)(puVar16[3] + 0x20) = 0x700;

    *(undefined2 *)((int)puVar16 + 6) = 0;
    *(undefined2 *)(puVar16 + 4) = 0;
    *(undefined2 *)((int)puVar16 + 0x12) = 0xc00;
    *(undefined2 *)(puVar16 + 5) = 0;
    *(undefined2 *)((int)puVar16 + 0x16) = 0;

	// if wumpa < 10
    if (*(char *)(param_1 + 0x30) < '\n')
	{
	  // 12 seconds,
	  // 12 * 30 * 32
      *(undefined2 *)(puVar16 + 1) = 0x2d00;
    }

	// if weapon is 10
    else
	{
	  // use a flag to disable the countdown timer (in 231)
      *(ushort *)((int)puVar16 + 6) = *(ushort *)((int)puVar16 + 6) | 4;
    }

    *(undefined2 *)(iVar5 + 0x22) = 0x400;
    *puVar16 = 0;
    *(int *)(param_1 + 0x14) = iVar5;
    break;

  // if weapon ID is mask
  case 7:
    // Weapon_Mask_UseWeapon
    FUN_80064c38(param_1,1);
    break;

  // if weapon ID is clock
  case 8:
    *(char *)(param_1 + 0x558) = *(char *)(param_1 + 0x558) + '\x01';

	// OtherFX_Play
    FUN_80028468(0x44);

	// loop iteration counter
    iVar5 = 0;

	// If this is human and not AI
    if ((*(uint *)(param_1 + 0x2c8) & 0x100000) == 0)
	{
	  // Make driver talk
      FUN_8002cbe8(0xe,(int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)],0x10);
      iVar5 = 0;
    }

	// for iVar5 = 0; iVar5 < 8; iVar5++
	do
	{
	  // pointer incrementer, for each player structure
      iVar14 = iVar5 * 4;

      *(undefined *)(*(int *)(PTR_DAT_8008d2ac + iVar14 + 0x24ec) + 0x367) = 4;

	  // get pointer to each player structure
      iVar8 = *(int *)(PTR_DAT_8008d2ac + iVar14 + 0x24ec);

	  // if pointer is not nullptr
      if (iVar8 != 0)
	  {
		// do not put weapon effect on the player that used it
        if (iVar8 == param_1) {
          *(undefined *)(param_1 + 0x45) = 0x1e;
        }
        else
		{
		  // RB_Hazard_HurtDriver (spinout)
          iVar8 = FUN_800ac1b0(iVar8,1,0,0);

          if (iVar8 != 0)
		  {
			// if wumpa < 10
            if (*(char *)(param_1 + 0x30) < '\n')
			{
			  // little time
              *(undefined2 *)(*(int *)(PTR_DAT_8008d2ac + iVar14 + 0x24ec) + 0xc) = 0x1e00;
            }

			// if wumpa is 10
            else
			{
			  // long time
              *(undefined2 *)(*(int *)(PTR_DAT_8008d2ac + iVar14 + 0x24ec) + 0xc) = 0x2d00;
            }
          }
        }
      }

	  // increment loop counter
      iVar5 = iVar5 + 1;
    } while (iVar5 < 8);
    break;

  // if weapon ID is warp ball
  case 9:

    // both gamepad vibration
    FUN_80026440(param_1,8,0);
    FUN_800264c0(param_1,8,0x7f);

	// 0x200 flag = MediumStackPool
	// 6 = "tracking" thread bucket
    iVar5 = FUN_800309a4(0x36,"warpball",0x200,6,&DAT_800aef9c,0x58,0);

	// copy position from player to warpball
    *(int *)(iVar5 + 0x44) = *(int *)(param_1 + 0x2d4) >> 8;
    *(int *)(iVar5 + 0x48) = *(int *)(param_1 + 0x2d8) >> 8;
    iVar8 = *(int *)(param_1 + 0x2dc);

	// set scale
    *(undefined4 *)(iVar5 + 0x30) = 0x1000;
    *(undefined4 *)(iVar5 + 0x38) = 0x1000;
    *(undefined2 *)(iVar5 + 0x40) = 0x1000;

	// one more position variable
    *(int *)(iVar5 + 0x4c) = iVar8 >> 8;

	// rotation variables
    *(undefined4 *)(iVar5 + 0x34) = 0;
    *(undefined4 *)(iVar5 + 0x3c) = 0;

	// set funcThDestroy to remove instance from instance pool
    *(undefined4 *)(*(int *)(iVar5 + 0x6c) + 0x24) = 0x80041dfc;

	// Play warpball spawn sound,
	// volume depends on distance
	// between instance and nearest tileView
    FUN_8002f0dc(0x4d,iVar5);

	// If this is human and not AI
    if ((*(uint *)(param_1 + 0x2c8) & 0x100000) == 0)
	{
	  // Make driver talk
      FUN_8002cbe8(0xc,(int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)],0x10);
    }

	// warpball instance -> thread -> object
    piVar15 = *(int **)(*(int *)(iVar5 + 0x6c) + 0x30);

    piVar15[1] = param_1;

	// set animation to zero
    *(undefined2 *)((int)piVar15 + 0x52) = 0;

    piVar15[0x10] = 0;

	// by default, chase nobody
    iVar8 = 0;

	// If player is not in first place
    if ((int)*(short *)(param_1 + 0x482) != 0)
	{
	  // start chasing the player in front of you
      iVar8 = *(int *)(PTR_DAT_8008d2ac + ((int)*(short *)(param_1 + 0x482) + -1) * 4 + 0x250c);
    }

	// store target driver in warpball object
    *piVar15 = iVar8;

	// RB_Warpball_SeekDriver
    FUN_800aece0(piVar15,(uint)*(byte *)(param_1 + 0x495),param_1);

    iVar8 = *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c);
    *(byte *)((int)piVar15 + 0x45) = *(byte *)(piVar15 + 0x11);

	// if wumpa < 10
    *(undefined2 *)((int)piVar15 + 0x16) = 0;

    piVar15[0xb] = 0;
    piVar15[0xf] = iVar8 + (uint)*(byte *)(piVar15 + 0x11) * 0xc;

	// if 9 < wumpa
	// if wumpa is 10
	if ('\t' < *(char *)(param_1 + 0x30))
	{
	  // use flag to remember that 10 wumpa were used
      *(ushort *)((int)piVar15 + 0x16) = *(ushort *)((int)piVar15 + 0x16) | 1;
    }

	*(ushort *)((int)piVar15 + 0x16) = *(ushort *)((int)piVar15 + 0x16) | 8;
    piVar15[0xd] = 1 << ((uint)*(byte *)(param_1 + 0x4a) & 0x1f);

	// if driver is in first
	if (*(short *)(param_1 + 0x482) == 0)
	{
	  // warp ball will not chase any driver
      *piVar15 = 0;
    }

	// if driver is not in first
    else
	{
	  // Find a target driver to chase

	  // piVar15 is WarpBall object,
	  // iVar5 is WarpBall instance
	  
	  // RB_Warpball_GetDriverTarget
      iVar5 = FUN_800ae7dc(piVar15,iVar5);

	  // store pointer to driver that will be chased
	  *piVar15 = iVar5;
    }

	// if driver is in first (again?)
    if (*(short *)(param_1 + 0x482) == 0)
	{
	  // warp ball will not chase any driver
      *piVar15 = 0;
    }

	// if driver is being chased
    if (*piVar15 != 0)
	{
	  // RB_Warpball_SetTargetDriver
      FUN_800aeaac(piVar15);
    }

    if ((*(ushort *)((int)piVar15 + 0x16) & 4) == 0)
	{
	  // RB_Warpball_Start
      FUN_800ae778(piVar15);
    }
    else {
      *(ushort *)((int)piVar15 + 0x16) = *(ushort *)((int)piVar15 + 0x16) & 0xfff7;
    }

	// RB_Warpball_NewPathNode
    iVar5 = FUN_800ae668(piVar15[0xf],*piVar15);
    piVar15[0x10] = iVar5;

	// clear audio pointer
    piVar15[9] = 0;

	// get rotation of driver inst
    sVar2 = *(short *)(*(int *)(param_1 + 0x1c) + 0x34);

	// velY
    *(undefined2 *)((int)piVar15 + 0x12) = 0;

	// velX
	*(short *)(piVar15 + 4) = (short)((uint)((int)sVar2 * 7) >> 8);

	// get rotation of driver inst
	sVar2 = *(short *)(*(int *)(param_1 + 0x1c) + 0x40);

	*(undefined2 *)(piVar15 + 8) = 10;

	// velZ
	*(short *)(piVar15 + 5) = (short)((uint)((int)sVar2 * 7) >> 8);

	// gGT
	puVar12 = PTR_DAT_8008d2ac;

	// rotation
	*(undefined2 *)((int)piVar15 + 0x1a) = *(undefined2 *)(param_1 + 0x39a);

	// instance who shot the warpball
	piVar15[2] = *(int *)(param_1 + 0x1c);

	// Create instance in particle pool
    iVar5 = FUN_80040308(0,*(undefined4 *)(puVar12 + 0x2114),&DAT_80089c04);

	// offset 0xC
    piVar15[3] = iVar5;

    if (iVar5 != 0) {
      *(undefined *)(iVar5 + 0x18) = 0xfa;
    }
    break;

  // if weapon ID is Invisibility
  case 0xc:

	// if not already invisible
    if (*(int *)(param_1 + 0x28) == 0)
	{
	  // backup instance flags before invisible
      *(undefined4 *)(param_1 + 0x2c) = *(undefined4 *)(*(int *)(param_1 + 0x1c) + 0x28);

	  // instance flags
	  *(uint *)(*(int *)(param_1 + 0x1c) + 0x28) =
           *(uint *)(*(int *)(param_1 + 0x1c) + 0x28) & 0xfff8ffff;

	  // instance flags
      *(uint *)(*(int *)(param_1 + 0x1c) + 0x28) =
           *(uint *)(*(int *)(param_1 + 0x1c) + 0x28) | 0x60000;

	  // OtherFX_Play
      FUN_80028468(0x61,1);
    }

	// if wumpa is 10
    uVar7 = 0x1e00;

	// if 9 < wumpa
	// if wumpa is 10
    if ('\t' < *(char *)(param_1 + 0x30)) {
      uVar7 = 0x2d00;
    }

	// set invisible timer
    *(undefined4 *)(param_1 + 0x28) = uVar7;

    break;

  // if weapn ID is Super Engine
  case 0xd:

	// if wumpa is less than 10
    if (*(char *)(param_1 + 0x30) < '\n')
	{
	  // Set super engine powerup timer
      *(undefined2 *)(param_1 + 0x38) = 0x1e00;
    }

	// if wumpa is 10
    else
	{
	  // Set super engine powerup timer
      *(undefined2 *)(param_1 + 0x38) = 0x2d00;
    }
  }
  return;
}


// Weapon_Shoot_OnCirclePress
void FUN_800666e4(int param_1)

{
  uint uVar1;

  if (*(byte *)(param_1 + 0x4ff) != 0)
  {
	// Player_ChangeState
    FUN_80064568(param_1,(uint)*(byte *)(param_1 + 0x4ff),*(undefined4 *)(param_1 + 0x500),
                 (uint)*(byte *)(param_1 + 0x504));
  }

  // If you want to fire a weapon
  if ((*(uint *)(param_1 + 0x2c8) & 0x8000) != 0)
  {
	// Remove the request to fire a weapon, since we will fire it now
    *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) & 0xffff7fff;

	// Set weapon to one bomb
    uVar1 = 1;

    if (
			// If this weapon is not 3 bombs
			(*(char *)(param_1 + 0x36) != '\n') &&

			(
				// Set weapon to missile
				uVar1 = 2,

				// if this weapon is not 3 missiles
				*(char *)(param_1 + 0x36) != '\v'
			)
		)
	{
	  // Set to the original weapon the player has
      uVar1 = (uint)*(byte *)(param_1 + 0x36);
    }

	// whaat???
	// If weapon is bomb, change to missile?????
    if (uVar1 == 1) {
      uVar1 = 2;
    }

	// Weapon_Shoot_Now (player)
    FUN_8006540c(param_1,uVar1,0);
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x80066894)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// VehPtr_MaskGrab_FindDestPos (destination position)
void FUN_8006677c(int param_1,short *param_2)

{
  byte bVar1;
  short sVar2;
  undefined *puVar3;
  long lVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  short *psVar8;
  short *psVar9;

  puVar3 = PTR_DAT_8008d2ac;

  if (
		(
			// if no respawn positions are found in the LEV file
			(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x148) < 1) ||
			(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c) == 0)
		) ||

		// quadblock respawnIndex (0x3e)
		(*(char *)(param_2 + 0x1f) == -1))
  {
	// respawn driver on the last "valid" quadblock they touched

	// posX =
    *(int *)(param_1 + 0x2d4) =
	
		  // lev->mesh_info->ptrVertexArray[(Quadblock*)param_2->index[0]].pos[0]
         ((int)*(short *)((int)*param_2 * 0x10 +
                         *(int *)(**(int **)(PTR_DAT_8008d2ac + 0x160) + 0x10)) +
						 
		  // lev->mesh_info->ptrVertexArray[(Quadblock*)param_2->index[3]].pos[0]
         (int)*(short *)((int)param_2[3] * 0x10 +
                        *(int *)(**(int **)(PTR_DAT_8008d2ac + 0x160) + 0x10))) 
			
		  // midpoint between
		  * 0x80;
    
	// lev->mesh_info->ptrVertexArray
	iVar6 = *(int *)(**(int **)(puVar3 + 0x160) + 0x10);
	
	// posY = 
    *(int *)(param_1 + 0x2d8) =
	
		 // ptrVertexArray[(Quadblock*)param_2->index[0]].pos[1]
         ((int)*(short *)((int)*param_2 * 0x10 + iVar6 + 2) +
		 
		   // ptrVertexArray[(Quadblock*)param_2->index[3]].pos[1]
          (int)*(short *)((int)param_2[3] * 0x10 + iVar6 + 2) + 0x80) 
		  
		  // midpoint between
		  * 0x80;
		  
    iVar6 = *(int *)(**(int **)(puVar3 + 0x160) + 0x10);
	
	// posZ
    *(int *)(param_1 + 0x2dc) =
	
		  
		   // ptrVertexArray[(Quadblock*)param_2->index[0]].pos[2]
         ((int)*(short *)((int)*param_2 * 0x10 + iVar6 + 4) +
		 
		   // ptrVertexArray[(Quadblock*)param_2->index[3]].pos[2]
         (int)*(short *)((int)param_2[3] * 0x10 + iVar6 + 4)) 
		 
		 // midpiont between
		 * 0x80;
  }

  // if respawnIndex is not -1,
  // and respawn points exist on LEV
  else
  {
	// search BSP for valid quadblock near the point, and spawn there

	// thread offset 0x42?

	// a bunch of driver -> instance -> thread -> xxx
	DAT_1f80010e = *(undefined2 *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x42);
    _DAT_1f800110 = *(undefined4 *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x38);
    DAT_1f80011c._2_2_ = *(undefined2 *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x42);
    DAT_1f800120 = *(undefined4 *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x38);

	DAT_1f800134 = **(int **)(PTR_DAT_8008d2ac + 0x160);
    DAT_1f800130 = 0x4010;

	// ground quadblock flags
    DAT_1f80012c = 0x1000;

	// quadblock respawnIndex (0x3e)
	bVar1 = *(byte *)(param_2 + 0x1f);
	
	// lev -> respawn_points
    iVar6 = *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c);
	
    *(undefined4 *)(param_1 + 0x490) = 0;
	
	// respawn data
    psVar8 = (short *)(iVar6 + (uint)bVar1 * 0xc);
	
    do {
      do {
		  
		// next respawn data after the one being spawned on
        psVar9 = (short *)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c) +
                          (uint)*(byte *)(psVar8 + 4) * 0xc);
		
		// posX
        *(int *)(param_1 + 0x2d4) = (int)*psVar8 << 8;
		
		// posY (+ offset for mask in air)
        *(int *)(param_1 + 0x2d8) = ((int)psVar8[1] + 0x80) * 0x100;
        
		// posZ
		sVar2 = psVar8[2];
        
		// rotX = 0 (not on slant)
		*(undefined2 *)(param_1 + 0x2ec) = 0;
        
		// posZ
		*(int *)(param_1 + 0x2dc) = (int)sVar2 << 8;
        
		// get rotY by comparing positions of cur respawn and next respawn
		lVar4 = ratan2((int)*psVar9 - (int)*psVar8,(int)psVar9[2] - (int)psVar8[2]);
        *(undefined2 *)(param_1 + 0x2ee) = (short)lVar4;
		
		// rotZ = 0 (not on slant)
        *(undefined2 *)(param_1 + 0x2f0) = 0;
        
		// build hitbox for driver
		DAT_1f800118._0_2_ = (short)((uint)*(undefined4 *)(param_1 + 0x2d4) >> 8);
        DAT_1f800118._2_2_ = (ushort)((uint)*(undefined4 *)(param_1 + 0x2d8) >> 8);
        DAT_1f80011c._0_2_ = (ushort)((uint)*(undefined4 *)(param_1 + 0x2dc) >> 8);
        DAT_1f800108 = (short)((uint)*(undefined4 *)(param_1 + 0x2d4) >> 8);
        DAT_1f80010a = (short)((uint)*(undefined4 *)(param_1 + 0x2d8) >> 8) - 0x100;
        
		// low-LOD collision (2 triangles)
		DAT_1f80012a = 0;
		
        DAT_1f80010c = (ushort)((uint)*(undefined4 *)(param_1 + 0x2dc) >> 8);

		// if numPlyrCurrGame is less than 3
        if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 3) 
		{
		  // high-LOD collision (8 triangles)
          DAT_1f80012a = 2;
        }

        DAT_1f800146 = 0;
        DAT_1f800144 = 0;
        DAT_1f80018c = 0x1000;
        DAT_1f8002ac = 0;
        DAT_1f800138 = (short)DAT_1f800118;
        if (DAT_1f800108 < (short)DAT_1f800118) {
          DAT_1f800138 = DAT_1f800108;
        }
        DAT_1f80013a = DAT_1f800118._2_2_;
        if ((int)((uint)DAT_1f80010a << 0x10) < (int)((uint)DAT_1f800118._2_2_ << 0x10)) {
          DAT_1f80013a = DAT_1f80010a;
        }
        DAT_1f80013c = (ushort)DAT_1f80011c;
        if ((int)((uint)DAT_1f80010c << 0x10) < (int)((uint)(ushort)DAT_1f80011c << 0x10)) {
          DAT_1f80013c = DAT_1f80010c;
        }
        DAT_1f80013e = (short)DAT_1f800118;
        if ((short)DAT_1f800118 < DAT_1f800108) {
          DAT_1f80013e = DAT_1f800108;
        }
        DAT_1f800140 = DAT_1f800118._2_2_;
        if ((int)((uint)DAT_1f800118._2_2_ << 0x10) < (int)((uint)DAT_1f80010a << 0x10)) {
          DAT_1f800140 = DAT_1f80010a;
        }
        DAT_1f800142 = (ushort)DAT_1f80011c;
        if ((int)((uint)(ushort)DAT_1f80011c << 0x10) < (int)((uint)DAT_1f80010c << 0x10)) {
          DAT_1f800142 = DAT_1f80010c;
        }
        DAT_1f800124._0_2_ = DAT_1f800108;
        DAT_1f800124._2_2_ = DAT_1f80010a;
        DAT_1f800128 = DAT_1f80010c;

		// COLL_SearchTree_FindX, callback for touching quadblocks,
		// COLL_PerVisData_CheckQuadblocks_Touching
        FUN_8001ebec(*(undefined4 *)(DAT_1f800134 + 0x18),&DAT_1f800138,FUN_8001f5f0,&DAT_1f800108);

		// cur respawn = next respawn
        psVar8 = psVar9;
		
		// loop again if no quadblock is found under the driver
      } while ((DAT_1f800146 == 0) || ((DAT_1f8002ac & 0x4000) != 0));

	  // pointer to first Player thread
      iVar6 = *(int *)(PTR_DAT_8008d2ac + 0x1b2c);

	  // if player does not exist, quit
      if (iVar6 == 0) break;

	  // loop through all players
      do
	  {
		// player object
        iVar7 = *(int *)(iVar6 + 0x30);

		// dont check for collision against yourself
        if (iVar7 != param_1) 
		{
		  // compare X
          iVar5 = *(int *)(param_1 + 0x2d4) - *(int *)(iVar7 + 0x2d4);
          
		  // absolute value
		  if (iVar5 < 0) {
            iVar5 = -iVar5;
          }
		  
		  // if distance too close, go to next respawn point
          if (iVar5 < 0x2000) break;
		  
		  // compare Z
          iVar7 = *(int *)(param_1 + 0x2dc) - *(int *)(iVar7 + 0x2dc);
		  
		  // absolute value
          if (iVar7 < 0) {
            iVar7 = -iVar7;
          }
		  
		  // if distance too close, go to next respawn point
          if (iVar7 < 0x2000) break;
        }

		// next player
        iVar6 = *(int *)(iVar6 + 0x10);

	  // if == 0, player does not spawn on top of another,
	  // else, check next driver
      } while (iVar6 != 0);
	 
	// if == 0, player does not spawn on top of another,
	// else, spawn player on the next respawn point
    } while (iVar6 != 0);
  }

  // CameraDC flag
  *(uint *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_1 + 0x4a) * 0xdc + 0x1508) =
       *(uint *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_1 + 0x4a) * 0xdc + 0x1508) | 1;
  return;
}


// VehPtr_MaskGrab_Particles
void FUN_80066cb0(int param_1)

{
  int iVar1;
  int iVar2;

  iVar2 = 10;
  do
  {
	// Create instance in particle pool
    iVar1 = FUN_80040308(0,*(undefined4 *)(PTR_DAT_8008d2ac + 0x2114),&DAT_80089d90);

	iVar2 = iVar2 + -1;
    if (iVar1 == 0) {
      return;
    }

	// position variables
    *(int *)(iVar1 + 0x24) = *(int *)(iVar1 + 0x24) + *(int *)(param_1 + 0x2d4);
    *(int *)(iVar1 + 0x2c) = *(int *)(iVar1 + 0x2c) + *(int *)(param_1 + 0x2d8);
    *(int *)(iVar1 + 0x34) = *(int *)(iVar1 + 0x34) + *(int *)(param_1 + 0x2dc);

  } while (iVar2 != 0);
  return;
}


// VehPtr_MaskGrab_Update
// param1 = thread, param2 = driver
void FUN_80066d4c(undefined4 param_1,int param_2)

{
  int iVar1;

  // NoInput timer = NoInput timer - elapsed milliseconds per frame, ~32
  iVar1 = (uint)*(ushort *)(param_2 + 0x400) - (uint)*(ushort *)(PTR_DAT_8008d2ac + 0x1d04);
  *(undefined2 *)(param_2 + 0x400) = (short)iVar1;

  // if negative
  if (iVar1 * 0x10000 < 0)
  {
	// set to zero
    *(undefined2 *)(param_2 + 0x400) = 0;
  }

  // when input is allowed,
  // which is when driver is spawned back over track
  if (*(short *)(param_2 + 0x400) == 0)
  {
	// maskObj
    iVar1 = *(int *)(param_2 + 0x580);
    
	if (iVar1 != 0) 
	{
	  // mask rotY
      *(ushort *)(iVar1 + 4) = *(ushort *)(iVar1 + 4) & 0xfffe;
      
	  // scale = 100%
	  *(undefined2 *)(*(int *)(param_2 + 0x580) + 0x12) = 0x1000;
    }

	// CameraDC flag
    *(uint *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_2 + 0x4a) * 0xdc + 0x1508) =
         *(uint *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_2 + 0x4a) * 0xdc + 0x1508) | 8;

	// VehPtr_MaskGrab_FindDestPos
	// driver, and quadblock (last valid)
    FUN_8006677c(param_2,*(undefined4 *)(param_2 + 0x354));

	// VehInit_TeleportSelf (back onto track)
    FUN_80057c8c(param_2,0,0x80);

	// VehPtr_EngineRevving_Init
    FUN_80067f4c(param_1,param_2);
  }
  return;
}

// VehPtr_MaskGrab_PhysLinear
// param1 = thread, param2 = driver
void FUN_80066e3c(undefined4 param_1,int param_2)

{
  // VehPtr_Driving_PhysLinear
  FUN_8006181c(param_1, param_2);

  // reset base speed
  *(undefined2 *)(param_2 + 0x39e) = 0;

  //reset Jump buffer Timer
  *(undefined2 *)(param_2 + 0x3f0) = 0;

  // reset base speed (again?)
  *(undefined2 *)(param_2 + 0x39e) = 0;

  // reset "basic" speed
  *(undefined2 *)(param_2 + 0x39c) = 0;

  // reset turning state
  *(undefined *)(param_2 + 0x4b) = 0;

  *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) & 0xfffdffdb | 8;
  return;
}

// VehPtr_MaskGrab_Animate
// param1 = thread, param2 = driver
void FUN_80066e8c(int param_1,int param_2)
{
  char cVar1;
  short sVar2;
  ushort uVar3;
  undefined2 uVar4;
  undefined4 uVar5;
  int iVar6;

  // get instance from thread
  iVar6 = *(int *)(param_1 + 0x34);

  // if driver touched ground before mask grab
  if (*(char *)(param_2 + 0x58d) == '\0') {

	//reset Kart emote
    *(undefined *)(param_2 + 0x4c) = 0;

	//reset Kart emote Frame
    *(undefined *)(param_2 + 0x4d) = 0;

	// set animation
    *(undefined *)(iVar6 + 0x52) = 0;

	// Instance_GetNumAnimFrames(instance, anim#0)
    uVar5 = FUN_8005b0f4(iVar6,0);

	// Instance_GetStartFrame(midpoint, numFrames)
    uVar4 = FUN_8005b0c4(0,uVar5);

    *(undefined2 *)(iVar6 + 0x54) = uVar4;
    *(undefined2 *)(param_2 + 0x368) = *(undefined2 *)(param_2 + 0x584);
    *(undefined2 *)(param_2 + 0x36a) = *(undefined2 *)(param_2 + 0x586);
    *(undefined2 *)(param_2 + 0x36c) = *(undefined2 *)(param_2 + 0x588);
  }

  // if driver did not touch ground (and is falling)
  else
  {
    if (
			// if whistle sound has not played
			(*(char *)(param_2 + 0x58f) == '\0') &&

			(*(short *)(param_2 + 0x400) < 0x3c0)
		)
	{
	  // OtherFX_Play "falling" sound, like a whistle
      FUN_80028468(0x55,1);

	  // whistle sound has played
      *(undefined *)(param_2 + 0x58f) = 1;
    }

    //Kart emote = Crashing
    *(undefined *)(param_2 + 0x4c) = 4;

	if (*(short *)(param_2 + 0x58a) < 3)
	{
      cVar1 = '\a';
    }

	else {
      cVar1 = *(char *)(param_2 + 0x58a) + '\x05';
    }
    //Crashing frame = cVar1
    *(char *)(param_2 + 0x4d) = cVar1;

	// change animation
    *(undefined *)(iVar6 + 0x52) = 2;

    sVar2 = 7;
    if (2 < *(short *)(param_2 + 0x58a)) {
      sVar2 = *(short *)(param_2 + 0x58a) + 5;
    }
    *(short *)(iVar6 + 0x54) = sVar2;
    sVar2 = *(short *)(param_2 + 0x58a) + 1;
    *(short *)(param_2 + 0x58a) = sVar2;
    if (7 < sVar2) {
      *(undefined2 *)(param_2 + 0x58a) = 7;
    }
    if (*(short *)(param_2 + 0x400) < 0x510) {
    	//Kart emote = Crashing
      *(undefined *)(param_2 + 0x4c) = 4;
      //Kart emote Frame = 12
      *(undefined *)(param_2 + 0x4d) = 0xc;

	  // set animation
      *(undefined *)(iVar6 + 0x52) = 2;

	  // set animation frame
      *(undefined2 *)(iVar6 + 0x54) = 0xc;

      if (*(short *)(param_2 + 0x400) < 0x3c1) {
        uVar3 = *(short *)(param_2 + 0x40c) - 800;
        *(ushort *)(param_2 + 0x40c) = uVar3;
        if ((int)((uint)uVar3 << 0x10) < 0) {
          *(undefined2 *)(param_2 + 0x40c) = 0;
        }
      }
      else 
	  {
		// if particles are not spawned
        if (*(char *)(param_2 + 0x58c) == '\0')
		{
		  // VehPtr_MaskGrab_Particles
          FUN_80066cb0(param_2);

		  // now they are spawned
          *(undefined *)(param_2 + 0x58c) = 1;
        }
        sVar2 = *(short *)(param_2 + 0x40c) + 0x2d0;
        *(short *)(param_2 + 0x40c) = sVar2;
        if (8000 < sVar2) {
          *(undefined2 *)(param_2 + 0x40c) = 8000;
        }
      }
    }
    else {
    	//reset Speed and Speed Approximate
      *(undefined2 *)(param_2 + 0x38c) = 0;
      *(undefined2 *)(param_2 + 0x38e) = 0;

      //position backups
      *(undefined4 *)(param_2 + 0x2d4) = *(undefined4 *)(param_2 + 0x2e0);
      *(undefined4 *)(param_2 + 0x2d8) = *(undefined4 *)(param_2 + 0x2e4);
      *(undefined4 *)(param_2 + 0x2dc) = *(undefined4 *)(param_2 + 0x2e8);
    }
  }
  
  // if maskObj
  if (*(int *)(param_2 + 0x580) != 0) 
  {
	// set mask duration
    *(undefined2 *)(*(int *)(param_2 + 0x580) + 6) = 0x1e00;
	
	// if more than 0.5s after player fell
    if (*(short *)(param_2 + 0x400) < 0x3c1) {
      
	  // if not lifting player
	  if (*(char *)(param_2 + 0x58e) == '\0') 
	  {
		// decrease mask posY by elapsed time
        *(short *)(*(int *)(param_2 + 0x580) + 0xe) =
		*(short *)(*(int *)(param_2 + 0x580) + 0xe) - *(short *)(PTR_DAT_8008d2ac + 0x1d04);
      }
	  
	  // if lifting player (if driver isn't falling infinitely)
      else
	  {
		// elapsed milliseconds per frame, ~32
        iVar6 = *(int *)(PTR_DAT_8008d2ac + 0x1d04);

		// speed = 0
        *(undefined2 *)(param_2 + 0x38c) = 0;
		
		// increase driver height, both posCurr and posPrev
        iVar6 = *(int *)(param_2 + 0x2d8) + iVar6 * 0x80;
        *(int *)(param_2 + 0x2d8) = iVar6;
		*(int *)(param_2 + 0x2e4) = iVar6;
      }
	  
	  // set mask posZ
      *(undefined2 *)(*(int *)(param_2 + 0x580) + 0x10) =
           (short)((uint)*(undefined4 *)(param_2 + 0x2dc) >> 8);
		   
	  // if mask posY < driver posY
      if ((int)*(short *)(*(int *)(param_2 + 0x580) + 0xe) < *(int *)(param_2 + 0x2d8) >> 8) 
	  {
		// mask posY = driver posY
        *(undefined2 *)(*(int *)(param_2 + 0x580) + 0xe) =
             (short)((uint)*(int *)(param_2 + 0x2d8) >> 8);
			 
		// boolLiftingPlayer = 1
        *(undefined *)(param_2 + 0x58e) = 1;
      }
	  
	  // maskPosX = driverPosX
      *(undefined2 *)(*(int *)(param_2 + 0x580) + 0xc) =
           (short)((uint)*(undefined4 *)(param_2 + 0x2d4) >> 8);
	
	  // if more than halfway through mask pickup
      if ((int)*(short *)(param_2 + 0x400) < 0x2d1) 
	  {
		// scale = 100%
        *(undefined2 *)(*(int *)(param_2 + 0x580) + 0x12) = 0x1000;
      }
      
	  // if less than half
	  else 
	  {
		// interpolate scale
        *(undefined2 *)(*(int *)(param_2 + 0x580) + 0x12) =
             (short)(((0x3c0 - (int)*(short *)(param_2 + 0x400)) * 0x1000) / 0xf0);
      }
    }
    
	// less than 0.5s after player fell
	else 
	{
	  // scale = 0%
      *(undefined2 *)(*(int *)(param_2 + 0x580) + 0x12) = 0;
    }
  }
  return;
}


// VehPtr_MaskGrab_Init
// when falling off track
// param1 = thread, param2 = driver
void FUN_800671b0(int param_1,int param_2)
{
  // When this function executes,
  // mask comes down to catch you

  undefined4 uVar1;
  int iVar2;
  int iVar3;
  int iVar4;

  // get instance from thread
  iVar4 = *(int *)(param_1 + 0x34);

  // now being mask grabbed
  *(undefined *)(param_2 + 0x376) = 5;

  *(undefined *)(param_2 + 0x58c) = 0;
  *(undefined2 *)(param_2 + 0x58a) = 0;
  *(undefined *)(param_2 + 0x58e) = 0;

  // reset whistle bool
  *(undefined *)(param_2 + 0x58f) = 0;

  // reset stillFalling bool
  *(undefined *)(param_2 + 0x58d) = 0;

  // Weapon_Mask_UseWeapon
  uVar1 = FUN_80064c38(param_2,1);

  // Mask Object
  *(undefined4 *)(param_2 + 0x580) = uVar1;

  *(undefined2 *)(param_2 + 0x3dc) = 0;
  *(undefined2 *)(param_2 + 0x3e2) = 0;
  *(undefined2 *)(param_2 + 0x3de) = 0;
  *(undefined *)(param_2 + 0x4c) = 0;
  *(undefined *)(param_2 + 0x4d) = 0;

  // 1.44s until spawned back over track
  *(undefined2 *)(param_2 + 0x400) = 0x5a0;

  *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) & 0xfff7ffbf;

  // Check if 231 dll is loaded
  iVar2 = FUN_800348e8();

  if (
		// If it is loaded
		(iVar2 != 0) &&

		// If you're not in Adventure Arena
		((*(uint *)PTR_DAT_8008d2ac & 0x100000) == 0)
	  )
  {
	// RB_Player_ModifyWumpa, -2
    FUN_800abefc(param_2,0xfffffffe);
  }
  // if stored quadblock height + 0x8000 < posCurr.y
  if (*(int *)(param_2 + 0x2d0) + 0x8000 < *(int *)(param_2 + 0x2d8)) 
  {
	// mask grab count (for end of race comments)
    *(char *)(param_2 + 0x56a) = *(char *)(param_2 + 0x56a) + '\x01';

	// if driver touched surface before mask grab
	if (
			// if height is low
			// like splashing water on coco park happens on low height,
			// not high height when you're on the grass
			(*(int *)(param_2 + 0x2d8) < -0x8000) &&
			(
				// 10 particles
				iVar2 = 10,

				// if mask should grab you when underwater
				(*(uint *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0xdc) & 2) != 0
			)
		)
	{
	  // AngleAxis normalVec
      *(undefined2 *)(param_2 + 0x584) = *(undefined2 *)(param_2 + 0x368);
      *(undefined2 *)(param_2 + 0x586) = *(undefined2 *)(param_2 + 0x36a);
      *(undefined2 *)(param_2 + 0x588) = *(undefined2 *)(param_2 + 0x36c);

	  // spawn particles
      do
	  {
		// 0x2138 = "falling",
		// like splashing in water on coco park

		// Create instance in particle pool
        iVar3 = FUN_80040308(0,*(undefined4 *)(PTR_DAT_8008d2ac + 0x2138),&DAT_80089a94);

		// if particle exists
		if (iVar3 != 0) {
          *(undefined *)(iVar3 + 0x18) = *(undefined *)(*(int *)(param_2 + 0x1c) + 0x50);

		  // driver -> instSelf
          *(undefined4 *)(iVar3 + 0x20) = *(undefined4 *)(param_2 + 0x1c);

		  // driverID
          *(undefined *)(iVar3 + 0x19) = *(undefined *)(param_2 + 0x4a);
        }

		// loop counter
        iVar2 = iVar2 + -1;

      } while (iVar2 != 0);
    }

	// if driver did not touch surface (and is still falling)
    else
	{
	  // save result in a bool
      *(undefined *)(param_2 + 0x58d) = 1;
    }
  }
  else 
  {
	// AngleAxis normalVec
    *(undefined2 *)(param_2 + 0x584) = *(undefined2 *)(param_2 + 0x368);
    *(undefined2 *)(param_2 + 0x586) = *(undefined2 *)(param_2 + 0x36a);
    *(undefined2 *)(param_2 + 0x588) = *(undefined2 *)(param_2 + 0x36c);
  }
  
  // edits position
  *(int *)(param_2 + 0x2d4) = *(int *)(iVar4 + 0x44) << 8;
  iVar2 = *(int *)(param_2 + 0x580);
  *(int *)(param_2 + 0x2d8) = *(int *)(iVar4 + 0x48) << 8;
  *(int *)(param_2 + 0x2dc) = *(int *)(iVar4 + 0x4c) << 8;
  
  //set previous frame velocity to the same as current frame velocity
  *(undefined4 *)(param_2 + 0x2e4) = *(undefined4 *)(param_2 + 0x2d8);
  *(undefined4 *)(param_2 + 0x2e0) = *(undefined4 *)(param_2 + 0x2d4);
  *(undefined4 *)(param_2 + 0x2e8) = *(undefined4 *)(param_2 + 0x2dc);
  
  // if maskObj
  if (iVar2 != 0) 
  {
    *(ushort *)(iVar2 + 4) = *(ushort *)(iVar2 + 4) | 1;
	
	// maskX = driverX
    *(undefined2 *)(*(int *)(param_2 + 0x580) + 0xc) =
         (short)((uint)*(undefined4 *)(param_2 + 0x2d4) >> 8);
		 
	// maskY = driverY
    *(short *)(*(int *)(param_2 + 0x580) + 0xe) =
         (short)((uint)*(undefined4 *)(param_2 + 0x2d8) >> 8) + 0x140;
		 
	// maskZ = driverZ
    *(undefined2 *)(*(int *)(param_2 + 0x580) + 0x10) =
         (short)((uint)*(undefined4 *)(param_2 + 0x2dc) >> 8);
  }

  // VehPtr_MaskGrab_Update
  *(undefined4 *)(param_2 + 0x58) = 0x80066d4c;

  // VehPtr_MaskGrab_PhysLinear
  *(undefined4 *)(param_2 + 0x5c) = 0x80066e3c;

  *(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
  *(undefined4 *)(param_2 + 100) = 0x8005fc8c; // OnPhysAngular
  *(undefined4 *)(param_2 + 0x68) = 0x8005ea60; // OnApplyForces
  *(undefined4 *)(param_2 + 0x6c) = 0x80020410; // OnCollide_QuadblockTouch
  *(undefined4 *)(param_2 + 0x70) = 0x8005ebac; // OnCollide_Drivers
  *(undefined4 *)(param_2 + 0x74) = 0x8001d944; // OnCollide_QuadblockNear
  *(undefined4 *)(param_2 + 0x78) = 0x80060630; // JumpAndFriction
  *(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix

  // VehPtr_MaskGrab_Animate
  *(undefined4 *)(param_2 + 0x80) = 0x80066e8c;

  *(undefined4 *)(param_2 + 0x54) = 0;

  // VehParticle_DriverMain
  *(undefined4 *)(param_2 + 0x84) = 0x80059a18;

  return;
}


// VehPtr_EatenByPlant_Update
void FUN_8006749c(int param_1,int param_2)

{
  int iVar1;
  int iVar2;

  // get instance from thread
  iVar2 = *(int *)(param_1 + 0x34);

  // NoInput timer = NoInput timer - elapsed milliseconds per frame, ~32
  iVar1 = (uint)*(ushort *)(param_2 + 0x400) - (uint)*(ushort *)(PTR_DAT_8008d2ac + 0x1d04);
  *(undefined2 *)(param_2 + 0x400) = (short)iVar1;

  // if negative
  if (iVar1 * 0x10000 < 0)
  {
	// set to zero
    *(undefined2 *)(param_2 + 0x400) = 0;
  }

  // when input is now allowed
  if (*(short *)(param_2 + 0x400) == 0)
  {
	// VehPtr_MaskGrab_FindDestPos
	// driver, and quadblock previously touched by driver
    FUN_8006677c(param_2,*(undefined4 *)(param_2 + 0x354));

	// VehInit_TeleportSelf (back onto track)
    FUN_80057c8c(param_2,0,0x80);

	// enable collision for this thread
    *(uint *)(param_1 + 0x1c) = *(uint *)(param_1 + 0x1c) & 0xffffefff;

	// make visible
	*(uint *)(iVar2 + 0x28) = *(uint *)(iVar2 + 0x28) & 0xffffff7f;

	// VehPtr_EngineRevving_Init
	// this lets you rev engine while falling
	FUN_80067f4c(param_1,param_2);
  }
  return;
}


// VehPtr_EatenByPlant_PhysLinear
void FUN_80067554(undefined4 param_1,int param_2)

{
  undefined *puVar1;

  // VehPtr_Driving_PhysLinear
  FUN_8006181c();

  // reset speed
  *(undefined2 *)(param_2 + 0x39e) = 0;

  // reset jump variable
  *(undefined2 *)(param_2 + 0x3f0) = 0;

  // reset two speed variables
  *(undefined2 *)(param_2 + 0x39e) = 0;
  *(undefined2 *)(param_2 + 0x39c) = 0;

  *(undefined *)(param_2 + 0x4b) = 0;
  puVar1 = PTR_DAT_8008d2ac;
  
  // acceleration prevention,
  // drop bits for jump button, 0x20?, reversing engine
  *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) & 0xfffdffdb | 8;
  
  // increment time spent in mask grab
  *(int *)(param_2 + 0x548) = *(int *)(param_2 + 0x548) + *(int *)(puVar1 + 0x1d04);
  
  return;
}



// WARNING: Could not reconcile some variable overlaps

// VehPtr_EatenByPlant_Animate
// param1 = thread, param2 = driver
void FUN_800675c0(undefined4 param_1,int param_2)

{
  short sVar1;
  undefined *puVar2;
  long x;
  int iVar3;
  int iVar4;
  SVECTOR local_38;
  int local_30;
  int local_28;
  long alStack32 [2];

  // plantEatingMe
  iVar3 = *(int *)(param_2 + 0x4a8);
  
  if (
		(
			// if plant is eating me
			(iVar3 != 0) && 
			
			// if not initialized
			(*(char *)(param_2 + 0x580) == '\0')
		) &&
		
		// if more than 0.5s since player death
		(*(short *)(param_2 + 0x400) < 0xb40))
  {
	// get instance from thread
    iVar4 = *(int *)(iVar3 + 0x34);

	// initialized, player eaten
    *(undefined *)(param_2 + 0x580) = 1;
	
    local_38.vx = -0xfa;
    if (*(short *)(*(int *)(iVar3 + 0x30) + 4) == 0) {
      local_38.vx = 0xfa;
    }
    local_38.vy = 0;
    local_38.vz = 0x2ee;

	// driver -> instance -> matrix
    SetRotMatrix((MATRIX *)(iVar4 + 0x30));

	// driver -> instance -> matrix
    SetTransMatrix((MATRIX *)(iVar4 + 0x30));

    RotTrans(&local_38,(VECTOR *)&local_30,alStack32);
    puVar2 = PTR_DAT_8008d2ac;

	// tileView->posX
    *(undefined2 *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_2 + 0x4a) * 0x110 + 0x168) =
         (undefined2)local_30;

	// tileView->posY
	*(short *)(puVar2 + (uint)*(byte *)(param_2 + 0x4a) * 0x110 + 0x16a) =

		// driverY + 0xc0
         *(short *)(iVar4 + 0x48) + 0xc0;

	// tileView->posZ
    *(undefined2 *)(puVar2 + (uint)*(byte *)(param_2 + 0x4a) * 0x110 + 0x16c) =
		(undefined2)local_28;

	// cameraX = cameraX - driverX
    local_30 = local_30 - *(int *)(iVar4 + 0x44);

	// get tileView->rotX
    sVar1 = *(short *)(puVar2 + (uint)*(byte *)(param_2 + 0x4a) * 0x110 + 0x16a);

	// driverZ
	iVar3 = *(int *)(iVar4 + 0x48);

	// cameraZ = cameraZ - driverZ
    local_28 = local_28 - *(int *)(iVar4 + 0x4c);

	// get direction from camera to driver
    x = ratan2(local_30,local_28);

	// tileView-> ??? right after rotZ
    *(short *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_2 + 0x4a) * 0x110 + 0x170) = (short)x;

	// get distance between car and camera
	x = SquareRoot0(local_30 * local_30 + local_28 * local_28);

	// what???
    x = ratan2(sVar1 - iVar3,x);

    puVar2 = PTR_DAT_8008d2ac;

	// camera->rotZ
    *(short *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_2 + 0x4a) * 0x110 + 0x16e) =
         0x800 - (short)x;

	// camera-> ???
	*(undefined2 *)(puVar2 + (uint)*(byte *)(param_2 + 0x4a) * 0x110 + 0x172) = 0;
  }
  return;
}


// VehPtr_EatenByPlant_Init
// when eaten by plant on papu pyramid
// param1 = thread, param2 = driver
void FUN_800677d0(int param_1,int param_2)
{
  // when this function executes, you are lifted
  // above the track by the mask, where you respawn

  int iVar1;
  int iVar2;

  iVar2 = *(int *)(param_1 + 0x34);
  
  // set state to mask grab, so nobody hits you with weapon
  *(undefined *)(param_2 + 0x376) = 5;
  
  // boolInited = false
  *(undefined *)(param_2 + 0x580) = 0;
  
  *(undefined2 *)(param_2 + 0x3dc) = 0;
  *(undefined2 *)(param_2 + 0x3e2) = 0;
  *(undefined2 *)(param_2 + 0x3de) = 0;
  
  // drop bits for airborne (and another?)
  *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) & 0xfff7ffbf;

  // "cloud" is the raincloud after hitting red potion

  // if thread of "cloud" exists
  if (*(int *)(param_2 + 0x4a0) != 0)
  {
    *(undefined2 *)(*(int *)(*(int *)(param_2 + 0x4a0) + 0x30) + 4) = 0;

	// Set driver->cloudTh->funcThTick to destroy thread
    *(undefined4 *)(*(int *)(param_2 + 0x4a0) + 0x2c) = 0x800b0f1c;

	// erase pointer to "cloud" thread
    *(undefined4 *)(param_2 + 0x4a0) = 0;
  }

  // Check if 231 dll is loaded
  iVar1 = FUN_800348e8();

  if (
		// If it is loaded
		(iVar1 != 0) &&

		// If you're not in Adventure Arena
		((*(uint *)PTR_DAT_8008d2ac & 0x100000) == 0)
	)
  {
	// RB_Player_ModifyWumpa, -2
    FUN_800abefc(param_2,0xfffffffe);
  }

  // allow this thread to ignore all collisions
  *(uint *)(param_1 + 0x1c) = *(uint *)(param_1 + 0x1c) | 0x1000;

  // make invisible
  *(uint *)(iVar2 + 0x28) = *(uint *)(iVar2 + 0x28) | 0x80;

  // OtherFX_Stop1 (three sounds)
  FUN_80028808(*(undefined4 *)(param_2 + 0x304));
  *(undefined4 *)(param_2 + 0x304) = 0;
  FUN_80028808(*(undefined4 *)(param_2 + 0x308));
  *(undefined4 *)(param_2 + 0x308) = 0;
  FUN_80028808(*(undefined4 *)(param_2 + 0x300));

  // VehPtr_EatenByPlant_Update
  *(undefined4 *)(param_2 + 0x58) = 0x8006749c;

  // VehPtr_EatenByPlant_PhysLinear
  *(undefined4 *)(param_2 + 0x5c) = 0x80067554;

  *(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
  *(undefined4 *)(param_2 + 0x300) = 0;
  *(undefined4 *)(param_2 + 0x54) = 0;
  *(undefined4 *)(param_2 + 100) = 0;
  *(undefined4 *)(param_2 + 0x68) = 0;
  *(undefined4 *)(param_2 + 0x6c) = 0; // OnCollide_QuadblockTouch
  *(undefined4 *)(param_2 + 0x70) = 0; // OnCollide_Drivers
  *(undefined4 *)(param_2 + 0x74) = 0; // OnCollide_QuadblockNear
  *(undefined4 *)(param_2 + 0x78) = 0; // cant move anymore
  *(undefined4 *)(param_2 + 0x7c) = 0;

  // VehPtr_EatenByPlant_Animate
  *(undefined4 *)(param_2 + 0x80) = 0x800675c0;

  // no particles
  *(undefined4 *)(param_2 + 0x84) = 0;
  return;
}

// VehPtr_Dead_Init
// param1 = thread, param2 = driver
void FUN_80067930(undefined4 param_1,int param_2)
{
  // VehPtr_EatenByPlant_Init
  FUN_800677d0(param_1, param_2);

  // erase OnUpdate
  *(undefined4 *)(param_2 + 0x58) = 0;

  // erase OnAnimate
  *(undefined4 *)(param_2 + 0x80) = 0;

  // erase invisibleTimer
  *(undefined4 *)(param_2 + 0x28) = 0;

  return;
}


// VehPtr_EngineRevving_Update
// param1 = thread, param2 = driver
void FUN_80067960(undefined4 param_1,int param_2)

{
  undefined4 uVar1;

  // If race has not started
  if (*(char *)(param_2 + 0x594) == '\0')
  {
	// If Traffic Lights are not done counting down
    if (0 < *(int *)(PTR_DAT_8008d2ac + 0x1d0c))
	{
	  // Dont continue with the function,
	  // let your kart stay in a revving state
      return;
    }
  }

  // If race has started
  else
  {

	// If mask grab has not lowered you close
	// enough to the track to let you go
    if (*(int *)(param_2 + 0x2d0) + 0x4000 <= *(int *)(param_2 + 0x2d8))
	{
	  // Dont continue with the function,
	  // let your kart stay in a revving state
      return;
    }
  }

  // Assume it's time to transition out of being
  // frozen, and into driving, last iteration of
  // this function

  if (
		// if reason for revving is mask grab
		(*(char *)(param_2 + 0x594) != '\0') &&

		// if maskObj exists
		(*(int *)(param_2 + 0x580) != 0)
	  )
  {
	// end duration
    *(undefined2 *)(*(int *)(param_2 + 0x580) + 6) = 0;
  }

  if (
		// If sacred fire constant is less than 				???
		((int)*(short *)(param_2 + 0x42e) < *(int *)(param_2 + 0x588)) &&
		((*(byte *)(param_2 + 0x593) & 3) == 0)
	 )
  {

    if (
		// While not moving, if you rev'd your engine less than...
		*(int *)(param_2 + 0x584) <

        (int)*(short *)(param_2 + 0x42e) + (int)*(short *)(param_2 + 0x432))
	{
	  // You get a small boost
      uVar1 = 0x20;
    }

	// if you rev'd your engine high
    else
	{
	  // you get a big boost
      uVar1 = 0x80;
    }

	// Turbo_Increment
	// one full second of reserves
    FUN_8005abfc(param_2,0x3c0,0,uVar1);
  }
  *(undefined2 *)(param_2 + 0x3dc) = 0;
  *(undefined *)(param_2 + 0x4fe) = 0;

  // VehPtr_Driving_Init
  FUN_80062b74(param_1);
  return;
}


// VehPtr_EngineRevving_PhysLinear
// param1 = thread, param2 = driver
void FUN_80067a74(undefined4 param_1,int param_2)

{
  undefined *puVar1;
  int iVar2;

												// elapsed milliseconds per frame, ~32
  iVar2 = (uint)*(ushort *)(param_2 + 0x58e) - (uint)*(ushort *)(PTR_DAT_8008d2ac + 0x1d04);

  *(undefined2 *)(param_2 + 0x58e) = (short)iVar2;
  if (iVar2 * 0x10000 < 0) {
    *(undefined2 *)(param_2 + 0x58e) = 0;
  }
												// elapsed milliseconds per frame, ~32
  iVar2 = (uint)*(ushort *)(param_2 + 0x590) - (uint)*(ushort *)(PTR_DAT_8008d2ac + 0x1d04);
  *(undefined2 *)(param_2 + 0x590) = (short)iVar2;
  if (iVar2 * 0x10000 < 0) {
    *(undefined2 *)(param_2 + 0x590) = 0;
  }

  // VehPtr_Driving_PhysLinear
  FUN_8006181c(param_1,param_2);

  puVar1 = PTR_DAT_8008d2ac;

  // if race already started
  if (*(char *)(param_2 + 0x594) != '\0')
  {
	// cameraDC flag
    *(uint *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_2 + 0x4a) * 0xdc + 0x1508) =
         *(uint *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_2 + 0x4a) * 0xdc + 0x1508) | 0x10;

    *(undefined2 *)(puVar1 + (uint)*(byte *)(param_2 + 0x4a) * 0xdc + 0x1530) = 0x40;

    // Y pos -= 0x200
    *(int *)(param_2 + 0x2d8) = *(int *)(param_2 + 0x2d8) + -0x200;
    
	// if maskObj exists
	if (*(int *)(param_2 + 0x580) != 0) 
	{
	  // set mask duration
      *(undefined2 *)(*(int *)(param_2 + 0x580) + 6) = 0x1e00;
    }
  }
  return;
}


// VehPtr_EngineRevving_Animate
// param1 = thread, param2 = driver
void FUN_80067b7c(int param_1,int param_2)

{
  byte bVar1;
  bool bVar2;
  undefined2 uVar3;
  int iVar4;
  int local_18;
  short sVar5;
  undefined4 uVar6;
  int iVar7;
  uint uVar8;
  int iVar9;
  int iVar10;

  // thread -> instance
  iVar10 = *(int *)(param_1 + 0x34);

  if (((0 < *(short *)(param_2 + 0x39e)) && (*(short *)(param_2 + 0x58e) == 0)) &&
     ((*(byte *)(param_2 + 0x593) & 3) == 0)) {

	// Curr revving meter   -   Max revving meter
	iVar4 = *(int *)(param_2 + 0x588) - *(int *)(param_2 + 0x584);

	// absolute value
	if (iVar4 < 0) {
      iVar4 = -iVar4;
    }

	// NOPing will fill meter in
	// slow motion, showing how it works
	iVar4 = iVar4 >> 1;

	iVar7 = iVar4;

	// Speed of filling the meter changes
	// depending on how full the meter is,
	// there are two speeds

	if (5000 < iVar4) {
      iVar7 = 5000;
    }

	if (iVar4 < 0x100) {
      iVar7 = 0x100;
    }

	// Interpolate turboMeter by speed
	// parameters: curr revving meter and meter filling speed
    iVar4 = FUN_80058f54(*(int *)(param_2 + 0x588),iVar7);

	// Set new curr rev
    *(int *)(param_2 + 0x588) = iVar4;

    *(undefined *)(param_2 + 0x592) = 2;

    // if max revv > filling speed
    if (iVar4 < *(int *)(param_2 + 0x584)) {
      *(undefined2 *)(param_2 + 0x58c) = 0;
    }

    else
    {
	  // elapsed milliseconds per frame, ~32
      sVar5 = *(short *)(param_2 + 0x58c) + *(short *)(PTR_DAT_8008d2ac + 0x1d04);
      *(short *)(param_2 + 0x58c) = sVar5;

	  // if more than 0.192s
	  if (0xc0 < sVar5) 
	  {
        *(undefined *)(param_2 + 0x592) = 0;
        *(byte *)(param_2 + 0x593) = *(byte *)(param_2 + 0x593) | 3;

		// OtherFX_Play_Echo
        FUN_80028494(0xf,1,(uint)*(ushort *)(param_2 + 0x2ca) & 1);
      }
    }
    goto LAB_80067dec;
  }
  *(undefined2 *)(param_2 + 0x58c) = 0;
  if (*(char *)(param_2 + 0x592) == '\x02') {
    *(undefined2 *)(param_2 + 0x58e) = 0x100;
    *(undefined *)(param_2 + 0x592) = 0;

    // if curr rev > ???
    if ((int)*(short *)(param_2 + 0x42e) < *(int *)(param_2 + 0x588)) {
      *(undefined *)(param_2 + 0x592) = 1;
    }
  }
  if ((*(char *)(param_2 + 0x592) != '\0') &&

    // curr rev < ???
     (*(int *)(param_2 + 0x588) < (int)*(short *)(param_2 + 0x42e))) {
    *(undefined *)(param_2 + 0x592) = 0;

	  // Interpolate rotation by speed
    // params: max revv, ???
    uVar6 = FUN_80058f54(*(undefined4 *)(param_2 + 0x584),(int)*(short *)(param_2 + 0x432) / 3 + 3);

    // max rev = ???
    *(undefined4 *)(param_2 + 0x584) = uVar6;
  }

  // if curr rev < 1
  if (*(int *)(param_2 + 0x588) < 1) {
    *(byte *)(param_2 + 0x593) = *(byte *)(param_2 + 0x593) & 0xfd;

    // max rev = ???
    *(int *)(param_2 + 0x584) =
         (int)*(short *)(param_2 + 0x42e) + (int)*(short *)(param_2 + 0x432) / 3;
  }

  // if curr rev >= 1
  else {

    // rev deacceleration rate = curr rev / 2
    uVar8 = *(int *)(param_2 + 0x588) >> 1;

    if ((*(byte *)(param_2 + 0x593) & 2) == 0) {
      bVar2 = (int)uVar8 < 0x100;

      // if rev deacceleration rate > 1000
      if (1000 < (int)uVar8) {

        // rev deacceleration rate = 1000
        uVar8 = 1000;
        goto LAB_80067d64;
      }
    }

    else {
      bVar2 = (int)uVar8 < 0x100;

      // if rev deacceleration rate > 3000
      if (3000 < (int)uVar8) {

        // rev deacceleration rate = 3000
        uVar8 = 3000;
LAB_80067d64:
        bVar2 = uVar8 < 0x100;
      }
    }
    if (bVar2) {

      // rev deacceleration rate = 0x100
      uVar8 = 0x100;
    }

    // new rev = curr rev - rev deacceleration rate
    iVar4 = *(int *)(param_2 + 0x588) - uVar8;

    // curr rev = new rev
    *(int *)(param_2 + 0x588) = iVar4;

    // if new rev < 1
    if (iVar4 < 1) {

      *(undefined2 *)(param_2 + 0x590) = 0xc0;

      // curr rev = 0
      *(undefined4 *)(param_2 + 0x588) = 0;
    }
  }
  if (*(short *)(param_2 + 0x39e) < 1) {
    *(byte *)(param_2 + 0x593) = *(byte *)(param_2 + 0x593) & 0xfe;
  }
LAB_80067dec:
  if ((*(uint *)(param_2 + 0x590) & 0x200ffff) == 0) {

    // if curr rev < ???
    if (*(int *)(param_2 + 0x588) < (int)*(short *)(param_2 + 0x42e)) {
      *(undefined *)(param_2 + 0x4fe) = 0;
    }
    else {
      *(undefined *)(param_2 + 0x4fe) = 1;
    }
  }
  else {
    *(undefined *)(param_2 + 0x4fe) = 2;
  }
  iVar4 = (int)*(short *)(param_2 + 0x42e);

  // ??? = curr rev
  *(undefined2 *)(param_2 + 0x36e) = *(undefined2 *)(param_2 + 0x588);

  // if curr rev < ???
  if (*(int *)(param_2 + 0x588) < iVar4)
  {

	// 476 and 447 can be absolutely any value,
	// by default they are 15 and 30, but as long as
	// they are proportional (1 and 2, 4 and 8), they
	// behave the same as 15 and 30

    bVar1 = *(byte *)(param_2 + 0x476);

	// 477 changes when meter turns red
    local_18 = (uint)*(byte *)(param_2 + 0x477) * 0x20 + 1;

	  // curr rev
    uVar6 = *(undefined4 *)(param_2 + 0x588);
    iVar7 = 0;
    iVar9 = iVar4;
  }
  else
  {
	// 477 changes when meter turns red
    bVar1 = *(byte *)(param_2 + 0x477);

    local_18 = 1;

	// curr rev
	uVar6 = *(undefined4 *)(param_2 + 0x588);
    iVar9 = iVar4 + *(short *)(param_2 + 0x432);
    iVar7 = iVar4;
  }

  // Get percentage of uVar6 between iVar7 and iVar9,
  // then return that same percentage between bVar1<<5 and local18
  // Map value from [oldMin, oldMax] to [newMin, newMax]
  // inverting newMin and newMax will give an inverse range mapping
  uVar3 = FUN_80058f9c(uVar6,iVar7,iVar9,(uint)bVar1 << 5,local_18);

  *(undefined2 *)(param_2 + 0x3dc) = uVar3;
  *(undefined4 *)(param_2 + 0x490) = 0;
  iVar4 = (int)((uint)*(ushort *)(param_2 + 0x36e) << 0x10) >> 0x16;

  *(short *)(param_2 + 0x40c) = (short)*(ushort *)(param_2 + 0x36e) >> 6;

  if (iVar4 < 0x401) {
    if (iVar4 < 0) {
      *(undefined2 *)(param_2 + 0x40c) = 0;
    }
  }

  else {
    *(undefined2 *)(param_2 + 0x40c) = 0x400;
  }

  // Set the scale of the car while revving the engine,
  // this is a basic "squash and stretch" concept of animation, before motion

  // Reduce height a little
  *(short *)(iVar10 + 0x1e) = 0xccc - *(short *)(param_2 + 0x40c);

  // Increase X and Z a little
  *(short *)(iVar10 + 0x1c) = (short)(((int)*(short *)(param_2 + 0x40c) * 6) / 10) + 0xccc;
  *(short *)(iVar10 + 0x20) = (short)(((int)*(short *)(param_2 + 0x40c) * 6) / 10) + 0xccc;

  return;
}

// VehPtr_EngineRevving_Init
// param1 = thread, param2 = driver
void FUN_80067f4c(undefined4 param_1,int param_2)

{
  // spawn function that waits for traffic lights

  undefined4 uVar1;

  // kart state to rev
  *(undefined *)(param_2 + 0x376) = 4;

  *(undefined *)(param_2 + 0x4fe) = 0;
  *(undefined4 *)(param_2 + 0x588) = 0;

  // assume reason for revving is: start of race
  *(undefined *)(param_2 + 0x594) = 0;

  // clear maskObj
  *(undefined4 *)(param_2 + 0x580) = 0;

  // if this is a mask grab
  if (*(int *)(param_2 + 0x2d0) + 0x1000 < *(int *)(param_2 + 0x2d8))
  {
	// assume reason for revving is: mask grab
    *(undefined *)(param_2 + 0x594) = 1;

	// Weapon_Mask_UseWeapon
    uVar1 = FUN_80064c38(param_2,0);

	// Mask Object
    *(undefined4 *)(param_2 + 0x580) = uVar1;

	// Driver flag
    *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) & 0xfffffffe;

	// CameraDC flag
    *(uint *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_2 + 0x4a) * 0xdc + 0x1508) =
         *(uint *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_2 + 0x4a) * 0xdc + 0x1508) | 8;
  }
  
  // firstFrameSinceEngineRevving
  *(undefined *)(param_2 + 0x449) = 1;

  // VehPtr_EngineRevving_Update
  *(undefined4 *)(param_2 + 0x58) = 0x80067960;

  // VehPtr_EngineRevving_PhysLinear
  *(undefined4 *)(param_2 + 0x5c) = 0x80067a74;

  *(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
  *(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix

  // VehPtr_EngineRevving_Animate
  *(undefined4 *)(param_2 + 0x80) = 0x80067b7c;

  // VehParticle_DriverMain
  *(undefined4 *)(param_2 + 0x84) = 0x80059a18;

  *(undefined2 *)(param_2 + 0x58c) = 0;
  *(undefined2 *)(param_2 + 0x58e) = 0;
  *(undefined *)(param_2 + 0x592) = 0;
  *(undefined *)(param_2 + 0x593) = 0;
  *(undefined2 *)(param_2 + 0x590) = 0;
  *(undefined4 *)(param_2 + 0x54) = 0;
  *(undefined4 *)(param_2 + 100) = 0;
  *(undefined4 *)(param_2 + 0x68) = 0;
  *(undefined4 *)(param_2 + 0x6c) = 0; // OnCollide_QuadblockTouch
  *(undefined4 *)(param_2 + 0x70) = 0; // OnCollide_Drivers
  *(undefined4 *)(param_2 + 0x74) = 0; // OnCollide_QuadblockNear
  *(undefined4 *)(param_2 + 0x78) = 0; // cant move anymore
  *(int *)(param_2 + 0x584) =
       (int)*(short *)(param_2 + 0x42e) + (int)*(short *)(param_2 + 0x432) / 3;
  return;
}


// VehPtr_Blasted_Update
// param1 = thread, param2 = driver
void FUN_8006809c(undefined4 param_1,int param_2)

{
  // if you are done being blasted, NoInput ended
  if (*(short *)(param_2 + 0x400) == 0) {
    *(undefined *)(param_2 + 0x4c) = 0;
    *(undefined *)(param_2 + 0x4d) = 0;

	// VehPtr_Driving_Init
    FUN_80062b74();
  }
  return;
}

// VehPtr_Blasted_PhysLinear
// param1 = thread, param2 = driver
void FUN_800680d0(undefined4 param_1,int param_2)

{
  int iVar1;

  // NoInput timer = NoInput timer -  elapsed milliseconds per frame, ~32
  iVar1 = (uint)*(ushort *)(param_2 + 0x400) - (uint)*(ushort *)(PTR_DAT_8008d2ac + 0x1d04);
  *(undefined2 *)(param_2 + 0x400) = (short)iVar1;

  // if negative
  if (iVar1 * 0x10000 < 0)
  {
	// set to zero
    *(undefined2 *)(param_2 + 0x400) = 0;
  }

  // VehPtr_Driving_PhysLinear
  FUN_8006181c(param_1,param_2);

  // force to jump when hit the ground,
  // lock to 96ms (0.1s) until blasted state is over
  *(undefined2 *)(param_2 + 0x3f6) = 0x60;

  // reset two speed variables
  *(undefined2 *)(param_2 + 0x39c) = 0;
  *(undefined2 *)(param_2 + 0x39e) = 0;

  // wheels skidding, blasted, accel prevention
  *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) | 0x5808;
  
  // jump_InitialVelY to throw driver in air
  *(short *)(param_2 + 0x3f8) = *(short *)(param_2 + 0x400) * 2 + 6000;
  
  return;
}


// VehPtr_Blasted_PhysAngular
// param1 = thread, param2 = driver
void FUN_80068150(undefined4 param_1,int param_2)

{
  undefined *puVar1;
  ushort uVar2;
  undefined2 uVar3;
  short sVar4;

  puVar1 = PTR_DAT_8008d2ac;
  *(undefined2 *)(param_2 + 0x3e6) = 10000;
  
  // decrease turn rate by 1/8 of itself
  *(short *)(param_2 + 0x3b4) = *(short *)(param_2 + 0x3b4) - (*(short *)(param_2 + 0x3b4) >> 3);
  
  sVar4 = *(short *)(param_2 + 0x3d2) - (*(short *)(param_2 + 0x3d2) >> 3);
  *(short *)(param_2 + 0x3d2) = sVar4;
  
  *(short *)(param_2 + 0xc0) = *(short *)(param_2 + 0x3b4);
  *(short *)(param_2 + 0x3c6) = (*(short *)(param_2 + 0x3c6) + sVar4 + 0x800U & 0xfff) - 0x800;
  *(short *)(param_2 + 0x3d4) = *(short *)(param_2 + 0x3d4) - (*(short *)(param_2 + 0x3d4) >> 3);

  // angle change = angle + (spinRate * time lapsed between frames) & 0xFFF
  uVar2 = *(short *)(param_2 + 0x39a) +
          (short)((int)*(short *)(param_2 + 0x3b4) * *(int *)(puVar1 + 0x1d04) >> 0xd) & 0xfff;

  // angle = angle change
  *(ushort *)(param_2 + 0x39a) = uVar2;
  
  // cameraRotY = ??? + kart angle + drift angle
  *(short *)(param_2 + 0x2ee) = *(short *)(param_2 + 0x3d4) + uVar2 + *(short *)(param_2 + 0x3c6);

  // Interpolate rotation by speed
  uVar3 = FUN_80058f54((int)*(short *)(param_2 + 0x2f2),(*(int *)(puVar1 + 0x1d04) << 5) >> 5,0);

  // set new camera rotation
  *(undefined2 *)(param_2 + 0x2f2) = uVar3;

  // Rot_AxisAngle
  FUN_8005f89c(param_2 + 0x310,param_2 + 0x360,(int)*(short *)(param_2 + 0x39a));
  return;
}

// VehPtr_Blasted_Animate
// param1 = thread, param2 = driver
void FUN_80068244(undefined4 param_1,int param_2)

{
  char cVar1;
  int iVar2;

  // set animation index
  *(undefined *)(param_2 + 0x4c) = 6;

  // get amount of time remaining before you can move (while blasted),
  // use that to determine animation frame of bouncing around
  iVar2 = (int)((uint)*(ushort *)(param_2 + 0x400) << 0x10) >> 0x15;

  // DAT_80087f28 is a constant for how many frames are in "blasted" anim

  // Just a stupid fail-safe to alert the debugger
  if (DAT_80087f28 == 0) trap(0x1c00);
  if ((DAT_80087f28 == -1) && (iVar2 == -0x80000000)) trap(0x1800);

  // get animation frame of blasted
  cVar1 = (char)(iVar2 % DAT_80087f28);

  if (*(char *)(param_2 + 0x580) != '\0')
  {
	// play animation backwards???
    cVar1 = (char)DAT_80087f28 - (cVar1 + '\x01');
  }

  // set animation frame
  *(char *)(param_2 + 0x4d) = cVar1;

  return;
}

// VehPtr_Blasted_Init
// param1 = thread, param2 = driver
void FUN_800682a4(undefined4 param_1,int param_2)

{
  byte bVar1;
  undefined2 uVar2;
  int iVar3;
  undefined4 uVar4;

  // put player in flipping animation after being hit
  *(undefined *)(param_2 + 0x376) = 6;

  *(undefined2 *)(param_2 + 0x3dc) = 0;

  // Check if 231 dll is loaded
  iVar3 = FUN_800348e8();
  if (
		// if it is loaded
		(iVar3 != 0) &&

		// If you're not in Adventure Arena
		((*(uint *)PTR_DAT_8008d2ac & 0x100000) == 0)
	)
  {
	// RB_Player_ModifyWumpa, -3
    FUN_800abefc(param_2,0xfffffffd);
  }

  // set animation to zero
  *(undefined *)(*(int *)(param_2 + 0x1c) + 0x52) = 0;

  // Instance_GetNumAnimFrames(instance, anim#0)
  uVar4 = FUN_8005b0f4(*(undefined4 *)(param_2 + 0x1c),0);

  // Instance_GetStartFrame(midpoint, numFrames)
  uVar2 = FUN_8005b0c4(0,uVar4);

  // set animation frame
  *(undefined2 *)(*(int *)(param_2 + 0x1c) + 0x54) = uVar2;

  // Get random number
  bVar1 = FUN_8003ea28();

  // randomly play blasted backwards
  *(byte *)(param_2 + 0x580) = bVar1 & 4;

  // VehPtr_Blasted_Update
  *(undefined4 *)(param_2 + 0x58) = 0x8006809c;

  // VehPtr_Blasted_PhysLinear
  *(undefined4 *)(param_2 + 0x5c) = 0x800680d0;

  *(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
  *(undefined4 *)(param_2 + 100) = 0x80068150; // OnPhysAngular
  *(undefined4 *)(param_2 + 0x68) = 0x8005ea60; // OnApplyForces
  *(undefined4 *)(param_2 + 0x6c) = 0x80020410; // OnCollide_QuadblockTouch
  *(undefined4 *)(param_2 + 0x70) = 0x8005ebac; // OnCollide_Drivers
  *(undefined4 *)(param_2 + 0x74) = 0x8001d944; // OnCollide_QuadblockNear
  *(undefined4 *)(param_2 + 0x78) = 0x80060630; // JumpAndFriction
  *(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix

  // VehPtr_Blasted_Animate
  *(undefined4 *)(param_2 + 0x80) = 0x80068244;

  // Erase OnInit, now that it has executed
  *(undefined4 *)(param_2 + 0x54) = 0;

  // VehParticle_DriverMain
  *(undefined4 *)(param_2 + 0x84) = 0x80059a18;

  if (*(char *)(param_2 + 0x4b) < '\x01') {
    uVar4 = 0x19;
  }
  else {
    uVar4 = 0x29;
  }

  // gamepad vibration
  FUN_800263a0(param_2,uVar4,0x60);

  return;
}


// VehPtr_Warp_MoveDustPuff
// "dustpuff" is really lightning under the player,
// without this, lightning is half-stuck under the player
void FUN_800683f4(short *param_1,int param_2,int param_3,short *param_4)

{
  uint uVar1;
  short *psVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  short *psVar6;
  int iVar7;

  // Get random number
  uVar1 = FUN_8003ea28();

  iVar4 = param_3 >> 1;
  iVar5 = (int)((uVar1 & 0xfff) * param_3) >> 0xc;
  if (iVar5 < iVar4) {
    iVar5 = iVar5 - param_3;
  }

  // Get random number
  uVar1 = FUN_8003ea28();

  iVar7 = (int)((uVar1 & 0xfff) * param_3) >> 0xc;
  if (iVar7 < iVar4) {
    iVar7 = iVar7 - param_3;
  }

  // Get random number
  uVar1 = FUN_8003ea28();

  iVar3 = (int)((uVar1 & 0xfff) * param_3) >> 0xc;
  if (iVar3 < iVar4) {
    iVar3 = iVar3 - param_3;
  }
  psVar2 = param_1 + param_2 * 4;
  iVar4 = param_2 >> 1;
  psVar6 = param_1 + iVar4 * 4;
  *psVar6 = (short)((int)*param_1 + (int)*psVar2 >> 1) + (short)(*param_4 * iVar5 >> 0xc);
  psVar6[1] = (short)((int)param_1[1] + (int)psVar2[1] >> 1) + (short)(param_4[1] * iVar7 >> 0xc);
  psVar6[2] = (short)((int)param_1[2] + (int)psVar2[2] >> 1) + (short)(param_4[2] * iVar3 >> 0xc);
  if (2 < param_2) {
    iVar5 = param_3 * 0xc00 >> 0xc;

	// VehPtr_Warp_MoveDustPuff
    FUN_800683f4(param_1,iVar4,iVar5,param_4);

	// VehPtr_Warp_MoveDustPuff
    FUN_800683f4(psVar6,iVar4,iVar5,param_4);
  }
  return;
}


// Add DustPuff particle to warp pad
void FUN_800685b0(short *param_1)

{
  int iVar1;

  if (((*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 1) == 0) &&
     (
		// Create instance in particle pool
		iVar1 = FUN_80040308(0,*(undefined4 *)(PTR_DAT_8008d2ac + 0x2118),&DAT_8008a180),
		iVar1 != 0
	 ))
  {
	// position variables
    *(int *)(iVar1 + 0x24) = *(int *)(iVar1 + 0x24) + (int)*param_1 * 0x100;
    *(int *)(iVar1 + 0x2c) = *(int *)(iVar1 + 0x2c) + (int)param_1[1] * 0x100;
    *(int *)(iVar1 + 0x34) = *(int *)(iVar1 + 0x34) + (int)param_1[2] * 0x100;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_80068644(int param_1,int param_2)

{
  short sVar1;
  short sVar2;
  ushort uVar3;
  short sVar4;
  short sVar5;
  short sVar6;
  uint *puVar7;
  undefined4 in_zero;
  undefined4 in_at;
  short extraout_var;
  short extraout_var_00;
  int iVar8;
  uint uVar9;
  uint *puVar10;
  undefined4 uVar11;
  uint *puVar12;
  uint *puVar13;
  short *psVar14;
  short *psVar15;
  uint *puVar16;
  undefined4 *puVar17;
  int iVar18;
  uint *puVar19;
  undefined *puVar20;
  int local_30;

  // pointer to each player's tileView buffer
  puVar20 = PTR_DAT_8008d2ac + (uint)*(byte *)(param_1 + 0x4a) * 0x110 + 0x168;

  // set several tileView buffer variables to coprocessor
  gte_SetRotMatrix(puVar20 + 0x28);
  gte_SetTransMatrix(puVar20 + 0x28);

  // handle some tileView buffer variables in RAM
  sVar1 = *(short *)(puVar20 + 0x48);
  sVar2 = *(short *)(puVar20 + 0x4e);
  uVar3 = *(ushort *)(puVar20 + 0x54);

  // handle some tileView buffer variables in scratchpad
  DAT_1f8001c0 = (undefined2)((int)sVar1 + (int)*(short *)(puVar20 + 0x4a) >> 5);
  DAT_1f8001c2 = (undefined2)
                 ((int)*(short *)(puVar20 + 0x4e) + (int)*(short *)(puVar20 + 0x50) >> 5);
  DAT_1f8001c4 = (undefined2)
                 ((int)*(short *)(puVar20 + 0x54) + (int)*(short *)(puVar20 + 0x56) >> 5);

  // backBuffer->primMem.curr
  puVar19 = *(uint **)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80);

  // if driver -> instance -> flags & INVISIBLE is true
  if ((*(uint *)(*(int *)(param_1 + 0x1c) + 0x28) & 0x80) != 0)
  {
    DAT_1f800188._0_2_ = (short)((uint)*(undefined4 *)(param_1 + 0x2d4) >> 8);
    DAT_1f800188._2_2_ = (undefined2)((uint)*(undefined4 *)(param_2 + 0x10) >> 8);
    DAT_1f80018c._0_2_ = (short)((uint)*(undefined4 *)(param_1 + 0x2dc) >> 8);

	// add dust puff
    FUN_800685b0(&DAT_1f800188);
  }

  local_30 = 0;
  do {
    iVar18 = (local_30 << 0xc) / 6;

	// Sine(angle)
    iVar8 = FUN_8003d184(iVar18 + *(int *)(param_2 + 0xc));

	_DAT_1f800108 =
         CONCAT22((short)((uint)*(undefined4 *)(param_2 + 8) >> 8),
                  (short)((uint)*(undefined4 *)(param_1 + 0x2d4) >> 8) - (short)(iVar8 >> 5));

	// Cosine(angle)
	iVar8 = FUN_8003d1c0(iVar18 + *(int *)(param_2 + 0xc));

	_DAT_1f80010c =
         _DAT_1f80010c & 0xffff0000 |
         (uint)(ushort)((short)((uint)*(undefined4 *)(param_1 + 0x2dc) >> 8) - (short)(iVar8 >> 5));
    DAT_1f800188._0_2_ = (short)((uint)*(undefined4 *)(param_1 + 0x2d4) >> 8);
    DAT_1f800188._2_2_ = (undefined2)((uint)*(undefined4 *)(param_2 + 0x10) >> 8);
    DAT_1f80018c._0_2_ = (short)((uint)*(undefined4 *)(param_1 + 0x2dc) >> 8);

	// driver -> instSelf -> flags -> INVISIBLE is false
    if ((*(uint *)(*(int *)(param_1 + 0x1c) + 0x28) & 0x80) == 0) {

	  // Sine(angle)
	  iVar8 = FUN_8003d184(iVar18 + *(int *)(param_2 + 0xc));

	  _DAT_1f800108 =
           _DAT_1f800108 & 0xffff0000 | (uint)(ushort)(DAT_1f800108 - (short)(iVar8 >> 6));

	  // Cosine(angle)
	  iVar8 = FUN_8003d1c0(iVar18 + *(int *)(param_2 + 0xc));

	  _DAT_1f80010c =
           _DAT_1f80010c & 0xffff0000 | (uint)(ushort)(DAT_1f80010c - (short)(iVar8 >> 6));

	  // Sine(angle)
	  FUN_8003d184(iVar18 + *(int *)(param_2 + 0xc));

	  DAT_1f800188._0_2_ = (short)DAT_1f800188 + extraout_var;

	  // Cosine(angle)
	  FUN_8003d1c0(iVar18 + *(int *)(param_2 + 0xc));

	  DAT_1f80018c._0_2_ = (short)DAT_1f80018c + extraout_var_00;
    }

	// if driver is visible
    else
	{
	  // add dust puff
      FUN_800685b0(&DAT_1f800108);
    }

    uVar11 = 0x10;

	// VehPtr_Warp_MoveDustPuff
	FUN_800683f4(&DAT_1f800108,0x10,0x100,&DAT_1f8001c0);

    iVar18 = 1;
    puVar17 = (undefined4 *)&DAT_1f800108;
    do {
      puVar10 = (uint *)(iVar18 << 7);

	  // Sine(angle)
      iVar8 = FUN_8003d184(puVar10);

	  iVar18 = iVar18 + 1;
      *(short *)((int)puVar17 + 10) = *(short *)((int)puVar17 + 10) + (short)(iVar8 >> 7);
      puVar17 = puVar17 + 2;
    } while (iVar18 < 0x10);
    sVar4 = sVar1 >> 10;
    sVar5 = sVar2 >> 10;
    DAT_1f800190 = CONCAT22(DAT_1f80010a + sVar5,DAT_1f800108 + sVar4);
    sVar6 = (short)uVar3 >> 10;
    DAT_1f800194 = DAT_1f800194 & 0xffff0000 | (uint)(ushort)(DAT_1f80010c + sVar6);
    uVar9 = (_DAT_1f80010c & 0xffff) - ((int)((uint)uVar3 << 0x10) >> 0x1a);
    DAT_1f800198 = CONCAT22(DAT_1f80010a - sVar5,DAT_1f800108 - sVar4);
    DAT_1f80019c = DAT_1f80019c & 0xffff0000 | uVar9 & 0xffff;
    setCopReg(2,in_zero,DAT_1f800190);
    setCopReg(2,in_at,DAT_1f800194);
    setCopReg(2,0x1f800190,_DAT_1f800108);
    setCopReg(2,uVar9,_DAT_1f80010c);
    setCopReg(2,puVar10,DAT_1f800198);
    setCopReg(2,uVar11,DAT_1f80019c);

	// RTPT - Perspective Transformation (triple)
	copFunction(2,0x280030);

    DAT_1f8001a0 = getCopReg(2,0xc);
    DAT_1f8001a4 = getCopReg(2,0xd);
    DAT_1f8001a8 = getCopReg(2,0xe);
    DAT_1f8001ac = getCopReg(2,0x11);
    iVar18 = 0;
    puVar12 = puVar19 + 0x11;
    puVar7 = &DAT_1f8001a0;
    psVar14 = &DAT_1f80010c;
    puVar16 = &DAT_1f8001b0;
    puVar17 = (undefined4 *)&DAT_1f800108;
    do {
      puVar13 = puVar7;
      puVar17 = puVar17 + 2;
      psVar15 = psVar14 + 4;
      DAT_1f800190 = CONCAT22(psVar14[3] + sVar5,*(short *)puVar17 + sVar4);
      DAT_1f800194 = DAT_1f800194 & 0xffff0000 | (uint)(ushort)(*psVar15 + sVar6);
      DAT_1f800198 = CONCAT22(psVar14[3] - sVar5,*(short *)puVar17 - sVar4);
      DAT_1f80019c = DAT_1f80019c & 0xffff0000 | (uint)(ushort)(*psVar15 - sVar6);
      setCopReg(2,in_zero,DAT_1f800190);
      setCopReg(2,in_at,DAT_1f800194);
      setCopReg(2,0x1f800190,*puVar17);
      setCopReg(2,puVar16,puVar17[3]);
      setCopReg(2,puVar10,DAT_1f800198);
      setCopReg(2,puVar12,DAT_1f80019c);

	  // RTPT - Perspective Transformation (triple)
	  copFunction(2,0x280030);

	  uVar9 = getCopReg(2,0xc);
      *puVar16 = uVar9;
      uVar9 = getCopReg(2,0xd);
      puVar16[1] = uVar9;
      uVar9 = getCopReg(2,0xe);
      puVar16[2] = uVar9;
      uVar9 = getCopReg(2,0x11);
      puVar16[3] = uVar9;
      puVar12[-0x10] = 0xe1000a20;
      puVar12[-0xf] = 0x3a000000;
      puVar12[-0xd] = 0x7f1f3f;
      puVar12[-0xb] = 0;
      puVar12[-9] = 0x7f1f3f;
      puVar12[-0xe] = *puVar16;
      puVar12[-0xc] = puVar16[1];
      puVar12[-10] = *puVar13;
      uVar9 = puVar13[1];
      puVar12[-7] = 0x3a000000;
      puVar12[-5] = 0x7f1f3f;
      puVar12[-3] = 0;
      puVar12[-1] = 0x7f1f3f;
      puVar12[-8] = uVar9;
      puVar12[-6] = puVar16[2];
      puVar12[-4] = puVar16[1];
      iVar18 = iVar18 + 1;
      puVar12[-2] = puVar13[2];
      *puVar12 = puVar13[1];
      puVar10 = (uint *)(*(int *)(puVar20 + 0xf4) + ((int)puVar16[3] >> 6) * 4);
      puVar12 = puVar12 + 0x12;
      *puVar19 = *puVar10 | 0x11000000;
      *puVar10 = (uint)puVar19 & 0xffffff;
      puVar19 = puVar19 + 0x12;
      puVar7 = puVar16;
      psVar14 = psVar15;
      puVar16 = puVar13;
      puVar17 = puVar17;
    } while (iVar18 < 0x10);
    local_30 = local_30 + 1;
  } while (local_30 < 6);

  // backBuffer->primMem.curr
  *(uint **)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80) = puVar19;

  return;
}


// VehPtr_Warp_PhysAngular
// param1 = thread, param2 = driver
// animate rotation and scale in warppad
void FUN_80068be8(undefined4 param_1,int param_2)

{
  undefined2 uVar1;
  short sVar2;
  int iVar3;
  int iVar4;
  int *piVar5;
  undefined2 local_18;
  short local_16;
  undefined2 local_14;

  // get instance from driver object
  iVar4 = *(int *)(param_2 + 0x1c);

  piVar5 = (int *)(param_2 + 0x580);

  // if driver is visible
  if ((*(uint *)(iVar4 + 0x28) & 0x80) == 0)
  {
	// height + 0x100
    iVar3 = *(int *)(param_2 + 0x2d8) + 0x100;

    *(int *)(param_2 + 0x590) = iVar3;
    if (iVar3 < *(int *)(param_2 + 0x588)) {
      *(int *)(param_2 + 0x590) = *(int *)(param_2 + 0x588);
    }

	// if driver is visible
    if ((*(uint *)(iVar4 + 0x28) & 0x80) == 0) 
	{
	  // stop particle spawning
      *(int *)(param_2 + 0x58c) = *(int *)(param_2 + 0x58c) + -100;
    }

	// add dust puff
    FUN_80068644(param_2,piVar5);
  }

  // timer
  iVar3 = *piVar5;
  *piVar5 = iVar3 + 0x1a;

  // timer < 801
  if (iVar3 + 0x1a < 0x321)
  {
	// interpolate until scale is [0x12c0, 0x960, 0x12c0],
	// car is wide and short

	// Interpolate scale by speed
    uVar1 = FUN_80058f54((int)*(short *)(iVar4 + 0x1c),0x78,0x12c0);
    *(undefined2 *)(iVar4 + 0x1c) = uVar1;

	// Interpolate scale by speed
    uVar1 = FUN_80058f54((int)*(short *)(iVar4 + 0x1e),0x78,0x960);
    *(undefined2 *)(iVar4 + 0x1e) = uVar1;

	// Interpolate scale by speed
    uVar1 = FUN_80058f54((int)*(short *)(iVar4 + 0x20),0x78,0x12c0);


    *(undefined2 *)(iVar4 + 0x20) = uVar1;
    iVar4 = *(int *)(param_2 + 0x2d8) + 0x800;
    if (*(int *)(param_2 + 0x2d0) + 0x8000 <= *(int *)(param_2 + 0x2d8)) goto LAB_80068db0;
  }
  else
  {
	// cap to 800
    *piVar5 = 800;

    *(undefined *)(param_2 + 0x4fe) = 2;

	// interpolate until scale is [0, 24000, 0],
	// car is tall and thin

	// Interpolate scale by speed
    uVar1 = FUN_80058f54((int)*(short *)(iVar4 + 0x1c),600,0);
    *(undefined2 *)(iVar4 + 0x1c) = uVar1;

	// Interpolate scale by speed
    uVar1 = FUN_80058f54((int)*(short *)(iVar4 + 0x1e),0xc80,24000);
    *(undefined2 *)(iVar4 + 0x1e) = uVar1;

	// Interpolate scale by speed
    uVar1 = FUN_80058f54((int)*(short *)(iVar4 + 0x20),600,0);
    *(undefined2 *)(iVar4 + 0x20) = uVar1;

	// if scale shrinks to zero
    if (*(short *)(iVar4 + 0x1c) == 0)
	{
	  // if car is visible
      if ((*(uint *)(iVar4 + 0x28) & 0x80) == 0) 
	  {
		// position above kart
        local_18 = (undefined2)((uint)*(undefined4 *)(param_2 + 0x2d4) >> 8);
        local_16 = (short)((uint)*(undefined4 *)(param_2 + 0x588) >> 8) + 0x40;
        local_14 = (undefined2)((uint)*(undefined4 *)(param_2 + 0x2dc) >> 8);
        
		// FLARE_Init
		FUN_80025138(&local_18);
      }

	  // make invisible
      *(uint *)(iVar4 + 0x28) = *(uint *)(iVar4 + 0x28) | 0x80;

      goto LAB_80068db0;
    }

	iVar4 = *(int *)(param_2 + 0x584) + -0x1800;
    *(int *)(param_2 + 0x584) = iVar4;

    iVar4 = *(int *)(param_2 + 0x2d8) + iVar4;
  }
  *(int *)(param_2 + 0x2d8) = iVar4;
LAB_80068db0:

  // drift angle = ((drift angle + warp timer + 0x800) & 0xfff) - 0x800
  sVar2 = (*(short *)(param_2 + 0x3c6) + *(short *)piVar5 + 0x800U & 0xfff) - 0x800;
  *(short *)(param_2 + 0x3c6) = sVar2;
  
  // cameraRotY = ??? + kart angle + drift angle
  *(short *)(param_2 + 0x2ee) = *(short *)(param_2 + 0x3d4) + *(short *)(param_2 + 0x39a) + sVar2;

  // driver is warping
  *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) | 0x4000;
  return;
}


// VehPtr_Warp_Init
// param1 = thread, param2 = driver
void FUN_80068e04(undefined4 param_1,int param_2)

{
  int iVar1;

  // If you are not in a warp pad
  if (*(char *)(param_2 + 0x376) != '\n')
  {
    *(undefined4 *)(param_2 + 0x580) = 0x3c;
    *(undefined4 *)(param_2 + 0x584) = 0;
    *(undefined4 *)(param_2 + 0x588) = *(undefined4 *)(param_2 + 0x2d0);

	// OtherFX_Play
    FUN_80028468(0x97,1);

	// OtherFX_Stop1 (three sounds)
    FUN_80028808(*(undefined4 *)(param_2 + 0x304));
    *(undefined4 *)(param_2 + 0x304) = 0;
    FUN_80028808(*(undefined4 *)(param_2 + 0x308));
    *(undefined4 *)(param_2 + 0x308) = 0;
    FUN_80028808(*(undefined4 *)(param_2 + 0x300));
    *(undefined4 *)(param_2 + 0x300) = 0;

	// engineID from metadata, given characterID
    FUN_80028b54((uint)*(byte *)(param_2 + 0x4a) +
                 *(int *)(&DAT_80086d90 +
                         (int)(short)(&DAT_80086e84)[*(byte *)(param_2 + 0x4a)] * 0x10) * 4 & 0xffff
                );

	// driver -> instSelf
	iVar1 = *(int *)(param_2 + 0x1c);

	// instance flags, now reflective
    *(uint *)(iVar1 + 0x28) = *(uint *)(iVar1 + 0x28) | 0x4000;

	// vertical line for split or reflection
    *(undefined2 *)(iVar1 + 0x56) = (short)((uint)*(undefined4 *)(param_2 + 0x2d0) >> 8);

	// CameraDC, freecam mode
    *(undefined2 *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_2 + 0x4a) * 0xdc + 0x1532) = 3;

    *(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio

	// eventually calls AddDustPuff
    *(undefined4 *)(param_2 + 100) = 0x80068be8;  // OnPhysAngular

	*(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix

    *(undefined4 *)(param_2 + 0x80) = 0x8005b178; // OnAnimate_Driving

	// you are now in a warp pad
    *(undefined *)(param_2 + 0x376) = 10;

    *(undefined2 *)(param_2 + 0x38c) = 0;
    *(undefined2 *)(param_2 + 0x38e) = 0;

    *(undefined4 *)(param_2 + 0x54) = 0; // OnInit
    *(undefined4 *)(param_2 + 0x58) = 0; // OnUpdate
	*(undefined4 *)(param_2 + 0x5c) = 0; // OnPhysLinear -- disable input, timers, and effects

    *(undefined4 *)(param_2 + 0x68) = 0;
    *(undefined4 *)(param_2 + 0x6c) = 0; // OnCollide_QuadblockTouch
    *(undefined4 *)(param_2 + 0x70) = 0; // OnCollide_Drivers
    *(undefined4 *)(param_2 + 0x74) = 0; // OnCollide_QuadblockNear
    *(undefined4 *)(param_2 + 0x78) = 0; // cant move anymore

	// VehParticle_DriverMain
    *(undefined4 *)(param_2 + 0x84) = 0x80059a18;

	// driver is warping
    *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) | 0x4000;
  }
  return;
}


// Talking Mask (adventure hints)
// param1 is thread
void FUN_80068f90(int param_1)

{
  undefined *puVar1;
  undefined2 uVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;

  puVar1 = PTR_DAT_8008d2ac;

  // get object attached to thread
  iVar8 = *(int *)(param_1 + 0x30);

  // get instance attached to thread
  iVar7 = *(int *)(param_1 + 0x34);

  iVar4 = 0x2000;

  // if mask model is nullptr
  if (DAT_8008d0f0 == 0) {
    iVar4 = 0x1000;

	// Check if P1 is valid
    if (*(int *)(PTR_DAT_8008d2ac + 0x24ec) != 0)
	{
	  // Weapon_Mask_boolGoodGuy
      uVar3 = FUN_80064be4();

	  // If you use Uka mask,
	  // uka model
      iVar4 = 0xe8;

	  // If you use Aku mask
      if ((uVar3 & 0xffff) != 0)
	  {
		// aku model
        iVar4 = 0xe4;
      }

	  // set instance's model pointer
      *(undefined4 *)(iVar7 + 0x18) = *(undefined4 *)(puVar1 + iVar4 + 0x2160);

      iVar4 = 0x1000;
    }
  }

  else
  {
	// set model of talking mask
    *(int *)(iVar7 + 0x18) = DAT_8008d0f0;
  }

  // max value in some SPU data
  DAT_8008d9f8 = DAT_8008d6f4;

  uVar2 = (undefined2)(*(short *)(iVar8 + 4) * iVar4 >> 0xc);

  // scale
  *(undefined2 *)(iVar7 + 0x20) = uVar2;
  *(undefined2 *)(iVar7 + 0x1e) = uVar2;
  *(undefined2 *)(iVar7 + 0x1c) = uVar2;

  // number of animFrames
  iVar8 = FUN_8005b0f4(iVar7,0);

  // multiply by 7
  iVar4 = DAT_8008d9f8 * 7;

  if (iVar4 < 0) {
    iVar4 = iVar4 + 0x3fff;
  }

  iVar4 = iVar4 >> 0xe;

  if (DAT_8008d9fc < iVar4) {
    DAT_8008d9fc = iVar4;
  }

  iVar6 = iVar4;
  if (iVar4 < 2) {
    iVar6 = 0;
  }
  if (iVar4 < 4)
  {
	// animFrame
    iVar5 = (int)*(short *)(iVar7 + 0x54);
  }

  else
  {
	// animFrame
	iVar5 = (int)*(short *)(iVar7 + 0x54);

	iVar4 = iVar5 - iVar6;

	if (iVar4 < 0) {
      iVar4 = -iVar4;
    }

    if (3 < iVar4)
	{
	  // animFrame
	  *(undefined2 *)(iVar7 + 0x54) = (short)iVar6;

      goto LAB_800690dc;
    }
  }

  // EngineSound_VolumeAdjust
  uVar2 = FUN_8002fc28(iVar6,iVar5,1);

  // animFrame
  *(undefined2 *)(iVar7 + 0x54) = uVar2;

LAB_800690dc:

  // animFrame
  iVar4 = (int)*(short *)(iVar7 + 0x54) - iVar6;

  if (iVar4 < 0) {
    iVar4 = -iVar4;
  }

  if (iVar4 < 6)
  {
	// EngineSound_VolumeAdjust
    uVar2 = FUN_8002fc28(iVar6,(int)*(short *)(iVar7 + 0x54),1);

	// animFrame
    *(undefined2 *)(iVar7 + 0x54) = uVar2;
  }
  else
  {
	// animFrame
    *(undefined2 *)(iVar7 + 0x54) = (short)iVar6;
  }

  // animation frame goes back and forth
  // 0x00: mouth close
  // 0x0C: mouth open

  // if frame is less than zero, set to zero
  if ((int)*(short *)(iVar7 + 0x54) < 0) {
    *(undefined2 *)(iVar7 + 0x54) = 0;
  }

  // if frame is positive
  else
  {
	// if animation frame goes beyond number of frames
    if (iVar8 + -1 < (int)*(short *)(iVar7 + 0x54))
	{
	  // set animation frame to last frame
      *(undefined2 *)(iVar7 + 0x54) = (short)(iVar8 + -1);
    }
  }

  // If mask should disappear
  if (DAT_8008da00 != '\0')
  {
	// dont need this variable anymore,
	// so set it from one to zero
    DAT_8008da00 = '\0';

	// 0x800 = this thread needs to be deleted
    *(uint *)(param_1 + 0x1c) = *(uint *)(param_1 + 0x1c) | 0x800;
  }
  return;
}


// TalkingMask_Init
void FUN_80069178(void)

{
  int iVar1;

  // mask is now talking (I think)
  DAT_8008d65c = 1;

  // talking mask does not
  // need to go away
  DAT_8008da00 = 0;

  // DAT_8008d660
  // "head"

  // 0x39 = aku aku model pointer
  // it changes in FUN_80068f90

  // Create instance
  // 0x300 flag = SmallStackPool
  // 0xe = "aku aku" thread bucket
  iVar1 = FUN_800309a4(0x39,&DAT_8008d660,0x300,0xe,FUN_80068f90,6,0);

  // get thread from instance
  iVar1 = *(int *)(iVar1 + 0x6c);

  // set funcThDestroy to remove instance from instance pool
  *(undefined4 *)(iVar1 + 0x24) = 0x80041dfc;

  // object -> 4
  *(undefined2 *)(*(int *)(iVar1 + 0x30) + 4) = 0;
  return;
}


// TalkingMask_PlayXA
void FUN_800691e4(undefined4 param_1,short param_2)

{
  uint uVar1;

  if (
		// If Player Structure pointer is not nullptr
		(*(int *)(PTR_DAT_8008d2ac + 0x24ec) != 0) &&
		(
			// Weapon_Mask_boolGoodGuy
			uVar1 = FUN_80064be4(),

			// if player uses uka
			(uVar1 & 0xffff) == 0
		)
	  )
  {
	// if you use uka, increment parameter
    param_2 = param_2 + 0x1f;
  }

  // if you use aku, leave parameter alone

  // CDSYS_XAPlay(CDSYS_XA_TYPE_EXTRA, (int)param_2);
  FUN_8001cdb4(1,(int)param_2);

  return;
}

// TalkingMask_boolNoXA
bool FUN_8006924c(void)

{
  return DAT_8008d708 == 0;
}

// TalkingMask_End
void FUN_8006925c(void)

{
  // CDSYS_XAPauseRequest
  FUN_8001cf98();

  // mask is not talking (I think)
  DAT_8008d65c = 0;

  // talking mask needs to go away
  DAT_8008da00 = 1;

  return;
}


// Turbo_ProcessBucket
void FUN_80069284(int param_1)

{
  undefined2 uVar1;
  undefined *puVar2;
  undefined *puVar3;
  int iVar4;
  undefined4 uVar5;
  int iVar6;
  int iVar7;
  int iVar8;

  puVar2 = PTR_DAT_8008d2ac;

  // if first thread is valid
  if (param_1 != 0)
  {
	// loop through all threads
    do
	{
      puVar3 = PTR_DAT_8008d2ac;

	  // get instance from thread
      iVar6 = *(int *)(param_1 + 0x34);

	  // get object from thread
      iVar7 = **(int **)(param_1 + 0x30);

	  // object -> driver -> instSelf
      iVar4 = *(int *)((*(int **)(param_1 + 0x30))[1] + 0x1c);

      iVar8 = 0;

	  // numPlyrCurrGame is not zero
      if (puVar2[0x1ca8] != '\0') 
	  {
		// each InstDrawPerPlayer
		// for iVar8 = 0; iVar8 < numPlyrCurrGame; iVar8++
        do
		{
		  // if tileView does not exist ?
		  // judging by 0x28 being copied to 0xb8 ?
          if ((*(uint *)(iVar4 + 0xb8) & 0x100) == 0)
		  {
			// flags
            *(uint *)(iVar7 + 0xb8) =
                 *(uint *)(iVar7 + 0xb8) & (*(uint *)(iVar4 + 0xb8) | 0xffffffbf);
            *(uint *)(iVar6 + 0xb8) =
                 *(uint *)(iVar6 + 0xb8) & (*(uint *)(iVar4 + 0xb8) | 0xffffffbf);
				 
            uVar5 = *(undefined4 *)(iVar4 + 0xe4);
            *(undefined4 *)(iVar6 + 0xe4) = uVar5;
            *(undefined4 *)(iVar7 + 0xe4) = uVar5;
            uVar5 = *(undefined4 *)(iVar4 + 0xe8);
            *(undefined4 *)(iVar6 + 0xe8) = uVar5;
            *(undefined4 *)(iVar7 + 0xe8) = uVar5;
            uVar1 = *(undefined2 *)(iVar4 + 0xdc);
            *(undefined2 *)(iVar6 + 0xdc) = uVar1;
            *(undefined2 *)(iVar7 + 0xdc) = uVar1;
            uVar1 = *(undefined2 *)(iVar4 + 0xde);
            *(undefined2 *)(iVar6 + 0xde) = uVar1;
            *(undefined2 *)(iVar7 + 0xde) = uVar1;
          }
		  
		  // InstDrawPerPlayer
          iVar6 = iVar6 + 0x88;
          iVar7 = iVar7 + 0x88;
          iVar8 = iVar8 + 1;
          iVar4 = iVar4 + 0x88;
		  
        } while (iVar8 < (int)(uint)(byte)puVar3[0x1ca8]);
      }

	  // go to next thread

	  // thread = thread->sibling
      param_1 = *(int *)(param_1 + 0x10);

    } while (param_1 != 0);
  }
  return;
}


// Turbo_ThDestroy
void FUN_80069370(int param_1)

{
  int iVar1;
  undefined4 *puVar2;

  // thread -> object
  puVar2 = *(undefined4 **)(param_1 + 0x30);

  // get Driver object from Turbo object
  iVar1 = puVar2[1];

  // remove flags for boosting
  *(uint *)(iVar1 + 0x2c8) = *(uint *)(iVar1 + 0x2c8) & 0xfffffdff;

  // INSTANCE_Death
  FUN_80030aa8(*puVar2);
  FUN_80030aa8(*(undefined4 *)(param_1 + 0x34));

  return;
}


// Turbo_ThTick
void FUN_800693c8(int param_1)

{
  char cVar1;
  short sVar2;
  ushort uVar3;
  undefined *puVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  undefined4 uVar8;
  int *piVar9;
  int iVar10;
  int iVar11;
  int iVar12;

  // get object attached to thread
  piVar9 = *(int **)(param_1 + 0x30);

  // turbo -> driver
  iVar12 = piVar9[1];

  // get instance
  iVar11 = *(int *)(param_1 + 0x34);

  // driver -> instSelf
  iVar10 = *(int *)(iVar12 + 0x1c);

  do {
    if (
		(
			// if not burnt
			(*(short *)(iVar12 + 0x402) == 0) &&

			// if alpha of turbo is zero
			(*(short *)(iVar11 + 0x22) == 0)) &&

		// instance -> thread -> modelID == DYNAMIC_GHOST
		(*(short *)(*(int *)(iVar10 + 0x6c) + 0x44) != 0x4b)
	   )
	{
	  // cut driverInst transparency in half
      *(ushort *)(iVar10 + 0x22) = *(ushort *)(iVar10 + 0x22) >> 1;
    }

	// if instance is not split by water
    if ((*(uint *)(iVar10 + 0x28) & 0x2000) == 0)
	{
	  // instance flags
      *(uint *)(iVar11 + 0x28) = *(uint *)(iVar11 + 0x28) & 0xffffdfff;
      *(uint *)(*piVar9 + 0x28) = *(uint *)(*piVar9 + 0x28) & 0xffffdfff;
    }

	// if instance is split by water
	else
	{
	  // turbos are now split by water, set vertical split height
      *(uint *)(iVar11 + 0x28) = *(uint *)(iVar11 + 0x28) | 0x2000;
      *(undefined2 *)(iVar11 + 0x56) = *(undefined2 *)(iVar10 + 0x56);
	  *(uint *)(*piVar9 + 0x28) = *(uint *)(*piVar9 + 0x28) | 0x2000;
	  *(undefined2 *)(*piVar9 + 0x56) = *(undefined2 *)(iVar10 + 0x56);
    }

	// if driver instance is not reflective
	if ((*(uint *)(iVar10 + 0x28) & 0x4000) == 0)
	{
	  // remove reflection from turbo instances
      *(uint *)(iVar11 + 0x28) = *(uint *)(iVar11 + 0x28) & 0xffffbfff;
      *(uint *)(*piVar9 + 0x28) = *(uint *)(*piVar9 + 0x28) & 0xffffbfff;
    }

	// if driver instance is reflective
	else
	{
      // make turbo instances reflective
	  // copy reflection height axis to instance
	  *(uint *)(iVar11 + 0x28) = *(uint *)(iVar11 + 0x28) | 0x4000;
	  *(undefined2 *)(iVar11 + 0x56) = *(undefined2 *)(iVar10 + 0x56);
	  *(uint *)(*piVar9 + 0x28) = *(uint *)(*piVar9 + 0x28) | 0x4000;
	  *(undefined2 *)(*piVar9 + 0x56) = *(undefined2 *)(iVar10 + 0x56);
    }

	// matrix from instance
    gte_SetRotMatrix(iVar10 + 0x30);
    gte_SetTransMatrix(iVar10 + 0x30);

    iVar6 = (int)*(short *)((int)piVar9 + 10);
    iVar7 = iVar6;
    if (8 < iVar6) {
      iVar7 = 8;
    }
    if (iVar6 < 4) {
      iVar7 = 4;
    }
    
	// matrix of first turbo instance
	*(undefined2 *)(iVar11 + 0x30) = (short)(*(short *)(iVar10 + 0x30) * iVar7 >> 3);
    *(undefined2 *)(iVar11 + 0x32) = (short)(*(short *)(iVar10 + 0x32) * iVar7 >> 3);
    *(undefined2 *)(iVar11 + 0x34) = (short)(*(short *)(iVar10 + 0x34) * iVar7 >> 3);
    *(undefined2 *)(iVar11 + 0x36) = (short)(*(short *)(iVar10 + 0x36) * iVar7 >> 3);
    *(undefined2 *)(iVar11 + 0x38) = (short)(*(short *)(iVar10 + 0x38) * iVar7 >> 3);
    *(undefined2 *)(iVar11 + 0x3a) = (short)(*(short *)(iVar10 + 0x3a) * iVar7 >> 3);
    *(undefined2 *)(iVar11 + 0x3c) = (short)(*(short *)(iVar10 + 0x3c) * iVar7 >> 3);
    *(undefined2 *)(iVar11 + 0x3e) = (short)(*(short *)(iVar10 + 0x3e) * iVar7 >> 3);
    *(undefined2 *)(iVar11 + 0x40) = (short)(*(short *)(iVar10 + 0x40) * iVar7 >> 3);
	
	// driver -> instSelf
    iVar6 = *(int *)(iVar12 + 0x1c);
	
    gte_ldVXY0(*(short *)(iVar6 + 0x1c) * 9 >> 0xb & 0xffffU |
               (*(short *)(iVar6 + 0x1e) * 3 >> 8) << 0x10);
    gte_ldVZ0(*(short *)(iVar6 + 0x20) * -0x34 >> 0xc);
    gte_rt();
	
	// set translation vector
    gte_stlvl((VECTOR *)(iVar11 + 0x44));
	
	// matrix of second turbo instance, negate X axis
    *(undefined2 *)(*piVar9 + 0x30) = (short)(-(int)*(short *)(iVar10 + 0x30) * iVar7 >> 3);
    *(undefined2 *)(*piVar9 + 0x32) = (short)(*(short *)(iVar10 + 0x32) * iVar7 >> 3);
    *(undefined2 *)(*piVar9 + 0x34) = (short)(*(short *)(iVar10 + 0x34) * iVar7 >> 3);
    *(undefined2 *)(*piVar9 + 0x36) = (short)(-(int)*(short *)(iVar10 + 0x36) * iVar7 >> 3);
    *(undefined2 *)(*piVar9 + 0x38) = (short)(*(short *)(iVar10 + 0x38) * iVar7 >> 3);
    *(undefined2 *)(*piVar9 + 0x3a) = (short)(*(short *)(iVar10 + 0x3a) * iVar7 >> 3);
    *(undefined2 *)(*piVar9 + 0x3c) = (short)(-(int)*(short *)(iVar10 + 0x3c) * iVar7 >> 3);
    *(undefined2 *)(*piVar9 + 0x3e) = (short)(*(short *)(iVar10 + 0x3e) * iVar7 >> 3);
    *(undefined2 *)(*piVar9 + 0x40) = (short)(*(short *)(iVar10 + 0x40) * iVar7 >> 3);
	
	// driver -> instSelf
    iVar7 = *(int *)(iVar12 + 0x1c);
	
    gte_ldVXY0(*(short *)(iVar7 + 0x1c) * -0x12 >> 0xc & 0xffffU |
               (*(short *)(iVar7 + 0x1e) * 3 >> 8) << 0x10);
    gte_ldVZ0(*(short *)(iVar7 + 0x20) * -0x34 >> 0xc);
    gte_rt();
	
	// set translation vector
    gte_stlvl((VECTOR *)(*piVar9 + 0x44));

													// elapsed milliseconds per frame, ~32
    iVar7 = (uint)*(ushort *)((int)piVar9 + 0xe) - (uint)*(ushort *)(PTR_DAT_8008d2ac + 0x1d04);

    *(undefined2 *)((int)piVar9 + 0xe) = (short)iVar7;
    if (iVar7 * 0x10000 < 0) {
      *(undefined2 *)((int)piVar9 + 0xe) = 0;
    }

	if (*(short *)((int)piVar9 + 0xe) == 0)
	{
	  // make visible
      *(uint *)(iVar11 + 0x28) = *(uint *)(iVar11 + 0x28) & 0xffffff7f;
      *(uint *)(*piVar9 + 0x28) = *(uint *)(*piVar9 + 0x28) & 0xffffff7f;
    }

	if (*(ushort *)(iVar11 + 0x22) < 0x9c4)
	{
	  // gamepad vibration
      FUN_80026440(iVar12,4,4);
    }

    puVar4 = PTR_DAT_8008d2ac;

	// set new model pointer, one of seven
    *(undefined4 *)(iVar11 + 0x18) =
         *(undefined4 *)(PTR_DAT_8008d2ac + ((int)*(short *)(piVar9 + 2) + 0x2c) * 4 + 0x2160);

	// set new model pointer, one of seven
	*(undefined4 *)(*piVar9 + 0x18) =
         *(undefined4 *)(puVar4 + (((int)*(short *)(piVar9 + 2) + 3U & 7) + 0x2c) * 4 + 0x2160);

	// increment frame index
	sVar2 = *(short *)(piVar9 + 2);
    *(short *)(piVar9 + 2) = sVar2 + 1;

	// if gone past seven frames of fire
    if (7 < (short)(sVar2 + 1))
	{
	  // back to first frame of fire
      *(undefined2 *)(piVar9 + 2) = 0;
    }

    if ('\0' < *(char *)(piVar9 + 3)) {
      *(char *)(piVar9 + 3) = *(char *)(piVar9 + 3) + -1;
    }

	// instance -> thread -> modelIndex == "player" of any kind
    if (*(short *)(*(int *)(iVar10 + 0x6c) + 0x44) == 0x18) {
      iVar7 = 0x100 - (uint)(*(ushort *)(iVar11 + 0x22) >> 4);
      if (iVar7 < 0) {
        iVar7 = 0;
      }
      else {
        if (0x82 < iVar7) {
          iVar7 = 0x82;
        }
      }
      uVar5 = (uint)*(byte *)((int)piVar9 + 0xd) + 0x10;
      if ((int)uVar5 < 0) {
        uVar5 = 0;
      }
      else {
        if (0x80 < uVar5) {
          uVar5 = 0x80;
        }
      }

	  // distort
      uVar5 = uVar5 << 8;

	  // if echo is required
      if ((*(uint *)(iVar12 + 0x2c8) & 0x10000) != 0)
	  {
		// add echo
		uVar5 = uVar5 | 0x1000000;
      }

	  // driver audio
	  FUN_8002e690(iVar12 + 0x30c,0xe,iVar7 << 0x10 | uVar5 | 0x80);

      if (*(byte *)((int)piVar9 + 0xd) < 0xc0) {
        *(char *)((int)piVar9 + 0xd) = *(byte *)((int)piVar9 + 0xd) + 1;
      }
    }

    if (
			// if this is a ghost
			(*(short *)(*(int *)(iVar10 + 0x6c) + 0x44) == 0x4b) ||

			// kart state
			(((cVar1 = *(char *)(iVar12 + 0x376),

			// if not being mask grabbed, not crashing, not being warped
			cVar1 != '\x05' && (cVar1 != '\x01')) && (cVar1 != '\n')))
		)
	{
	  // if reserves are nearing zero
      if ((*(short *)(iVar12 + 0x3e2) < 0x10) || (*(char *)(piVar9 + 3) == '\0'))
	  {
		// get turboInst alpha
        uVar3 = *(ushort *)(iVar11 + 0x22);

		// if fully transparent, skip lines
        if (0xfff < uVar3) goto LAB_80069b50;

		if (*(char *)(piVar9 + 3) == '\0')
		{
		  // increase transparency
          *(short *)(iVar11 + 0x22) = uVar3 + 0x100;
          *(short *)(*piVar9 + 0x22) = *(short *)(*piVar9 + 0x22) + 0x100;
        }
        else
		{
		  // increase transparency
          *(short *)(iVar11 + 0x22) = uVar3 + 0x40;
          *(short *)(*piVar9 + 0x22) = *(short *)(*piVar9 + 0x22) + 0x40;
        }
      }
      else
	  {
		// if scale is big, skip lines
        if (0xfff < *(ushort *)(iVar11 + 0x22)) goto LAB_80069b50;
      }
    }

	// if not a ghost, and
	// kart state is mask grab, crashed, or warped
    else
	{
	  // restore backup of alpha
      *(undefined2 *)(iVar10 + 0x22) = *(undefined2 *)(iVar12 + 0x508);
LAB_80069b50:

	  // instance -> thread -> modelIndex == "player" of any kind
      if (*(short *)(*(int *)(iVar10 + 0x6c) + 0x44) == 0x18)
	  {
		// volume, distortion, left/right
        uVar8 = 0x8080;

		// if echo is required
		if ((*(uint *)(iVar12 + 0x2c8) & 0x10000) != 0)
		{
		  // add echo, volume, distortion, left/right
          uVar8 = 0x1008080;
        }

		// driver audio
        FUN_8002e690(iVar12 + 0x30c,0xffffffff,uVar8);
      }

	  // 0x800 = this thread needs to be deleted
      *(uint *)(param_1 + 0x1c) = *(uint *)(param_1 + 0x1c) | 0x800;
    }

	// this skips $RA backup/restore, faster than JR $RA
    FUN_80071694(param_1);

  } while( true );
}


// draws level skybox
// param_1 - lev ptr_skybox
// param_2 - tileView
// param_3 - primMem
void FUN_80069bb0(int param_1,int param_2,int param_3)

{
  // register v0
  undefined4 uVar1;
  
  // register backups
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_retaddr;

  // primMem curr
  uVar1 = *(undefined4 *)(param_3 + 0xc);
  
  // backup
  DAT_1f800000 = unaff_ra;
  DAT_1f800004 = unaff_s0;
  DAT_1f800008 = unaff_s1;
  DAT_1f80000c = unaff_s2;
  
  // level ptr_skybox
  if (param_1 != 0) 
  {
	// tileView ViewProj
    gte_ldR11R12(*(undefined4 *)(param_2 + 0x28));
    gte_ldR13R21(*(undefined4 *)(param_2 + 0x2c));
    gte_ldR22R23(*(undefined4 *)(param_2 + 0x30));
    gte_ldR31R32(*(undefined4 *)(param_2 + 0x34));
    gte_ldR33(*(undefined4 *)(param_2 + 0x38));
	
	// remove transformation,
	// standard for sky in most games
    gte_ldtr(0,0,0);
	
	// These get modified in between skybox segments,
	// the C output is wrong
    DAT_1f800010 = *(int *)(param_2 + 8) + 0x500U >> 7 & 0x1c;
    DAT_1f800014 = DAT_1f800010 >> 1;
    
	// draw four skybox segments
	uVar1 = FUN_80069cc4(param_1, param_2, param_3, (param_2->0xF4) + 0xFFC);
    uVar1 = FUN_80069cc4(param_1, param_2, param_3, (param_2->0xF4) + 0xFFC);
    uVar1 = FUN_80069cc4(param_1, param_2, param_3, (param_2->0xF4) + 0xFFC);
    uVar1 = FUN_80069cc4(param_1, param_2, param_3, (param_2->0xF4) + 0xFFC);
  }
  
  // restore
  unaff_ra = DAT_1f800000;
  unaff_s0 = DAT_1f800004;
  unaff_s1 = DAT_1f800008;
  unaff_s2 = DAT_1f80000c;
  
  // new primMem curr
  *(undefined4 *)(param_3 + 0xc) = uVar1;
  
  return;
}


// draws skybox segment
// every skybox is splitted in 8 segments, only 4 are drawn at a time
// param_1 - lev ptr_skybox
// param_2 - tileView
// param_3 - primMem
// param_4 - tileView->ptrOT
void FUN_80069cc4(undefined4 param_1,undefined4 param_2,undefined4 param_3,int param_4)
{
  bool bVar1;
  uint *in_v0;
  SVECTOR *r0;
  int in_a3;
  SVECTOR *r0_00;
  SVECTOR *r0_01;
  int iVar2;
  uint uVar3;
  int in_t3;
  ushort *puVar4;
  ushort *puVar5;
  int in_t4;
  int in_t5;
  int iVar6;
  int in_t7;
  uint uVar7;
  uint uVar8;
  uint *puVar9;
  uint *puVar10;
  uint *in_t9;
  
  puVar4 = *(ushort **)(in_t3 + 0x18);
  
  if (*(ushort *)(in_t5 + 8) != 0) 
  {
    r0 = (SVECTOR *)((uint)*puVar4 + in_t4);
    r0_00 = (SVECTOR *)((uint)puVar4[1] + in_t4);
    r0_01 = (SVECTOR *)((*(uint *)(puVar4 + 2) & 0xffff) + in_t4);
    iVar6 = *(ushort *)(in_t5 + 8) - 1;
    puVar9 = (uint *)(((int)*(uint *)(puVar4 + 2) >> 0x10) + param_4);
    
	while( true ) 
	{
      puVar10 = puVar9;
      gte_ldv0(r0);
      gte_ldRGB0(r0 + 1);
      gte_ldv1(r0_00);
      gte_ldRGB1(r0_00 + 1);
      gte_ldv2(r0_01);
      gte_ldRGB2(r0_01 + 1);
      bVar1 = iVar6 == 0;
      iVar6 = iVar6 + -1;
      if (bVar1) break;
      gte_rtpt_b();
      puVar5 = puVar4 + 4;
      r0 = (SVECTOR *)((uint)*puVar5 + in_t4);
      r0_00 = (SVECTOR *)((uint)puVar4[5] + in_t4);
      puVar9 = (uint *)(((int)*(uint *)(puVar4 + 6) >> 0x10) + param_4);
      r0_01 = (SVECTOR *)((*(uint *)(puVar4 + 6) & 0xffff) + in_t4);
      uVar7 = gte_stSXY0();
      iVar2 = gte_stFLAG();
      uVar8 = gte_stSXY1();
      uVar3 = gte_stSXY2();
      puVar4 = puVar5;
      in_t9 = puVar10;
      
	  if ((((uint)(iVar2 << 0xd) >> 0x1d == 0) &&
          (uVar3 = ~(uVar7 - in_t7 | uVar8 - in_t7 | uVar3 - in_t7) | uVar7 & uVar8 & uVar3,
          -1 < (int)uVar3)) && (-1 < (int)(uVar3 << 0x10))) 
	  {
        gte_stRGB0();
        gte_stSXY0();
        gte_stRGB1();
        gte_stSXY1();
        gte_stRGB2();
        gte_stSXY2();
		
		// write PrimMem and OTMem
        uVar3 = (uint)in_v0 & 0xffffff;
        *in_v0 = *puVar10 | 0x6000000;
        in_v0 = in_v0 + 7;
        *puVar10 = uVar3;
      }
    }
    
	gte_rtpt_b();
    uVar7 = gte_stSXY0();
    iVar6 = gte_stFLAG();
    uVar8 = gte_stSXY1();
    uVar3 = gte_stSXY2();
	
    if ((((uint)(iVar6 << 0xd) >> 0x1d == 0) &&
        (uVar3 = ~(uVar7 - in_t7 | uVar8 - in_t7 | uVar3 - in_t7) | uVar7 & uVar8 & uVar3,
        -1 < (int)uVar3)) && (-1 < (int)(uVar3 << 0x10))) 
	{
      gte_stRGB0();
      gte_stSXY0();
      gte_stRGB1();
      gte_stSXY1();
      gte_stRGB2();
      gte_stSXY2();
	  
	  // write PrimMem and OTMem
      *in_v0 = *in_t9 | 0x6000000;
      *in_t9 = (uint)in_v0 & 0xffffff;
    }
  }
  return;
}


// AnimateQuads
// param1 - timer
// param2 - num vertices
// param3 - ptr OVert
// param4 - VisMem 0x30 - 0x3F (visSCVertList)
// animates vertex position and color (i.e. roo's pipes floor and vegetation)
void FUN_80069e70(undefined4 param_1,int param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  undefined4 unaff_s7;
  undefined4 unaff_retaddr;

  // clear GTE color registers
  gte_ldfcdir(0,0,0);

  param_3 = param_3 + -0x10;
  iVar2 = 0x20;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800028 = unaff_retaddr;
  
  // loop through all vertices
  while (bVar1 = param_2 != 0, param_2 = param_2 + -1, bVar1) 
  {
    bVar1 = iVar2 == 0;
    iVar2 = iVar2 + -1;
    if (bVar1) {
      iVar2 = 0x1f;
    }
	
	// next OVert
    param_3 = param_3 + 0x10;
	
	// AnimateQuadVertex
    FUN_80069f0c(param_1,param_2,param_3);
  }
  return;
}


// AnimateQuadVertex
// param1 - timer
// param2 - num vertices
// param3 - ptr OVert
void FUN_80069f0c(undefined4 param_1,undefined4 param_2,uint **param_3)

{
  uint in_t5;
  uint *puVar1;
  uint uVar2;
  int unaff_s1;
  int unaff_s2;
  uint *puVar3;
  uint *puVar4;
  code *UNRECOVERED_JUMPTABLE;

  if ((in_t5 & 1) != 0)
  {
	  // jmp 8 bytes back, which is basically...
	  return;
  }

  // OVert -> xy offset
  puVar4 = param_3[2];
  
  // OVert -> LevVert
  puVar1 = *param_3;
  
  // OVert -> zw offset
  puVar3 = param_3[1];
  
  // r16 = r23 >> 0x10
  uVar2 = (int)puVar4 >> 0x10;

  // r19 = r16 & 0x3ff
  
  // unused parameter copy
  // in the delay slot of jal
  // r4 = r19

  // TRIG_AngleSinCos_r19r17r18
  FUN_80069f94();

  // r16 & 0x8000,
  // 180-360 degrees
  if ((int)uVar2 < 0) 
  {
	// warp position
	
	// LevVert -> position = trig output multiplied by
	// OVert -> position offsets
    *puVar1 = (int)puVar3 + (unaff_s1 >> 7) | (uint)puVar3 & 0xffff0000;
    *(short *)(puVar1 + 1) = (short)puVar4 + (short)(unaff_s2 >> 7);
  }
  
  // 90 - 180, or 270 - 360
  if ((uVar2 & 0x4000) != 0)
  {
	// warp color
	  
    gte_ldIR0(unaff_s1 + 0x1000 >> 2);

	// OVert -> color offset
	// load vector into gte color registers
    gte_ldRGB(param_3 + 3);

	// kernel of dpq color
	gte_dpcs();

    gte_stRGB2();
    gte_stRGB2();
  }

  // jumps to right before
  // the call to FUN_80069f0c
  jmp r20;
}


// TRIG_AngleSinCos_r19r17r18
void FUN_80069f94(void)
{
		// input:
		// s3 = angle [0000 - ffff]
		// [0 - 360] degrees

		// output:
		// s1 = trigApprox (sine or cosine)

		// input,output
		// s3,s1
		// (000-180)	0x000,0x000		0x200,0xB50		0x400,0x1000,	0x600,0xB50
		// (180-360)	0x800,0x000		0xA00,-0xB50	0xC00,-0x1000,	0xE00,-0xB50

		// v1 = 800845a0 (trigApprox)
        80069f94 08 80 03 3c     lui        v1,0x8008
        80069f98 a0 45 63 24     addiu      v1,v1,0x45a0

        80069f9c ff 03 71 32     andi       s1,s3,0x3ff
        80069fa0 80 88 11 00     sll        s1,s1,0x2
        80069fa4 21 18 71 00     addu       v1,v1,s1
        80069fa8 00 00 71 8c     lw         s1,0x0(v1)=>DAT_800845a0
        80069fac 00 04 63 32     andi       v1,s3,0x400
        80069fb0 07 00 60 14     bne        v1,zero,LAB_80069fd0
        80069fb4 00 08 63 32     _andi      v1,s3,0x800
        80069fb8 03 94 11 00     sra        s2,s1,0x10
        80069fbc 00 8c 11 00     sll        s1,s1,0x10
        80069fc0 09 00 60 14     bne        v1,zero,LAB_80069fe8
        80069fc4 03 8c 11 00     _sra       s1,s1,0x10
        80069fc8 08 00 e0 03     jr         ra
        80069fcc 00 00 00 00     _nop

		80069fd0 00 94 11 00     sll        s2,s1,0x10
        80069fd4 03 94 12 00     sra        s2,s2,0x10
        80069fd8 06 00 60 14     bne        v1,zero,LAB_80069ff4
        80069fdc 03 8c 11 00     _sra       s1,s1,0x10
        80069fe0 08 00 e0 03     jr         ra
        80069fe4 22 90 12 00     _sub       s2,zero,s2

		80069fe8 22 90 12 00     sub        s2,zero,s2
        80069fec 08 00 e0 03     jr         ra
        80069ff0 22 88 11 00     _sub       s1,zero,s1

		80069ff4 08 00 e0 03     jr         ra
        80069ff8 22 88 11 00     _sub       s1,zero,s1
}


// Draw Confetti
// param1 - tileView
// param2 - primMem
// param3 - &gGT->confetti
// param4 - frame timer
// param5 - isPaused
void FUN_80069ffc(short *param_1,int param_2,uint *param_3,short param_4,int param_5)

{
  bool bVar1;
  undefined uVar2;
  short sVar3;
  short sVar4;
  short sVar5;
  short sVar6;
  ushort uVar7;
  int iVar8;
  uint *puVar9;
  undefined4 *puVar10;
  uint uVar11;
  short sVar12;
  short sVar13;
  undefined4 *puVar14;
  uint uVar15;
  int iVar16;
  int iVar17;
  int iVar18;
  uint uVar19;
  undefined4 uVar20;
  int iVar21;
  int iVar22;
  uint uVar23;
  int iVar24;
  int iVar25;
  uint uVar26;
  uint *puVar27;
  int unaff_s0;
  int iVar28;
  int unaff_s1;
  int iVar29;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  uint uVar30;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  int iVar31;
  undefined4 unaff_s7;
  uint uVar32;
  uint uVar33;
  short sVar34;
  uint uVar35;
  undefined *puVar36;
  uint uVar37;
  undefined *puVar38;
  undefined4 unaff_s8;
  uint uVar39;
  undefined4 unaff_retaddr;
  int iVar40;
  undefined auStackX0 [16];

  iVar8 = 0x1f800000;

  // backup $gp
  DAT_1f800020 = &DAT_8008cf6c;

  gte_ldtr(0,0,0);
  puVar10 = &DAT_8008a2a0;
  puVar14 = &DAT_1f800058;
  iVar16 = 8;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800024 = (undefined *)register0x00000074;
  DAT_1f800028 = unaff_s8;
  DAT_1f80002c = unaff_retaddr;
  do {
    uVar20 = *puVar10;
    puVar10 = puVar10 + 1;
    *puVar14 = uVar20;
    puVar14 = puVar14 + 1;
    bVar1 = 0 < iVar16;
    iVar16 = iVar16 + -1;
  } while (bVar1);

  // cameara110 matrix m1 (0x28)
  gte_ldR11R12(*(undefined4 *)(param_1 + 0x14));
  gte_ldR13R21(*(undefined4 *)(param_1 + 0x16));
  gte_ldR22R23(*(undefined4 *)(param_1 + 0x18));
  gte_ldR31R32(*(undefined4 *)(param_1 + 0x1a));
  gte_ldR33(*(undefined4 *)(param_1 + 0x1c));

  // TRIG_AngleSinCos_r15r16r17
  puVar9 = (uint *)FUN_8006a4c4();

  iVar28 = unaff_s0 >> 2;
  sVar6 = (short)iVar28 + 0x400;
  iVar16 = unaff_s1 >> 2;
  iVar31 = iVar16 + 0x400;

  // numParticles_max
  uVar30 = param_3[2];

  // sizeX
  iVar25 = *(int *)(param_1 + 0x10);

  // ptrOT
  iVar24 = *(int *)(param_1 + 0x7a);

  // window size X and Y
  gte_ldOFX((int)param_1[0x10] << 0xf);
  gte_ldOFY((int)param_1[0x11] << 0xf);

  // distance to screen
  gte_ldH(*(undefined4 *)(param_1 + 0xc));

  // numParticles_curr
  uVar26 = *param_3;

  // previous frame?
  uVar11 = (uint)*(ushort *)(param_3 + 1);

  // if not paused
  if (param_5 == 0) {
    uVar15 = (uint)*(ushort *)((int)param_3 + 6);

	// change in particles?
    iVar17 = uVar11 - uVar26;

	// if change?
	if (uVar11 != uVar26)
	{
      if (iVar17 < 0) {
        uVar26 = uVar26 - uVar15;
        if (0 < (int)(iVar17 + uVar15)) {
          uVar26 = uVar11;
        }
      }
      else {
        uVar26 = uVar26 + uVar15;
        if ((int)(iVar17 - uVar15) < 0) {
          uVar26 = uVar11;
        }
      }

	  // set new numParticles?
      *param_3 = uVar26;
    }
  }

  // camera position
  sVar3 = *param_1;
  sVar4 = param_1[1];
  sVar5 = param_1[2];

  *(undefined4 *)(iVar8 + 0x34) = 0x28000000;
  uVar39 = 6;
  uVar35 = 0x95000000;
  puVar36 = (undefined *)0xb9000000;
  uVar11 = 0x3583fe30;
  puVar38 = (undefined *)0x59000000;
  uVar15 = 0x59b99549;
  while( true ) {
    uVar39 = uVar39 - 1;
    if (uVar39 == 0) {
      uVar39 = 6;
    }
    bVar1 = uVar26 == 0;
    uVar26 = uVar26 - 1;
    if (bVar1) break;
    *(uint *)(iVar8 + 0x30) = uVar26;
    uVar7 = (short)((int)puVar36 >> 0x15) + ((short)uVar30 * param_4 - sVar4) & 0x7ff;
    uVar37 = ((int)puVar38 >> 0x15) + (iVar31 - sVar5) & 0x7ff;
    sVar34 = ((short)((int)uVar35 >> 0x15) + (sVar6 - sVar3) & 0x7ffU) - sVar6;
    iVar17 = -iVar31;

	// TRIG_AngleSinCos_r15r16r17
    FUN_8006a4c4();

    sVar34 = sVar34 + (short)(iVar28 >> 5);
    iVar21 = iVar16 >> 5;
    iVar18 = iVar28;
    iVar22 = iVar16;

	// TRIG_AngleSinCos_r15r16r17
    puVar9 = (uint *)FUN_8006a4c4();

    iVar29 = iVar16;
    if (iVar16 < 1) {
      iVar29 = -iVar16;
    }
    uVar2 = *(undefined *)((iVar29 >> 7) + iVar8 + 0x58);
    *(undefined *)(iVar8 + 0x34) = 0;
    if ((uVar39 & 1) != 0) {
      *(undefined *)(iVar8 + 0x34) = uVar2;
    }
    *(undefined *)(iVar8 + 0x35) = 0;
    if ((uVar39 & 2) != 0) {
      *(undefined *)(iVar8 + 0x35) = uVar2;
    }
    *(undefined *)(iVar8 + 0x36) = 0;
    if ((uVar39 & 4) != 0) {
      *(undefined *)(iVar8 + 0x36) = uVar2;
    }
    iVar40 = iVar28 * iVar18;
    iVar29 = iVar16 >> 8;
    sVar13 = (short)((uint)iVar16 >> 8);
    sVar12 = (uVar7 - 0x400) - sVar13;
    *(short *)(iVar8 + 0x3a) = sVar12;
    *(short *)(iVar8 + 0x42) = sVar12;
    sVar13 = (uVar7 - 0x400) + sVar13;
    *(short *)(iVar8 + 0x4a) = sVar13;
    *(short *)(iVar8 + 0x52) = sVar13;
    iVar16 = iVar28 * iVar22;
    iVar28 = iVar28 >> 8;
    sVar12 = (short)((uint)iVar22 >> 8);
    sVar13 = (short)(iVar40 >> 0x14);
    *(short *)(iVar8 + 0x38) = (sVar34 - sVar12) - sVar13;
    *(short *)(iVar8 + 0x40) = (sVar34 + sVar12) - sVar13;
    *(short *)(iVar8 + 0x48) = (sVar34 - sVar12) + sVar13;
    *(short *)(iVar8 + 0x50) = sVar34 + sVar12 + sVar13;
    iVar18 = iVar18 >> 8;
    iVar16 = iVar16 >> 0x14;
    *(uint *)(iVar8 + 0x3c) = ((uVar37 + iVar17 + iVar21) - iVar18) + iVar16;
    *(uint *)(iVar8 + 0x44) = uVar37 + iVar17 + iVar21 + iVar18 + iVar16;
    *(uint *)(iVar8 + 0x4c) = ((uVar37 + iVar17 + iVar21) - iVar18) - iVar16;
    *(uint *)(iVar8 + 0x54) = (uVar37 + iVar17 + iVar21 + iVar18) - iVar16;
    gte_ldVXY0(iVar8 + 0x38);
    gte_ldVZ0(iVar8 + 0x3c);
    gte_ldVXY1(iVar8 + 0x40);
    gte_ldVZ1(iVar8 + 0x44);
    gte_ldVXY2(iVar8 + 0x48);
    gte_ldVZ2(iVar8 + 0x4c);
    uVar32 = uVar15 >> 8;
    gte_rtpt_b();
    uVar15 = uVar11 >> 8 | uVar15 << 0x18;
    uVar35 = (uVar11 + uVar32 + (uVar15 >> 8)) * 0x1000000;
    uVar33 = (uVar32 | uVar35) >> 8;
    uVar32 = uVar15 >> 8 | uVar32 << 0x18;
    puVar36 = (undefined *)((uVar15 + uVar33 + (uVar32 >> 8)) * 0x1000000);
    uVar11 = uVar32 >> 8 | uVar33 << 0x18;
    puVar38 = (undefined *)((uVar32 + ((uVar33 | (uint)puVar36) >> 8) + (uVar11 >> 8)) * 0x1000000);
    uVar15 = (uVar33 | (uint)puVar36) >> 8 | (uint)puVar38;
    uVar32 = gte_stSXY0();
    iVar17 = gte_stFLAG();
    uVar33 = gte_stSXY1();
    uVar19 = gte_stSXY2();
    gte_stSXY0();
    gte_ldVXY0(iVar8 + 0x50);
    gte_ldVZ0(iVar8 + 0x54);
    iVar16 = iVar29;
    if (-1 < iVar17 << 0xe) {
      gte_rtps_b();
      uVar23 = gte_stSXY2();
      iVar17 = gte_stFLAG();
      uVar32 = ~(uVar32 - iVar25 | uVar33 - iVar25 | uVar19 - iVar25 | uVar23) |
               uVar32 & uVar33 & uVar19 & uVar23;
      if (-1 < iVar17 << 0xe) {
        gte_avsz4_b();
        if ((-1 < (int)uVar32) && (-1 < (int)(uVar32 << 0x10))) {
          gte_stSXY0();
          gte_stSXY1();
          gte_stSXY2();
          uVar26 = gte_stMAC0();
          puVar9[1] = *(uint *)(iVar8 + 0x34);
          puVar27 = (uint *)((uVar26 >> 0x12) * 4 + iVar24);
          *puVar9 = *puVar27 | 0x5000000;
          *puVar27 = (uint)puVar9 & 0xffffff;
          uVar26 = *(uint *)(iVar8 + 0x30);
          puVar9 = puVar9 + 6;
        }
      }
    }
  }
  *(uint **)(param_2 + 0xc) = puVar9;
  return;
}

// TRIG_AngleSinCos_r15r16r17
void FUN_8006a4c4(void)

{
		// input:
		// t7 = angle [0000 - ffff]
		// [0 - 360] degrees

		// output:
		// s0 = trigApprox (sine or cosine)

		// input,output
		// t7,s0
		// (000-180)	0x000,0x000		0x200,0xB50		0x400,0x1000,	0x600,0xB50
		// (180-360)	0x800,0x000		0xA00,-0xB50	0xC00,-0x1000,	0xE00,-0xB50

		// v1 = 800845a0 (trigApprox)
        8006a4c4 08 80 03 3c     lui        v1,0x8008
        8006a4c8 a0 45 63 24     addiu      v1,v1,0x45a0

		// s0 = t7 & 3fff
		// clamp [0 - 90 degrees]
        8006a4cc ff 03 f0 31     andi       s0,t7,0x3ff

		// multiply by 4, byte offset, int array
        8006a4d0 80 80 10 00     sll        s0,s0,0x2

		// v1 = &trigApprox[t7 & 0x3ff]
        8006a4d4 21 18 70 00     addu       v1,v1,s0

		// s0 = *v1
		// read trigApprox
        8006a4d8 00 00 70 8c     lw         s0,0x0(v1)=>DAT_800845a0

		// if (90 < angle < 180) or (270 < angle < 360), jump 8006a500
        8006a4dc 00 04 e3 31     andi       v1,t7,0x400
        8006a4e0 07 00 60 14     bne        v1,zero,LAB_8006a500

		// if (0 < angle < 90) or (180 < angle < 270)
		// {
			8006a4e4 00 08 e3 31     _andi      v1,t7,0x800
			8006a4e8 03 8c 10 00     sra        s1,s0,0x10
			8006a4ec 00 84 10 00     sll        s0,s0,0x10
			8006a4f0 09 00 60 14     bne        v1,zero,LAB_8006a518
			8006a4f4 03 84 10 00     _sra       s0,s0,0x10
			8006a4f8 08 00 e0 03     jr         ra
			8006a4fc 00 00 00 00     _nop
		// }

        8006a500 00 8c 10 00     sll        s1,s0,0x10
        8006a504 03 8c 11 00     sra        s1,s1,0x10
        8006a508 06 00 60 14     bne        v1,zero,LAB_8006a524
        8006a50c 03 84 10 00     _sra       s0,s0,0x10
        8006a510 08 00 e0 03     jr         ra
        8006a514 22 88 11 00     _sub       s1,zero,s1

        8006a518 22 88 11 00     sub        s1,zero,s1
        8006a51c 08 00 e0 03     jr         ra
        8006a520 22 80 10 00     _sub       s0,zero,s0

        8006a524 08 00 e0 03     jr         ra
        8006a528 22 80 10 00     _sub       s0,zero,s0
}

// RenderBucket_DrawFunc_Normal
void FUN_8006a52c(void)

{
  bool bVar1;
  undefined uVar2;
  short sVar3;
  short sVar4;
  ushort uVar5;
  ushort uVar6;
  int in_at;
  undefined4 in_v0;
  undefined4 extraout_v1;
  undefined4 extraout_v1_00;
  int iVar7;
  code *pcVar8;
  int *piVar9;
  int iVar10;
  uint uVar11;
  int iVar12;
  int in_t0;
  uint uVar13;
  uint uVar14;
  int iVar15;
  undefined4 *puVar16;
  undefined4 uVar17;
  undefined4 uVar18;
  uint in_t3;
  code *unaff_s5;
  code *unaff_s6;
  ushort *puVar19;
  short *psVar20;
  uint *in_t9;
  uint *puVar21;
  undefined4 *puVar22;
  undefined8 uVar23;
  int iStack4;

code_r0x8006a52c:
  puVar21 = in_t9 + 1;
  if (in_t0 == 0) {
    while( true ) {
      piVar9 = *(int **)(in_at + 4);

	  // get pointer to Instance
      iVar7 = *piVar9;

	  // also pointer to instance?
	  iVar12 = piVar9[1];

      *(int **)(in_at + 4) = piVar9 + 2;

	  if (iVar7 == 0) break;

	  // instance -> tileView
      iVar10 = *(int *)(iVar12 + 0x74);
	  
      iVar15 = *(int *)(in_at + 8);
      *(int *)(in_at + 0x10) = iVar7;
      *(int *)(in_at + 8) = iVar10;
      
	  // if not the same tileView as previous instance
	  if (iVar10 != iVar15) 
	  {
		// take tileView width, height,
		// and distToScreen, put them all in GTE,
		// and scratchpad
		
		// width, height, distToScreen
        sVar3 = *(short *)(iVar10 + 0x20);
        sVar4 = *(short *)(iVar10 + 0x22);
        uVar17 = *(undefined4 *)(iVar10 + 0x18);
		
		// scratchpad
        *(short *)(in_at + 0x1c) = sVar3;
        *(short *)(in_at + 0x1e) = sVar4;
        
		// GTE
		setCopControlWord(2,0xc000,(int)sVar3 << 0xf);
        setCopControlWord(2,0xc800,(int)sVar4 << 0xf);
        setCopControlWord(2,0xd000,uVar17);
      }

	  // instance flags, duplicate of 0x28
	  uVar11 = *(uint *)(iVar12 + 0xb8);

      sVar3 = *(short *)(iVar12 + 0xbc);

	  if (
			((uVar11 & 0x40) != 0) &&

			// if instance is not invisible
			((uVar11 & 0x80) == 0)
		 )
	  {
		// instance matrix at offset 0x78
		gte_ldR11R12(*(undefined4 *)(iVar12 + 0x78));
		gte_ldR13R21(*(undefined4 *)(iVar12 + 0x7c));
		gte_ldR22R23(*(undefined4 *)(iVar12 + 0x80));
		gte_ldR31R32(*(undefined4 *)(iVar12 + 0x84));
		gte_ldR33(*(undefined4 *)(iVar12 + 0x88));
		
		gte_ldtr(
		  *(undefined4 *)(iVar12 + 0x8c),
		  *(undefined4 *)(iVar12 + 0x90),
		  *(undefined4 *)(iVar12 + 0x94)
		);

        *(uint *)(in_at + 0x24) = uVar11;
        *(int *)(in_at + 0x120) = (int)sVar3;

        if ((uVar11 & 0x7000) != 0)
		{
		  // instance matrix at offset 0x98
		  gte_ldL11L12(*(undefined4 *)(iVar12 + 0x98));
		  gte_ldL13L21(*(undefined4 *)(iVar12 + 0x9c));
		  gte_ldL22L23(*(undefined4 *)(iVar12 + 0xa0));
		  gte_ldL31L32(*(undefined4 *)(iVar12 + 0xa4));
		  gte_ldL33(*(undefined4 *)(iVar12 + 0xa8));

          sVar3 = *(short *)(iVar12 + 0xbe);
          uVar2 = *(undefined *)(iVar7 + 0x53);
          uVar17 = *(undefined4 *)(iVar7 + 0x58);
          *(short *)(in_at + 0x44) = sVar3;
          *(short *)(in_at + 0xda) = sVar3;
          *(short *)(in_at + 0xf2) = sVar3;
          *(undefined *)(in_at + 0x48) = uVar2;
          *(undefined4 *)(in_at + 0x4c) = uVar17;
          *(int *)(in_at + 0x11c) = (int)sVar3 << 0x11;
          *(undefined4 *)(in_at + 0xe0) = 0;
          *(undefined4 *)(in_at + 0xf8) = 0;
        }

		// next origin
		psVar20 = *(short **)(iVar12 + 0xc4);

		// current origin
		puVar19 = *(ushort **)(iVar12 + 0xc0);

		// if there is no pointer to next origin,
		// if there is no 60fps
        if (psVar20 == (short *)0x0)
		{
		  // store origin
          uVar5 = puVar19[1];
          uVar6 = puVar19[2];
          *(ushort *)(in_at + 0x30) = *puVar19 & 0x7fff;
          *(ushort *)(in_at + 0x32) = uVar5;
          *(int *)(in_at + 0x34) = (int)(short)uVar6;
        }

		// if there is a next origin,
		// for 60fps stuff
        else
		{
		  // add them both, for interpolation.
		  // they were both halved before this function was called
          *(ushort *)(in_at + 0x30) = *puVar19 + *psVar20;
          *(ushort *)(in_at + 0x32) = puVar19[1] + psVar20[1];
          *(int *)(in_at + 0x34) = ((int)(short)puVar19[2] + (int)psVar20[2]) * 2;
        }

		// reset reflection color
        *(undefined4 *)(in_at + 0x58) = 0;

		// ptrColorLayout
        puVar22 = *(undefined4 **)(iVar12 + 0xd0);

		// deref ptrCommandList, get numColors
        iVar10 = **(int **)(iVar12 + 200);

        puVar16 = (undefined4 *)(in_at + 0x140);

		// write color array
        while (bVar1 = 0 < iVar10, iVar10 = iVar10 + -1, bVar1) {
          uVar17 = *puVar22;
          puVar22 = puVar22 + 1;
          *puVar16 = uVar17;
          puVar16 = puVar16 + 1;
        }

		// execute instance->funcPtr
        (**(code **)(iVar7 + 0x5c))();

		sVar3 = *(short *)(iVar12 + 0xde);
        *(short *)(in_at + 0x134) = (short)((int)*(short *)(iVar12 + 0xdc) << 2);
        *(short *)(in_at + 0x136) = (short)((int)sVar3 << 2);
        uVar17 = *(undefined4 *)(iVar12 + 0xe4);
        uVar18 = *(undefined4 *)(iVar12 + 0xe8);
        pcVar8 = *(code **)(iVar12 + 0xec);
        *(undefined4 *)(in_at + 0x38) = uVar17;
        *(undefined4 *)(in_at + 0x3c) = uVar17;
        *(undefined4 *)(in_at + 0x40) = uVar18;
        in_v0 = (*pcVar8)(*(undefined4 *)(iVar7 + 100));
      }
    }
    *(undefined4 *)(*(int *)(in_at + 0xc) + 0xc) = in_v0;
    return;
  }
  *(uint *)(in_at + 0x10c) = in_t3;
  (*unaff_s6)();
  setCopReg(2,0,in_t0);
  setCopReg(2,0x800,extraout_v1);
  (*unaff_s6)();
  setCopReg(2,0x1000,in_t0);
  setCopReg(2,0x1800,extraout_v1_00);
  uVar23 = (*unaff_s6)();
  in_v0 = (undefined4)uVar23;
  setCopReg(2,0x2000,in_t0);
  setCopReg(2,0x2800,(int)((ulonglong)uVar23 >> 0x20));
  in_t3 = *(uint *)(in_at + 0x10c);
  copFunction(2,0x280030);
  in_t9 = puVar21 + 1;
  do {
    uVar11 = in_t3 & 0x1ff;
    iVar12 = uVar11 * 4;
    if (uVar11 != 0) {
      iVar12 = (&iStack4)[uVar11];
    }
    iVar7 = *(int *)(in_at + 0x1c);
    uVar11 = getCopReg(2,0x7000);
    iVar10 = getCopControlWord(2,0xf800);
    if (-1 < iVar10 << 0xd) {
      if ((int)(in_t3 << 3) < 0) {
        copFunction(2,0x1400006);
        uVar13 = getCopReg(2,0xc000);
        if ((uVar13 == 0) ||
           (uVar14 = getCopReg(2,0x6000),
           (int)(uVar13 ^ (int)*(short *)(in_at + 0x24) ^ in_t3 << 2) < 1)) goto LAB_8006a610;
      }
      else {
        uVar14 = getCopReg(2,0x6000);
      }
      uVar13 = getCopReg(2,0x6800);
      copFunction(2,0x158002d);
      uVar11 = ~(uVar14 - iVar7 | uVar13 - iVar7 | uVar11 - iVar7) | uVar14 & uVar11 & uVar13;
      if (-1 < (int)uVar11) {
        uVar17 = getCopReg(2,0x18);
        *(undefined4 *)(in_at + 0x2c) = uVar17;
        if (-1 < (int)(uVar11 << 0x10)) {
          *(int *)(in_at + 0x50) = iVar12;
          in_v0 = (*unaff_s5)();
        }
      }
    }
LAB_8006a610:
    do {
      in_t3 = *in_t9;
      in_t9 = in_t9 + 1;
      in_t0 = in_t3 + 1;
      if ((int)in_t3 < 0) goto code_r0x8006a52c;
      uVar11 = in_t3 >> 0x10;
    } while (uVar11 == 0);
    if ((int)(in_t3 << 1) < 0) {
      uVar17 = getCopReg(2,0x6000);
      uVar18 = getCopReg(2,0x8800);
      setCopReg(2,0x6800,uVar17);
      setCopReg(2,0x9000,uVar18);
    }
    uVar23 = (*unaff_s6)();
    in_v0 = (undefined4)uVar23;
    setCopReg(2,0,uVar11);
    setCopReg(2,0x800,(int)((ulonglong)uVar23 >> 0x20));
    copFunction(2,0x180001);
  } while( true );
}

// animated model rendering related?
// called as funcPtr in register $s6 (r22)
// from DrawFunc_Normal
void FUN_8006a8e0(void)

{
  int in_at;
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  char cVar6;
  uint in_t3;
  uint in_t4;
  uint in_t5;
  uint unaff_s1; // int temporalbits
  int unaff_s3;
  uint uVar7;
  uint uVar8;
  int iVar9;
  uint uVar10;
  uint *unaff_s7;
  uint *unaff_s8;

  iVar5 = (in_t3 >> 0xd & 0x7f8) + in_at;
  if (-1 < (int)(in_t3 << 5)) { // check that it is actually a compressed animation
    if (unaff_s8 == (uint *)0x0) {  // 4D delta array pointer is zero i.e. doesn't exist. skip de-compression. and do something??
      uVar1 = *unaff_s7;
    }
    else {
      // some variable names change and flip because variables are re-used( compiler optimisations? ). from: branch


      // uint delta = *deltaArray[0];
      uVar10 = *unaff_s8;
      // uint AAA = delta >> 6 & 7;
      uVar2 = uVar10 >> 6 & 7; // AAA
      // uint bits_needed = AAA + 1;
      uVar3 = uVar2 + 1;
      // current_bits_difference = old_bits_left + bits_needed
      uVar7 = unaff_s3 + uVar3; // bits left in the temporal uint?
      // char temporal_x = (char)((int)temporalbits >> (bits_needed ^ 0x1f));
      cVar6 = (char)((int)unaff_s1 >> (uVar2 ^ 0x1f));
      // temporalBitData = temporalbits;
      uVar1 = unaff_s1;
      // bits_read = current_bits_difference;
      uVar8 = uVar7;
      // if(current_bits_difference < 0)
      if (0 < (int)uVar7) { // do we beed more bits from the temporalArray?
        // temporalBitData = *temporalArray;
        uVar1 = *unaff_s7;
        // temporalArray = temporalArray + 1;
        unaff_s7 = unaff_s7 + 1;
        // temporal_x = (char)((int)(temporalbits | temporalBitData >> (bits_needed - current_bits_difference & 0x1f)) >> (AAA ^ 0x1f));
        cVar6 = (char)((int)(unaff_s1 | uVar1 >> (uVar3 - uVar7 & 0x1f)) >> (uVar2 ^ 0x1f));
        // bits_read = current_bits_difference - 32;
        uVar8 = uVar7 - 0x20; // bitstream bit pointer moved by 32 bits
        // bits_needed = current_bits_difference;
        uVar3 = uVar7;
      }
      // temporalBitData = temporalBitData << (bits_needed & 0x1f);
      uVar1 = uVar1 << (uVar3 & 0x1f); // injecting fresh new bits to temporalBitData
      //if(AAA != 7)
      if (uVar2 != 7) { //if not reset X-counter reset; but if is reset just pass delta.X( accumulator.X gets erased)
        // temporal_x = temporal_x + delta.X * 2 + accumulator.X
        cVar6 = cVar6 + (char)((int)uVar10 >> 0x19) * '\x02' + *(char *)(in_at + 0x58);
      }
      // accumulator.X = temporal_x;
      *(char *)(in_at + 0x58) = cVar6;
      // uint BBB = delta >> 3 & 7;
      uVar4 = uVar10 >> 3 & 7; // BBB
      // bits_needed = BBB + 1;
      uVar2 = uVar4 + 1;
      // current_bits_difference = old_bits_left + bits_needed;
      uVar8 = uVar8 + uVar2;
      // bits_needed = temporalBitData;
      uVar3 = uVar1;
      // bits_read = current_bits_difference;
      uVar7 = uVar8;
      // if(current_bits_difference < 0)
      if (0 < (int)uVar8) { // do we beed more bits from the temporalArray?
        // temporalBitData = *temporalArray;
        uVar3 = *unaff_s7;
        // temporalArray = temporalArray + 1;
        unaff_s7 = unaff_s7 + 1;
        // temporalBitData = temporalBitData | temporalBitData >> (bits_needed - current_bits_difference & 0x1f);
        uVar1 = uVar1 | uVar3 >> (uVar2 - uVar8 & 0x1f);
        // bits_read = current_bits_difference - 32;
        uVar7 = uVar8 - 0x20;
        // bits_needed = current_bits_difference;
        uVar2 = uVar8;
      }
      // temporal_x = temporalBitData >> (BBB ^ 0x1f);
      cVar6 = (char)((int)uVar1 >> (uVar4 ^ 0x1f)); // xor may do the bit-reset, this may make accumulator-axis go to zero
      // temporalBitData = temporalBitData << (bits_needed & 0x1f);
      uVar3 = uVar3 << (uVar2 & 0x1f);
      //if(BBB != 7)
      if (uVar4 != 7) { //if not reset Z-counter reset; but if is reset just pass delta.Z( accumulator.Z gets zeroed)
        // temporal_z = (char)(temporal_z + (char)((delta << 7) >> 0x18)(delta.Z) + accumulator.Z);
        cVar6 = cVar6 + (char)((uVar10 << 7) >> 0x18) + *(char *)(in_at + 0x5a);
      }
      // accumulator.Z = temporal_z;
      *(char *)(in_at + 0x5a) = cVar6;
      // uint CCC = delta & 7;
      uVar1 = uVar10 & 7; // CCC
      // current_bits_difference = bits_read + CCC + 1
      iVar9 = uVar7 + uVar1 + 1;
      // if (0 < current_bits_difference) {
      if (0 < iVar9) { // check signed bit
        // temporalBitData = temporalBitData | (*temporalArray) >> ((CCC + 1) - current_bits_difference & 0x1f);
        uVar3 = uVar3 | *unaff_s7 >> ((uVar1 + 1) - iVar9 & 0x1f);
      }
      // temporal_z = (char)((int)temporalBitData >> (CCC ^ 0x1f));
      cVar6 = (char)((int)uVar3 >> (uVar1 ^ 0x1f)); // xor may do the bit-reset, i.e. this may make accumulator-axis go to zero
      //if(CCC != 7)
      if (uVar1 != 7) { //if not reset Y-counter reset; but if is reset just pass delta.Y( accumulator.Y gets zeroed)
        // temporal_y = (char)(temporal_y + (char)((delta << 15) >> 0x18)(delta.Y) + accumulator.Y);
        cVar6 = cVar6 + (char)((uVar10 << 0xf) >> 0x18) + *(char *)(in_at + 0x59);
      }
      // accumulator.Z = temporal_z;
      *(char *)(in_at + 0x59) = cVar6;
      uVar1 = *(uint *)(in_at + 0x58);
    }
    iVar9 = *(int *)(in_at + 0x34);
    *(uint *)(iVar5 + 0x140) = ((uVar1 & in_t4) + *(int *)(in_at + 0x30)) * 4 & in_t5;
    *(uint *)(iVar5 + 0x144) = ((uVar1 >> 8 & 0xff) + iVar9) * 4;
  }
  if (-1 < (int)(in_t3 << 4)) {
    return;
  }
  return;
}

// param1 is Render Bucket Instance
// param2 is PrimMem pointers
// RenderBucket_Execute
void FUN_8006aaa8(int *param_1,int param_2)

{
  bool bVar1;
  undefined uVar2;
  short sVar3;
  short sVar4;
  ushort uVar5;
  ushort uVar6;
  int iVar7;
  undefined4 uVar8;
  int iVar9;
  uint uVar10;
  code *pcVar11;
  int iVar12;
  int iVar13;
  undefined4 *puVar14;
  undefined4 uVar15;
  ushort *puVar16;
  short *psVar17;
  undefined4 *puVar18;
  int iVar19;
  undefined auStack60 [16];
  undefined1 *local_c;

  DAT_1f800000 = auStack60;
  local_c = &_gp_4;
  iVar7 = 0x1f800000;
  DAT_1f800008 = 0;
  iVar19 = *param_1;
  uVar8 = *(undefined4 *)(param_2 + 0xc);
  DAT_1f80000c = param_2;
  while( true )
  {
	// instance
    iVar12 = param_1[1];

    *(int **)(iVar7 + 4) = param_1 + 2;
    if (iVar19 == 0) break;
    iVar9 = *(int *)(iVar12 + 0x74);
    iVar13 = *(int *)(iVar7 + 8);
    *(int *)(iVar7 + 0x10) = iVar19;
    *(int *)(iVar7 + 8) = iVar9;
	
	// tileView
    if (iVar9 != iVar13) 
	{
	  // width, height, distToScreen
      sVar3 = *(short *)(iVar9 + 0x20);
      sVar4 = *(short *)(iVar9 + 0x22);
      uVar15 = *(undefined4 *)(iVar9 + 0x18);
		
	  // scratchpad
      *(short *)(iVar7 + 0x1c) = sVar3;
      *(short *)(iVar7 + 0x1e) = sVar4;
        
	  // GTE
      setCopControlWord(2,0xc000,(int)sVar3 << 0xf);
      setCopControlWord(2,0xc800,(int)sVar4 << 0xf);
      setCopControlWord(2,0xd000,uVar15);
    }

	// instance flags, duplicate of 0x28
    uVar10 = *(uint *)(iVar12 + 0xb8);

    sVar3 = *(short *)(iVar12 + 0xbc);

	if (
			((uVar10 & 0x40) != 0) &&

			// if instance is not invisible
			((uVar10 & 0x80) == 0)
		)
	{
	  // instance matrix
      gte_ldR11R12(*(undefined4 *)(iVar12 + 0x78));
      gte_ldR13R21(*(undefined4 *)(iVar12 + 0x7c));
      gte_ldR22R23(*(undefined4 *)(iVar12 + 0x80));
      gte_ldR31R32(*(undefined4 *)(iVar12 + 0x84));
      gte_ldR33(*(undefined4 *)(iVar12 + 0x88));
	  
	  gte_ldtr(
	    *(undefined4 *)(iVar12 + 0x8c),
	    *(undefined4 *)(iVar12 + 0x90),
	    *(undefined4 *)(iVar12 + 0x94)
	  );
	  
      *(uint *)(iVar7 + 0x24) = uVar10;
      *(int *)(iVar7 + 0x120) = (int)sVar3;
      if ((uVar10 & 0x7000) != 0) 
	  {
		// instance matrix
		gte_ldL11L12(*(undefined4 *)(iVar12 + 0x98));
		gte_ldL13L21(*(undefined4 *)(iVar12 + 0x9c));
		gte_ldL22L23(*(undefined4 *)(iVar12 + 0xa0));
		gte_ldL31L32(*(undefined4 *)(iVar12 + 0xa4));
		gte_ldL33(*(undefined4 *)(iVar12 + 0xa8));
		
        sVar3 = *(short *)(iVar12 + 0xbe);
        uVar2 = *(undefined *)(iVar19 + 0x53);
        uVar8 = *(undefined4 *)(iVar19 + 0x58);
        *(short *)(iVar7 + 0x44) = sVar3;
        *(short *)(iVar7 + 0xda) = sVar3;
        *(short *)(iVar7 + 0xf2) = sVar3;
        *(undefined *)(iVar7 + 0x48) = uVar2;
        *(undefined4 *)(iVar7 + 0x4c) = uVar8;
        *(int *)(iVar7 + 0x11c) = (int)sVar3 << 0x11;
        *(undefined4 *)(iVar7 + 0xe0) = 0;
        *(undefined4 *)(iVar7 + 0xf8) = 0;
      }
      psVar17 = *(short **)(iVar12 + 0xc4);
      puVar16 = *(ushort **)(iVar12 + 0xc0);
      if (psVar17 == (short *)0x0) {
        uVar5 = puVar16[1];
        uVar6 = puVar16[2];
        *(ushort *)(iVar7 + 0x30) = *puVar16 & 0x7fff;
        *(ushort *)(iVar7 + 0x32) = uVar5;
        *(int *)(iVar7 + 0x34) = (int)(short)uVar6;
      }
      else {
        *(short *)(iVar7 + 0x30) = *puVar16 + *psVar17;
        *(short *)(iVar7 + 0x32) = puVar16[1] + psVar17[1];
        *(int *)(iVar7 + 0x34) = ((int)(short)puVar16[2] + (int)psVar17[2]) * 2;
      }
      *(undefined4 *)(iVar7 + 0x58) = 0;

	  // ptrColorLayout
      puVar18 = *(undefined4 **)(iVar12 + 0xd0);

	  // ptrCommandList,
	  // first int is number of colors
      iVar9 = **(int **)(iVar12 + 200);

	  // pointer to scratchpad
      puVar14 = (undefined4 *)(iVar7 + 0x140);

	  // copy colors to scratchpad
	  while (bVar1 = 0 < iVar9, iVar9 = iVar9 + -1, bVar1) {
        uVar8 = *puVar18;
        puVar18 = puVar18 + 1;
        *puVar14 = uVar8;
        puVar14 = puVar14 + 1;
      }

	  // function pointer in instance
      (**(code **)(iVar19 + 0x5c))();

      sVar3 = *(short *)(iVar12 + 0xde);
      *(undefined2 *)(iVar7 + 0x134) = (short)((int)*(short *)(iVar12 + 0xdc) << 2);
      *(undefined2 *)(iVar7 + 0x136) = (short)((int)sVar3 << 2);
      uVar8 = *(undefined4 *)(iVar12 + 0xe4);
      uVar15 = *(undefined4 *)(iVar12 + 0xe8);

	  // get render function from Instance
	  pcVar11 = *(code **)(iVar12 + 0xec);

      *(undefined4 *)(iVar7 + 0x38) = uVar8;
      *(undefined4 *)(iVar7 + 0x3c) = uVar8;
      *(undefined4 *)(iVar7 + 0x40) = uVar15;

	  // render model
	  uVar8 = (*pcVar11)(*(undefined4 *)(iVar19 + 100));
    }
    param_1 = *(int **)(iVar7 + 4);
    iVar19 = *param_1;
  }
  *(undefined4 *)(*(int *)(iVar7 + 0xc) + 0xc) = uVar8;
  return;
}


// RenderBucket_DrawInstPrim_Normal
// called by jmp inst->0x60 (8006AD88),
// called for every primitive
int FUN_8006ad6c(void)

{
  int in_at;
  u_long *in_v0;
  undefined4 uVar1;
  uint uVar2;
  u_long uVar3;
  u_long *puVar4;
  uint uVar5;
  int iVar6;
  u_long uVar7;
  uint uVar8;
  int in_t3;
  uint *puVar9;
  undefined4 in_t6;
  undefined4 in_t7;
  undefined4 unaff_s0;

  uVar1 = *(undefined4 *)(in_at + 0x3c);
  if (in_t3 << 6 < 1) {
    uVar1 = *(undefined4 *)(in_at + 0x40);
  }
  *(undefined4 *)(in_at + 0x38) = uVar1;
  puVar9 = (uint *)((*(uint *)(in_at + 0x2c) >> 0x11) * 4 + *(int *)(in_at + 0x38));
  puVar4 = *(u_long **)(in_at + 0x50);

  // load colors
  gte_ldRGB0(in_t6);
  gte_ldRGB1(in_t7);
  gte_ldRGB2(unaff_s0);

  // set transparency (which only causes darkness in this func)
  gte_ldIR0((int)*(short *)(in_at + 0x120));
  if ((*(short *)(in_at + 0x120) != 0) && (-1 < (int)puVar9 * 0x80)) {
    gte_dpct_b();
  }
  uVar2 = 0x30000000;

  // if texture data is nullptr,
  // draw prim with no texture
  if (puVar4 == (u_long *)0x0) {
    gte_stsxy3_g3(in_v0);
    uVar5 = gte_stRGB0();

	// prim size
    iVar6 = 0x1c;

    in_v0[1] = uVar2 | uVar5;
    gte_stRGB1();
    gte_stRGB2();
    uVar2 = 0x6000000;
  }

  // if texture data is valid,
  // draw prim with texture
  else {
    uVar3 = *puVar4;
    uVar5 = puVar4[1];
    uVar7 = puVar4[2];
    gte_stsxy3_gt3(in_v0);
    in_v0[3] = uVar3;
    in_v0[6] = uVar5;
    in_v0[9] = uVar7;
    uVar8 = gte_stRGB0();
    uVar2 = 0x34000000;
    if ((uVar5 & 0x600000) != 0x600000) {
      uVar2 = 0x36000000;
    }
    in_v0[1] = uVar2 | uVar8;
    gte_stRGB1();
    gte_stRGB2();

    // prim size
    iVar6 = 0x28;

	uVar2 = 0x9000000;
  }

  // write to PrimMem and OTMem
  *in_v0 = *puVar9 | uVar2;
  *puVar9 = (uint)in_v0 & 0xffffff;

  return (int)in_v0 + iVar6;
}

// RenderBucket_InitDepthGTE
void FUN_8006ae74(void)
{
  // depth queing parameters,
  // A = coeff
  // B = offset
  gte_ldDQA(0);
  gte_ldDQB(0);

  // both impact depth and draw order somehow?
  // documentation says "average Z scale factor"
  gte_ldZSF3(0x555);
  gte_ldZSF4(0x400);

  return;
}

// RenderBucket_DrawInstPrim_KeyRelicToken
// does not apply to Tiger Temple Flamejet, so not "Prim_Specular"
uint * FUN_8006ae90(void)

{
  int in_at;
  uint *in_v0;
  int iVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint *puVar6;
  int iVar7;
  byte *pbVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  int in_t3;
  uint *puVar12;
  uint in_t6;

  gte_nclip_b();
  puVar12 = (uint *)((*(uint *)(in_at + 0x2c) >> 0x11) * 4 + *(int *)(in_at + 0x38));
  puVar6 = *(uint **)(in_at + 0x50);
  uVar11 = gte_stMAC0();
  uVar11 = uVar11 ^ (int)*(short *)(in_at + 0x24) ^ in_t3 << 2;
  gte_stSXY0();
  if ((int)uVar11 < 0) {
    puVar12 = puVar12 + 1;
  }
  gte_stSXY1();
  gte_stSXY2();
  gte_ldIR1((int)(in_t6 << 0x18) >> 0x13);
  gte_ldIR2((int)((in_t6 >> 8) << 0x18) >> 0x13);
  gte_ldIR3((int)((in_t6 >> 0x10) << 0x18) >> 0x13);
  gte_lcir();
  iVar1 = gte_stIR1();
  iVar7 = gte_stIR3();
  uVar2 = (iVar1 + 0x1000) * 7 + 0x2000;
  uVar3 = uVar2 >> 4;
  if ((int)uVar11 < 0) {
    uVar3 = uVar2 >> 5;
  }
  iVar7 = iVar7 >> 3;
  gte_ldIR0(uVar3);
  gte_dpcs_b();
  if (iVar7 < 0) {
    iVar7 = -iVar7;
  }
  uVar2 = 0;
  if (-1 < iVar7 + -0x180) {
    pbVar8 = &DAT_8008a144 + iVar7;
    if (-1 < iVar7 + -0x200) {
      pbVar8 = &DAT_8008a343;
    }
    uVar2 = (uint)*pbVar8;
  }
  uVar3 = gte_stRGB2();
  if ((int)uVar11 < 0) {
    uVar2 = uVar2 >> 3;
  }

  // red
  uVar9 = (uVar3 & 0xff) + uVar2;

  // green
  iVar1 = (uVar3 >> 8 & 0xff) + uVar2;

  // blue
  iVar7 = (uVar3 >> 0x10 & 0xff) + uVar2;

  // blue component
  uVar2 = iVar7 * 0x10000;
  if (0 < iVar7 + -0xff) {
    uVar2 = 0xff0000;
  }

  // green component
  uVar3 = iVar1 * 0x100;
  if (0 < iVar1 + -0xff) {
    uVar3 = 0xff00;
  }

  // red component
  if (0 < (int)(uVar9 - 0xff)) {
    uVar9 = 0xff;
  }

  uVar5 = puVar6[1];
  uVar10 = 0x600000;
  uVar4 = 0x24000000;
  if (((uVar5 & 0x600000) == 0) && (-1 < (int)uVar11)) {
    uVar10 = 0x200000;
    uVar4 = 0x26000000;
  }

  // uVar4 tag, plus 3-byte color
  in_v0[1] = uVar4 | uVar3 | uVar2 | uVar9;

  uVar11 = puVar6[2];
  in_v0[3] = *puVar6;
  in_v0[5] = uVar10 | uVar5;
  in_v0[7] = uVar11;
  *in_v0 = *puVar12 | 0x7000000;
  *puVar12 = (uint)in_v0 & 0xffffff;
  return in_v0 + 8;
}


// RenderBucket_DrawFunc_Split
// cuts models in half, fake depth buffer,
// when in mud or water
void FUN_8006b030(void)

{
  bool bVar1;
  undefined uVar2;
  short sVar3;
  short sVar4;
  ushort uVar5;
  ushort uVar6;
  undefined4 in_zero;
  int in_at;
  undefined4 in_v0;
  code *pcVar7;
  undefined4 extraout_v1;
  undefined4 extraout_v1_00;
  int iVar8;
  int *piVar9;
  int iVar10;
  uint uVar11;
  int iVar12;
  undefined4 *puVar13;
  int in_t0;
  int iVar14;
  uint uVar15;
  uint uVar16;
  undefined4 uVar17;
  undefined4 uVar18;
  uint in_t3;
  code *unaff_s6;
  ushort *puVar19;
  short *psVar20;
  uint *in_t9;
  uint *puVar21;
  undefined4 *puVar22;
  undefined8 uVar23;
  int iStack4;

code_r0x8006b030:
  puVar21 = in_t9 + 1;
  if (in_t0 == 0) {
    while( true ) {
      piVar9 = *(int **)(in_at + 4);

	  // ptrInstance
	  iVar8 = *piVar9;

	  // ptrInstance
      iVar14 = piVar9[1];

	  *(int **)(in_at + 4) = piVar9 + 2;
      if (iVar8 == 0) break;
      iVar10 = *(int *)(iVar14 + 0x74);
      iVar12 = *(int *)(in_at + 8);
      *(int *)(in_at + 0x10) = iVar8;
      *(int *)(in_at + 8) = iVar10;
	  
	  // tileView
      if (iVar10 != iVar12) 
	  {
		// width, height, distToScreen
        sVar3 = *(short *)(iVar10 + 0x20);
        sVar4 = *(short *)(iVar10 + 0x22);
        uVar17 = *(undefined4 *)(iVar10 + 0x18);
		
		// scratchpad
        *(short *)(in_at + 0x1c) = sVar3;
        *(short *)(in_at + 0x1e) = sVar4;
        
		// GTE
        setCopControlWord(2,0xc000,(int)sVar3 << 0xf);
        setCopControlWord(2,0xc800,(int)sVar4 << 0xf);
        setCopControlWord(2,0xd000,uVar17);
      }

	  // instance flags, duplicate of 0x28
	  uVar11 = *(uint *)(iVar14 + 0xb8);

	  sVar3 = *(short *)(iVar14 + 0xbc);

      if (
			((uVar11 & 0x40) != 0) &&

			// if instance is not invisible
			((uVar11 & 0x80) == 0)
		 )
	  {
		// instance offset 0x78
        gte_ldR11R12(*(undefined4 *)(iVar14 + 0x78));
        gte_ldR13R21(*(undefined4 *)(iVar14 + 0x7c));
        gte_ldR22R23(*(undefined4 *)(iVar14 + 0x80));
        gte_ldR31R32(*(undefined4 *)(iVar14 + 0x84));
        gte_ldR33(*(undefined4 *)(iVar14 + 0x88));
		
		gte_ldtr(
		  *(undefined4 *)(iVar14 + 0x8c),
		  *(undefined4 *)(iVar14 + 0x90),
		  *(undefined4 *)(iVar14 + 0x94)
		);

        *(uint *)(in_at + 0x24) = uVar11;
        *(int *)(in_at + 0x120) = (int)sVar3;

		if ((uVar11 & 0x7000) != 0)
		{
		  // instance offset 0x98
          gte_ldL11L12(*(undefined4 *)(iVar14 + 0x98));
          gte_ldL13L21(*(undefined4 *)(iVar14 + 0x9c));
          gte_ldL22L23(*(undefined4 *)(iVar14 + 0xa0));
          gte_ldL31L32(*(undefined4 *)(iVar14 + 0xa4));
          gte_ldL33(*(undefined4 *)(iVar14 + 0xa8));

		  sVar3 = *(short *)(iVar14 + 0xbe);
          uVar2 = *(undefined *)(iVar8 + 0x53);
          uVar17 = *(undefined4 *)(iVar8 + 0x58);
          *(short *)(in_at + 0x44) = sVar3;
          *(short *)(in_at + 0xda) = sVar3;
          *(short *)(in_at + 0xf2) = sVar3;
          *(undefined *)(in_at + 0x48) = uVar2;
          *(undefined4 *)(in_at + 0x4c) = uVar17;
          *(int *)(in_at + 0x11c) = (int)sVar3 << 0x11;
          *(undefined4 *)(in_at + 0xe0) = 0;
          *(undefined4 *)(in_at + 0xf8) = 0;
        }

		// origin next frame
        psVar20 = *(short **)(iVar14 + 0xc4);

		// origin this frame
        puVar19 = *(ushort **)(iVar14 + 0xc0);

		// no next frame,
		// no 60fps
        if (psVar20 == (short *)0x0)
		{
		  // copy origin data
          uVar5 = puVar19[1];
          uVar6 = puVar19[2];
          *(ushort *)(in_at + 0x30) = *puVar19 & 0x7fff;
          *(ushort *)(in_at + 0x32) = uVar5;
          *(int *)(in_at + 0x34) = (int)(short)uVar6;
        }

		// next frame exists,
		// 60fps
		else
		{
		  // interpolate between origins
          *(ushort *)(in_at + 0x30) = *puVar19 + *psVar20;
          *(ushort *)(in_at + 0x32) = puVar19[1] + psVar20[1];
          *(int *)(in_at + 0x34) = ((int)(short)puVar19[2] + (int)psVar20[2]) * 2;
        }

		// reflection color
        *(undefined4 *)(in_at + 0x58) = 0;

		// ptrColorLayout
        puVar22 = *(undefined4 **)(iVar14 + 0xd0);

		// deref ptrCommandList, get numColors
        iVar10 = **(int **)(iVar14 + 200);

        puVar13 = (undefined4 *)(in_at + 0x140);

		// write color array
		while (bVar1 = 0 < iVar10, iVar10 = iVar10 + -1, bVar1) {
          uVar17 = *puVar22;
          puVar22 = puVar22 + 1;
          *puVar13 = uVar17;
          puVar13 = puVar13 + 1;
        }

		// execute instance->funcPtr
		(**(code **)(iVar8 + 0x5c))();

        sVar3 = *(short *)(iVar14 + 0xde);
        *(short *)(in_at + 0x134) = (short)((int)*(short *)(iVar14 + 0xdc) << 2);
        *(short *)(in_at + 0x136) = (short)((int)sVar3 << 2);
        uVar17 = *(undefined4 *)(iVar14 + 0xe4);
        uVar18 = *(undefined4 *)(iVar14 + 0xe8);
        pcVar7 = *(code **)(iVar14 + 0xec);
        *(undefined4 *)(in_at + 0x38) = uVar17;
        *(undefined4 *)(in_at + 0x3c) = uVar17;
        *(undefined4 *)(in_at + 0x40) = uVar18;
        in_v0 = (*pcVar7)(*(undefined4 *)(iVar8 + 100));
      }
    }
    *(undefined4 *)(*(int *)(in_at + 0xc) + 0xc) = in_v0;
    return;
  }
  *(uint *)(in_at + 0x10c) = in_t3;
  (*unaff_s6)();
  *(int *)(in_at + 0x90) = in_t0;
  *(undefined4 *)(in_at + 0x94) = extraout_v1;
  iVar14 = (int)*(short *)(in_at + 0x44) - (in_t0 >> 0x10);
  *(short *)(in_at + 0x9e) = (short)iVar14;
  (*unaff_s6)();
  *(int *)(in_at + 0xa8) = iVar14;
  *(undefined4 *)(in_at + 0xac) = extraout_v1_00;
  iVar14 = (int)*(short *)(in_at + 0x44) - (iVar14 >> 0x10);
  *(short *)(in_at + 0xb6) = (short)iVar14;
  uVar23 = (*unaff_s6)();
  uVar17 = (undefined4)((ulonglong)uVar23 >> 0x20);
  in_v0 = (undefined4)uVar23;
  setCopReg(2,in_zero,*(undefined4 *)(in_at + 0x90));
  setCopReg(2,in_at,*(undefined4 *)(in_at + 0x94));
  setCopReg(2,in_v0,*(undefined4 *)(in_at + 0xa8));
  setCopReg(2,uVar17,*(undefined4 *)(in_at + 0xac));
  setCopReg(2,0x2000,iVar14);
  setCopReg(2,0x2800,uVar17);
  in_t3 = *(uint *)(in_at + 0x10c);
  copFunction(2,0x280030);
  *(int *)(in_at + 0xc0) = iVar14;
  *(undefined4 *)(in_at + 0xc4) = uVar17;
  *(short *)(in_at + 0xce) = *(short *)(in_at + 0x44) - (short)((uint)iVar14 >> 0x10);
  in_t9 = puVar21 + 1;
  do {
    uVar11 = in_t3 & 0x1ff;
    iVar14 = uVar11 * 4;
    if (uVar11 != 0) {
      iVar14 = (&iStack4)[uVar11];
    }
    iVar8 = *(int *)(in_at + 0x1c);
    uVar11 = getCopReg(2,0x7000);
    iVar10 = getCopControlWord(2,0xf800);
    if (-1 < iVar10 << 0xd) {
      if ((int)(in_t3 << 3) < 0) {
        copFunction(2,0x1400006);
        uVar15 = getCopReg(2,0xc000);
        if ((uVar15 == 0) ||
           (uVar16 = getCopReg(2,0x6000),
           (int)(uVar15 ^ (int)*(short *)(in_at + 0x24) ^ in_t3 << 2) < 1)) goto LAB_8006b15c;
      }
      else {
        uVar16 = getCopReg(2,0x6000);
      }
      uVar15 = getCopReg(2,0x6800);
      copFunction(2,0x158002d);
      uVar11 = ~(uVar16 - iVar8 | uVar15 - iVar8 | uVar11 - iVar8) | uVar16 & uVar11 & uVar15;
      if (-1 < (int)uVar11) {
        uVar17 = getCopReg(2,0x18);
        *(undefined4 *)(in_at + 0x2c) = uVar17;
        if (-1 < (int)(uVar11 << 0x10)) {
          *(int *)(in_at + 0x50) = iVar14;
          in_v0 = FUN_8006d094();
        }
      }
    }
LAB_8006b15c:
    do {
      in_t3 = *in_t9;
      in_t9 = in_t9 + 1;
      in_t0 = in_t3 + 1;
      if ((int)in_t3 < 0) goto code_r0x8006b030;
      uVar11 = in_t3 >> 0x10;
    } while (uVar11 == 0);
    if ((int)(in_t3 << 1) < 0) {
      uVar17 = getCopReg(2,0x6000);
      uVar18 = getCopReg(2,0x8800);
      setCopReg(2,0x6800,uVar17);
      setCopReg(2,0x9000,uVar18);
    }
    else {
      *(undefined4 *)(in_at + 0x90) = *(undefined4 *)(in_at + 0xa8);
      *(undefined4 *)(in_at + 0x94) = *(undefined4 *)(in_at + 0xac);
      *(undefined2 *)(in_at + 0x9e) = *(undefined2 *)(in_at + 0xb6);
    }
    *(undefined4 *)(in_at + 0xa8) = *(undefined4 *)(in_at + 0xc0);
    *(undefined4 *)(in_at + 0xac) = *(undefined4 *)(in_at + 0xc4);
    *(undefined2 *)(in_at + 0xb6) = *(undefined2 *)(in_at + 0xce);
    uVar23 = (*unaff_s6)();
    uVar17 = (undefined4)((ulonglong)uVar23 >> 0x20);
    in_v0 = (undefined4)uVar23;
    setCopReg(2,0,uVar11);
    setCopReg(2,0x800,uVar17);
    copFunction(2,0x180001);
    *(uint *)(in_at + 0xc0) = uVar11;
    *(undefined4 *)(in_at + 0xc4) = uVar17;
    *(short *)(in_at + 0xce) = *(short *)(in_at + 0x44) - (short)(uVar11 >> 0x10);
  } while( true );
}
// guessing: model close to camera near clipping or something like that???
void UndefinedFunction_8006b24c(void)

{
  char cVar1;
  int in_at;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  uint uVar7;
  char cVar8;
  uint uVar9;
  char cVar10;
  uint uVar11;
  uint in_t3;
  uint in_t4;
  uint in_t5;
  uint unaff_s1;
  uint unaff_s2;
  int unaff_s3;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  uint *unaff_s7;
  uint *in_t8;
  uint *unaff_s8;

  iVar5 = (in_t3 >> 0xd & 0x7f8) + in_at;
  if (-1 < (int)(in_t3 << 5)) {
    if (unaff_s8 == (uint *)0x0) {
      uVar9 = *unaff_s7;
      uVar11 = *in_t8;
    }
    else {
      *(int *)(in_at + 0x20) = iVar5;
      uVar14 = *unaff_s8;
      uVar2 = uVar14 >> 6 & 7;
      uVar7 = uVar2 ^ 0x1f;
      uVar3 = uVar2 + 1;
      uVar12 = unaff_s3 + uVar3;
      cVar8 = (char)((int)unaff_s1 >> uVar7);
      cVar10 = (char)((int)unaff_s2 >> uVar7);
      uVar9 = unaff_s1;
      uVar11 = unaff_s2;
      uVar13 = uVar12;
      if (0 < (int)uVar12) {
        uVar9 = *unaff_s7;
        uVar11 = *in_t8;
        unaff_s7 = unaff_s7 + 1;
        in_t8 = in_t8 + 1;
        cVar8 = (char)((int)(unaff_s1 | uVar9 >> (uVar3 - uVar12 & 0x1f)) >> uVar7);
        cVar10 = (char)((int)(unaff_s2 | uVar11 >> (uVar3 - uVar12 & 0x1f)) >> uVar7);
        uVar13 = uVar12 - 0x20;
        uVar3 = uVar12;
      }
      uVar9 = uVar9 << (uVar3 & 0x1f);
      uVar11 = uVar11 << (uVar3 & 0x1f);
      if (uVar2 != 7) {
        cVar1 = (char)((int)uVar14 >> 0x19) * '\x02';
        cVar8 = cVar8 + cVar1 + *(char *)(in_at + 0x58);
        cVar10 = cVar10 + cVar1 + *(char *)(in_at + 0x5c);
      }
      *(char *)(in_at + 0x58) = cVar8;
      *(char *)(in_at + 0x5c) = cVar10;
      uVar4 = uVar14 >> 3 & 7;
      uVar7 = uVar4 + 1;
      uVar13 = uVar13 + uVar7;
      uVar3 = uVar9;
      uVar2 = uVar11;
      uVar12 = uVar13;
      if (0 < (int)uVar13) {
        uVar3 = *unaff_s7;
        uVar2 = *in_t8;
        unaff_s7 = unaff_s7 + 1;
        in_t8 = in_t8 + 1;
        uVar9 = uVar9 | uVar3 >> (uVar7 - uVar13 & 0x1f);
        uVar11 = uVar11 | uVar2 >> (uVar7 - uVar13 & 0x1f);
        uVar12 = uVar13 - 0x20;
        uVar7 = uVar13;
      }
      cVar10 = (char)((int)uVar11 >> (uVar4 ^ 0x1f));
      cVar8 = (char)((int)uVar9 >> (uVar4 ^ 0x1f));
      uVar3 = uVar3 << (uVar7 & 0x1f);
      uVar2 = uVar2 << (uVar7 & 0x1f);
      if (uVar4 != 7) {
        cVar1 = (char)((uVar14 << 7) >> 0x18);
        cVar8 = cVar8 + cVar1 + *(char *)(in_at + 0x5a);
        cVar10 = cVar10 + cVar1 + *(char *)(in_at + 0x5e);
      }
      *(char *)(in_at + 0x5a) = cVar8;
      *(char *)(in_at + 0x5e) = cVar10;
      uVar9 = uVar14 & 7;
      iVar5 = uVar12 + uVar9 + 1;
      if (0 < iVar5) {
        uVar11 = (uVar9 + 1) - iVar5;
        uVar3 = uVar3 | *unaff_s7 >> (uVar11 & 0x1f);
        uVar2 = uVar2 | *in_t8 >> (uVar11 & 0x1f);
      }
      cVar10 = (char)((int)uVar2 >> (uVar9 ^ 0x1f));
      cVar8 = (char)((int)uVar3 >> (uVar9 ^ 0x1f));
      if (uVar9 != 7) {
        cVar1 = (char)((uVar14 << 0xf) >> 0x18);
        cVar8 = cVar8 + cVar1 + *(char *)(in_at + 0x59);
        cVar10 = cVar10 + cVar1 + *(char *)(in_at + 0x5d);
      }
      *(char *)(in_at + 0x59) = cVar8;
      *(char *)(in_at + 0x5d) = cVar10;
      uVar9 = *(uint *)(in_at + 0x58);
      uVar11 = *(uint *)(in_at + 0x5c);
      iVar5 = *(int *)(in_at + 0x20);
    }
    iVar6 = *(int *)(in_at + 0x34);
    *(uint *)(iVar5 + 0x140) =
         ((uVar9 & in_t4) + (uVar11 & in_t4) + *(int *)(in_at + 0x30)) * 2 & in_t5;
    *(uint *)(iVar5 + 0x144) = ((uVar9 & 0xff00) + (uVar11 & 0xff00) >> 7) + iVar6;
  }
  if (-1 < (int)(in_t3 << 4)) {
    return;
  }
  return;
}

// Draw_KartFlames
undefined8 FUN_8006bad0(void)

{
  int in_at;
  uint *in_v0;
  uint uVar1;
  int iVar2;
  uint *puVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  uint *puVar8;
  undefined4 in_t6;
  undefined4 in_t7;
  undefined4 unaff_s0;

  iVar2 = *(int *)(in_at + 0x38);
  iVar7 = (*(uint *)(in_at + 0x2c) >> 0x11) * 4;
  if (iVar7 - *(short *)(in_at + 0x134) < 0) {
    puVar8 = (uint *)(*(short *)(in_at + 0x134) + iVar2);
  }
  else {
    puVar8 = (uint *)(iVar7 + iVar2);
    if (0 < iVar7 - *(short *)(in_at + 0x136)) {
      puVar8 = (uint *)(*(short *)(in_at + 0x136) + iVar2);
    }
  }
  puVar3 = *(uint **)(in_at + 0x50);
  setCopReg(2,0xa000,in_t6);
  setCopReg(2,0xa800,in_t7);
  setCopReg(2,0xb000,unaff_s0);
  setCopReg(2,0x4000,(int)*(short *)(in_at + 0x120));
  if ((*(short *)(in_at + 0x120) != 0) && (-1 < (int)puVar8 << 7)) {
    copFunction(2,0xf8002a);
  }
  if (puVar3 == (uint *)0x0) {
    uVar4 = getCopReg(2,0xc);
    in_v0[2] = uVar4;
    uVar4 = getCopReg(2,0xd);
    in_v0[4] = uVar4;
    uVar4 = getCopReg(2,0xe);
    in_v0[6] = uVar4;
    uVar4 = getCopReg(2,0xa000);
    iVar2 = 0x1c;
    in_v0[1] = uVar4 | 0x30000000;
    uVar4 = getCopReg(2,0x15);
    in_v0[3] = uVar4;
    uVar4 = getCopReg(2,0x16);
    in_v0[5] = uVar4;
    uVar4 = 0x6000000;
  }
  else {
    uVar1 = *puVar3;
    uVar5 = puVar3[1];
    uVar6 = puVar3[2];
    uVar4 = getCopReg(2,0xc);
    in_v0[2] = uVar4;
    uVar4 = getCopReg(2,0xd);
    in_v0[5] = uVar4;
    uVar4 = getCopReg(2,0xe);
    in_v0[8] = uVar4;
    in_v0[3] = uVar1;
    in_v0[6] = uVar5;
    in_v0[9] = uVar6;
    uVar1 = getCopReg(2,0xa000);
    uVar4 = 0x34000000;
    if ((uVar5 & 0x600000) != 0x600000) {
      uVar4 = 0x36000000;
    }
    in_v0[1] = uVar4 | uVar1;
    uVar4 = getCopReg(2,0x15);
    in_v0[4] = uVar4;
    uVar4 = getCopReg(2,0x16);
    in_v0[7] = uVar4;
    iVar2 = 0x28;
    uVar4 = 0x9000000;
  }
  uVar1 = *puVar8;
  *in_v0 = uVar1 | uVar4;
  *puVar8 = (uint)in_v0 & 0xffffff;
  return CONCAT44(uVar1 | uVar4,(int)in_v0 + iVar2);
}

// something to do with drawing.
void FUN_8006bbc0(void)

{
  bool bVar1;
  undefined uVar2;
  short sVar3;
  short sVar4;
  ushort uVar5;
  ushort uVar6;
  int in_at;
  undefined4 in_v0;
  int iVar7;
  code *pcVar8;
  undefined4 extraout_v1;
  undefined4 extraout_v1_00;
  int iVar9;
  int *piVar10;
  int iVar11;
  int iVar12;
  undefined4 *puVar13;
  int in_t0;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  uint in_t1;
  uint uVar17;
  undefined4 uVar18;
  uint uVar19;
  undefined4 uVar20;
  uint in_t3;
  undefined4 in_t4;
  undefined4 in_t5;
  uint uVar21;
  uint uVar22;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  code *unaff_s5;
  code *unaff_s6;
  ushort *puVar23;
  short *psVar24;
  uint *in_t9;
  uint *puVar25;
  undefined4 *puVar26;
  undefined8 uVar27;
  int iStack4;

code_r0x8006bbc0:
  puVar25 = in_t9 + 1;
  if (in_t0 == 0) {
    while( true )
      piVar10 = *(int **)(in_at + 4);
      iVar11 = *piVar10;
      iVar9 = piVar10[1];
      *(int **)(in_at + 4) = piVar10 + 2;
      if (iVar11 == 0) break;
      iVar7 = *(int *)(iVar9 + 0x74);
      iVar12 = *(int *)(in_at + 8);
      *(int *)(in_at + 0x10) = iVar11;
      *(int *)(in_at + 8) = iVar7;
	  
	  // tileView
      if (iVar7 != iVar12) 
	  {
		// width, height, distToScreen
        sVar3 = *(short *)(iVar7 + 0x20);
        sVar4 = *(short *)(iVar7 + 0x22);
        uVar18 = *(undefined4 *)(iVar7 + 0x18);
		
		// scratchpad
        *(short *)(in_at + 0x1c) = sVar3;
        *(short *)(in_at + 0x1e) = sVar4;
        
		// GTE
		setCopControlWord(2,0xc000,(int)sVar3 << 0xf);
        setCopControlWord(2,0xc800,(int)sVar4 << 0xf);
        setCopControlWord(2,0xd000,uVar18);
      }
      uVar21 = *(uint *)(iVar9 + 0xb8);
      sVar3 = *(short *)(iVar9 + 0xbc);
      if (((uVar21 & 0x40) != 0) && ((uVar21 & 0x80) == 0)) 
	  {
		// instance matrix
		gte_ldR11R12(*(undefined4 *)(iVar9 + 0x78));
		gte_ldR13R21(*(undefined4 *)(iVar9 + 0x7c));
		gte_ldR22R23(*(undefined4 *)(iVar9 + 0x80));
		gte_ldR31R32(*(undefined4 *)(iVar9 + 0x84));
		gte_ldR33(*(undefined4 *)(iVar9 + 0x88));
		
		gte_ldtr(
		  *(undefined4 *)(iVar9 + 0x8c),
		  *(undefined4 *)(iVar9 + 0x90),
		  *(undefined4 *)(iVar9 + 0x94)
		);
		  
        *(uint *)(in_at + 0x24) = uVar21;
        *(int *)(in_at + 0x120) = (int)sVar3;
        if ((uVar21 & 0x7000) != 0) 
		{
		  // instance matrix
          gte_ldL11L12(*(undefined4 *)(iVar9 + 0x98));
          gte_ldL13L21(*(undefined4 *)(iVar9 + 0x9c));
          gte_ldL22L23(*(undefined4 *)(iVar9 + 0xa0));
          gte_ldL31L32(*(undefined4 *)(iVar9 + 0xa4));
          gte_ldL33(*(undefined4 *)(iVar9 + 0xa8));
			
          sVar3 = *(short *)(iVar9 + 0xbe);
          uVar2 = *(undefined *)(iVar11 + 0x53);
          uVar18 = *(undefined4 *)(iVar11 + 0x58);
          *(short *)(in_at + 0x44) = sVar3;
          *(short *)(in_at + 0xda) = sVar3;
          *(short *)(in_at + 0xf2) = sVar3;
          *(undefined *)(in_at + 0x48) = uVar2;
          *(undefined4 *)(in_at + 0x4c) = uVar18;
          *(int *)(in_at + 0x11c) = (int)sVar3 << 0x11;
          *(undefined4 *)(in_at + 0xe0) = 0;
          *(undefined4 *)(in_at + 0xf8) = 0;
        }
        psVar24 = *(short **)(iVar9 + 0xc4);
        puVar23 = *(ushort **)(iVar9 + 0xc0);
        if (psVar24 == (short *)0x0) {
          uVar5 = puVar23[1];
          uVar6 = puVar23[2];
          *(ushort *)(in_at + 0x30) = *puVar23 & 0x7fff;
          *(ushort *)(in_at + 0x32) = uVar5;
          *(int *)(in_at + 0x34) = (int)(short)uVar6;
        }
        else {
          *(ushort *)(in_at + 0x30) = *puVar23 + *psVar24;
          *(ushort *)(in_at + 0x32) = puVar23[1] + psVar24[1];
          *(int *)(in_at + 0x34) = ((int)(short)puVar23[2] + (int)psVar24[2]) * 2;
        }
        *(undefined4 *)(in_at + 0x58) = 0;
        puVar26 = *(undefined4 **)(iVar9 + 0xd0);
        iVar7 = **(int **)(iVar9 + 200);
        puVar13 = (undefined4 *)(in_at + 0x140);
        while (bVar1 = 0 < iVar7, iVar7 = iVar7 + -1, bVar1) {
          uVar18 = *puVar26;
          puVar26 = puVar26 + 1;
          *puVar13 = uVar18;
          puVar13 = puVar13 + 1;
        }
        (**(code **)(iVar11 + 0x5c))();
        sVar3 = *(short *)(iVar9 + 0xde);
        *(short *)(in_at + 0x134) = (short)((int)*(short *)(iVar9 + 0xdc) << 2);
        *(short *)(in_at + 0x136) = (short)((int)sVar3 << 2);
        uVar18 = *(undefined4 *)(iVar9 + 0xe4);
        uVar20 = *(undefined4 *)(iVar9 + 0xe8);
        pcVar8 = *(code **)(iVar9 + 0xec);
        *(undefined4 *)(in_at + 0x38) = uVar18;
        *(undefined4 *)(in_at + 0x3c) = uVar18;
        *(undefined4 *)(in_at + 0x40) = uVar20;
        in_v0 = (*pcVar8)(*(undefined4 *)(iVar11 + 100));
      }
    }
    *(undefined4 *)(*(int *)(in_at + 0xc) + 0xc) = in_v0;
    return;
  }
  *(uint *)(in_at + 0x10c) = in_t3;
  (*unaff_s6)();
  setCopReg(2,0,in_t0);
  setCopReg(2,0x800,extraout_v1);
  uVar21 = in_t1;
  (*unaff_s6)();
  setCopReg(2,0x1000,in_t0);
  setCopReg(2,0x1800,extraout_v1_00);
  uVar22 = in_t1;
  uVar27 = (*unaff_s6)();
  in_v0 = (undefined4)uVar27;
  setCopReg(2,0x2000,in_t0);
  setCopReg(2,0x2800,(int)((ulonglong)uVar27 >> 0x20));
  in_t3 = *(uint *)(in_at + 0x10c);
  copFunction(2,0x280030);
  in_t9 = puVar25 + 1;
  uVar18 = getCopReg(2,0xc);
  *(undefined4 *)(in_at + 0x90) = uVar18;
  uVar18 = getCopReg(2,0x11);
  *(undefined4 *)(in_at + 0x94) = uVar18;
  uVar18 = getCopReg(2,0xd);
  *(undefined4 *)(in_at + 0xa8) = uVar18;
  uVar18 = getCopReg(2,0x12);
  *(undefined4 *)(in_at + 0xac) = uVar18;
  uVar18 = getCopReg(2,0xe);
  *(undefined4 *)(in_at + 0xc0) = uVar18;
  uVar18 = getCopReg(2,0x13);
  *(undefined4 *)(in_at + 0xc4) = uVar18;
  iVar9 = *(int *)(in_at + 0x11c);
  uVar14 = getCopReg(2,0);
  uVar17 = getCopReg(2,0x1000);
  uVar19 = getCopReg(2,0x2000);
  setCopReg(2,0,iVar9 - (uVar14 & 0xffff0000) | uVar14 & 0xffff);
  setCopReg(2,0x1000,iVar9 - (uVar17 & 0xffff0000) | uVar17 & 0xffff);
  setCopReg(2,0x2000,iVar9 - (uVar19 & 0xffff0000) | uVar19 & 0xffff);
  copFunction(2,0x280030);
  do {
    uVar14 = in_t3 & 0x1ff;
    iVar9 = uVar14 * 4;
    if (uVar14 != 0) {
      iVar9 = (&iStack4)[uVar14];
    }
    *(ushort *)(in_at + 0x24) = *(ushort *)(in_at + 0x24) ^ 0x8000;
    *(int *)(in_at + 0x50) = iVar9;
    iVar9 = *(int *)(in_at + 0x1c);
    uVar17 = getCopReg(2,0x7000);
    iVar11 = getCopControlWord(2,0xf800);
    uVar14 = in_t1;
    if (-1 < iVar11 << 0xd) {
      if ((int)(in_t3 << 3) < 0) {
        copFunction(2,0x1400006);
        uVar15 = getCopReg(2,0xc000);
        if ((uVar15 == 0) ||
           (uVar19 = getCopReg(2,0x6000),
           (int)(uVar15 ^ (int)*(short *)(in_at + 0x24) ^ in_t3 << 2) < 1)) goto LAB_8006bd64;
      }
      else {
        uVar19 = getCopReg(2,0x6000);
      }
      uVar15 = getCopReg(2,0x6800);
      copFunction(2,0x158002d);
      uVar17 = ~(uVar19 - iVar9 | uVar15 - iVar9 | uVar17 - iVar9) | uVar19 & uVar17 & uVar15;
      if (-1 < (int)uVar17) {
        uVar18 = getCopReg(2,0x18);
        *(undefined4 *)(in_at + 0x2c) = uVar18;
        if (-1 < (int)(uVar17 << 0x10)) {
          *(uint *)(in_at + 0x98) = uVar21;
          *(uint *)(in_at + 0xb0) = uVar22;
          *(uint *)(in_at + 200) = in_t1;
          *(undefined4 *)(in_at + 0x38) = *(undefined4 *)(in_at + 0x40);
          in_v0 = (*unaff_s5)();
          uVar21 = *(uint *)(in_at + 0x98);
          uVar22 = *(uint *)(in_at + 0xb0);
          uVar14 = *(uint *)(in_at + 200);
        }
      }
    }
LAB_8006bd64:
    uVar18 = getCopReg(2,0xc);
    *(undefined4 *)(in_at + 0xa0) = uVar18;
    uVar18 = getCopReg(2,0x11);
    *(undefined4 *)(in_at + 0xa4) = uVar18;
    uVar18 = getCopReg(2,0xd);
    *(undefined4 *)(in_at + 0xb8) = uVar18;
    uVar18 = getCopReg(2,0x12);
    *(undefined4 *)(in_at + 0xbc) = uVar18;
    uVar18 = getCopReg(2,0xe);
    *(undefined4 *)(in_at + 0xd0) = uVar18;
    uVar18 = getCopReg(2,0x13);
    *(undefined4 *)(in_at + 0xd4) = uVar18;
    setCopReg(2,in_t4,*(undefined4 *)(in_at + 0x90));
    setCopReg(2,unaff_s1,*(undefined4 *)(in_at + 0x94));
    setCopReg(2,in_t5,*(undefined4 *)(in_at + 0xa8));
    setCopReg(2,unaff_s2,*(undefined4 *)(in_at + 0xac));
    setCopReg(2,uVar21,*(undefined4 *)(in_at + 0xc0));
    setCopReg(2,unaff_s3,*(undefined4 *)(in_at + 0xc4));
    *(ushort *)(in_at + 0x24) = *(ushort *)(in_at + 0x24) ^ 0x8000;
    iVar9 = *(int *)(in_at + 0x1c);
    uVar19 = getCopReg(2,0x7000);
    iVar11 = getCopControlWord(2,0xf800);
    in_t1 = in_t3 << 2;
    uVar17 = uVar22;
    if (-1 < iVar11 << 0xd) {
      if ((int)(in_t3 << 3) < 0) {
        copFunction(2,0x1400006);
        uVar16 = getCopReg(2,0xc000);
        in_t1 = (int)*(short *)(in_at + 0x24) ^ in_t1;
        if ((uVar16 == 0) || (uVar15 = getCopReg(2,0x6000), (int)(uVar16 ^ in_t1) < 1))
        goto LAB_8006be24;
      }
      else {
        uVar15 = getCopReg(2,0x6000);
      }
      uVar16 = getCopReg(2,0x6800);
      copFunction(2,0x158002d);
      in_t1 = uVar16 - iVar9;
      uVar19 = ~(uVar15 - iVar9 | in_t1 | uVar19 - iVar9) | uVar15 & uVar19 & uVar16;
      if (-1 < (int)uVar19) {
        uVar18 = getCopReg(2,0x18);
        *(undefined4 *)(in_at + 0x2c) = uVar18;
        if (-1 < (int)(uVar19 << 0x10)) {
          *(undefined4 *)(in_at + 0x38) = *(undefined4 *)(in_at + 0x3c);
          in_v0 = (*unaff_s5)();
          uVar17 = uVar22;
        }
      }
    }
LAB_8006be24:
    while( true ) {
      uVar22 = uVar14;
      in_t3 = *in_t9;
      in_t9 = in_t9 + 1;
      in_t0 = in_t3 + 1;
      if ((int)in_t3 < 0) goto code_r0x8006bbc0;
      uVar14 = in_t3 >> 0x10;
      in_t1 = in_t3 << 1;
      if (uVar14 != 0) break;
      uVar21 = in_t3 >> 7 & 0x1fc;
      if ((int)(in_t3 << 0x1f) < 0) {
        uVar21 = *(uint *)(uVar21 + in_at + 0x140);
      }
      else {
        uVar21 = *(uint *)(&gp0x00000000 + uVar21);
      }
      uVar17 = uVar21;
      if ((int)(in_t3 << 0x1e) < 0) {
        uVar14 = *(uint *)((in_t3 & 0x1fc) + in_at + 0x140);
      }
      else {
        uVar14 = *(uint *)(&gp0x00000000 + (in_t3 & 0x1fc));
      }
    }
    if ((int)in_t1 < 0) {
      uVar18 = getCopReg(2,0x6000);
      uVar20 = getCopReg(2,0x8800);
      setCopReg(2,0x6800,uVar18);
      setCopReg(2,0x9000,uVar20);
      in_t1 = *(uint *)(in_at + 0xa0);
      *(uint *)(in_at + 0xb8) = in_t1;
      *(undefined4 *)(in_at + 0xbc) = *(undefined4 *)(in_at + 0xa4);
      uVar17 = uVar21;
    }
    uVar21 = uVar17;
    uVar27 = (*unaff_s6)();
    in_v0 = (undefined4)uVar27;
    setCopReg(2,0,uVar14);
    setCopReg(2,0x800,(int)((ulonglong)uVar27 >> 0x20));
    copFunction(2,0x180001);
    uVar18 = getCopReg(2,0xc);
    *(undefined4 *)(in_at + 0x90) = uVar18;
    uVar18 = getCopReg(2,0x11);
    *(undefined4 *)(in_at + 0x94) = uVar18;
    uVar18 = getCopReg(2,0xd);
    *(undefined4 *)(in_at + 0xa8) = uVar18;
    uVar18 = getCopReg(2,0x12);
    *(undefined4 *)(in_at + 0xac) = uVar18;
    uVar18 = getCopReg(2,0xe);
    *(undefined4 *)(in_at + 0xc0) = uVar18;
    uVar18 = getCopReg(2,0x13);
    *(undefined4 *)(in_at + 0xc4) = uVar18;
    uVar14 = getCopReg(2,0);
    setCopReg(2,0,*(int *)(in_at + 0x11c) - (uVar14 & 0xffff0000) | uVar14 & 0xffff);
    setCopReg(2,in_t5,*(undefined4 *)(in_at + 0xb8));
    setCopReg(2,unaff_s2,*(undefined4 *)(in_at + 0xbc));
    setCopReg(2,uVar21,*(undefined4 *)(in_at + 0xd0));
    setCopReg(2,unaff_s3,*(undefined4 *)(in_at + 0xd4));
    copFunction(2,0x180001);
  } while( true );
}

// Draw_KartInWaterMud
void FUN_8006bf30(void)

{
  int in_at;
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  undefined4 uVar5;
  int iVar6;
  char cVar7;
  uint in_t3;
  uint in_t4;
  uint in_t5;
  uint unaff_s1;
  int unaff_s3;
  uint uVar8;
  uint uVar9;
  int iVar10;
  uint uVar11;
  uint *unaff_s7;
  uint *unaff_s8;

  iVar6 = (in_t3 >> 0xd & 0x7f8) + in_at;
  if (-1 < (int)(in_t3 << 5)) {
    if (unaff_s8 == (uint *)0x0) {
      uVar1 = *unaff_s7;
    }
    else {
      uVar11 = *unaff_s8;
      uVar2 = uVar11 >> 6 & 7;
      uVar3 = uVar2 + 1;
      uVar8 = unaff_s3 + uVar3;
      cVar7 = (char)((int)unaff_s1 >> (uVar2 ^ 0x1f));
      uVar1 = unaff_s1;
      uVar9 = uVar8;
      if (0 < (int)uVar8) {
        uVar1 = *unaff_s7;
        unaff_s7 = unaff_s7 + 1;
        cVar7 = (char)((int)(unaff_s1 | uVar1 >> (uVar3 - uVar8 & 0x1f)) >> (uVar2 ^ 0x1f));
        uVar9 = uVar8 - 0x20;
        uVar3 = uVar8;
      }
      uVar1 = uVar1 << (uVar3 & 0x1f);
      if (uVar2 != 7) {
        cVar7 = cVar7 + (char)((int)uVar11 >> 0x19) * '\x02' + *(char *)(in_at + 0x58);
      }
      *(char *)(in_at + 0x58) = cVar7;
      uVar4 = uVar11 >> 3 & 7;
      uVar2 = uVar4 + 1;
      uVar9 = uVar9 + uVar2;
      uVar3 = uVar1;
      uVar8 = uVar9;
      if (0 < (int)uVar9) {
        uVar3 = *unaff_s7;
        unaff_s7 = unaff_s7 + 1;
        uVar1 = uVar1 | uVar3 >> (uVar2 - uVar9 & 0x1f);
        uVar8 = uVar9 - 0x20;
        uVar2 = uVar9;
      }
      cVar7 = (char)((int)uVar1 >> (uVar4 ^ 0x1f));
      uVar3 = uVar3 << (uVar2 & 0x1f);
      if (uVar4 != 7) {
        cVar7 = cVar7 + (char)((uVar11 << 7) >> 0x18) + *(char *)(in_at + 0x5a);
      }
      *(char *)(in_at + 0x5a) = cVar7;
      uVar1 = uVar11 & 7;
      iVar10 = uVar8 + uVar1 + 1;
      if (0 < iVar10) {
        uVar3 = uVar3 | *unaff_s7 >> ((uVar1 + 1) - iVar10 & 0x1f);
      }
      cVar7 = (char)((int)uVar3 >> (uVar1 ^ 0x1f));
      if (uVar1 != 7) {
        cVar7 = cVar7 + (char)((uVar11 << 0xf) >> 0x18) + *(char *)(in_at + 0x59);
      }
      *(char *)(in_at + 0x59) = cVar7;
      uVar1 = *(uint *)(in_at + 0x58);
    }
    setCopReg(2,0,((uVar1 & in_t4) + *(int *)(in_at + 0x30)) * 4 & in_t5);
    setCopReg(2,0x800,((uVar1 >> 8 & 0xff) + *(int *)(in_at + 0x34)) * 4);
    copFunction(2,0x4a6012);
    uVar5 = getCopReg(2,0x5800);
    iVar10 = getCopReg(2,0x5000);
    uVar1 = getCopReg(2,0x4800);
    *(uint *)(iVar6 + 0x140) = iVar10 << 0x10 | uVar1 & 0xffff;
    *(undefined4 *)(iVar6 + 0x144) = uVar5;
  }
  if (-1 < (int)(in_t3 << 4)) {
    return;
  }
  return;
}

// ConvertRotToMatrix_InverseTranspose_NoRotY
// param1 MATRIX
// param2 vec3s rotation (similar to R_to_M)
void FUN_8006c124(uint *param_1,short *param_2)

{
  short sVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  undefined4 unaff_s0;
  int unaff_s1;
  uint unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_retaddr;

  sVar1 = *param_2;
  uVar5 = 0;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f80002c = unaff_retaddr;

  // TRIG_AngleSinCos_r16r17r18_duplicate
  FUN_8006c430();

  uVar6 = 0x1000;
  uVar2 = unaff_s1 * -0x10000 | unaff_s2;
  uVar3 = unaff_s1 << 0x10;
  uVar4 = unaff_s2;
  
  // MATRIX_SET_r11r12r13r14r15
  FUN_8006c540();

  if (sVar1 != 0) {
    uVar2 = 0x1000;

	// TRIG_AngleSinCos_r16r17r18_duplicate
	FUN_8006c430();

	uVar3 = 0;
    uVar4 = unaff_s1 * -0x10000 | unaff_s2;
    uVar5 = unaff_s1 << 0x10;
	FUN_8006c49c();
	uVar6 = unaff_s2;
  }
  *param_1 = uVar2;
  param_1[1] = uVar3;
  param_1[2] = uVar4;
  param_1[3] = uVar5;
  param_1[4] = uVar6;
  return;
}

// ConvertRotToMatrix_InverseTranspose
// param1 MATRIX
// param2 vec3s rotation (similar to R_to_M)
void FUN_8006c1d0(uint *param_1,short *param_2)
{
  // 8006c1d0(DC0,D80,D40)
  // 8006c378(240,280,2C0)

  short sVar1;
  short sVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  undefined4 unaff_s0;
  uint unaff_s1;
  uint unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_retaddr;

  sVar1 = *param_2;
  sVar2 = param_2[1];
  uVar6 = 0;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f80002c = unaff_retaddr;

  // TRIG_AngleSinCos_r16r17r18_duplicate
  FUN_8006c430();

  uVar7 = 0x1000;
  uVar3 = unaff_s1 * -0x10000 | unaff_s2;
  uVar4 = unaff_s1 << 0x10;
  uVar5 = unaff_s2;
  
  // MATRIX_SET_r11r12r13r14r15
  FUN_8006c540();
  
  if (sVar1 != 0) {
    uVar3 = 0x1000;

	// TRIG_AngleSinCos_r16r17r18_duplicate
	FUN_8006c430();

    uVar4 = 0;
    uVar5 = unaff_s1 * -0x10000 | unaff_s2;
    uVar6 = unaff_s1 << 0x10;
    uVar7 = unaff_s2;
	FUN_8006c49c();
  }
  if (sVar2 != 0) {
    uVar5 = 0x1000;

	// TRIG_AngleSinCos_r16r17r18_duplicate
    FUN_8006c430();

    uVar6 = -unaff_s1 & 0xffff;
    uVar7 = unaff_s2;
    FUN_8006c49c();

    uVar3 = unaff_s2;
    uVar4 = unaff_s1;
  }
  *param_1 = uVar3;
  param_1[1] = uVar4;
  param_1[2] = uVar5;
  param_1[3] = uVar6;
  param_1[4] = uVar7;
  return;
}


// ConvertRotToMatrix
// param1 is matrix, param2 is vec3s rotation,
void FUN_8006c2a4(uint *param_1,short *param_2)

{
  short sVar1;
  short sVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  undefined4 unaff_s0;
  uint unaff_s1;
  uint unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_retaddr;

  sVar1 = *param_2;
  sVar2 = param_2[2];
  uVar5 = 0x1000;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f80002c = unaff_retaddr;

  // TRIG_AngleSinCos_r16r17r18_duplicate
  FUN_8006c430();

  uVar6 = -unaff_s1 & 0xffff;
  uVar3 = unaff_s2;
  uVar4 = unaff_s1;
  uVar7 = unaff_s2;
  
  // MATRIX_SET_r11r12r13r14r15
  FUN_8006c540();
  
  if (sVar1 != 0) {
    uVar3 = 0x1000;

	// TRIG_AngleSinCos_r16r17r18_duplicate
    FUN_8006c430();

    uVar4 = 0;
    uVar5 = unaff_s1 * -0x10000 | unaff_s2;
    uVar6 = unaff_s1 << 0x10;
    uVar7 = unaff_s2;
    FUN_8006c49c();
  }
  if (sVar2 != 0) {
    uVar6 = 0;

	// TRIG_AngleSinCos_r16r17r18_duplicate
	FUN_8006c430();

    uVar7 = 0x1000;
    uVar3 = unaff_s1 * -0x10000 | unaff_s2;
    uVar4 = unaff_s1 << 0x10;
    FUN_8006c49c();
    uVar5 = unaff_s2;
  }

  // Set 5 ints,
  // which is 10 shorts,
  // m[3][3] in matrix
  *param_1 = uVar3;
  param_1[1] = uVar4;
  param_1[2] = uVar5;
  param_1[3] = uVar6;
  param_1[4] = uVar7;
  return;
}



// WARNING: Removing unreachable block (ram,0x8006c3b0)

// ConvertRotToMatrix_Transpose
// param_1 - MATRIX
// param_2 - vec3s rotation (similar to R_to_M)
void FUN_8006c378(uint *param_1,short *param_2)

{
  short sVar1;
  short sVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  undefined4 unaff_s0;
  uint unaff_s1;
  uint unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_retaddr;

  sVar1 = *param_2;
  sVar2 = param_2[1];
  uVar6 = 0;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f80002c = unaff_retaddr;

  // TRIG_AngleSinCos_r16r17r18_duplicate
  FUN_8006c430();

  uVar7 = 0x1000;
  uVar3 = unaff_s1 * -0x10000 | unaff_s2;
  uVar4 = unaff_s1 << 0x10;
  uVar5 = unaff_s2;
  
  // MATRIX_SET_r11r12r13r14r15
  FUN_8006c540();
  
  if (sVar1 != 0) {
    uVar3 = 0x1000;

	// TRIG_AngleSinCos_r16r17r18_duplicate
	FUN_8006c430();

	uVar4 = 0;
    uVar5 = unaff_s1 * -0x10000 | unaff_s2;
    uVar6 = unaff_s1 << 0x10;
    uVar7 = unaff_s2;
    FUN_8006c49c();
  }
  if (sVar2 != 0) {
    uVar5 = 0x1000;

	// TRIG_AngleSinCos_r16r17r18_duplicate
    FUN_8006c430();

    uVar6 = -unaff_s1 & 0xffff;
    uVar7 = unaff_s2;
    FUN_8006c49c();
    uVar3 = unaff_s2;
    uVar4 = unaff_s1;
  }
  *param_1 = uVar3;
  param_1[1] = uVar4;
  param_1[2] = uVar5;
  param_1[3] = uVar6;
  param_1[4] = uVar7;
  return;
}



// MatrixRotate (param_1 = param_2 matrix rotated by param_3 matrix)
void FUN_8006c3b0(undefined4 *param_1,undefined4 param_2,undefined4 *param_3)
{
  // see decompile RB_Crate for documented usage
	
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_retaddr;

  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f80002c = unaff_retaddr;
  
  // MATRIX_SET_r11r12r13r14r15
  FUN_8006c540();
  
  uVar1 = *param_3;
  uVar2 = param_3[1];
  uVar3 = param_3[2];
  uVar4 = param_3[3];
  uVar5 = param_3[4];
  FUN_8006c49c();
  *param_1 = uVar1;
  param_1[1] = uVar2;
  param_1[2] = uVar3;
  param_1[3] = uVar4;
  param_1[4] = uVar5;
  return;
}


// TRIG_AngleSinCos_r16r17r18_duplicate
void FUN_8006c430(void)

{
        8006c430 08 80 03 3c     lui        v1,0x8008
        8006c434 a0 45 63 24     addiu      v1,v1,0x45a0
        8006c438 ff 03 11 32     andi       s1,s0,0x3ff
        8006c43c 80 88 11 00     sll        s1,s1,0x2
        8006c440 21 18 71 00     addu       v1,v1,s1
        8006c444 00 00 71 8c     lw         s1,0x0(v1)=>DAT_800845a0
        8006c448 00 04 03 32     andi       v1,s0,0x400
        8006c44c 05 00 60 14     bne        v1,zero,LAB_8006c464
        8006c450 00 08 03 32     _andi      v1,s0,0x800
        8006c454 09 00 60 14     bne        v1,zero,LAB_8006c47c
        8006c458 02 94 11 00     _srl       s2,s1,0x10
        8006c45c 08 00 e0 03     jr         ra
        8006c460 ff ff 31 32     _andi      s1,s1,0xffff
                             LAB_8006c464                                    XREF[1]:     8006c44c(j)
        8006c464 ff ff 32 32     andi       s2,s1,0xffff
        8006c468 09 00 60 14     bne        v1,zero,LAB_8006c490
        8006c46c 02 8c 11 00     _srl       s1,s1,0x10
        8006c470 22 90 12 00     sub        s2,zero,s2
        8006c474 08 00 e0 03     jr         ra
        8006c478 ff ff 52 32     _andi      s2,s2,0xffff
                             LAB_8006c47c                                    XREF[1]:     8006c454(j)
        8006c47c 22 90 12 00     sub        s2,zero,s2
        8006c480 22 88 11 00     sub        s1,zero,s1
        8006c484 ff ff 52 32     andi       s2,s2,0xffff
        8006c488 08 00 e0 03     jr         ra
        8006c48c ff ff 31 32     _andi      s1,s1,0xffff
                             LAB_8006c490                                    XREF[1]:     8006c468(j)
        8006c490 22 88 11 00     sub        s1,zero,s1
        8006c494 08 00 e0 03     jr         ra
        8006c498 ff ff 31 32     _andi      s1,s1,0xffff

}


void FUN_8006c49c(void)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint in_t3;
  uint uVar5;
  uint in_t4;
  int iVar6;
  uint in_t5;
  uint uVar7;
  uint in_t6;
  uint uVar8;
  undefined4 in_t7;
  undefined4 uVar9;

  gte_ldVXY0(in_t3 & 0xffff | in_t4 & 0xffff0000);
  gte_ldVZ0(in_t6);
  gte_rtv0_b();

  gte_ldVXY1(in_t3 >> 0x10 | in_t5 << 0x10);
  gte_ldVZ1(in_t6 >> 0x10);
  uVar5 = gte_stIR1();
  iVar6 = gte_stIR2();
  uVar8 = gte_stIR3();
  gte_rtv1_b();

  gte_ldVXY2(in_t4 & 0xffff | in_t5 & 0xffff0000);
  gte_ldVZ2(in_t7);
  iVar1 = gte_stIR1();
  uVar7 = gte_stIR2();
  iVar3 = gte_stIR3();
  gte_rtv2_b();

  uVar2 = gte_stIR1();
  iVar4 = gte_stIR2();
  uVar9 = gte_stIR3();
  gte_ldR11R12(uVar5 & 0xffff | iVar1 << 0x10);
  gte_ldR13R21(iVar6 << 0x10 | uVar2 & 0xffff);
  gte_ldR22R23(uVar7 & 0xffff | iVar4 << 0x10);
  gte_ldR31R32(uVar8 & 0xffff | iVar3 << 0x10);
  gte_ldR33(uVar9);

  return;
}

// MATRIX_SET_r11r12r13r14r15
void FUN_8006c540(void)

{
  undefined4 in_t3;
  undefined4 in_t4;
  undefined4 in_t5;
  undefined4 in_t6;
  undefined4 in_t7;

  gte_ldR11R12(in_t3);
  gte_ldR13R21(in_t4);
  gte_ldR22R23(in_t5);
  gte_ldR31R32(in_t6);
  gte_ldR33(in_t7);
  return;
}



void FUN_8006c558(void)

{
  uint in_t3;
  uint in_t4;
  uint in_t5;
  uint in_t6;
  undefined4 in_t7;

  gte_ldVXY0(in_t3 & 0xffff | in_t4 & 0xffff0000);
  gte_ldVZ0(in_t6);

  // llv0     v0 * light matrix
  gte_llv0_b();

  gte_ldVXY1(in_t3 >> 0x10 | in_t5 << 0x10);
  gte_ldVZ1(in_t6 >> 0x10);
  gte_stIR1();
  gte_stIR2();
  gte_stIR3();

  // llv1     v1 * light matrix
  gte_llv1_b();

  gte_ldVXY2(in_t4 & 0xffff | in_t5 & 0xffff0000);
  gte_ldVZ2(in_t7);
  gte_stIR1();
  gte_stIR2();
  gte_stIR3();

  // llv2     v2 * light matrix
  gte_llv2_b();

  gte_stIR1();
  gte_stIR2();
  gte_stIR3();
  return;
}



void FUN_8006c600(void)

{
  undefined4 in_t3;
  undefined4 in_t4;
  undefined4 in_t5;
  undefined4 in_t6;
  undefined4 in_t7;

  gte_ldL11L12(in_t3);
  gte_ldL13L21(in_t4);
  gte_ldL22L23(in_t5);
  gte_ldL31L32(in_t6);
  gte_ldL33(in_t7);
  return;
}

//FUN_8006c618 SquareRoot0.

void FUN_8006c684(uint *param_1)

{
  uint uVar1;
  uint uVar2;

  uVar1 = param_1[1] >> 8;
  uVar2 = *param_1 >> 8 | param_1[1] << 0x18;
  param_1[1] = (uVar1 | (*param_1 + uVar1 + (uVar2 >> 8)) * 0x1000000) ^ 0xdeadc0ed;
  *param_1 = uVar2;
  return;
}


int * FUN_8006c6c8(uint *param_1,int *param_2,undefined4 *param_3)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int iVar6;

  gte_ldR11R12(*param_3);
  gte_ldR13R21(param_3[1]);
  gte_ldR22R23(param_3[2]);
  gte_ldR31R32(param_3[3]);
  gte_ldR33(param_3[4]);

  // 4,5,6
  iVar4 = (int)*param_1 >> 0xf;
  iVar5 = (int)param_1[1] >> 0xf;
  iVar6 = (int)param_1[2] >> 0xf;

  // 4,5,6
  gte_ldsv_(iVar4,iVar5,iVar6);

  // 1,2,3
  uVar1 = *param_1 & 0x7fff;
  gte_rtir_sf0_b();
  uVar2 = param_1[1] & 0x7fff;
  uVar3 = param_1[2] & 0x7fff;

  // 4,5,6
  read_mt(iVar4,iVar5,iVar6);

  // 1,2,3
  gte_ldsv_(uVar1,uVar2,uVar3);
  gte_rtir_b();

  // 1,2,3
  read_mt(uVar1,uVar2,uVar3);

  // combine all
  *param_2 = uVar1 + iVar4 * 8;
  param_2[1] = uVar2 + iVar5 * 8;
  param_2[2] = uVar3 + iVar6 * 8;
  return param_2;
}

//FUN_8006c6f0 ApplyMatrixLV.
//FUN_8006d094 used to be here, but it was deleted.
//FUN_8006d258 used to be here, but it was deleted.
//FUN_8006d2bc used to be here, but it was deleted.
//FUN_8006d324 used to be here, but it was deleted.
//FUN_8006d38c used to be here, but it was deleted.
//FUN_8006d3c8 used to be here, but it was deleted.
//FUN_8006d4a4 used to be here, but it was deleted.

// Draw_KartGhost
void FUN_8006c984(void)

{
  bool bVar1;
  short sVar2;
  ushort uVar3;
  ushort uVar4;
  short sVar5;
  int in_at;
  undefined4 in_v0;
  int iVar6;
  code *pcVar7;
  uint uVar8;
  int *piVar9;
  int iVar10;
  int iVar11;
  undefined4 *puVar12;
  undefined4 uVar13;
  undefined uVar14;
  undefined4 uVar15;
  code *UNRECOVERED_JUMPTABLE;
  ushort *puVar16;
  short *psVar17;
  undefined4 *puVar18;
  int iVar19;
  int unaff_retaddr;

  uVar8 = *(uint *)(unaff_retaddr + 0x24);
  sVar5 = *(short *)(unaff_retaddr + 0x22);
  if (uVar8 == 0) {
    uVar14 = (undefined)(0x1000U - (int)sVar5 >> 5);
    *(undefined *)(in_at + 0x124) = uVar14;
    *(undefined *)(in_at + 0x125) = uVar14;
    *(undefined *)(in_at + 0x126) = uVar14;
    *(undefined *)(in_at + 0x127) = 0x22;
    if (sVar5 == 0x1000) {
      while( true ) {
        piVar9 = *(int **)(in_at + 4);
        iVar19 = *piVar9;
        iVar10 = piVar9[1];
        *(int **)(in_at + 4) = piVar9 + 2;
        if (iVar19 == 0) break;
        iVar6 = *(int *)(iVar10 + 0x74);
        iVar11 = *(int *)(in_at + 8);
        *(int *)(in_at + 0x10) = iVar19;
        *(int *)(in_at + 8) = iVar6;
		
		// tileView
        if (iVar6 != iVar11) 
		{
		  // width, height, distToScreen
          sVar5 = *(short *)(iVar6 + 0x20);
          sVar2 = *(short *)(iVar6 + 0x22);
          uVar15 = *(undefined4 *)(iVar6 + 0x18);
		  
		  // scratchpad
          *(short *)(in_at + 0x1c) = sVar5;
          *(short *)(in_at + 0x1e) = sVar2;
          
		  // GTE
		  setCopControlWord(2,0xc000,(int)sVar5 << 0xf);
          setCopControlWord(2,0xc800,(int)sVar2 << 0xf);
          setCopControlWord(2,0xd000,uVar15);
        }
        uVar8 = *(uint *)(iVar10 + 0xb8);
        sVar5 = *(short *)(iVar10 + 0xbc);
        
		if (((uVar8 & 0x40) != 0) && ((uVar8 & 0x80) == 0)) 
		{
		  // instance matrix
          gte_ldR11R12(*(undefined4 *)(iVar10 + 0x78));
          gte_ldR13R21(*(undefined4 *)(iVar10 + 0x7c));
          gte_ldR22R23(*(undefined4 *)(iVar10 + 0x80));
          gte_ldR31R32(*(undefined4 *)(iVar10 + 0x84));
          gte_ldR33(*(undefined4 *)(iVar10 + 0x88));
          
		  gte_ldtr(
			*(undefined4 *)(iVar10 + 0x8c),
			*(undefined4 *)(iVar10 + 0x90),
			*(undefined4 *)(iVar10 + 0x94)
		  );
          
		  *(uint *)(in_at + 0x24) = uVar8;
          *(int *)(in_at + 0x120) = (int)sVar5;
          
		  if ((uVar8 & 0x7000) != 0) 
		  {
			// instance matrix
            gte_ldL11L12(*(undefined4 *)(iVar10 + 0x98));
            gte_ldL13L21(*(undefined4 *)(iVar10 + 0x9c));
            gte_ldL22L23(*(undefined4 *)(iVar10 + 0xa0));
            gte_ldL31L32(*(undefined4 *)(iVar10 + 0xa4));
            gte_ldL33(*(undefined4 *)(iVar10 + 0xa8));
            
			sVar5 = *(short *)(iVar10 + 0xbe);
            uVar14 = *(undefined *)(iVar19 + 0x53);
            uVar15 = *(undefined4 *)(iVar19 + 0x58);
            *(short *)(in_at + 0x44) = sVar5;
            *(short *)(in_at + 0xda) = sVar5;
            *(short *)(in_at + 0xf2) = sVar5;
            *(undefined *)(in_at + 0x48) = uVar14;
            *(undefined4 *)(in_at + 0x4c) = uVar15;
            *(int *)(in_at + 0x11c) = (int)sVar5 << 0x11;
            *(undefined4 *)(in_at + 0xe0) = 0;
            *(undefined4 *)(in_at + 0xf8) = 0;
          }
          psVar17 = *(short **)(iVar10 + 0xc4);
          puVar16 = *(ushort **)(iVar10 + 0xc0);
          if (psVar17 == (short *)0x0) {
            uVar3 = puVar16[1];
            uVar4 = puVar16[2];
            *(ushort *)(in_at + 0x30) = *puVar16 & 0x7fff;
            *(ushort *)(in_at + 0x32) = uVar3;
            *(int *)(in_at + 0x34) = (int)(short)uVar4;
          }
          else {
            *(ushort *)(in_at + 0x30) = *puVar16 + *psVar17;
            *(ushort *)(in_at + 0x32) = puVar16[1] + psVar17[1];
            *(int *)(in_at + 0x34) = ((int)(short)puVar16[2] + (int)psVar17[2]) * 2;
          }
          *(undefined4 *)(in_at + 0x58) = 0;
          puVar18 = *(undefined4 **)(iVar10 + 0xd0);
          iVar6 = **(int **)(iVar10 + 200);
          puVar12 = (undefined4 *)(in_at + 0x140);
          while (bVar1 = 0 < iVar6, iVar6 = iVar6 + -1, bVar1) {
            uVar15 = *puVar18;
            puVar18 = puVar18 + 1;
            *puVar12 = uVar15;
            puVar12 = puVar12 + 1;
          }
          (**(code **)(iVar19 + 0x5c))();
          sVar5 = *(short *)(iVar10 + 0xde);
          *(short *)(in_at + 0x134) = (short)((int)*(short *)(iVar10 + 0xdc) << 2);
          *(short *)(in_at + 0x136) = (short)((int)sVar5 << 2);
          uVar15 = *(undefined4 *)(iVar10 + 0xe4);
          uVar13 = *(undefined4 *)(iVar10 + 0xe8);
          pcVar7 = *(code **)(iVar10 + 0xec);
          *(undefined4 *)(in_at + 0x38) = uVar15;
          *(undefined4 *)(in_at + 0x3c) = uVar15;
          *(undefined4 *)(in_at + 0x40) = uVar13;
          in_v0 = (*pcVar7)(*(undefined4 *)(iVar19 + 100));
        }
      }
      *(undefined4 *)(*(int *)(in_at + 0xc) + 0xc) = in_v0;
      return;
    }
  }
  setCopReg(2,0x3000,0);
  setCopControlWord(2,0xa800,uVar8 >> 0x10 & 0xff0);
  setCopControlWord(2,0xb000,uVar8 >> 8 & 0xff0);
                    /* WARNING: Could not recover jumptable at 0x8006c96c. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  setCopControlWord(2,0xb800,uVar8 & 0xff0);
  (*UNRECOVERED_JUMPTABLE)();
  return;
}

// Draw_KartBodyReflection
void FUN_8006c9c4(void)

{
  bool bVar1;
  undefined uVar2;
  short sVar3;
  short sVar4;
  ushort uVar5;
  ushort uVar6;
  undefined4 in_zero;
  int in_at;
  undefined4 in_v0;
  int iVar7;
  code *pcVar8;
  undefined4 extraout_v1;
  undefined4 extraout_v1_00;
  undefined4 uVar9;
  uint uVar10;
  int *piVar11;
  int iVar12;
  int iVar13;
  undefined4 *puVar14;
  int in_t0;
  int iVar15;
  uint uVar16;
  uint uVar17;
  undefined4 uVar18;
  uint uVar19;
  uint in_t1;
  uint uVar20;
  undefined4 uVar21;
  uint uVar22;
  undefined4 uVar23;
  uint in_t3;
  undefined4 in_t4;
  undefined4 in_t5;
  uint uVar24;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  code *unaff_s6;
  ushort *puVar25;
  short *psVar26;
  uint *in_t9;
  uint *puVar27;
  undefined4 *puVar28;
  undefined8 uVar29;
  int iStack4;

code_r0x8006c9c4:
  puVar27 = in_t9 + 1;
  if (in_t0 == 0) {
    while( true ) {
      piVar11 = *(int **)(in_at + 4);
      iVar12 = *piVar11;
      iVar15 = piVar11[1];
      *(int **)(in_at + 4) = piVar11 + 2;
      if (iVar12 == 0) break;
	  
	  // instance -> tileView
      iVar7 = *(int *)(iVar15 + 0x74);
	  
      iVar13 = *(int *)(in_at + 8);
      *(int *)(in_at + 0x10) = iVar12;
      *(int *)(in_at + 8) = iVar7;
	  
	  // if this tileView is not previous
      if (iVar7 != iVar13) 
	  {
		// tileView width, height, distToScreen
        sVar3 = *(short *)(iVar7 + 0x20);
        sVar4 = *(short *)(iVar7 + 0x22);
        uVar9 = *(undefined4 *)(iVar7 + 0x18);
		
		// scratchpad
        *(short *)(in_at + 0x1c) = sVar3;
        *(short *)(in_at + 0x1e) = sVar4;
		
		// GTE
        setCopControlWord(2,0xc000,(int)sVar3 << 0xf);
        setCopControlWord(2,0xc800,(int)sVar4 << 0xf);
        setCopControlWord(2,0xd000,uVar9);
      }
      uVar10 = *(uint *)(iVar15 + 0xb8);
      sVar3 = *(short *)(iVar15 + 0xbc);
      if (((uVar10 & 0x40) != 0) && ((uVar10 & 0x80) == 0)) 
	  {
		// instance matrix
		gte_ldR11R12(*(undefined4 *)(iVar15 + 0x78));
		gte_ldR13R21(*(undefined4 *)(iVar15 + 0x7c));
		gte_ldR22R23(*(undefined4 *)(iVar15 + 0x80));
		gte_ldR31R32(*(undefined4 *)(iVar15 + 0x84));
		gte_ldR33(*(undefined4 *)(iVar15 + 0x88));
		
		gte_ldtr(
		  *(undefined4 *)(iVar15 + 0x8c),
		  *(undefined4 *)(iVar15 + 0x90),
		  *(undefined4 *)(iVar15 + 0x94)
		);
		
        *(uint *)(in_at + 0x24) = uVar10;
        *(int *)(in_at + 0x120) = (int)sVar3;
        if ((uVar10 & 0x7000) != 0) 
		{
		  // instance matrix
          gte_ldL11L12(*(undefined4 *)(iVar15 + 0x98));
          gte_ldL13L21(*(undefined4 *)(iVar15 + 0x9c));
          gte_ldL22L23(*(undefined4 *)(iVar15 + 0xa0));
          gte_ldL31L32(*(undefined4 *)(iVar15 + 0xa4));
          gte_ldL33(*(undefined4 *)(iVar15 + 0xa8));
			
          sVar3 = *(short *)(iVar15 + 0xbe);
          uVar2 = *(undefined *)(iVar12 + 0x53);
          uVar9 = *(undefined4 *)(iVar12 + 0x58);
          *(short *)(in_at + 0x44) = sVar3;
          *(short *)(in_at + 0xda) = sVar3;
          *(short *)(in_at + 0xf2) = sVar3;
          *(undefined *)(in_at + 0x48) = uVar2;
          *(undefined4 *)(in_at + 0x4c) = uVar9;
          *(int *)(in_at + 0x11c) = (int)sVar3 << 0x11;
          *(undefined4 *)(in_at + 0xe0) = 0;
          *(undefined4 *)(in_at + 0xf8) = 0;
        }
        psVar26 = *(short **)(iVar15 + 0xc4);
        puVar25 = *(ushort **)(iVar15 + 0xc0);
        if (psVar26 == (short *)0x0) {
          uVar5 = puVar25[1];
          uVar6 = puVar25[2];
          *(ushort *)(in_at + 0x30) = *puVar25 & 0x7fff;
          *(ushort *)(in_at + 0x32) = uVar5;
          *(int *)(in_at + 0x34) = (int)(short)uVar6;
        }
        else {
          *(ushort *)(in_at + 0x30) = *puVar25 + *psVar26;
          *(ushort *)(in_at + 0x32) = puVar25[1] + psVar26[1];
          *(int *)(in_at + 0x34) = ((int)(short)puVar25[2] + (int)psVar26[2]) * 2;
        }
        *(undefined4 *)(in_at + 0x58) = 0;
        puVar28 = *(undefined4 **)(iVar15 + 0xd0);
        iVar7 = **(int **)(iVar15 + 200);
        puVar14 = (undefined4 *)(in_at + 0x140);
        while (bVar1 = 0 < iVar7, iVar7 = iVar7 + -1, bVar1) {
          uVar9 = *puVar28;
          puVar28 = puVar28 + 1;
          *puVar14 = uVar9;
          puVar14 = puVar14 + 1;
        }
        (**(code **)(iVar12 + 0x5c))();
        sVar3 = *(short *)(iVar15 + 0xde);
        *(short *)(in_at + 0x134) = (short)((int)*(short *)(iVar15 + 0xdc) << 2);
        *(short *)(in_at + 0x136) = (short)((int)sVar3 << 2);
        uVar9 = *(undefined4 *)(iVar15 + 0xe4);
        uVar18 = *(undefined4 *)(iVar15 + 0xe8);
        pcVar8 = *(code **)(iVar15 + 0xec);
        *(undefined4 *)(in_at + 0x38) = uVar9;
        *(undefined4 *)(in_at + 0x3c) = uVar9;
        *(undefined4 *)(in_at + 0x40) = uVar18;
        in_v0 = (*pcVar8)(*(undefined4 *)(iVar12 + 100));
      }
    }
    *(undefined4 *)(*(int *)(in_at + 0xc) + 0xc) = in_v0;
    return;
  }
  *(uint *)(in_at + 0x10c) = in_t3;
  (*unaff_s6)();
  *(int *)(in_at + 0x90) = in_t0;
  *(undefined4 *)(in_at + 0x94) = extraout_v1;
  iVar15 = (int)*(short *)(in_at + 0x44) - (in_t0 >> 0x10);
  *(short *)(in_at + 0x9e) = (short)iVar15;
  uVar10 = in_t1;
  (*unaff_s6)();
  *(int *)(in_at + 0xa8) = iVar15;
  *(undefined4 *)(in_at + 0xac) = extraout_v1_00;
  iVar15 = (int)*(short *)(in_at + 0x44) - (iVar15 >> 0x10);
  *(short *)(in_at + 0xb6) = (short)iVar15;
  uVar24 = in_t1;
  uVar29 = (*unaff_s6)();
  uVar9 = (undefined4)((ulonglong)uVar29 >> 0x20);
  in_v0 = (undefined4)uVar29;
  setCopReg(2,in_zero,*(undefined4 *)(in_at + 0x90));
  setCopReg(2,in_at,*(undefined4 *)(in_at + 0x94));
  setCopReg(2,in_v0,*(undefined4 *)(in_at + 0xa8));
  setCopReg(2,uVar9,*(undefined4 *)(in_at + 0xac));
  setCopReg(2,0x2000,iVar15);
  setCopReg(2,0x2800,uVar9);
  in_t3 = *(uint *)(in_at + 0x10c);
  copFunction(2,0x280030);
  *(int *)(in_at + 0xc0) = iVar15;
  *(undefined4 *)(in_at + 0xc4) = uVar9;
  *(short *)(in_at + 0xce) = *(short *)(in_at + 0x44) - (short)((uint)iVar15 >> 0x10);
  in_t9 = puVar27 + 1;
  uVar9 = getCopReg(2,0xc);
  *(undefined4 *)(in_at + 0x6c) = uVar9;
  uVar9 = getCopReg(2,0x11);
  *(undefined4 *)(in_at + 0x70) = uVar9;
  uVar9 = getCopReg(2,0xd);
  *(undefined4 *)(in_at + 0x74) = uVar9;
  uVar9 = getCopReg(2,0x12);
  *(undefined4 *)(in_at + 0x78) = uVar9;
  uVar9 = getCopReg(2,0xe);
  *(undefined4 *)(in_at + 0x7c) = uVar9;
  uVar9 = getCopReg(2,0x13);
  *(undefined4 *)(in_at + 0x80) = uVar9;
  iVar15 = *(int *)(in_at + 0x11c);
  uVar16 = getCopReg(2,0);
  uVar20 = getCopReg(2,0x1000);
  uVar22 = getCopReg(2,0x2000);
  setCopReg(2,0,iVar15 - (uVar16 & 0xffff0000) | uVar16 & 0xffff);
  setCopReg(2,0x1000,iVar15 - (uVar20 & 0xffff0000) | uVar20 & 0xffff);
  setCopReg(2,0x2000,iVar15 - (uVar22 & 0xffff0000) | uVar22 & 0xffff);
  copFunction(2,0x280030);
  uVar16 = in_t1;
  do {
    uVar20 = in_t3 & 0x1ff;
    iVar15 = uVar20 * 4;
    if (uVar20 != 0) {
      iVar15 = (&iStack4)[uVar20];
    }
    *(ushort *)(in_at + 0x24) = *(ushort *)(in_at + 0x24) ^ 0x8000;
    *(int *)(in_at + 0x50) = iVar15;
    uVar9 = *(undefined4 *)(in_at + 0x3c);
    *(undefined4 *)(in_at + 0x3c) = *(undefined4 *)(in_at + 0x40);
    *(undefined4 *)(in_at + 0x40) = uVar9;
    *(undefined4 *)(in_at + 0x108) = 0;
    iVar15 = *(int *)(in_at + 0x1c);
    uVar20 = getCopReg(2,0x7000);
    iVar12 = getCopControlWord(2,0xf800);
    if (-1 < iVar12 << 0xd) {
      if ((int)(in_t3 << 3) < 0) {
        copFunction(2,0x1400006);
        uVar17 = getCopReg(2,0xc000);
        if ((uVar17 == 0) ||
           (uVar22 = getCopReg(2,0x6000),
           (int)(uVar17 ^ (int)*(short *)(in_at + 0x24) ^ in_t3 << 2) < 1)) goto LAB_8006cb88;
      }
      else {
        uVar22 = getCopReg(2,0x6000);
      }
      uVar17 = getCopReg(2,0x6800);
      copFunction(2,0x158002d);
      uVar20 = ~(uVar22 - iVar15 | uVar17 - iVar15 | uVar20 - iVar15) | uVar22 & uVar20 & uVar17;
      if (-1 < (int)uVar20) {
        uVar9 = getCopReg(2,0x18);
        *(undefined4 *)(in_at + 0x2c) = uVar9;
        if (-1 < (int)(uVar20 << 0x10)) {
          in_v0 = FUN_8006d094();
        }
      }
    }
LAB_8006cb88:
    uVar9 = getCopReg(2,0x6000);
    uVar18 = getCopReg(2,0x8800);
    uVar21 = getCopReg(2,0x6800);
    uVar23 = getCopReg(2,0x9000);
    setCopReg(2,in_t4,*(undefined4 *)(in_at + 0x6c));
    setCopReg(2,unaff_s1,*(undefined4 *)(in_at + 0x70));
    setCopReg(2,in_t5,*(undefined4 *)(in_at + 0x74));
    setCopReg(2,unaff_s2,*(undefined4 *)(in_at + 0x78));
    *(undefined4 *)(in_at + 0x6c) = uVar9;
    *(undefined4 *)(in_at + 0x70) = uVar18;
    *(undefined4 *)(in_at + 0x74) = uVar21;
    *(undefined4 *)(in_at + 0x78) = uVar23;
    uVar9 = getCopReg(2,0x7000);
    uVar18 = getCopReg(2,0x9800);
    setCopReg(2,uVar10,*(undefined4 *)(in_at + 0x7c));
    setCopReg(2,unaff_s3,*(undefined4 *)(in_at + 0x80));
    *(undefined4 *)(in_at + 0x7c) = uVar9;
    *(undefined4 *)(in_at + 0x80) = uVar18;
    *(ushort *)(in_at + 0x24) = *(ushort *)(in_at + 0x24) ^ 0x8000;
    uVar9 = *(undefined4 *)(in_at + 0x40);
    *(undefined4 *)(in_at + 0x40) = *(undefined4 *)(in_at + 0x3c);
    *(undefined4 *)(in_at + 0x3c) = uVar9;
    *(undefined4 *)(in_at + 0x108) = 0xffffffff;
    iVar15 = *(int *)(in_at + 0x1c);
    uVar22 = getCopReg(2,0x7000);
    iVar12 = getCopControlWord(2,0xf800);
    in_t1 = in_t3 << 2;
    uVar20 = uVar24;
    if (-1 < iVar12 << 0xd) {
      if ((int)(in_t3 << 3) < 0) {
        copFunction(2,0x1400006);
        uVar19 = getCopReg(2,0xc000);
        in_t1 = (int)*(short *)(in_at + 0x24) ^ in_t1;
        if ((uVar19 == 0) || (uVar17 = getCopReg(2,0x6000), (int)(uVar19 ^ in_t1) < 1))
        goto LAB_8006cc74;
      }
      else {
        uVar17 = getCopReg(2,0x6000);
      }
      uVar19 = getCopReg(2,0x6800);
      copFunction(2,0x158002d);
      in_t1 = uVar19 - iVar15;
      uVar22 = ~(uVar17 - iVar15 | in_t1 | uVar22 - iVar15) | uVar17 & uVar22 & uVar19;
      if (-1 < (int)uVar22) {
        uVar9 = getCopReg(2,0x18);
        *(undefined4 *)(in_at + 0x2c) = uVar9;
        if (-1 < (int)(uVar22 << 0x10)) {
          in_v0 = FUN_8006d094();
          uVar20 = uVar24;
        }
      }
    }
LAB_8006cc74:
    while( true ) {
      uVar24 = uVar16;
      in_t3 = *in_t9;
      in_t9 = in_t9 + 1;
      in_t0 = in_t3 + 1;
      if ((int)in_t3 < 0) goto code_r0x8006c9c4;
      uVar22 = in_t3 >> 0x10;
      in_t1 = in_t3 << 1;
      if (uVar22 != 0) break;
      uVar10 = in_t3 >> 7 & 0x1fc;
      if ((int)(in_t3 << 0x1f) < 0) {
        uVar10 = *(uint *)(uVar10 + in_at + 0x140);
      }
      else {
        uVar10 = *(uint *)(&gp0x00000000 + uVar10);
      }
      uVar20 = uVar10;
      if ((int)(in_t3 << 0x1e) < 0) {
        uVar16 = *(uint *)((in_t3 & 0x1fc) + in_at + 0x140);
      }
      else {
        uVar16 = *(uint *)(&gp0x00000000 + (in_t3 & 0x1fc));
      }
    }
    if ((int)in_t1 < 0) {
      uVar9 = getCopReg(2,0x6000);
      uVar18 = getCopReg(2,0x8800);
      setCopReg(2,0x6800,uVar9);
      setCopReg(2,0x9000,uVar18);
      *(undefined4 *)(in_at + 0x74) = *(undefined4 *)(in_at + 0x6c);
      *(undefined4 *)(in_at + 0x78) = *(undefined4 *)(in_at + 0x70);
    }
    else {
      *(undefined4 *)(in_at + 0x90) = *(undefined4 *)(in_at + 0xa8);
      *(undefined4 *)(in_at + 0x94) = *(undefined4 *)(in_at + 0xac);
      *(undefined2 *)(in_at + 0x9e) = *(undefined2 *)(in_at + 0xb6);
      uVar10 = uVar20;
    }
    *(undefined4 *)(in_at + 0xa8) = *(undefined4 *)(in_at + 0xc0);
    uVar16 = (uint)*(short *)(in_at + 0xce);
    *(undefined4 *)(in_at + 0xac) = *(undefined4 *)(in_at + 0xc4);
    *(short *)(in_at + 0xb6) = *(short *)(in_at + 0xce);
    uVar29 = (*unaff_s6)();
    uVar9 = (undefined4)((ulonglong)uVar29 >> 0x20);
    in_v0 = (undefined4)uVar29;
    setCopReg(2,0,uVar22);
    setCopReg(2,0x800,uVar9);
    copFunction(2,0x180001);
    *(uint *)(in_at + 0xc0) = uVar22;
    *(undefined4 *)(in_at + 0xc4) = uVar9;
    *(short *)(in_at + 0xce) = *(short *)(in_at + 0x44) - (short)(uVar22 >> 0x10);
    uVar9 = getCopReg(2,0x6000);
    uVar18 = getCopReg(2,0x8800);
    uVar21 = getCopReg(2,0x6800);
    uVar23 = getCopReg(2,0x9000);
    setCopReg(2,in_t4,*(undefined4 *)(in_at + 0x6c));
    setCopReg(2,unaff_s1,*(undefined4 *)(in_at + 0x70));
    setCopReg(2,in_t5,*(undefined4 *)(in_at + 0x74));
    setCopReg(2,unaff_s2,*(undefined4 *)(in_at + 0x78));
    *(undefined4 *)(in_at + 0x6c) = uVar9;
    *(undefined4 *)(in_at + 0x70) = uVar18;
    *(undefined4 *)(in_at + 0x74) = uVar21;
    *(undefined4 *)(in_at + 0x78) = uVar23;
    uVar9 = getCopReg(2,0x7000);
    uVar18 = getCopReg(2,0x9800);
    setCopReg(2,uVar10,*(undefined4 *)(in_at + 0x7c));
    setCopReg(2,unaff_s3,*(undefined4 *)(in_at + 0x80));
    *(undefined4 *)(in_at + 0x7c) = uVar9;
    *(undefined4 *)(in_at + 0x80) = uVar18;
    uVar20 = getCopReg(2,0);
    setCopReg(2,0,*(int *)(in_at + 0x11c) - (uVar20 & 0xffff0000) | uVar20 & 0xffff);
    copFunction(2,0x180001);
  } while( true );
}


void FUN_8006cdec(void)
{
  char cVar1;
  int in_at;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  undefined4 uVar5;
  int iVar6;
  uint uVar7;
  int iVar8;
  char cVar9;
  uint uVar10;
  char cVar11;
  uint uVar12;
  uint in_t3;
  uint in_t4;
  uint in_t5;
  uint unaff_s1;
  uint unaff_s2;
  int unaff_s3;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  uint *unaff_s7;
  uint *in_t8;
  uint *unaff_s8;

  iVar6 = (in_t3 >> 0xd & 0x7f8) + in_at;
  if (-1 < (int)(in_t3 << 5)) {
    if (unaff_s8 == (uint *)0x0) {
      uVar10 = *unaff_s7;
      uVar12 = *in_t8;
    }
    else {
      *(int *)(in_at + 0x20) = iVar6;
      uVar15 = *unaff_s8;
      uVar2 = uVar15 >> 6 & 7;
      uVar7 = uVar2 ^ 0x1f;
      uVar3 = uVar2 + 1;
      uVar13 = unaff_s3 + uVar3;
      cVar9 = (char)((int)unaff_s1 >> uVar7);
      cVar11 = (char)((int)unaff_s2 >> uVar7);
      uVar10 = unaff_s1;
      uVar12 = unaff_s2;
      uVar14 = uVar13;
      if (0 < (int)uVar13) {
        uVar10 = *unaff_s7;
        uVar12 = *in_t8;
        unaff_s7 = unaff_s7 + 1;
        in_t8 = in_t8 + 1;
        cVar9 = (char)((int)(unaff_s1 | uVar10 >> (uVar3 - uVar13 & 0x1f)) >> uVar7);
        cVar11 = (char)((int)(unaff_s2 | uVar12 >> (uVar3 - uVar13 & 0x1f)) >> uVar7);
        uVar14 = uVar13 - 0x20;
        uVar3 = uVar13;
      }
      uVar10 = uVar10 << (uVar3 & 0x1f);
      uVar12 = uVar12 << (uVar3 & 0x1f);
      if (uVar2 != 7) {
        cVar1 = (char)((int)uVar15 >> 0x19) * '\x02';
        cVar9 = cVar9 + cVar1 + *(char *)(in_at + 0x58);
        cVar11 = cVar11 + cVar1 + *(char *)(in_at + 0x5c);
      }
      *(char *)(in_at + 0x58) = cVar9;
      *(char *)(in_at + 0x5c) = cVar11;
      uVar4 = uVar15 >> 3 & 7;
      uVar7 = uVar4 + 1;
      uVar14 = uVar14 + uVar7;
      uVar3 = uVar10;
      uVar2 = uVar12;
      uVar13 = uVar14;
      if (0 < (int)uVar14) {
        uVar3 = *unaff_s7;
        uVar2 = *in_t8;
        unaff_s7 = unaff_s7 + 1;
        in_t8 = in_t8 + 1;
        uVar10 = uVar10 | uVar3 >> (uVar7 - uVar14 & 0x1f);
        uVar12 = uVar12 | uVar2 >> (uVar7 - uVar14 & 0x1f);
        uVar13 = uVar14 - 0x20;
        uVar7 = uVar14;
      }
      cVar11 = (char)((int)uVar12 >> (uVar4 ^ 0x1f));
      cVar9 = (char)((int)uVar10 >> (uVar4 ^ 0x1f));
      uVar3 = uVar3 << (uVar7 & 0x1f);
      uVar2 = uVar2 << (uVar7 & 0x1f);
      if (uVar4 != 7) {
        cVar1 = (char)((uVar15 << 7) >> 0x18);
        cVar9 = cVar9 + cVar1 + *(char *)(in_at + 0x5a);
        cVar11 = cVar11 + cVar1 + *(char *)(in_at + 0x5e);
      }
      *(char *)(in_at + 0x5a) = cVar9;
      *(char *)(in_at + 0x5e) = cVar11;
      uVar10 = uVar15 & 7;
      iVar6 = uVar13 + uVar10 + 1;
      if (0 < iVar6) {
        uVar12 = (uVar10 + 1) - iVar6;
        uVar3 = uVar3 | *unaff_s7 >> (uVar12 & 0x1f);
        uVar2 = uVar2 | *in_t8 >> (uVar12 & 0x1f);
      }
      cVar11 = (char)((int)uVar2 >> (uVar10 ^ 0x1f));
      cVar9 = (char)((int)uVar3 >> (uVar10 ^ 0x1f));
      if (uVar10 != 7) {
        cVar1 = (char)((uVar15 << 0xf) >> 0x18);
        cVar9 = cVar9 + cVar1 + *(char *)(in_at + 0x59);
        cVar11 = cVar11 + cVar1 + *(char *)(in_at + 0x5d);
      }
      *(char *)(in_at + 0x59) = cVar9;
      *(char *)(in_at + 0x5d) = cVar11;
      uVar10 = *(uint *)(in_at + 0x58);
      uVar12 = *(uint *)(in_at + 0x5c);
      iVar6 = *(int *)(in_at + 0x20);
    }
    setCopReg(2,0,((uVar10 & in_t4) + (uVar12 & in_t4) + *(int *)(in_at + 0x30)) * 2 & in_t5);
    setCopReg(2,0x800,((uVar10 & 0xff00) + (uVar12 & 0xff00) >> 7) + *(int *)(in_at + 0x34));
    copFunction(2,0x4a6012);
    uVar5 = getCopReg(2,0x5800);
    iVar8 = getCopReg(2,0x5000);
    uVar10 = getCopReg(2,0x4800);
    *(uint *)(iVar6 + 0x140) = iVar8 << 0x10 | uVar10 & 0xffff;
    *(undefined4 *)(iVar6 + 0x144) = uVar5;
  }
  if (-1 < (int)(in_t3 << 4)) {
    return;
  }
  return;
}

void FUN_8006d5b8(void)

{
  int in_at;
  uint in_t0;
  uint uVar1;
  code *UNRECOVERED_JUMPTABLE;

  if (-1 < (int)(in_t0 ^ (int)*(char *)(in_at + 0x48))) {
    
	uVar1 = gte_stSXY0();
    gte_ldSXY0(uVar1 & 0xffff0000 | (uVar1 & 0xffff) + 3 & 0xffff);
	
    uVar1 = gte_stSXY1();
    gte_ldSXY1(uVar1 & 0xffff0000 | (uVar1 & 0xffff) + 3 & 0xffff);
	
    uVar1 = gte_stSXY2();
    gte_ldSXY2(uVar1 & 0xffff0000 | (uVar1 & 0xffff) + 3 & 0xffff);
  }

  // JR $s5
}

// several hand-written asm functions in this range

// RenderBucket_DrawInstPrim_Ghost
// called directly by instance->0x60
u_long * FUN_8006d670(void)

{
  int in_at;
  u_long *in_v0;
  u_long *puVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  u_long uVar5;
  uint uVar6;
  u_long uVar7;
  uint *puVar8;
  undefined4 in_t6;
  undefined4 in_t7;
  undefined4 unaff_s0;

  puVar8 = (uint *)((*(uint *)(in_at + 0x2c) >> 0x11) * 4 + *(int *)(in_at + 0x38));
  puVar1 = *(u_long **)(in_at + 0x50);

  // load colors
  gte_ldRGB0(in_t6);
  gte_ldRGB1(in_t7);
  gte_ldRGB2(unaff_s0);

  // set transparency
  // 0xA00 for some (if not all) ghosts
  gte_ldIR0(*(int *)(in_at + 0x120));

  // if no transparency
  if (*(int *)(in_at + 0x120) == 0)
  {
    uVar3 = 0x30000000;

	// if no texture data,
	// draw prim without texture
    if (puVar1 == (u_long *)0x0) {
      gte_stsxy3_g3(in_v0);
      uVar2 = gte_stRGB0();

	  // prim size
	  iVar4 = 0x1c;

	  in_v0[1] = uVar3 | uVar2;
      gte_stRGB1();
      gte_stRGB2();
      uVar3 = 0x6000000;
    }

	// if texture data,
	// draw prim with texture
    else {
      uVar7 = *puVar1;
      uVar2 = puVar1[1];
      uVar5 = puVar1[2];
      gte_stsxy3_gt3(in_v0);
      in_v0[3] = uVar7;
      in_v0[6] = uVar2;
      in_v0[9] = uVar5;
      uVar6 = gte_stRGB0();
      uVar3 = 0x34000000;
      if ((uVar2 & 0x600000) != 0x600000) {
        uVar3 = 0x36000000;
      }
      in_v0[1] = uVar3 | uVar6;
      gte_stRGB1();
      gte_stRGB2();

	  // prim size
	  iVar4 = 0x28;

      uVar3 = 0x9000000;
    }

	// write PrimMem and OTMem
    *in_v0 = *puVar8 | uVar3;
    *puVar8 = (uint)in_v0 & 0xffffff;

	return (u_long *)((int)in_v0 + iVar4);
  }

  // if transparency

  gte_dpct_b();
  in_v0[1] = 0xe1000a40;
  in_v0[2] = 0;
  gte_stSXY0();
  gte_stSXY1();
  in_v0[3] = *(u_long *)(in_at + 0x124);
  gte_stSXY2();

  // if texture data,
  // draw prim with texture
  if (puVar1 != (u_long *)0x0) {
    uVar3 = puVar1[1];
    uVar7 = puVar1[2];
    gte_stSXY0();
    gte_stSXY1();
    gte_stSXY2();
    in_v0[9] = *puVar1;
    in_v0[0xc] = uVar3 & 0xff9fffff | 0x200000;
    in_v0[0xf] = uVar7;
    uVar3 = gte_stRGB0();
    in_v0[7] = uVar3 | 0x36000000;
    gte_stRGB1();
    gte_stRGB2();

    // PrimMem and OTMem
    *in_v0 = *puVar8 | 0xf000000;
    *puVar8 = (uint)in_v0 & 0xffffff;

	return in_v0 + 0x10;
  }

  // draw prim without texture

  in_v0[7] = 0xe1000a20;
  in_v0[8] = 0;
  uVar3 = gte_stRGB0();
  in_v0[9] = uVar3 | 0x32000000;
  gte_stSXY0();
  gte_stRGB1();
  gte_stSXY1();
  gte_stRGB2();
  gte_stSXY2();

  // PrimMem and OTMem
  *in_v0 = *puVar8 | 0xe000000;
  *puVar8 = (uint)in_v0 & 0xffffff;

  return in_v0 + 0xf;
}


// animates water, 1P mode
// param_1 is frame timer (gGT->1cec)
// param_2 is lev->water_count
// param_3 is lev->water_ptr
void FUN_8006d79c(uint param_1,int param_2)

{
  bool bVar1;
  int iVar2;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  undefined4 unaff_s7;
  undefined4 unaff_retaddr;

  gte_ldIR0((param_1 & 7) << 9);
  iVar2 = 0x20;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800028 = unaff_retaddr;

  // iVar2 is not a loop counter,
  // it assigns each water vertex
  // a number [0 to 0x1f]

  // loop for all lev->water_count
  while (bVar1 = param_2 != 0, param_2 = param_2 + -1, bVar1)
  {
    bVar1 = iVar2 == 0;
    iVar2 = iVar2 + -1;
    if (bVar1) {
      iVar2 = 0x1f;
    }

	// AnimateWaterVertex
    FUN_8006db7c(param_1, param_2, param_3, param_4);
  }
  return;
}


// animates water, 2P mode
// param_1 is frame timer (gGT->1cec)
// param_2 is lev->water_count
// param_3 is lev->water_ptr
void FUN_8006d864(uint param_1,int param_2)

{
  bool bVar1;
  int iVar2;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  undefined4 unaff_s7;
  undefined4 unaff_retaddr;

  gte_ldIR0((param_1 & 7) << 9);
  iVar2 = 0x20;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800028 = unaff_retaddr;

  // iVar2 is not a loop counter,
  // it assigns each water vertex
  // a number [0 to 0x1f]

  // loop for all lev->water_count
  while (bVar1 = param_2 != 0, param_2 = param_2 + -1, bVar1) {
    bVar1 = iVar2 == 0;
    iVar2 = iVar2 + -1;
    if (bVar1) {
      iVar2 = 0x1f;
    }

	// AnimateWaterVertex
    FUN_8006db7c(param_1, param_2, param_3, param_4);
  }
  return;
}


// animates water, 3P mode
// param_1 is frame timer (gGT->1cec)
// param_2 is lev->water_count
// param_3 is lev->water_ptr
void FUN_8006d948(uint param_1,int param_2)

{
  bool bVar1;
  int iVar2;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  undefined4 unaff_s7;
  undefined4 unaff_retaddr;

  DAT_1f800020 = &_gp_4;
  gte_ldIR0((param_1 & 7) << 9);
  iVar2 = 0x20;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800028 = unaff_retaddr;

  // iVar2 is not a loop counter,
  // it assigns each water vertex
  // a number [0 to 0x1f]

  // loop for all lev->water_count
  while (bVar1 = param_2 != 0, param_2 = param_2 + -1, bVar1) {
    bVar1 = iVar2 == 0;
    iVar2 = iVar2 + -1;
    if (bVar1) {
      iVar2 = 0x1f;
    }

	// AnimateWaterVertex
    FUN_8006db7c(param_1, param_2, param_3, param_4);
  }
  return;
}


// animates water, 4P mode
// param_1 is frame timer (gGT->1cec)
// param_2 is lev->water_count
// param_3 is lev->water_ptr
void FUN_8006da50(uint param_1,int param_2)

{
  bool bVar1;
  int iVar2;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  undefined4 unaff_s7;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];
  undefined4 param_8;

  DAT_1f800020 = &_gp_4;
  gte_ldIR0((param_1 & 7) << 9);
  iVar2 = 0x20;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800024 = (undefined *)register0x00000074;
  DAT_1f800028 = unaff_retaddr;

  // iVar2 is not a loop counter,
  // it assigns each water vertex
  // a number [0 to 0x1f]

  // loop for all lev->water_count
  while (bVar1 = param_2 != 0, param_2 = param_2 + -1, bVar1) {
    bVar1 = iVar2 == 0;
    iVar2 = iVar2 + -1;
    if (bVar1) {
      iVar2 = 0x1f;
    }

	// AnimateWaterVertex
    FUN_8006db7c(param_1, param_2, param_3, param_4);
  }
  return;
}


// AnimateWaterVertex
void FUN_8006db7c(undefined4 param_1,undefined4 param_2,int *param_3,short param_4)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  int in_t3;
  int in_t4;
  uint in_t5;
  int iVar4;

  if ((in_t5 & 1) != 0) {
    /*
    some details missing but the gist of it:
    water data in .lev is an animated lookup table, it's a 28 long 16-bit array which is interpolated
     a = ( water_color_data & 0x003f)
     b = ( (water_color_data & 0x0fc0) >> 6 )
     c = ( (water_color_data & 0xf000) >> 12 )
     color components c one is used twice?


     new Color( b, b, max(b,a), 1f-c ) seems to result in correct looking pattern but this needs verification.

     the different player modes use less detail.
    */
	
	// WaterVert -> LevVert
    iVar4 = *param_3;
	
	// OVert data is in pairs of two,
	// so this is aligned to 4 bytes
	
	// OVert 1
	// t3 = 0
    uVar1 = (uint)*(ushort *)(param_3[1] + in_t3);
	
	// OVert 2
	// t4 = 2
    uVar3 = (uint)*(ushort *)(param_3[1] + in_t4);
	
	// OVert 1
    uVar2 = (uVar1 & 0xf000) << 8;
    gte_ldRGB(uVar1 & 0x3f | (uVar1 & 0xfc0) << 2 | uVar2 | uVar2 >> 4);
    
	// OVert 2
	gte_ldRFC((uVar3 & 0x3f) << 4);
    gte_ldGFC((uVar3 & 0xfc0) >> 2);
    gte_ldBFC((uVar3 & 0xf000) >> 4 | (uVar3 & 0xf000) >> 8);

	// DPCS - Depth Cueing (single)
	gte_dpcs();

	uVar1 = gte_stRGB2();
	
	// LevVert color_low
    *(short *)(iVar4 + 0xc) = (short)uVar1 + param_4;
    
	// LevVert color_hi
	uVar1 = uVar1 >> 0x10 & 0xff;
    *(uint *)(iVar4 + 8) = (uVar1 << 8 | uVar1) << 8 | uVar1;
    
	return;
  }
  return;
}




// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// RedBeaker_RenderRain
// param1 - tileView
// param2 - primMem
// param3 - rainPool
// param4 - numPlyrCurrGame
// param5 - check if game is paused
void FUN_8006dc30(int param_1,int param_2,int param_3,int param_4,int param_5)

{
  bool bVar1;
  uint uVar2;
  uint *puVar3;
  uint uVar4;
  int *piVar5;
  int iVar6;
  uint uVar7;
  char cVar8;
  char cVar9;
  uint uVar10;
  int iVar11;
  int iVar12;
  uint *puVar13;
  int iVar14;
  int iVar15;
  undefined4 unaff_s0;
  uint uVar16;
  undefined4 unaff_s1;
  uint uVar17;
  undefined4 unaff_s2;
  int iVar18;
  undefined4 unaff_s3;
  int iVar19;
  undefined4 unaff_s4;
  int iVar20;
  undefined4 unaff_s5;
  uint uVar21;
  undefined4 unaff_s6;
  int iVar22;
  undefined4 unaff_s7;
  uint uVar23;
  int iVar24;
  uint uVar25;
  uint uVar26;
  uint uVar27;
  uint uVar28;
  undefined4 unaff_s8;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];

  // backup $gp
  DAT_1f800020 = &DAT_8008cf6c;

  puVar3 = *(uint **)(param_2 + 0xc);
  DAT_1f800038 = *(int *)(param_3 + 0xc);
  param_4 = param_4 + -1;
  iVar18 = 0;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800024 = (undefined *)register0x00000074;
  DAT_1f800028 = unaff_s8;
  DAT_1f80002c = unaff_retaddr;
  if (DAT_1f800038 != 0) {
    DAT_1f800048 = 0;
    DAT_1f80004c = 0;
    DAT_1f800030 = 0x2000080;
    do 
	{
	  // tileView ViewProj
      gte_ldR11R12(*(undefined4 *)(param_1 + 0x28));
      gte_ldR13R21(*(undefined4 *)(param_1 + 0x2c));
      gte_ldR22R23(*(undefined4 *)(param_1 + 0x30));
      gte_ldR31R32(*(undefined4 *)(param_1 + 0x34));
      gte_ldR33(*(undefined4 *)(param_1 + 0x38));
	  
      iVar14 = *(int *)(param_1 + 0x20);
	  
	  // ptrOT
      DAT_1f800034 = *(int *)(param_1 + 0xf4);
	  
	  // window parameters
      gte_ldOFX((int)*(short *)(param_1 + 0x20) << 0xf);
      gte_ldOFY((int)*(short *)(param_1 + 0x22) << 0xf);
      gte_ldH(*(undefined4 *)(param_1 + 0x18));
	  
      for (piVar5 = (int *)DAT_1f800038; piVar5 != (int *)0x0; piVar5 = (int *)*piVar5) {
        iVar15 = piVar5[2];
        iVar19 = piVar5[3];
        if (piVar5[9] != 0) {
          iVar20 = (int)*(short *)(piVar5 + 4);
          iVar24 = (int)*(short *)(piVar5 + 6);
          uVar23 = piVar5[5] & 0xfffeffff;
          iVar22 = iVar20 + iVar24;
          uVar21 = iVar19 + uVar23 & 0xfffeffff;
          if (param_5 == 0) {
            piVar5[3] = uVar21;
            piVar5[4] = iVar22;
          }
          iVar12 = piVar5[9] + iVar18;
          iVar6 = (int)*(short *)(iVar12 + 0x94);
          gte_ldtr((int)*(short *)(iVar12 + 0x8c),(int)*(short *)(iVar12 + 0x90),iVar6);
          if ((-1 < iVar6) && (iVar6 + -0xc00 < 0)) {
            uVar10 = iVar6 - 0x400U >> 3;
            if ((int)(iVar6 - 0x400U) < 0) {
              uVar10 = 0;
            }
            iVar11 = 0xff - (uVar10 & 0xff);
            cVar8 = (char)iVar11;
            DAT_1f80004c = DAT_1f80004c & 0xff000000 | (uint)CONCAT12(cVar8,CONCAT11(cVar8,cVar8));
            cVar9 = cVar8 - (char)(iVar11 >> 2);
            DAT_1f800048 = CONCAT22(CONCAT11(DAT_1f800048._3_1_,cVar8),CONCAT11(cVar9,cVar9));
            iVar6 = (iVar6 >> 7) + *(char *)(iVar12 + 0x50) + -6;
            iVar12 = iVar6 * 4;
            if (iVar6 < 0) {
              iVar12 = 0;
            }
            if (-1 < iVar12 + -0x1000) {
              iVar12 = 0xffc;
            }
            puVar13 = (uint *)(DAT_1f800034 + iVar12);
            uVar10 = 0x30125400;
            uVar17 = 0x493583fe;
            while( true ) {
              uVar2 = DAT_1f800048;
              uVar4 = uVar17 >> 8;
              uVar17 = uVar10 >> 8 | uVar17 << 0x18;
              uVar7 = (uVar10 + uVar4 + (uVar17 >> 8)) * 0x1000000;
              uVar10 = (uVar4 | uVar7) >> 8;
              uVar4 = uVar17 >> 8 | uVar4 << 0x18;
              uVar25 = (uVar17 + uVar10 + (uVar4 >> 8)) * 0x1000000;
              uVar16 = (uVar10 | uVar25) >> 8;
              uVar10 = uVar4 >> 8 | uVar10 << 0x18;
              uVar27 = (uVar4 + uVar16 + (uVar10 >> 8)) * 0x1000000;
              uVar17 = uVar16 | uVar27;
              bVar1 = iVar15 == 0;
              iVar15 = iVar15 + -1;
              if (bVar1) break;
              uVar7 = (int)uVar7 >> 0x18 & 0xffffU | (int)uVar25 >> 7;
              uVar4 = (uVar7 + iVar19 & 0x1fe00ff) - DAT_1f800030;
              uVar7 = (uVar7 + uVar21 & 0x1fe00ff) - DAT_1f800030;
              if (uVar7 - uVar4 == uVar23) {
                uVar7 = uVar7 & 0xfffeffff;
                gte_ldVXY0(uVar4 & 0xfffeffff);
                gte_ldVXY1(uVar7);
                gte_ldVXY2(uVar7);
                iVar6 = (int)uVar27 >> 0x17;
                uVar4 = iVar6 + iVar20 & 0xff;
                uVar7 = iVar6 + iVar22 & 0xff;
                if (uVar7 - uVar4 == iVar24) {
                  iVar6 = uVar7 - 0x80;
                  gte_ldVZ0(uVar4 - 0x80);
                  gte_ldVZ1(iVar6);
                  gte_ldVZ2(iVar6);
                  uVar17 = uVar17 >> 8;
                  gte_rtpt_b();
                  uVar4 = uVar10 >> 8 | uVar16 << 0x18;
                  uVar10 = (uVar17 | (uVar10 + uVar17 + (uVar4 >> 8)) * 0x1000000) >> 8;
                  uVar16 = uVar4 >> 8 | uVar17 << 0x18;
                  uVar17 = (uVar10 | (uVar4 + uVar10 + (uVar16 >> 8)) * 0x1000000) >> 8;
                  uVar10 = uVar16 >> 8 | uVar10 << 0x18;
                  uVar17 = uVar17 | (uVar16 + uVar17 + (uVar10 >> 8)) * 0x1000000;
                  uVar4 = gte_stSXY0();
                  iVar6 = gte_stFLAG();
                  uVar16 = gte_stSXY1();
                  if (((-1 < iVar6 << 0xe) &&
                      (uVar4 = ~(uVar4 - iVar14 | uVar16 - iVar14) | uVar4 & uVar16, -1 < (int)uVar4
                      )) && (-1 < (int)(uVar4 << 0x10))) {
                    puVar3[1] = 0x52000000;
                    puVar3[3] = uVar2;
                    *puVar3 = *puVar13 | 0x4000000;
                    gte_stSXY0();
                    gte_stSXY1();
                    *puVar13 = (uint)puVar3 & 0xffffff;
                    puVar3 = puVar3 + 5;
                  }
                }
              }
            }
            iVar15 = piVar5[2];
            puVar3[1] = 0xe1000a20;
            puVar3[2] = 0;
            *puVar3 = *puVar13 | 0x2000000;
            *puVar13 = (uint)puVar3 & 0xffffff;
            puVar3 = puVar3 + 3;
            uVar10 = 0x30125400;
            uVar17 = 0x493583fe;
            while( true ) {
              uVar2 = DAT_1f80004c;
              uVar4 = uVar17 >> 8;
              uVar17 = uVar10 >> 8 | uVar17 << 0x18;
              uVar7 = (uVar10 + uVar4 + (uVar17 >> 8)) * 0x1000000;
              uVar10 = (uVar4 | uVar7) >> 8;
              uVar4 = uVar17 >> 8 | uVar4 << 0x18;
              uVar26 = (uVar17 + uVar10 + (uVar4 >> 8)) * 0x1000000;
              uVar16 = (uVar10 | uVar26) >> 8;
              uVar10 = uVar4 >> 8 | uVar10 << 0x18;
              uVar28 = (uVar4 + uVar16 + (uVar10 >> 8)) * 0x1000000;
              uVar17 = uVar16 | uVar28;
              bVar1 = iVar15 == 0;
              iVar15 = iVar15 + -1;
              if (bVar1) break;
              uVar7 = (int)uVar7 >> 0x18 & 0xffffU | (int)uVar26 >> 7;
              uVar4 = (uVar7 + iVar19 & 0x1fe00ff) - DAT_1f800030;
              uVar7 = (uVar7 + uVar21 & 0x1fe00ff) - DAT_1f800030;
              if (uVar7 - uVar4 == uVar23) {
                uVar7 = uVar7 & 0xfffeffff;
                gte_ldVXY0(uVar4 & 0xfffeffff);
                gte_ldVXY1(uVar7);
                gte_ldVXY2(uVar7);
                iVar6 = (int)uVar28 >> 0x17;
                uVar4 = iVar6 + iVar20 & 0xff;
                uVar7 = iVar6 + iVar22 & 0xff;
                if (uVar7 - uVar4 == iVar24) {
                  iVar6 = uVar7 - 0x80;
                  gte_ldVZ0(uVar4 - 0x80);
                  gte_ldVZ1(iVar6);
                  gte_ldVZ2(iVar6);
                  uVar17 = uVar17 >> 8;
                  gte_rtpt_b();
                  uVar4 = uVar10 >> 8 | uVar16 << 0x18;
                  uVar10 = (uVar17 | (uVar10 + uVar17 + (uVar4 >> 8)) * 0x1000000) >> 8;
                  uVar16 = uVar4 >> 8 | uVar17 << 0x18;
                  uVar17 = (uVar10 | (uVar4 + uVar10 + (uVar16 >> 8)) * 0x1000000) >> 8;
                  uVar10 = uVar16 >> 8 | uVar10 << 0x18;
                  uVar17 = uVar17 | (uVar16 + uVar17 + (uVar10 >> 8)) * 0x1000000;
                  uVar4 = gte_stSXY0();
                  iVar6 = gte_stFLAG();
                  uVar16 = gte_stSXY1();
                  if (((-1 < iVar6 << 0xe) &&
                      (uVar4 = ~(uVar4 - iVar14 | uVar16 - iVar14) | uVar4 & uVar16, -1 < (int)uVar4
                      )) && (-1 < (int)(uVar4 << 0x10))) {
                    puVar3[1] = 0x52000000;
                    puVar3[3] = uVar2;
                    *puVar3 = *puVar13 | 0x4000000;
                    gte_stSXY0();
                    gte_stSXY1();
                    *puVar13 = (uint)puVar3 & 0xffffff;
                    puVar3 = puVar3 + 5;
                  }
                }
              }
            }
            puVar3[1] = 0xe1000a40;
            puVar3[2] = 0;
            *puVar3 = *puVar13 | 0x2000000;
            *puVar13 = (uint)puVar3 & 0xffffff;
            puVar3 = puVar3 + 3;
          }
        }
      }
      param_1 = param_1 + 0x110;
      iVar18 = iVar18 + 0x88;
      bVar1 = param_4 != 0;
      param_4 = param_4 + -1;
    } while (bVar1);
  }
  *(uint **)(param_2 + 0xc) = puVar3;
  return;
}


//apparently this function renders stars in various levels, i.e. cutsenes, nd box, oxide station.
//https://media.discordapp.net/attachments/637616020177289236/823950457101221988/unknown.png

// param1 - tileView
// param2 - PrimMem
// param3 - numStars
// param4 - numPlyrCurrGame
void FUN_8006e26c(int param_1,int param_2,ushort *param_3,int param_4)

{
  bool bVar1;
  ushort uVar2;
  ushort uVar3;
  uint *puVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  uint *puVar12;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  uint uVar13;
  undefined4 unaff_s7;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  undefined4 unaff_s8;
  undefined4 unaff_retaddr;
  int iVar19;
  undefined auStackX0 [16];

  // backup $gp
  DAT_1f800020 = &DAT_8008cf6c;

  gte_ldtr(0,0,0);
  param_4 = param_4 + -1;

  // new PrimMem curr
  puVar4 = *(uint **)(param_2 + 0xc);

  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800024 = (undefined *)register0x00000074;
  DAT_1f800028 = unaff_s8;
  DAT_1f80002c = unaff_retaddr;
  do
  {
	// tileView matrix 0x28
    gte_ldR11R12(*(undefined4 *)(param_1 + 0x28));
    gte_ldR13R21(*(undefined4 *)(param_1 + 0x2c));
    gte_ldR22R23(*(undefined4 *)(param_1 + 0x30));
    gte_ldR31R32(*(undefined4 *)(param_1 + 0x34));
    gte_ldR33(*(undefined4 *)(param_1 + 0x38));

	// window size X and Y
    gte_ldOFX((int)*(short *)(param_1 + 0x20) << 0xf);
    gte_ldOFY((int)*(short *)(param_1 + 0x22) << 0xf);

	// distance to screen
    gte_ldH(*(undefined4 *)(param_1 + 0x18));

    gte_ldtr(0,0,0);

	// number of stars
    uVar13 = (uint)*param_3;

	// ???
	uVar2 = param_3[1];

	// ???
    uVar3 = param_3[2];

	// tileView ptrOT + offset?
    puVar12 = (uint *)(*(int *)(param_1 + 0xf4) + (uint)param_3[3] * 4);

	// RNG seed,
	// produces different random numbers for each iteration
	// of the loop, but will generate same random numbers each frame,
	// putting stars in the same place each frame
    uVar14 = 0x30125400;
    uVar16 = 0x493583fe;

	// loop for every star
    while (bVar1 = -1 < (int)uVar13, uVar13 = uVar13 - 1, bVar1)
	{
      uVar5 = uVar14 + (uVar16 >> 8);
      uVar15 = uVar14 >> 8 | uVar5;
      uVar14 = (uVar5 + (uVar15 >> 8)) * 0x1000000;
      uVar17 = (uVar16 >> 8 | uVar14) >> 8;
      uVar5 = uVar15 >> 8 | uVar14;
      uVar16 = (uVar15 + uVar17 + (uVar5 >> 8)) * 0x1000000;
      uVar17 = (uVar17 | uVar16) >> 8;
      uVar15 = uVar5 >> 8 | uVar14;
      uVar5 = (uVar5 + uVar17 + (uVar15 >> 8)) * 0x1000000;
      iVar6 = (int)uVar14 >> 0x14;
      iVar7 = (int)uVar16 >> (uVar3 + 0x14 & 0x1f);
      iVar8 = (int)uVar5 >> 0x14;
      iVar19 = iVar6;
      if (iVar6 < 0) {
        iVar19 = -iVar6;
      }
      iVar10 = iVar7;
      if ((iVar7 < 0) && (iVar10 = -iVar7, uVar2 == 0)) {
        iVar7 = iVar10;
      }
      iVar11 = iVar8;
      if (iVar8 < 0) {
        iVar11 = -iVar8;
      }
      iVar9 = iVar19;
      if (iVar19 - iVar10 < 1) {
        iVar9 = iVar10;
        iVar10 = iVar19;
      }
      iVar19 = iVar9;
      if (iVar9 - iVar11 < 1) {
        iVar19 = iVar11;
        iVar11 = iVar9;
      }
      iVar19 = 0x1000000 / (iVar19 + (iVar10 >> 2) + (iVar11 >> 2));
      uVar14 = iVar6 * iVar19 >> 0xc & 0xffffU | (iVar7 * iVar19 >> 0xc) << 0x10;
      gte_ldVXY0(uVar14);
      gte_ldVZ0(iVar8 * iVar19 >> 0xc);
      uVar5 = (uVar17 | uVar5) >> 8;
      uVar14 = uVar15 >> 8 | uVar14;
      uVar16 = uVar5 | (uVar15 + uVar5 + (uVar14 >> 8)) * 0x1000000;
      gte_rtps_b();
      uVar18 = uVar15 + uVar5 + (uVar14 >> 8) & 0xff | 0x40;
      iVar19 = gte_stFLAG();
      uVar5 = gte_stSXY2();

      if (
			((-1 < iVar19 << 0xd) && (uVar15 = uVar5 - 0xd90200 | uVar5, (int)uVar15 < 0)) &&
			(-1 < (int)(~uVar15 << 0x10))
		 )
	  {
		// write Pimitive
        uVar15 = *puVar12;
        puVar4[1] = uVar18 | uVar18 << 8 | uVar18 << 0x10 | 0x68000000;
        *puVar4 = uVar15 | 0x2000000;
        puVar4[2] = uVar5;
        *puVar12 = (uint)puVar4 & 0xffffff;

		// advance to next primitive
		puVar4 = puVar4 + 3;
      }
    }

	// write Pimitive
    puVar4[1] = 0xe1000a20;
    puVar4[2] = 0;
    *puVar4 = *puVar12 | 0x2000000;
    *puVar12 = (uint)puVar4 & 0xffffff;

	// advance to next primitive
    puVar4 = puVar4 + 3;

	// next tileView
    param_1 = param_1 + 0x110;

	// next player
    bVar1 = param_4 != 0;
    param_4 = param_4 + -1;

  } while (bVar1);

  // new PrimMem curr
  *(uint **)(param_2 + 0xc) = puVar4;

  return;
}


// draw normal tires (not reflected)
// param1 - first thread
// param2 - PrimMem
// param3 - numPlyrCurrGame
void FUN_8006e588(int param_1,int param_2,int param_3)

{
  bool bVar1;
  short sVar2;
  int iVar3;
  int iVar4;
  char *pcVar5;
  short *psVar6;
  int iVar7;
  undefined **ppuVar8;
  uint uVar9;
  int iVar10;
  code *UNRECOVERED_JUMPTABLE;
  short sVar11;
  undefined2 uVar12;
  undefined4 *puVar13;
  int iVar14;
  undefined4 uVar15;
  int iVar16;
  undefined *puVar17;
  int iVar18;
  uint uVar19;
  uint uVar20;
  int iVar21;
  int iVar22;
  int iVar23;
  int iVar24;
  undefined4 unaff_s0;
  undefined4 uVar25;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  uint unaff_s6;
  undefined4 unaff_s7;
  int iVar26;
  int iVar27;
  undefined4 *puVar28;
  undefined4 unaff_s8;
  int iVar29;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];

  iVar3 = 0x1f800000;

  // backup $gp
  DAT_1f800020 = &DAT_8008cf6c;

  // if 3P or 4P
  DAT_1f800054 = 0;
  if (param_3 + -2 < 1)
  {
	// if 1P or 2P
    DAT_1f800054 = 2;
  }

  // loop 8 times
  iVar4 = 7;

  // tire jmp pointers
  ppuVar8 = &PTR_LAB_8008a344;

  puVar13 = &DAT_1f800130;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800024 = (undefined *)register0x00000074;
  DAT_1f800028 = unaff_s8;
  DAT_1f80002c = unaff_retaddr;

  // store number of players
  DAT_1f800030 = param_3;

  // loop 8 times
  do {
    puVar17 = *ppuVar8;
    ppuVar8 = ppuVar8 + 1;
    *puVar13 = puVar17;
    puVar13 = puVar13 + 1;
    bVar1 = iVar4 != 0;
    iVar4 = iVar4 + -1;
  } while (bVar1);

  // PrimMem data
  iVar4 = *(int *)(param_2 + 0xc);
  uVar25 = *(undefined4 *)(param_2 + 0x14);

  // loop through all threads (player or robotcar)
  do
  {
	// get instance from thread
    iVar7 = *(int *)(param_1 + 0x34);

	// get object from thread
    puVar28 = *(undefined4 **)(param_1 + 0x30);

	// vertical line for split or reflection
    uVar12 = *(undefined2 *)(iVar7 + 0x56);

	// numPlyrCurrGame to render tires on
    *(undefined4 *)(iVar3 + 0x34) = *(undefined4 *)(iVar3 + 0x30);

	// vertical line for split or reflection
    *(undefined2 *)(iVar3 + 0x4c) = uVar12;

	// store instance
    iVar29 = iVar7;

	// loop through all cameras
	// that tires need to render on
    do
	{
      sVar2 = *(short *)(iVar29 + 0xde);
      *(short *)(iVar3 + 0x16c) = (short)((int)*(short *)(iVar29 + 0xdc) << 2);
      *(short *)(iVar3 + 0x16e) = (short)((int)sVar2 << 2);

	  // instance flags, duplicate of 0x28
      uVar9 = *(uint *)(iVar29 + 0xb8);

	  // model LOD index
      iVar14 = *(int *)(iVar29 + 0xd8);

      *(uint *)(iVar3 + 0x160) = uVar9;

      if (
			(
				((uVar9 & 0x40) != 0) &&

				// if instance is not invisible
				((uVar9 & 0x80) == 0)
			) &&

			// if tires shouldn't disappear on this model LOD
			(iVar14 - *(int *)(iVar3 + 0x54) < 1)
		  )
      {
		// tire color
        uVar15 = 0x2e808080;

        if ((uVar9 & 0x100) == 0)
		{
		  // driver->tireColor
          uVar15 = puVar28[2];
        }

		// driver ptr, thread -> object
        *(undefined4 *)(iVar3 + 0x38) = *puVar28;

		// tire color
		*(undefined4 *)(iVar3 + 0x3c) = uVar15;

		// instance -> tileView
        psVar6 = *(short **)(iVar29 + 0x74);

		// if tileView exists
        if (psVar6 != (short *)0x0)
		{
		  // instance scale
          sVar2 = *(short *)(iVar7 + 0x1e);
          iVar4 = *(short *)(iVar7 + 0x1c) * 0x90 >> 0xc;

          sVar11 = (short)iVar4;
          *(short *)(iVar3 + 0x58) = sVar11;
          *(short *)(iVar3 + 0x78) = sVar11;
          iVar4 = -iVar4;
          uVar12 = (undefined2)iVar4;
          *(undefined2 *)(iVar3 + 0x68) = uVar12;
          *(undefined2 *)(iVar3 + 0x88) = uVar12;
          *(short *)(iVar3 + 0x60) = sVar11 + -0x1000;
          *(short *)(iVar3 + 0x80) = sVar11 + -0x1000;
          iVar4 = iVar4 + 0x1000;
          *(short *)(iVar3 + 0x70) = (short)iVar4;
          *(short *)(iVar3 + 0x90) = (short)iVar4;

		  // instance scale
          sVar11 = *(short *)(iVar7 + 0x20);
          uVar12 = (undefined2)(sVar2 * 0x40 >> 0xc);

          *(undefined2 *)(iVar3 + 0x5a) = uVar12;
          *(undefined2 *)(iVar3 + 0x62) = 0;
          *(undefined2 *)(iVar3 + 0x6a) = uVar12;
          *(undefined2 *)(iVar3 + 0x72) = 0;
          *(undefined2 *)(iVar3 + 0x7a) = uVar12;
          *(undefined2 *)(iVar3 + 0x82) = 0;
          *(undefined2 *)(iVar3 + 0x8a) = uVar12;
          *(undefined2 *)(iVar3 + 0x92) = 0;
          iVar14 = sVar11 * 199 >> 0xc;
          *(int *)(iVar3 + 0x5c) = iVar14;
          *(int *)(iVar3 + 0x6c) = iVar14;
          iVar14 = sVar11 * -0x60 >> 0xc;
          *(int *)(iVar3 + 0x7c) = iVar14;
          *(int *)(iVar3 + 0x84) = iVar14;
          *(int *)(iVar3 + 0x8c) = iVar14;
          *(int *)(iVar3 + 0x94) = iVar14;
          iVar14 = *(int *)(iVar29 + 0xe8);
          sVar2 = *(short *)(puVar28 + 1);
          *(undefined4 *)(iVar3 + 0x40) = *(undefined4 *)(iVar29 + 0xe4);
          *(int *)(iVar3 + 0x44) = iVar14;
          *(int *)(iVar3 + 0x48) = (int)sVar2;

		  // TRIG_AngleSinCos_r9r8r10
		  FUN_8006ef30();

		  *(short *)(iVar3 + 0x60) = *(short *)(iVar3 + 0x58) - (short)iVar4;
          *(int *)(iVar3 + 100) = *(int *)(iVar3 + 0x5c) + iVar14;
          sVar2 = *(short *)((int)puVar28 + 0xe);
          *(short *)(iVar3 + 0x70) = *(short *)(iVar3 + 0x68) + (short)iVar4;
          *(int *)(iVar3 + 0x74) = *(int *)(iVar3 + 0x6c) - iVar14;
          uVar9 = (int)sVar2 & 1;
          uVar20 = 9;
          if (uVar9 != 0) {
            uVar20 = 6;
          }

		  // TRIG_AngleSinCos_r9r8r10
          FUN_8006ef30();

		  iVar4 = iVar4 >> (uVar20 & 0x1f);
          iVar14 = (int)uVar9 >> (uVar20 & 0x1f);
          *(short *)(iVar3 + 0x62) = *(short *)(iVar3 + 0x62) + (short)iVar4;
          *(short *)(iVar3 + 100) = *(short *)(iVar3 + 100) + (short)iVar14;

		  // TRIG_AngleSinCos_r9r8r10
		  FUN_8006ef30();

		  iVar4 = iVar4 >> (uVar20 & 0x1f);
          iVar14 = iVar14 >> (uVar20 & 0x1f);
          *(short *)(iVar3 + 0x82) = *(short *)(iVar3 + 0x82) + (short)iVar4;
          *(short *)(iVar3 + 0x84) = *(short *)(iVar3 + 0x84) + (short)iVar14;

		  // TRIG_AngleSinCos_r9r8r10
		  FUN_8006ef30();

		  iVar4 = iVar4 >> (uVar20 & 0x1f);
          iVar14 = iVar14 >> (uVar20 & 0x1f);
          *(short *)(iVar3 + 0x72) = *(short *)(iVar3 + 0x72) + (short)iVar4;
          *(short *)(iVar3 + 0x74) = *(short *)(iVar3 + 0x74) + (short)iVar14;

		  // TRIG_AngleSinCos_r9r8r10
		  FUN_8006ef30();

		  *(short *)(iVar3 + 0x92) = *(short *)(iVar3 + 0x92) + (short)(iVar4 >> (uVar20 & 0x1f));
          *(short *)(iVar3 + 0x94) = *(short *)(iVar3 + 0x94) + (short)(iVar14 >> (uVar20 & 0x1f));

		  // instance matrix
		  gte_ldLR1LR2(*(undefined4 *)(iVar7 + 0x30));
          gte_ldLR3LG1(*(undefined4 *)(iVar7 + 0x34));
          gte_ldLG2LG3(*(undefined4 *)(iVar7 + 0x38));
          gte_ldLB1LB2(*(undefined4 *)(iVar7 + 0x3c));
          gte_ldLB3(*(undefined4 *)(iVar7 + 0x40));

		  // another matrix in instance?
		  gte_ldL11L12(*(undefined4 *)(iVar29 + 0x98));
          gte_ldL13L21(*(undefined4 *)(iVar29 + 0x9c));
          gte_ldL22L23(*(undefined4 *)(iVar29 + 0xa0));
          gte_ldL31L32(*(undefined4 *)(iVar29 + 0xa4));
          gte_ldL33(*(undefined4 *)(iVar29 + 0xa8));

		  // instance position - camera position
		  iVar14 = (*(int *)(iVar7 + 0x44) - (int)*psVar6) * 4;
          iVar10 = (*(int *)(iVar7 + 0x48) - (int)psVar6[1]) * 4;
          iVar16 = (*(int *)(iVar7 + 0x4c) - (int)psVar6[2]) * 4;
          gte_ldtr(iVar14,iVar10,iVar16);

		  // vertical line split - camera posY
          *(short *)(iVar3 + 0x50) = (*(short *)(iVar3 + 0x4c) - psVar6[1]) * 4;

          iVar26 = iVar3 + 0x30;
          iVar27 = iVar3 + 0x18;
          do {
            gte_ldVXY0(iVar26 + 0x58);
            gte_ldVZ0(iVar26 + 0x5c);
            gte_ldVXY1(iVar26 + 0x60);
            gte_ldVZ1(iVar26 + 100);
            gte_lcv0tr_b();
            iVar4 = gte_stIR1();
            iVar21 = gte_stIR2();
            iVar23 = gte_stIR3();
            gte_sqr0_b(0);
            *(short *)(iVar26 + 0x58) = (short)iVar4;
            *(short *)(iVar26 + 0x5a) = (short)iVar21;
            read_mt(iVar14,iVar10,iVar16);
            FUN_8006ef98();
            iVar18 = 0x10000;
            gte_lcv1_b();
            *(int *)(iVar26 + 0x5c) = iVar23;
            iVar14 = -(0x10000 / unaff_s6);
            uVar15 = gte_stIR1();
            iVar10 = gte_stIR2();
            iVar16 = gte_stIR3();
            *(short *)(iVar27 + 0xb8) = (short)uVar15;
            uVar9 = iVar4 * iVar14 >> 4;
            *(short *)(iVar27 + 0x98) = (short)uVar9;
            *(short *)(iVar27 + 0xba) = (short)iVar10;
            *(int *)(iVar27 + 0xbc) = iVar16;
            iVar4 = iVar23 * iVar14 >> 4;
            uVar9 = uVar9 & 0xffff;
            uVar20 = iVar21 * iVar14 >> 4 & 0xffff;
            gte_ldR11R12(uVar9);
            gte_ldR22R23(uVar20);
            gte_ldR33(iVar4);
            *(short *)(iVar27 + 0x9a) = (short)uVar20;
            *(int *)(iVar27 + 0x9c) = iVar4;
            gte_op12_b();
            read_mt(uVar9,uVar20,iVar4);
            gte_sqr0_b(0);
            read_mt(uVar15,iVar10,iVar16);
            FUN_8006ef98();
            iVar14 = iVar18 / iVar14;
            iVar21 = (int)(uVar9 * iVar14) >> 4;
            gte_ldIR1(iVar21);
            iVar22 = (int)(uVar20 * iVar14) >> 4;
            gte_ldIR2(iVar22);
            iVar24 = iVar4 * iVar14 >> 4;
            gte_ldIR3(iVar24);
            iVar4 = *(int *)(iVar3 + 0x48);
            gte_op12_b();
            iVar21 = iVar21 * iVar4;
            iVar23 = iVar21 >> 0x12;
            *(short *)(iVar27 + 0xd8) = (short)(iVar21 >> 0x12);
            iVar22 = iVar22 * iVar4;
            iVar21 = iVar22 >> 0x12;
            *(short *)(iVar27 + 0xda) = (short)(iVar22 >> 0x12);
            iVar24 = iVar24 * iVar4;
            iVar22 = iVar24 >> 0x12;
            *(short *)(iVar27 + 0xdc) = (short)(iVar24 >> 0x12);
            read_mt(iVar23,iVar21,iVar22);
            gte_sqr0_b(0);
            read_mt(iVar4,iVar10,iVar16);
            iVar4 = FUN_8006ef98();
            unaff_s6 = *(int *)(iVar3 + 0x48) * -(iVar18 / iVar14) >> 0xc;
            *(short *)(iVar27 + 0xf8) = (short)((int)(iVar23 * unaff_s6) >> 10);
            *(short *)(iVar27 + 0xfa) = (short)((int)(iVar21 * unaff_s6) >> 10);
            *(short *)(iVar27 + 0xfc) = (short)((int)(iVar22 * unaff_s6) >> 10);
            iVar26 = iVar26 + -0x10;
            iVar14 = iVar26 - iVar3;
            iVar27 = iVar27 + -8;
          } while (-1 < iVar14);

		  // tileView ViewProj
		  // (multiply by 2, offset 0x28)
          gte_ldR11R12(*(undefined4 *)(psVar6 + 0x14));
          gte_ldR13R21(*(undefined4 *)(psVar6 + 0x16));
          gte_ldR22R23(*(undefined4 *)(psVar6 + 0x18));
          gte_ldR31R32(*(undefined4 *)(psVar6 + 0x1a));
          gte_ldR33(*(undefined4 *)(psVar6 + 0x1c));

		  // no translation, rotation only
          gte_ldtr(0,0,0);

		  // screen dimensions, and distance from screen
		  gte_ldOFX((int)psVar6[0x10] << 0xf);
          gte_ldOFY((int)psVar6[0x11] << 0xf);
          gte_ldH(*(undefined4 *)(psVar6 + 0xc));

          iVar14 = iVar3 + 0x30;
          iVar10 = iVar3 + 0x18;
          uVar9 = iVar3 + 0xc;
          do {
            gte_ldVXY0(((int)*(short *)(iVar14 + 0x58) - (int)*(short *)(iVar10 + 0xd8)) -
                       (int)*(short *)(iVar10 + 0xf8) & 0xffffU |
                       (((int)*(short *)(iVar14 + 0x5a) - (int)*(short *)(iVar10 + 0xda)) -
                       (int)*(short *)(iVar10 + 0xfa)) * 0x10000);
            gte_ldVZ0(((int)*(short *)(iVar14 + 0x5c) - (int)*(short *)(iVar10 + 0xdc)) -
                      (int)*(short *)(iVar10 + 0xfc));
            gte_ldVXY1(((int)*(short *)(iVar14 + 0x58) + (int)*(short *)(iVar10 + 0xd8)) -
                       (int)*(short *)(iVar10 + 0xf8) & 0xffffU |
                       (((int)*(short *)(iVar14 + 0x5a) + (int)*(short *)(iVar10 + 0xda)) -
                       (int)*(short *)(iVar10 + 0xfa)) * 0x10000);
            gte_ldVZ1(((int)*(short *)(iVar14 + 0x5c) + (int)*(short *)(iVar10 + 0xdc)) -
                      (int)*(short *)(iVar10 + 0xfc));
            gte_ldVXY2(((int)*(short *)(iVar14 + 0x58) - (int)*(short *)(iVar10 + 0xd8)) +
                       (int)*(short *)(iVar10 + 0xf8) & 0xffffU |
                       (((int)*(short *)(iVar14 + 0x5a) - (int)*(short *)(iVar10 + 0xda)) +
                       (int)*(short *)(iVar10 + 0xfa)) * 0x10000);
            gte_ldVZ2(((int)*(short *)(iVar14 + 0x5c) - (int)*(short *)(iVar10 + 0xdc)) +
                      (int)*(short *)(iVar10 + 0xfc));
            gte_rtpt_b();
            gte_stSXY0();
            gte_stSXY1();
            gte_stSXY2();
            gte_ldVXY0((int)*(short *)(iVar14 + 0x58) + (int)*(short *)(iVar10 + 0xd8) +
                       (int)*(short *)(iVar10 + 0xf8) & 0xffffU |
                       ((int)*(short *)(iVar14 + 0x5a) + (int)*(short *)(iVar10 + 0xda) +
                       (int)*(short *)(iVar10 + 0xfa)) * 0x10000);
            gte_ldVZ0((int)*(short *)(iVar14 + 0x5c) + (int)*(short *)(iVar10 + 0xdc) +
                      (int)*(short *)(iVar10 + 0xfc));
            uVar15 = *(undefined4 *)(iVar10 + 0xb8);
            gte_rtps_b();

			// poly_ft4->color = tireColor
            *(undefined4 *)(iVar4 + 4) = *(undefined4 *)(iVar3 + 0x3c);

            gte_stSXY2();
            gte_avsz4_b();
            iVar16 = *(int *)(iVar3 + 0x40);
            if (-1 < (int)*(short *)(iVar3 + 0x50) - (int)*(short *)(iVar14 + 0x5a)) {
              iVar16 = *(int *)(iVar3 + 0x44);
            }
            gte_ldVXY0(iVar10 + 0x98);
            gte_ldVZ0(iVar10 + 0x9c);
            gte_ldL11L12(uVar15);
            gte_ldL13L21(*(undefined4 *)(iVar10 + 0xbc));
            gte_llv0_b();
            gte_stMAC0();
            *(int *)(iVar3 + 0x170) = *(short *)(iVar3 + 0x16c) + iVar16;
            *(int *)(iVar3 + 0x174) = *(short *)(iVar3 + 0x16e) + iVar16;
            iVar26 = gte_stIR1();
            iVar16 = iVar26 >> 5;
            if (iVar26 < 0) {
              iVar16 = -iVar16;
            }

			// tire sprite index to render,
			// based on camera rotation
            pcVar5 = &DAT_8008a384 + iVar16;
            if (0 < iVar16 + -0x80) {
              pcVar5 = &DAT_8008a404;
            }

			// iVar3 + 38, is a copy of driver ptr on scratchpad
			// driver->wheelSprites[*pcVar5]
            iVar16 = *(int *)(*pcVar5 * 4 + *(int *)(iVar3 + 0x38));

			// if wheel sprite exists
            if (iVar16 != 0)
			{
              uVar25 = *(undefined4 *)(iVar16 + 0x18);
              uVar19 = *(uint *)(iVar16 + 0x1c);
              *(undefined4 *)(iVar4 + 0xc) = *(undefined4 *)(iVar16 + 0x14);
              uVar20 = gte_stIR1();
              *(undefined4 *)(iVar4 + 0x14) = uVar25;
              *(uint *)(iVar4 + 0x1c) = uVar19;

			  // function pointer from 8008a344
              UNRECOVERED_JUMPTABLE = *(code **)((uVar20 >> 0x1a & 0x10 | uVar9) + 0x130);

              *(uint *)(iVar4 + 0x24) = uVar19 >> 0x10;

			  // execute render function
              (*UNRECOVERED_JUMPTABLE)();
              return;
            }
            iVar14 = iVar14 + -0x10;
            iVar10 = iVar10 + -8;
            uVar9 = uVar9 - 4;
          } while (-1 < iVar14 - iVar3);
        }
      }
      iVar29 = iVar29 + 0x88;

	  // subtract number of players
      iVar14 = *(int *)(iVar3 + 0x34) + -1;
      *(int *)(iVar3 + 0x34) = iVar14;

    } while (0 < iVar14);

	// next thread
    param_1 = *(int *)(param_1 + 0x10);

	// if no threads remain
    if (param_1 == 0)
	{
	  // finalize PrimMem
      *(undefined4 *)(param_2 + 0x14) = uVar25;
      *(int *)(param_2 + 0xc) = iVar4;

	  // quit loop
	  return;
    }

  } while( true );
}


// TRIG_AngleSinCos_r9r8r10
void FUN_8006ef30(void)
{
        8006ef30 08 80 03 3c     lui        v1,0x8008
        8006ef34 a0 45 63 24     addiu      v1,v1,0x45a0
        8006ef38 ff 03 28 31     andi       t0,t1,0x3ff
        8006ef3c 80 40 08 00     sll        t0,t0,0x2
        8006ef40 21 18 68 00     addu       v1,v1,t0
        8006ef44 00 00 68 8c     lw         t0,0x0(v1)=>DAT_800845a0
        8006ef48 00 04 23 31     andi       v1,t1,0x400
        8006ef4c 07 00 60 14     bne        v1,zero,LAB_8006ef6c
        8006ef50 00 08 23 31     _andi      v1,t1,0x800
        8006ef54 03 54 08 00     sra        t2,t0,0x10
        8006ef58 00 44 08 00     sll        t0,t0,0x10
        8006ef5c 09 00 60 14     bne        v1,zero,LAB_8006ef84
        8006ef60 03 44 08 00     _sra       t0,t0,0x10
        8006ef64 08 00 e0 03     jr         ra
        8006ef68 00 00 00 00     _nop
                             LAB_8006ef6c                                    XREF[1]:     8006ef4c(j)
        8006ef6c 00 54 08 00     sll        t2,t0,0x10
        8006ef70 03 54 0a 00     sra        t2,t2,0x10
        8006ef74 06 00 60 14     bne        v1,zero,LAB_8006ef90
        8006ef78 03 44 08 00     _sra       t0,t0,0x10
        8006ef7c 08 00 e0 03     jr         ra
        8006ef80 22 50 0a 00     _sub       t2,zero,t2
                             LAB_8006ef84                                    XREF[1]:     8006ef5c(j)
        8006ef84 22 50 0a 00     sub        t2,zero,t2
        8006ef88 08 00 e0 03     jr         ra
        8006ef8c 22 40 08 00     _sub       t0,zero,t0
                             LAB_8006ef90                                    XREF[1]:     8006ef74(j)
        8006ef90 08 00 e0 03     jr         ra
        8006ef94 22 40 08 00     _sub       t0,zero,t0
}



// WARNING: Instruction at (ram,0x8006eff0) overlaps instruction at (ram,0x8006efec)
//

void FUN_8006ef98(void)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  int unaff_s5;
  uint uVar4;
  int iVar5;

  gte_ldLZCS(unaff_s5);
  iVar5 = 0;
  if (unaff_s5 == 0) {
    return;
  }
  uVar3 = gte_stLZCR();
  uVar1 = 0;
  uVar4 = unaff_s5 << (uVar3 & 0x1e);
  uVar3 = uVar3 & 0x1e ^ 0x1e;
  do {
    if ((int)uVar3 < 0) {
      return;
    }
    while( true ) {
      uVar3 = uVar3 - 2;
      uVar1 = uVar1 | uVar4 >> 0x1e;
      iVar2 = iVar5 * 4;
      iVar5 = iVar5 * 2;
      iVar2 = uVar1 - (iVar2 + 1);
      uVar4 = uVar4 << 2;
      if (-1 < iVar2) break;
      uVar1 = uVar1 << 2;
      if ((int)uVar3 < 0) {
        return;
      }
    }
    iVar5 = iVar5 + 1;
    uVar1 = iVar2 * 4;
  } while( true );
}


// draw reflected tires (reflected on ice)
// param1 - first thread
// param2 - PrimMem
// param3 - numPlyrCurrGame
void FUN_8006f004(int param_1,int param_2,int param_3)

{
  bool bVar1;
  short sVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  char *pcVar6;
  short *psVar7;
  int iVar8;
  undefined **ppuVar9;
  uint uVar10;
  code *UNRECOVERED_JUMPTABLE;
  short sVar11;
  undefined2 uVar12;
  undefined4 *puVar13;
  int iVar14;
  undefined4 uVar15;
  int iVar16;
  undefined *puVar17;
  int iVar18;
  uint uVar19;
  int iVar20;
  uint uVar21;
  int iVar22;
  int iVar23;
  int iVar24;
  undefined4 unaff_s0;
  undefined4 uVar25;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  uint unaff_s6;
  undefined4 unaff_s7;
  int iVar26;
  int iVar27;
  undefined4 *puVar28;
  undefined4 unaff_s8;
  int iVar29;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];

  iVar3 = 0x1f800000;

  // backup $gp
  DAT_1f800020 = &DAT_8008cf6c;

  // if 3P or 4P
  DAT_1f800054 = 0;
  if (param_3 + -2 < 1)
  {
	// if 1P or 2P
    DAT_1f800054 = 2;
  }

  // loop 8 times
  iVar4 = 7;

  // tire (reflect) jmp pointers
  ppuVar9 = &PTR_LAB_8008a364;

  puVar13 = &DAT_1f800130;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800024 = (undefined *)register0x00000074;
  DAT_1f800028 = unaff_s8;
  DAT_1f80002c = unaff_retaddr;

  // store number of players
  DAT_1f800030 = param_3;

  // loop 8 times
  do {
    puVar17 = *ppuVar9;
    ppuVar9 = ppuVar9 + 1;
    *puVar13 = puVar17;
    puVar13 = puVar13 + 1;
    bVar1 = iVar4 != 0;
    iVar4 = iVar4 + -1;
  } while (bVar1);

  // PrimMem data
  iVar4 = *(int *)(param_2 + 0xc);
  uVar25 = *(undefined4 *)(param_2 + 0x14);

  // loop through all threads (player or robotcar)
  do
  {
	// get instance from thread
    iVar8 = *(int *)(param_1 + 0x34);

	// get object from thread
    puVar28 = *(undefined4 **)(param_1 + 0x30);

	// vertical line for split or reflection
    uVar12 = *(undefined2 *)(iVar8 + 0x56);

	// numPlyrCurrGame to render tires on
    *(undefined4 *)(iVar3 + 0x34) = *(undefined4 *)(iVar3 + 0x30);

	// vertical line for split or reflection
    *(undefined2 *)(iVar3 + 0x4c) = uVar12;

	// store instance
    iVar29 = iVar8;

	// loop through all cameras
	// that tires need to render on
    do {
      sVar2 = *(short *)(iVar29 + 0xde);
      *(short *)(iVar3 + 0x16c) = (short)((int)*(short *)(iVar29 + 0xdc) << 2);
      *(short *)(iVar3 + 0x16e) = (short)((int)sVar2 << 2);

	  // instance flags, duplicate of 0x28
      uVar10 = *(uint *)(iVar29 + 0xb8);

	  // model LOD index
      iVar14 = *(int *)(iVar29 + 0xd8);

      *(uint *)(iVar3 + 0x160) = uVar10;

	  if (
			(
				(
					((uVar10 & 0x40) != 0) &&

					((uVar10 & 0x4000) != 0)
				) &&
				(
					// instance -> tileView
					psVar7 = *(short **)(iVar29 + 0x74),

					// if tires shouldn't disappear on this model LOD
					iVar14 - *(int *)(iVar3 + 0x54) < 1
				)
			) &&

			// if tileView exists
			(psVar7 != (short *)0x0)
		 )
	  {
		// tire color
        uVar15 = 0x2e808080;

        if ((uVar10 & 0x100) == 0)
		{
		  // driver->tireColor
          uVar15 = puVar28[2];
        }

		// driver ptr, thread -> object
		*(undefined4 *)(iVar3 + 0x38) = *puVar28;

		// tire color
        *(undefined4 *)(iVar3 + 0x3c) = uVar15;

		// instance scale
        sVar2 = *(short *)(iVar8 + 0x1e);
        iVar4 = (int)((uVar10 & 0x100) * 0x90) >> 0xc;

		sVar11 = (short)iVar4;
        *(short *)(iVar3 + 0x58) = sVar11;
        *(short *)(iVar3 + 0x78) = sVar11;
        iVar4 = -iVar4;
        uVar12 = (undefined2)iVar4;
        *(undefined2 *)(iVar3 + 0x68) = uVar12;
        *(undefined2 *)(iVar3 + 0x88) = uVar12;
        *(short *)(iVar3 + 0x60) = sVar11 + -0x1000;
        *(short *)(iVar3 + 0x80) = sVar11 + -0x1000;
        iVar4 = iVar4 + 0x1000;
        *(short *)(iVar3 + 0x70) = (short)iVar4;
        *(short *)(iVar3 + 0x90) = (short)iVar4;

		// instance scale
        sVar11 = *(short *)(iVar8 + 0x20);
        uVar12 = (undefined2)(sVar2 * 0x40 >> 0xc);

		*(undefined2 *)(iVar3 + 0x5a) = uVar12;
        *(undefined2 *)(iVar3 + 0x62) = 0;
        *(undefined2 *)(iVar3 + 0x6a) = uVar12;
        *(undefined2 *)(iVar3 + 0x72) = 0;
        *(undefined2 *)(iVar3 + 0x7a) = uVar12;
        *(undefined2 *)(iVar3 + 0x82) = 0;
        *(undefined2 *)(iVar3 + 0x8a) = uVar12;
        *(undefined2 *)(iVar3 + 0x92) = 0;
        iVar14 = sVar11 * 199 >> 0xc;
        *(int *)(iVar3 + 0x5c) = iVar14;
        *(int *)(iVar3 + 0x6c) = iVar14;
        iVar14 = sVar11 * -0x60 >> 0xc;
        *(int *)(iVar3 + 0x7c) = iVar14;
        *(int *)(iVar3 + 0x84) = iVar14;
        *(int *)(iVar3 + 0x8c) = iVar14;
        *(int *)(iVar3 + 0x94) = iVar14;
        iVar14 = *(int *)(iVar29 + 0xe8);
        sVar2 = *(short *)(puVar28 + 1);
        *(undefined4 *)(iVar3 + 0x40) = *(undefined4 *)(iVar29 + 0xe4);
        *(int *)(iVar3 + 0x44) = iVar14;
        *(int *)(iVar3 + 0x48) = (int)sVar2;

		// TRIG_AngleSinCos_r9r8r10
        FUN_8006ef30();

        *(short *)(iVar3 + 0x60) = *(short *)(iVar3 + 0x58) - (short)iVar4;
        *(int *)(iVar3 + 100) = *(int *)(iVar3 + 0x5c) + iVar14;
        sVar2 = *(short *)((int)puVar28 + 0xe);
        *(short *)(iVar3 + 0x70) = *(short *)(iVar3 + 0x68) + (short)iVar4;
        *(int *)(iVar3 + 0x74) = *(int *)(iVar3 + 0x6c) - iVar14;
        uVar10 = (int)sVar2 & 1;
        uVar21 = 9;
        if (uVar10 != 0) {
          uVar21 = 6;
        }

		// TRIG_AngleSinCos_r9r8r10
		FUN_8006ef30();

        iVar4 = iVar4 >> (uVar21 & 0x1f);
        iVar14 = (int)uVar10 >> (uVar21 & 0x1f);
        *(short *)(iVar3 + 0x62) = *(short *)(iVar3 + 0x62) + (short)iVar4;
        *(short *)(iVar3 + 100) = *(short *)(iVar3 + 100) + (short)iVar14;

		// TRIG_AngleSinCos_r9r8r10
        FUN_8006ef30();

		iVar4 = iVar4 >> (uVar21 & 0x1f);
        iVar14 = iVar14 >> (uVar21 & 0x1f);
        *(short *)(iVar3 + 0x82) = *(short *)(iVar3 + 0x82) + (short)iVar4;
        *(short *)(iVar3 + 0x84) = *(short *)(iVar3 + 0x84) + (short)iVar14;

		// TRIG_AngleSinCos_r9r8r10
		FUN_8006ef30();

		iVar4 = iVar4 >> (uVar21 & 0x1f);
        iVar14 = iVar14 >> (uVar21 & 0x1f);
        *(short *)(iVar3 + 0x72) = *(short *)(iVar3 + 0x72) + (short)iVar4;
        *(short *)(iVar3 + 0x74) = *(short *)(iVar3 + 0x74) + (short)iVar14;

		// TRIG_AngleSinCos_r9r8r10
		FUN_8006ef30();

		*(short *)(iVar3 + 0x92) = *(short *)(iVar3 + 0x92) + (short)(iVar4 >> (uVar21 & 0x1f));
        *(short *)(iVar3 + 0x94) = *(short *)(iVar3 + 0x94) + (short)(iVar14 >> (uVar21 & 0x1f));

		// instance matrix
		gte_ldLR1LR2(*(undefined4 *)(iVar8 + 0x30));
        gte_ldLR3LG1(*(undefined4 *)(iVar8 + 0x34));
        gte_ldLG2LG3(*(undefined4 *)(iVar8 + 0x38));
        gte_ldLB1LB2(*(undefined4 *)(iVar8 + 0x3c));
        gte_ldLB3(*(undefined4 *)(iVar8 + 0x40));

		// another matrix in instance?
		gte_ldL11L12(*(undefined4 *)(iVar29 + 0x98));
        gte_ldL13L21(*(undefined4 *)(iVar29 + 0x9c));
        gte_ldL22L23(*(undefined4 *)(iVar29 + 0xa0));
        gte_ldL31L32(*(undefined4 *)(iVar29 + 0xa4));
        gte_ldL33(*(undefined4 *)(iVar29 + 0xa8));

		// instance position - camera position
		iVar5 = (*(int *)(iVar8 + 0x44) - (int)*psVar7) * 4;
        iVar14 = (*(int *)(iVar8 + 0x48) - (int)psVar7[1]) * 4;
        iVar16 = (*(int *)(iVar8 + 0x4c) - (int)psVar7[2]) * 4;
        gte_ldtr(iVar5,iVar14,iVar16);

		// vertical line split - camera posY
        *(short *)(iVar3 + 0x50) = (*(short *)(iVar3 + 0x4c) - psVar7[1]) * 4;

		iVar26 = iVar3 + 0x30;
        iVar27 = iVar3 + 0x18;
        do {
          gte_ldVXY0(iVar26 + 0x58);
          gte_ldVZ0(iVar26 + 0x5c);
          gte_ldVXY1(iVar26 + 0x60);
          gte_ldVZ1(iVar26 + 100);
          gte_lcv0tr_b();
          iVar20 = gte_stIR1();
          iVar4 = gte_stIR2();
          iVar23 = gte_stIR3();
          iVar4 = *(short *)(iVar3 + 0x50) * 2 - iVar4;
          gte_sqr0_b(0);
          *(short *)(iVar26 + 0x58) = (short)iVar20;
          *(short *)(iVar26 + 0x5a) = (short)iVar4;
          read_mt(iVar5,iVar14,iVar16);
          FUN_8006ef98();
          iVar18 = 0x10000;
          gte_lcv1_b();
          *(int *)(iVar26 + 0x5c) = iVar23;
          iVar5 = -(0x10000 / unaff_s6);
          uVar15 = gte_stIR1();
          iVar14 = gte_stIR2();
          iVar16 = gte_stIR3();
          iVar14 = -iVar14;
          *(short *)(iVar27 + 0xb8) = (short)uVar15;
          uVar10 = iVar20 * iVar5 >> 4;
          *(short *)(iVar27 + 0x98) = (short)uVar10;
          *(short *)(iVar27 + 0xba) = (short)iVar14;
          *(int *)(iVar27 + 0xbc) = iVar16;
          iVar23 = iVar23 * iVar5 >> 4;
          uVar10 = uVar10 & 0xffff;
          uVar21 = iVar4 * iVar5 >> 4 & 0xffff;
          gte_ldR11R12(uVar10);
          gte_ldR22R23(uVar21);
          gte_ldR33(iVar23);
          *(short *)(iVar27 + 0x9a) = (short)uVar21;
          *(int *)(iVar27 + 0x9c) = iVar23;
          gte_op12_b();
          read_mt(uVar10,uVar21,iVar23);
          gte_sqr0_b(0);
          read_mt(uVar15,iVar14,iVar16);
          FUN_8006ef98();
          iVar5 = iVar18 / iVar5;
          iVar20 = (int)(uVar10 * iVar5) >> 4;
          gte_ldIR1(iVar20);
          iVar22 = (int)(uVar21 * iVar5) >> 4;
          gte_ldIR2(iVar22);
          iVar24 = iVar23 * iVar5 >> 4;
          gte_ldIR3(iVar24);
          iVar4 = *(int *)(iVar3 + 0x48);
          gte_op12_b();
          iVar20 = iVar20 * iVar4;
          iVar23 = iVar20 >> 0x12;
          *(short *)(iVar27 + 0xd8) = (short)(iVar20 >> 0x12);
          iVar22 = iVar22 * iVar4;
          iVar20 = iVar22 >> 0x12;
          *(short *)(iVar27 + 0xda) = (short)(iVar22 >> 0x12);
          iVar24 = iVar24 * iVar4;
          iVar22 = iVar24 >> 0x12;
          *(short *)(iVar27 + 0xdc) = (short)(iVar24 >> 0x12);
          read_mt(iVar23,iVar20,iVar22);
          gte_sqr0_b(0);
          read_mt(iVar4,iVar14,iVar16);
          iVar4 = FUN_8006ef98();
          unaff_s6 = *(int *)(iVar3 + 0x48) * -(iVar18 / iVar5) >> 0xc;
          *(short *)(iVar27 + 0xf8) = (short)((int)(iVar23 * unaff_s6) >> 10);
          *(short *)(iVar27 + 0xfa) = (short)((int)(iVar20 * unaff_s6) >> 10);
          *(short *)(iVar27 + 0xfc) = (short)((int)(iVar22 * unaff_s6) >> 10);
          iVar26 = iVar26 + -0x10;
          iVar5 = iVar26 - iVar3;
          iVar27 = iVar27 + -8;
        } while (-1 < iVar5);

		// tileView ViewProj
		// (multiply by 2, offset 0x28)
        gte_ldR11R12(*(undefined4 *)(psVar7 + 0x14));
        gte_ldR13R21(*(undefined4 *)(psVar7 + 0x16));
        gte_ldR22R23(*(undefined4 *)(psVar7 + 0x18));
        gte_ldR31R32(*(undefined4 *)(psVar7 + 0x1a));
        gte_ldR33(*(undefined4 *)(psVar7 + 0x1c));

		// no translation, rotation only
        gte_ldtr(0,0,0);

		// screen dimensions, and distance from screen
		gte_ldOFX((int)psVar7[0x10] << 0xf);
        gte_ldOFY((int)psVar7[0x11] << 0xf);
        gte_ldH(*(undefined4 *)(psVar7 + 0xc));

        iVar14 = iVar3 + 0x30;
        iVar5 = iVar3 + 0x18;
        uVar10 = iVar3 + 0xc;
        do {
          gte_ldVXY0(((int)*(short *)(iVar14 + 0x58) - (int)*(short *)(iVar5 + 0xd8)) -
                     (int)*(short *)(iVar5 + 0xf8) & 0xffffU |
                     (((int)*(short *)(iVar14 + 0x5a) - (int)*(short *)(iVar5 + 0xda)) -
                     (int)*(short *)(iVar5 + 0xfa)) * 0x10000);
          gte_ldVZ0(((int)*(short *)(iVar14 + 0x5c) - (int)*(short *)(iVar5 + 0xdc)) -
                    (int)*(short *)(iVar5 + 0xfc));
          gte_ldVXY1(((int)*(short *)(iVar14 + 0x58) + (int)*(short *)(iVar5 + 0xd8)) -
                     (int)*(short *)(iVar5 + 0xf8) & 0xffffU |
                     (((int)*(short *)(iVar14 + 0x5a) + (int)*(short *)(iVar5 + 0xda)) -
                     (int)*(short *)(iVar5 + 0xfa)) * 0x10000);
          gte_ldVZ1(((int)*(short *)(iVar14 + 0x5c) + (int)*(short *)(iVar5 + 0xdc)) -
                    (int)*(short *)(iVar5 + 0xfc));
          gte_ldVXY2(((int)*(short *)(iVar14 + 0x58) - (int)*(short *)(iVar5 + 0xd8)) +
                     (int)*(short *)(iVar5 + 0xf8) & 0xffffU |
                     (((int)*(short *)(iVar14 + 0x5a) - (int)*(short *)(iVar5 + 0xda)) +
                     (int)*(short *)(iVar5 + 0xfa)) * 0x10000);
          gte_ldVZ2(((int)*(short *)(iVar14 + 0x5c) - (int)*(short *)(iVar5 + 0xdc)) +
                    (int)*(short *)(iVar5 + 0xfc));
          gte_rtpt_b();
          gte_stSXY0();
          gte_stSXY1();
          gte_stSXY2();
          gte_ldVXY0((int)*(short *)(iVar14 + 0x58) + (int)*(short *)(iVar5 + 0xd8) +
                     (int)*(short *)(iVar5 + 0xf8) & 0xffffU |
                     ((int)*(short *)(iVar14 + 0x5a) + (int)*(short *)(iVar5 + 0xda) +
                     (int)*(short *)(iVar5 + 0xfa)) * 0x10000);
          gte_ldVZ0((int)*(short *)(iVar14 + 0x5c) + (int)*(short *)(iVar5 + 0xdc) +
                    (int)*(short *)(iVar5 + 0xfc));
          uVar15 = *(undefined4 *)(iVar5 + 0xb8);
          gte_rtps_b();
          *(undefined4 *)(iVar4 + 4) = *(undefined4 *)(iVar3 + 0x3c);
          gte_stSXY2();
          gte_avsz4_b();
          gte_stMAC0();
          gte_ldVXY0(iVar5 + 0x98);
          gte_ldVZ0(iVar5 + 0x9c);
          gte_ldL11L12(uVar15);
          gte_ldL13L21(*(undefined4 *)(iVar5 + 0xbc));
          gte_llv0_b();
          *(int *)(iVar3 + 0x170) = (int)*(short *)(iVar3 + 0x16c) + *(int *)(iVar3 + 0x44);
          *(int *)(iVar3 + 0x174) = (int)*(short *)(iVar3 + 0x16e) + *(int *)(iVar3 + 0x44);
          iVar26 = gte_stIR1();
          iVar16 = iVar26 >> 5;
          if (iVar26 < 0) {
            iVar16 = -iVar16;
          }

		  // tire sprite index to render,
		  // based on camera rotation
          pcVar6 = &DAT_8008a384 + iVar16;
          if (0 < iVar16 + -0x80) {
            pcVar6 = &DAT_8008a404;
          }

		  // iVar3 + 38, is a copy of driver ptr on scratchpad
		  // driver->wheelSprites[*pcVar5]
          iVar16 = *(int *)(*pcVar6 * 4 + *(int *)(iVar3 + 0x38));

		  // if wheel sprite exists
          if (iVar16 != 0)
		  {
            uVar25 = *(undefined4 *)(iVar16 + 0x18);
            uVar19 = *(uint *)(iVar16 + 0x1c);
            *(undefined4 *)(iVar4 + 0xc) = *(undefined4 *)(iVar16 + 0x14);
            uVar21 = gte_stIR1();
            *(undefined4 *)(iVar4 + 0x14) = uVar25;
            *(uint *)(iVar4 + 0x1c) = uVar19;

			// function pointer from global array
            UNRECOVERED_JUMPTABLE = *(code **)((uVar21 >> 0x1a & 0x10 | uVar10) + 0x130);

            *(uint *)(iVar4 + 0x24) = uVar19 >> 0x10;

			// execute function pointer
            (*UNRECOVERED_JUMPTABLE)();
            return;
          }
          iVar14 = iVar14 + -0x10;
          iVar5 = iVar5 + -8;
          uVar10 = uVar10 - 4;
        } while (-1 < iVar14 - iVar3);
      }
      iVar29 = iVar29 + 0x88;

	  // subtract number of players
      iVar14 = *(int *)(iVar3 + 0x34) + -1;
      *(int *)(iVar3 + 0x34) = iVar14;

    } while (0 < iVar14);

	// next thread
	param_1 = *(int *)(param_1 + 0x10);

	// if no threads remain
    if (param_1 == 0)
	{
	  // finalize PrimMem
      *(undefined4 *)(param_2 + 0x14) = uVar25;
      *(int *)(param_2 + 0xc) = iVar4;

	  // quit loop
      return;
    }
  } while( true );
}



// RenderWeather
// param_1 tileView
// param_2 PrimMem
// param_3 RainBuffer
// param_4 numPlyrCurrGame
// param_5 paused?
void FUN_8006f9a8(uint *param_1,int param_2,uint *param_3,undefined4 param_4,int param_5)
{
  bool bVar1;
  short sVar2;
  short sVar3;
  int iVar4;
  uint *puVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  int iVar9;
  uint uVar10;
  uint uVar11;
  uint *puVar12;
  uint uVar13;
  uint uVar14;
  undefined4 unaff_s0;
  int unaff_s1;
  uint uVar15;
  int unaff_s2;
  int iVar16;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  int iVar17;
  undefined4 unaff_s5;
  uint uVar18;
  undefined4 unaff_s6;
  uint uVar19;
  undefined4 unaff_s7;
  uint uVar20;
  undefined *puVar21;
  uint uVar22;
  undefined *puVar23;
  undefined4 unaff_s8;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];

  iVar4 = 0x1f800000;
  DAT_1f800020 = &DAT_8008cf6c;
  gte_ldtr(0,0,0);
  
  // matrix_ViewProj
  gte_ldR11R12(param_1[10]);
  gte_ldR13R21(param_1[0xb]);
  gte_ldR22R23(param_1[0xc]);
  gte_ldR31R32(param_1[0xd]);
  gte_ldR33(param_1[0xe]);
  
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800024 = (undefined *)register0x00000074;
  DAT_1f800028 = unaff_s8;
  DAT_1f80002c = unaff_retaddr;

  // TRIG_AngleSinCos_r16r17r18
  puVar5 = (uint *)FUN_8006fe08();

  // sin and cos output
  iVar16 = (unaff_s2 >> 2) + 0x400;
  uVar15 = (unaff_s1 >> 2) + 0x400;

  *(uint *)(iVar4 + 0x38) = uVar15 | 0x4000000;
  *(int *)(iVar4 + 0x3c) = iVar16;
  
  uVar13 = param_1[8];
  
  // ptrOT
  uVar11 = param_1[0x3d];
  
  // window dimensions
  gte_ldOFX((int)*(short *)(param_1 + 8) << 0xf);
  gte_ldOFY((int)*(short *)((int)param_1 + 0x22) << 0xf);
  gte_ldH(param_1[6]);
  
  uVar14 = *param_3;
  
  // rain numParticles_max
  uVar6 = (uint)*(ushort *)(param_3 + 1);
  
  // if not paused
  if (param_5 == 0) 
  {
	// rain vanishRate
    uVar8 = (uint)*(ushort *)((int)param_3 + 6);
    
	iVar9 = uVar6 - uVar14;
    if (uVar6 != uVar14) {
      if (iVar9 < 0) {
        uVar14 = uVar14 - uVar8;
        if (0 < (int)(iVar9 + uVar8)) {
          uVar14 = uVar6;
        }
      }
      else {
        uVar14 = uVar14 + uVar8;
        if ((int)(iVar9 - uVar8) < 0) {
          uVar14 = uVar6;
        }
      }
      *param_3 = uVar14;
    }
  }
  
  uVar6 = param_3[2];
  uVar8 = param_3[3];
  uVar19 = uVar8 + param_3[5];
  uVar18 = uVar6 + (param_3[4] & 0xfffeffff) & 0xfffeffff;
  if (param_5 == 0) {
    param_3[2] = uVar18;
    param_3[3] = uVar19;
  }
  sVar2 = *(short *)(param_1 + 1);
  iVar9 = (int)sVar2;
  uVar10 = param_3[6];
  sVar3 = *(short *)(param_3 + 7);
  uVar7 = *param_1 & 0xfffeffff;
  if (param_5 == 0) {
    param_3[6] = uVar7;
    *(short *)(param_3 + 7) = sVar2;
  }
  uVar10 = ((uVar6 + ((int)(param_3[4] & 0xfffeffff) >> 1 & 0xfffeffffU) & 0xfffeffff) -
            (uVar7 - ((int)((uVar7 - uVar10) * 0x10000) >> 0x13 & 0xffffU |
                     ((int)(uVar7 - uVar10) >> 0x14) << 0x11) & 0xfffeffff) & 0xfffeffff) + uVar15 &
           0xfffeffff;
  uVar18 = (uVar18 - uVar7 & 0xfffeffff) + uVar15 & 0xfffeffff;
  iVar17 = ((uVar8 + ((int)param_3[5] >> 1)) - (iVar9 - (iVar9 - sVar3 >> 3))) + iVar16;
  iVar16 = (uVar19 - iVar9) + iVar16;
  uVar6 = param_3[9];
  uVar15 = param_3[10];
  puVar12 = (uint *)(uVar11 + param_3[0xb] * 4);
  *(uint *)(iVar4 + 0x30) = param_3[8] | 0x52000000;
  *(uint *)(iVar4 + 0x34) = uVar6;
  uVar6 = 0x30125400;
  uVar11 = 0x493583fe;
  do {
    uVar8 = uVar11 >> 8;
    uVar11 = uVar6 >> 8 | uVar11 << 0x18;
    uVar19 = (uVar6 + uVar8 + (uVar11 >> 8)) * 0x1000000;
    uVar6 = (uVar8 | uVar19) >> 8;
    uVar8 = uVar11 >> 8 | uVar8 << 0x18;
    uVar22 = (uVar11 + uVar6 + (uVar8 >> 8)) * 0x1000000;
    uVar11 = (uVar6 | uVar22) >> 8;
    uVar6 = uVar8 >> 8 | uVar6 << 0x18;
    puVar23 = (undefined *)((uVar8 + uVar11 + (uVar6 >> 8)) * 0x1000000);
    uVar11 = uVar11 | (uint)puVar23;
    puVar21 = (undefined *)((int)uVar22 >> 5);
    uVar8 = (int)uVar19 >> 0x15 & 0xffff;
    while( true ) {
      bVar1 = uVar14 == 0;
      uVar14 = uVar14 - 1;
      if (bVar1) {
        puVar5[1] = uVar15;
        puVar5[2] = 0;
        *puVar5 = *puVar12 | 0x2000000;
        *puVar12 = (uint)puVar5 & 0xffffff;
        *(uint **)(param_2 + 0xc) = puVar5 + 3;
        return;
      }
      uVar19 = ((uVar8 | (uint)puVar21) + uVar10 & 0x7fe07ff) - *(int *)(iVar4 + 0x38);
      uVar8 = ((uVar8 | (uint)puVar21) + uVar18 & 0x7fe07ff) - *(int *)(iVar4 + 0x38);
      if (uVar8 - uVar19 != uVar18 - uVar10) break;
      uVar8 = uVar8 & 0xfffeffff;
      gte_ldVXY0(uVar19 & 0xfffeffff);
      gte_ldVXY1(uVar8);
      gte_ldVXY2(uVar8);
      uVar8 = ((uint)puVar23 >> 0x15) + iVar17 & 0x7ff;
      uVar19 = ((uint)puVar23 >> 0x15) + iVar16 & 0x7ff;
      if (uVar19 - uVar8 != iVar16 - iVar17) break;
      iVar9 = uVar19 - *(int *)(iVar4 + 0x3c);
      gte_ldVZ0(uVar8 - *(int *)(iVar4 + 0x3c));
      gte_ldVZ1(iVar9);
      gte_ldVZ2(iVar9);
      uVar8 = uVar11 >> 8;
      gte_rtpt_b();
      uVar11 = uVar6 >> 8 | uVar11 << 0x18;
      uVar19 = (uVar6 + uVar8 + (uVar11 >> 8)) * 0x1000000;
      uVar6 = (uVar8 | uVar19) >> 8;
      uVar8 = uVar11 >> 8 | uVar8 << 0x18;
      uVar20 = (uVar11 + uVar6 + (uVar8 >> 8)) * 0x1000000;
      uVar11 = (uVar6 | uVar20) >> 8;
      uVar6 = uVar8 >> 8 | uVar6 << 0x18;
      puVar23 = (undefined *)((uVar8 + uVar11 + (uVar6 >> 8)) * 0x1000000);
      uVar11 = uVar11 | (uint)puVar23;
      puVar21 = (undefined *)((int)uVar20 >> 5);
      uVar8 = (int)uVar19 >> 0x15 & 0xffff;
      uVar19 = gte_stSXY0();
      iVar9 = gte_stFLAG();
      uVar7 = gte_stSXY1();
      if (((-1 < iVar9 << 0xe) &&
          (uVar19 = ~(uVar19 - uVar13 | uVar7 - uVar13) | uVar19 & uVar7, -1 < (int)uVar19)) &&
         (-1 < (int)(uVar19 << 0x10))) {
        uVar19 = *(uint *)(iVar4 + 0x34);
        puVar5[1] = *(uint *)(iVar4 + 0x30);
        puVar5[3] = uVar19;
        *puVar5 = *puVar12 | 0x4000000;
        gte_stSXY0();
        gte_stSXY1();
        *puVar12 = (uint)puVar5 & 0xffffff;
        puVar5 = puVar5 + 5;
      }
    }
  } while( true );
}


// TRIG_AngleSinCos_r16r17r18
void FUN_8006fe08(void)
{
	// input: s0
	// output: s1 SIN, s2 COS

        8006fe08 08 80 03 3c     lui        v1,0x8008
        8006fe0c a0 45 63 24     addiu      v1,v1,0x45a0
        8006fe10 ff 03 11 32     andi       s1,s0,0x3ff
        8006fe14 80 88 11 00     sll        s1,s1,0x2
        8006fe18 21 18 71 00     addu       v1,v1,s1
        8006fe1c 00 00 71 8c     lw         s1,0x0(v1)=>DAT_800845a0
        8006fe20 00 04 03 32     andi       v1,s0,0x400
        8006fe24 07 00 60 14     bne        v1,zero,LAB_8006fe44
        8006fe28 00 08 03 32     _andi      v1,s0,0x800
        8006fe2c 03 94 11 00     sra        s2,s1,0x10
        8006fe30 00 8c 11 00     sll        s1,s1,0x10
        8006fe34 09 00 60 14     bne        v1,zero,LAB_8006fe5c
        8006fe38 03 8c 11 00     _sra       s1,s1,0x10
        8006fe3c 08 00 e0 03     jr         ra
        8006fe40 00 00 00 00     _nop

		8006fe44 00 94 11 00     sll        s2,s1,0x10
        8006fe48 03 94 12 00     sra        s2,s2,0x10
        8006fe4c 06 00 60 14     bne        v1,zero,LAB_8006fe68
        8006fe50 03 8c 11 00     _sra       s1,s1,0x10
        8006fe54 08 00 e0 03     jr         ra
        8006fe58 22 90 12 00     _sub       s2,zero,s2

		8006fe5c 22 90 12 00     sub        s2,zero,s2
        8006fe60 08 00 e0 03     jr         ra
        8006fe64 22 88 11 00     _sub       s1,zero,s1

		8006fe68 08 00 e0 03     jr         ra
        8006fe6c 22 88 11 00     _sub       s1,zero,s1

}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// CreateRenderLists_1P2P
// param1 is lev->mesh_info->ptrVisDataArray
// param2 is VisMem 0x00-0x0F (visLeafList)
// param3 is tileView
// param4 is pointer of linked list VisData (1808) to draw in 226
// param5 is VisMem 0x80-0x8F (bspList)
// param6 is number of players
undefined4 FUN_8006fe70(ushort *param_1,int param_2,int param_3,int param_4,int param_5,int param_6)

{
  short *psVar1;
  short sVar2;
  ushort uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  ushort *puVar13;
  undefined4 unaff_s3;
  uint uVar14;
  int *piVar15;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  uint uVar16;
  undefined4 unaff_s7;
  int iVar17;
  int *piVar18;
  code *pcVar19;
  undefined4 unaff_s8;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];

  // function pointer back to itself
  pcVar19 = FUN_8006fe70;

  iVar4 = 0x1f800000;
  _DAT_1f800050 = &_gp_4;
  _DAT_1f800080 = 0;
  iVar5 = 0x1f800000;

  // if 1 player
  DAT_1f8000a4 = DAT_1f800018;

  // if not 1 player
  if (param_6 != 1) {
    DAT_1f8000a4 = 0x1540;
  }

  // load matrix at tileView 0x28, into GTE registers
  gte_ldR11R12(*(undefined4 *)(param_3 + 0x28));
  gte_ldR13R21(*(undefined4 *)(param_3 + 0x2c));
  gte_ldR22R23(*(undefined4 *)(param_3 + 0x30));
  gte_ldR31R32(*(undefined4 *)(param_3 + 0x34));
  gte_ldR33(*(undefined4 *)(param_3 + 0x38));
  gte_ldtr(*(undefined4 *)(param_3 + 0x3c),*(undefined4 *)(param_3 + 0x40),
           *(undefined4 *)(param_3 + 0x44));

  // tileView sizeX and sizeY
  gte_ldOFX((int)*(short *)(param_3 + 0x20) << 0xf);
  gte_ldOFY((int)*(short *)(param_3 + 0x22) << 0xf);

  // distance to screen
  gte_ldH(*(undefined4 *)(param_3 + 0x18));

  // boundingBox around camera
  iVar8 = (int)*(short *)(param_3 + 0xe8);
  iVar9 = (int)*(short *)(param_3 + 0xea);
  iVar10 = (int)*(short *)(param_3 + 0xec);
  iVar11 = (int)*(short *)(param_3 + 0xee);
  iVar12 = (int)*(short *)(param_3 + 0xf0);
  sVar2 = *(short *)(param_3 + 0xf2);
  
  // frustum data on each side of frustum
  _DAT_1f800060 = *(undefined4 *)(param_3 + 0xa8);
  DAT_1f800064 = *(undefined4 *)(param_3 + 0xac);
  _DAT_1f800068 = *(undefined4 *)(param_3 + 0xb0);
  DAT_1f80006c = *(undefined4 *)(param_3 + 0xb4);
  _DAT_1f800070 = *(undefined4 *)(param_3 + 0xb8);
  DAT_1f800074 = *(undefined4 *)(param_3 + 0xbc);
  _DAT_1f800078 = *(undefined4 *)(param_3 + 0xc0);
  DAT_1f80007c = *(undefined4 *)(param_3 + 0xc4);
  
  // jump pointers (stored on scratchpad from VisData_CopyJMPsToScratchpad),
  // given the index from tileView, which depends on direction camera faces
  DAT_1f8000ac = (&DAT_1f800084)[*(int *)(param_3 + 0xd0)];
  _DAT_1f8000b0 = (&DAT_1f800084)[*(int *)(param_3 + 0xd4)];
  DAT_1f8000b4 = (&DAT_1f800084)[*(int *)(param_3 + 0xd8)];
  DAT_1f8000b8 = (&DAT_1f800084)[*(int *)(param_3 + 0xdc)];
  DAT_1f8000c0 = (&DAT_1f800084)[*(int *)(param_3 + 0xe4)];

  // VisMem 0x80-0x8F
  iVar7 = param_5;

  // lev -> mesh -> visData
  puVar13 = param_1;

  DAT_1f800030 = unaff_s0;
  DAT_1f800034 = unaff_s1;
  DAT_1f800038 = unaff_s2;
  DAT_1f80003c = unaff_s3;
  DAT_1f800040 = unaff_s4;
  DAT_1f800044 = unaff_s5;
  DAT_1f800048 = unaff_s6;
  _DAT_1f80004c = unaff_s7;
  DAT_1f800054 = (undefined *)register0x00000074;
  _DAT_1f800058 = unaff_s8;
  DAT_1f80005c = unaff_retaddr;
  
  // loop infinitely until scratchpad 
  // list is built and emptied
  do
  {
	// Assume VisData branch, not leaf

	// leftChildID
    uVar14 = *(uint *)(puVar13 + 0xc);

	// rightChildID
	uVar16 = (int)uVar14 >> 0x10;

	// (if left child exists)
	if (((uVar14 & 0x8000) == 0) &&
	
		// if visLeafList says this visData node is not a leaf
		(*(int *)((uVar14 >> 3 & 0x7fc) + param_2) << (uVar14 & 0x1f) < 0)) {

	  // leftChild = array + index * 0x10 (short ptr, 0x10 -> 0x20)
	  puVar13 = param_1 + (uVar14 & 0x3fff) * 0x10;

	  // minPos x,y
	  iVar6 = *(int *)(puVar13 + 2);

	  // minPos z, maxPos x
	  iVar17 = *(int *)(puVar13 + 4);

	  // if inside hitbox
	  if (
			((iVar6 >> 0x10) - iVar12 < 1) &&
			(
				// 1f8000d4 = minPosX
				// 1f8000d6 = minPosY
				*(int *)(iVar5 + 0xd4) = iVar6, 
				(short)iVar6 - iVar11 < 1
			)
		  ) 
	  {

		// maxPos y,z
		iVar6 = *(int *)(puVar13 + 6);

		// if still in hitbox
		if (
			(
				(
					// camMinPosX < maxPosX
					(iVar8 - (iVar17 >> 0x10) < 1) && 
					
					// camMaxPosZ > minPosX
					((int)(short)iVar17 - (int)sVar2 < 1)
				) &&
				(iVar10 - (iVar6 >> 0x10) < 1)
			) &&
			(
				// 1f8000d8 = minPosZ
				// 1f8000da = maxPosX
				*(int *)(iVar5 + 0xd8) = iVar17,
				
				iVar9 - (short)iVar6 < 1
			)
		   ) 
		{
		  // 1f8000dc = maxPosY
		  // 1f8000de = maxPosZ
          *(int *)(iVar5 + 0xdc) = iVar6;
		  
		  // record childID
          *(undefined2 *)(iVar5 + 0xd0) = (short)uVar14;
          
		  // advance recording
		  iVar5 = iVar5 + 0x10;
        }
      }
    }

	// (if right child exists)
    if ((-1 < (int)uVar16) &&
	
		// if visLeafList says this visData node is not a leaf
		(*(int *)((uVar16 >> 3 & 0x7fc) + param_2) << (uVar16 & 0x1f) < 0)) {

	  // rightChild = array + index * 0x10 (short ptr, 0x10 -> 0x20)
	  puVar13 = param_1 + (uVar16 & 0x3fff) * 0x10;

	  // minPos x,y
      iVar6 = *(int *)(puVar13 + 2);

	  // minPos z, maxPos x
      iVar17 = *(int *)(puVar13 + 4);
	  
	  // if in hitbox
      if (
			((iVar6 >> 0x10) - iVar12 < 1) &&
			(

				// 1f8000d4 = minPosX
				// 1f8000d6 = minPosY
				*(int *)(iVar5 + 0xd4) = iVar6, 
				
				(short)iVar6 - iVar11 < 1
			)
		  ) 
	  {

		// maxPos y,z
		iVar6 = *(int *)(puVar13 + 6);

		// if in hitbox
		if (
				(
					((iVar8 - (iVar17 >> 0x10) < 1) && ((int)(short)iVar17 - (int)sVar2 < 1)) &&
					(iVar10 - (iVar6 >> 0x10) < 1)
				) &&
           
				// 1f8000d8 = minPosZ
				// 1f8000da = maxPosX
				(*(int *)(iVar5 + 0xd8) = iVar17, iVar9 - (short)iVar6 < 1)
			) 
		{
		  // 1f8000dc = maxPosY
		  // 1f8000de = maxPosZ
          *(int *)(iVar5 + 0xdc) = iVar6;
		  
		  // record childID
          *(undefined2 *)(iVar5 + 0xd0) = (short)(uVar14 >> 0x10);
          
		  // advance recording
		  iVar5 = iVar5 + 0x10;
        }
      }
    }
	
	// loop infinitely until last leaf node
    while( true ) 
	{
		// if scratchpad list empty, quit function
		if (iVar5 == iVar4) {
		return *(undefined4 *)(iVar4 + 0x80);
		}
		
		// get child VisData index (and flags)
		psVar1 = (short *)(iVar5 + 0xc0);
		
		iVar5 = iVar5 + -0x10;
		
		// get just the index
		uVar14 = (int)*psVar1 & 0x3fff;
		
		// pointer to VisData node
		puVar13 = param_1 + uVar14 * 0x10;
		
		// If this is not a leaf node, break
		if (((int)*psVar1 & 0x4000U) == 0) break;
		
		// as long as we have leaf nodes, keep going...
		
		// VisData flag
		uVar3 = *puVar13;
		

		// FUN_80070284:
		// 	li $t9 80070290
		//	jr $s7 (800703XX)
		//  === (at s7) ===
		//  li $fp deref(1f8000xx) -- depends which s7
		//	li $gp deref(1f8000xx) -- depends which s7
		//	jr $t9 (80070290)
		
		
		// lw $s7, deref(1f8000AC), (1f800084[tileView->0xd0]) (80070330)
		// $t8 = 0x0
		// 80070284():
		//   $t9 = 80070290
		//   80070330():
		//     $gp = 1f8000d4 + (lwr)1f8000da (maxPosX, minPosY)
		//     $fp = 1f8000de (maxPosY)
		//     80070290():
		//       ldv0(gp, gp, fp, fp)
		//       t9 = result
		iVar5 = FUN_80070284();
		if ($t9 > 0) goto CheckNextLeaf;
		
		// lw $s7, deref(1f8000B0), (1f800084[tileView->0xd4]) (80070340)
		// $t8 = 0x8
		// $gp = 1f8000d4 (minPosX, minPosY)
		// $fp = 1f8000de (maxPosZ)
		// 80070290();
		// which then returns at the IF
		iVar5 = FUN_80070284();
		if ($t9 > 0) goto CheckNextLeaf;
		
		// lw $s7, deref(1f8000B4), (1f800084[tileView->0xd8]) (8007035C)
		// $t8 = 0x10
		// $gp = 1f8000d4 + (lwr)1f8000dd (minPosX, maxPosY)
		// $fp = 1f8000d8 (minPosZ)
		// 80070290();
		// which then returns at the IF
		iVar5 = FUN_80070284();
		if ($t9 > 0) goto CheckNextLeaf;
		
		// lw $s7, deref(1f8000B8), (1f800084[tileView->0xdc]) (8007036C)
		// $t8 = 0x18
		// $gp = 1f8000d4 + (lwr)1f8000da (maxPosX, minPosY)
		// $fp = 1f8000d8 (minPosZ)
		// 80070290();
		iVar5 = FUN_80070284();
		if ($t9 > 0) goto CheckNextLeaf;
		
		
		// == Leaf Node ==
		
		
		// VisDataList_Water
        piVar18 = (int *)(param_4 + 0x24);
		  
        if (
			  // is VisData flag is not water	
			  ((uVar3 & 2) == 0) && 
			  
			  (
			  	// VisDataList_DynamicSubdiv
			  	piVar18 = (int *)(param_4 + 0xc), 
			  	
			  	// if forcedDynamicSubdiv is disabled
			  	(uVar3 & 0x20) == 0
			  )
			) 
		  {
			// lw $s7, deref(1f8000C0), (1f800084[tileView->0xe4])  (8007037C)
			
			// 80070308():
			//   t9 = ra
			//   jr s7
			//   8007037C():
			//     gp = 1f8000d4 (minX, minY)
			//     fp = 1f8000d8 (maxZ)
			//     jr t9 (fake ra)
            iVar5 = FUN_80070308();

			// $gp overwritten temporarily
			gte_ldVXY0($gp);
            gte_ldVZ0($fp);

			// RTPS - Perspective Transformation (single)
			gte_rtps();

			// replace with "li t0, 0" for max LOD,
			// the higher t0, the higher the distance
            iVar6 = gte_stSZ3();
			
			// anything min LOD to max LOD
			// VisDataList_FullDynamic
            piVar18 = (int *)(param_4 + 0x28);
			
            if (
				(
					// if distance < *(int *)(iVar4+0xa4)
					(iVar6 - *(int *)(iVar4 + 0xa4) < 1) &&
					(
						(
							// VisDataList_4x4
							piVar18 = (int *)(param_4 + 4), 
							
							// if forced 4x4 is disabled
							(uVar3 & 0x80) == 0 &&
						
							(
								// VisDataList_4x1
								piVar18 = (int *)(param_4 + 0x1c), 
								
								// if forced 4x1 is disabled
								(uVar3 & 8) == 0
							)
						)
					)
				) &&
				 
				(
					// VisDataList_4x2
					piVar18 = (int *)(param_4 + 0x14), 
					
					// if forced 4x2 is disabled
					(uVar3 & 0x10) == 0
				)
			  ) 
			{
			  // if distance is close,
			  // and all force-subdiv flags are disabled
				
			  // pick 4x1 - 4x4 depending on distance
			  // VisDataList_DynamicSubdiv
			  piVar18 = (int *)(param_4 + 0xc);
            }
          }
		  
		  // VisMem 0x80-0x8F (bspList)
		  // linked list of VisData nodes
		  
		  // region after quadblock int flags
		  // vismem + VisData index * 8
          piVar15 = (int *)(uVar14 * 8 + iVar7);
		  
		  // get most recent addition to VisDataList
          iVar17 = *piVar18;
		  
		  // VisDataList pointer = VisMem pointer
          *(int **)piVar18 = piVar15;
		  
		  // 1f800080 count
          iVar6 = *(int *)(iVar4 + 0x80);

		  // VisDataList->next = the former
          *piVar15 = iVar17;

		  // increment counter
		  *(int *)(iVar4 + 0x80) = iVar6 + 1;
    
	// loop infinitely until last leaf node
	CheckNextLeaf:
	}
      
  // loop infinitely until scratchpad 
  // list is built and emptied
  } while( true );
}


// part of FindVisData
void FUN_80070284(void)
{	
        80070284 07 80 19 3c     lui        t9,0x8007
        80070288 08 00 e0 02     jr         s7
        8007028c 90 02 39 37     _ori       t9,t9,0x290
}


// called from FUN_80070284,
// which is part of FindVisData
void FUN_80070290(void)

{
  int in_at;
  int iVar1;
  int in_t8;

  // point on VisData node hitbox
  gte_ldVXY0($gp);
  gte_ldVZ0(&fp);
  
  // camera frustum stuff, cam->0xa8 and beyond
  gte_ldL11L12(*(int*)(1f800060+in_t8));
  gte_ldL13L21(*(int*)(1f800064+in_t8) & 0xffff);
  gte_ldRBK((*(int*)(1f800064+in_t8) >> 0x10) * -2);
  
  gte_llv0bk();
  
  // store result in $t9
  gte_stIR1();
  return;
}

// VisData_CopyJMPsToScratchpad
void FUN_800702d4(void)

{
  bool bVar1;
  undefined *puVar2;
  undefined **ppuVar3;
  undefined4 *puVar4;
  int iVar5;

  iVar5 = 7;
  ppuVar3 = &PTR_LAB_8008a408;
  puVar4 = &DAT_1f800084;
  do {
    puVar2 = *ppuVar3;
    ppuVar3 = ppuVar3 + 1;
    *(undefined **)puVar4 = puVar2;
    puVar4 = puVar4 + 1;
    bVar1 = iVar5 != 0;
    iVar5 = iVar5 + -1;
  } while (bVar1);
  return;
}



void FUN_80070308(void)

{
        80070308 08 00 e0 02     jr         s7
        8007030c 21 c8 e0 03     _move      t9,ra
}

// After that, are 8 functions that are used from JMP pointers,
// each only a few bytes large



// CreateRenderLists_3P4P
// param1 is lev->mesh_info->ptrVisDataArray
// param2 is VisMem 0x00-0x0F
// param3 is tileView
// param4 is pointer of linked list VisData (1808) to draw in 226
// param5 is VisMem 0x80-0x8F
// param6 is number of players
undefined4 FUN_80070388(ushort *param_1,int param_2,int param_3,int param_4,int param_5)

{
  short *psVar1;
  short sVar2;
  ushort uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  ushort *puVar13;
  undefined4 unaff_s3;
  uint uVar14;
  int *piVar15;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  uint uVar16;
  undefined4 unaff_s7;
  int iVar17;
  int *piVar18;
  code *pcVar19;
  undefined4 unaff_s8;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];

  pcVar19 = FUN_80070388;
  _DAT_1f800050 = &_gp_4;
  iVar4 = 0x1f800000;
  _DAT_1f800080 = 0;
  iVar5 = 0x1f800000;

  // matrix
  gte_ldR11R12(*(undefined4 *)(param_3 + 0x28));
  gte_ldR13R21(*(undefined4 *)(param_3 + 0x2c));
  gte_ldR22R23(*(undefined4 *)(param_3 + 0x30));
  gte_ldR31R32(*(undefined4 *)(param_3 + 0x34));
  gte_ldR33(*(undefined4 *)(param_3 + 0x38));
  gte_ldtr(*(undefined4 *)(param_3 + 0x3c),*(undefined4 *)(param_3 + 0x40),
           *(undefined4 *)(param_3 + 0x44));
		   
  // screen dimensions
  gte_ldOFX((int)*(short *)(param_3 + 0x20) << 0xf);
  gte_ldOFY((int)*(short *)(param_3 + 0x22) << 0xf);
  
  // distance to screen
  gte_ldH(*(undefined4 *)(param_3 + 0x18));

  iVar8 = (int)*(short *)(param_3 + 0xe8);
  iVar9 = (int)*(short *)(param_3 + 0xea);
  iVar10 = (int)*(short *)(param_3 + 0xec);
  iVar11 = (int)*(short *)(param_3 + 0xee);
  iVar12 = (int)*(short *)(param_3 + 0xf0);
  sVar2 = *(short *)(param_3 + 0xf2);
  _DAT_1f800060 = *(undefined4 *)(param_3 + 0xa8);
  DAT_1f800064 = *(undefined4 *)(param_3 + 0xac);
  _DAT_1f800068 = *(undefined4 *)(param_3 + 0xb0);
  DAT_1f80006c = *(undefined4 *)(param_3 + 0xb4);
  _DAT_1f800070 = *(undefined4 *)(param_3 + 0xb8);
  DAT_1f800074 = *(undefined4 *)(param_3 + 0xbc);
  _DAT_1f800078 = *(undefined4 *)(param_3 + 0xc0);
  DAT_1f80007c = *(undefined4 *)(param_3 + 0xc4);
  DAT_1f8000ac = (&DAT_1f800084)[*(int *)(param_3 + 0xd0)];
  _DAT_1f8000b0 = (&DAT_1f800084)[*(int *)(param_3 + 0xd4)];
  DAT_1f8000b4 = (&DAT_1f800084)[*(int *)(param_3 + 0xd8)];
  DAT_1f8000b8 = (&DAT_1f800084)[*(int *)(param_3 + 0xdc)];
  
  // VisMem 0x80 - 0x8F
  iVar7 = param_5;
  
  // ptrVisDataArray
  puVar13 = param_1;
  
  DAT_1f800030 = unaff_s0;
  DAT_1f800034 = unaff_s1;
  DAT_1f800038 = unaff_s2;
  DAT_1f80003c = unaff_s3;
  DAT_1f800040 = unaff_s4;
  DAT_1f800044 = unaff_s5;
  DAT_1f800048 = unaff_s6;
  _DAT_1f80004c = unaff_s7;
  DAT_1f800054 = (undefined *)register0x00000074;
  _DAT_1f800058 = unaff_s8;
  DAT_1f80005c = unaff_retaddr;
  do {
    uVar14 = *(uint *)(puVar13 + 0xc);
    uVar16 = (int)uVar14 >> 0x10;
    if (((uVar14 & 0x8000) == 0) &&
       (*(int *)((uVar14 >> 3 & 0x7fc) + param_2) << (uVar14 & 0x1f) < 0)) {
      puVar13 = param_1 + (uVar14 & 0x3fff) * 0x10;
      iVar6 = *(int *)(puVar13 + 2);
      iVar17 = *(int *)(puVar13 + 4);
      if (((iVar6 >> 0x10) - iVar12 < 1) &&
         (*(int *)(iVar5 + 0xd4) = iVar6, (short)iVar6 - iVar11 < 1)) {
        iVar6 = *(int *)(puVar13 + 6);
        if ((((iVar8 - (iVar17 >> 0x10) < 1) && ((int)(short)iVar17 - (int)sVar2 < 1)) &&
            (iVar10 - (iVar6 >> 0x10) < 1)) &&
           (*(int *)(iVar5 + 0xd8) = iVar17, iVar9 - (short)iVar6 < 1)) {
          *(int *)(iVar5 + 0xdc) = iVar6;
          *(undefined2 *)(iVar5 + 0xd0) = (short)uVar14;
          iVar5 = iVar5 + 0x10;
        }
      }
    }
    if ((-1 < (int)uVar16) && (*(int *)((uVar16 >> 3 & 0x7fc) + param_2) << (uVar16 & 0x1f) < 0)) {
      puVar13 = param_1 + (uVar16 & 0x3fff) * 0x10;
      iVar6 = *(int *)(puVar13 + 2);
      iVar17 = *(int *)(puVar13 + 4);
      if (((iVar6 >> 0x10) - iVar12 < 1) &&
         (*(int *)(iVar5 + 0xd4) = iVar6, (short)iVar6 - iVar11 < 1)) {
        iVar6 = *(int *)(puVar13 + 6);
        if ((((iVar8 - (iVar17 >> 0x10) < 1) && ((int)(short)iVar17 - (int)sVar2 < 1)) &&
            (iVar10 - (iVar6 >> 0x10) < 1)) &&
           (*(int *)(iVar5 + 0xd8) = iVar17, iVar9 - (short)iVar6 < 1)) {
          *(int *)(iVar5 + 0xdc) = iVar6;
          *(undefined2 *)(iVar5 + 0xd0) = (short)(uVar14 >> 0x10);
          iVar5 = iVar5 + 0x10;
        }
      }
    }
    while( true ) {
      if (iVar5 == iVar4) {
        return *(undefined4 *)(iVar4 + 0x80);
      }
      psVar1 = (short *)(iVar5 + 0xc0);
      iVar5 = iVar5 + -0x10;

	  // VisData index
	  uVar14 = (int)*psVar1 & 0x3fff;

      puVar13 = param_1 + uVar14 * 0x10;

	  // If this is not a leaf node, break
      if (((int)*psVar1 & 0x4000U) == 0) break;
	  
	  // as long as we have leaf nodes, keep going...

	  // VisData flag
      uVar3 = *puVar13;
	  
      iVar5 = FUN_80070284();
      
	  if ((((int)pcVar19 < 1) && (iVar5 = FUN_80070284(), (int)pcVar19 < 1)) &&
         (iVar5 = FUN_80070284(), (int)pcVar19 < 1)) 
	  {
        iVar5 = FUN_80070284();
        
		if ((int)pcVar19 < 1) 
		{
		
		  // VisDataList inside RenderList is not
		  // the same in 3P4P as it is 1P2P, different offsets
		  
		  // VisDataList_Water (ocean)
          piVar18 = (int *)(param_4 + 0x14);
		  
          if (
				(
					// if VisData flag is not water
					((uVar3 & 2) == 0) && 
					
					(
						// force high LOD
						// scrolling textures (waterfall)
						piVar18 = (int *)(param_4 + 0x1c),

						// if force high LOD is disabled
						(uVar3 & 0x20) == 0
					)
				) &&
				
				(piVar18 = (int *)(param_4 + 4), (uVar3 & 0x80) == 0)
			  ) 
		  {
			// almost all 3P4P rendering
            piVar18 = (int *)(param_4 + 0xc);
          }
		  
		  // build upon linked lists
		  
		  // VisMem 0x80-0x8F
		  // region after quadblock int flags
          piVar15 = (int *)(uVar14 * 8 + iVar7);
          
		  iVar17 = *piVar18;
          *(int **)piVar18 = piVar15;
          iVar6 = *(int *)(iVar4 + 0x80);
          *piVar15 = iVar17;
		  
		  // 0x1f800080
		  // increment length of linked list
          *(int *)(iVar4 + 0x80) = iVar6 + 1;
        }
      }
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// param1 - cameraDC pointer
// param2 - otMem
// param3 - render bucket instance, unused?
// param4 - trackLOD
// param5 - numPlyrCurrGame
// param6 - isPaused?
// RenderBucket_QueueLevInstances
undefined4
FUN_80070720(int param_1,int param_2,undefined4 param_3,undefined4 param_4,int param_5,
            undefined4 param_6)

{
  int iVar1;
  int iVar2;
  int iVar3;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  undefined4 unaff_s7;
  undefined *puVar4;
  undefined4 unaff_s8;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];

  iVar1 = 0x1f800000;
  DAT_1f800020 = &_gp_4;
  DAT_1f800034 = *(undefined4 *)(param_2 + 0xc);

  // number of players
  DAT_1f80005c = param_5;

  _DAT_1f800090 = param_6;
  DAT_1f800038 = *(int *)(param_2 + 8) + -4;

  // increment to last player's CameraDC
  _DAT_1f800060 = param_1 + (param_5 + -1) * 0xdc;

  // InstDrawPerPlayer
  DAT_1f800054 = (param_5 + -1) * 0x88;

  // CameraDC -> 0x28 (comes from QuadBlock + 0x44)
  iVar2 = *(int *)(_DAT_1f800060 + 0x28);

  _DAT_1f800058 = 0;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800024 = (undefined *)register0x00000074;
  DAT_1f800028 = unaff_s8;
  DAT_1f80002c = unaff_retaddr;
  _DAT_1f800050 = param_4;
  FUN_80071590();

  // loop for all players
  do
  {
	// derefrence pointer to array,
	// get first instance pointer
    puVar4 = *(undefined **)iVar2;

	if (iVar2 != 0)
	{
	  // every instance that is visible from QuadBlock,
	  // loop until nullptr is found
      while (iVar2 = iVar2 + 4, puVar4 != (undefined *)0x0)
	  {
		// RenderBucket_QueueDraw
        FUN_80070950(puVar4);

		// get next instance pointer
        puVar4 = *(undefined **)iVar2;
      }
    }

	// cameraDC
    iVar2 = *(int *)(iVar1 + 0x60);

	// previous camera
    *(int *)(iVar1 + 0x60) = iVar2 + -0xdc;

	// minus 0xdc, plus 0x28,
	// next camera's 0x28 offset
    iVar2 = *(int *)(iVar2 + -0xb4);

	// decrease number of remaining players
	iVar3 = *(int *)(iVar1 + 0x5c) + -1;

	// InstDrawPerPlayer
	*(int *)(iVar1 + 0x54) = *(int *)(iVar1 + 0x54) + -0x88;

    *(int *)(iVar1 + 0x5c) = iVar3;

  } while (0 < iVar3);

  *(undefined4 *)(param_2 + 0xc) = *(undefined4 *)(iVar1 + 0x34);

  return param_3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// param1 - instance pool "taken" list
// param2 - otMem
// param3 - RenderBucketInstance
// param4 - track LOD
// param5 - numPlyrCurrGame
// param6 - isPaused?
// RenderBucket_QueueNonLevInstances
undefined4
FUN_8007084c(undefined *param_1,int param_2,undefined4 param_3,undefined4 param_4,int param_5,
            undefined4 param_6)

{
  int iVar1;
  int iVar2;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  undefined4 unaff_s7;
  undefined *puVar3;
  undefined4 unaff_s8;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];

  iVar1 = 0x1f800000;
  DAT_1f800020 = &_gp_4;
  DAT_1f800034 = *(undefined4 *)(param_2 + 0xc);

  // put numPlyrCurrGame on scratchpad
  DAT_1f80005c = param_5;

  _DAT_1f800090 = param_6;
  DAT_1f800038 = *(int *)(param_2 + 8) + -4;
  
  // InstDrawPerPlayer
  DAT_1f800054 = (param_5 + -1) * 0x88;
  
  _DAT_1f800058 = 0;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800024 = (undefined *)register0x00000074;
  DAT_1f800028 = unaff_s8;
  DAT_1f80002c = unaff_retaddr;
  _DAT_1f800050 = param_4;
  FUN_80071590();

  // pointer to instance
  puVar3 = param_1;

  // loop for every screen
  do
  {
	// every instance in InstancePool
    while (puVar3 != (undefined *)0x0)
	{
	  // RenderBucket_QueueDraw
      FUN_80070950(puVar3);

	  // instance = instance->next
      puVar3 = *(undefined **)puVar3;
    }

	// decrease numPlyrCurrGame
    iVar2 = *(int *)(iVar1 + 0x5c) + -1;

	// InstDrawPerPlayer
    *(int *)(iVar1 + 0x54) = *(int *)(iVar1 + 0x54) + -0x88;

	// store numPlyrCurrGame
    *(int *)(iVar1 + 0x5c) = iVar2;

	// go back to start of instance pool,
	// to add all instances again, for other screens
    puVar3 = param_1;

  } while (0 < iVar2);

  *(undefined4 *)(param_2 + 0xc) = *(undefined4 *)(iVar1 + 0x34);
  return param_3;
}



// WARNING: Instruction at (ram,0x8007144c) overlaps instruction at (ram,0x80071448)
//
// WARNING: Removing unreachable block (ram,0x80070a1c)
// WARNING: Removing unreachable block (ram,0x800709e4)
// WARNING: Removing unreachable block (ram,0x80070a04)
// WARNING: Removing unreachable block (ram,0x80070a70)
// WARNING: Removing unreachable block (ram,0x80070a7c)
// WARNING: Removing unreachable block (ram,0x80070abc)
// WARNING: Removing unreachable block (ram,0x80070edc)
// WARNING: Removing unreachable block (ram,0x80070f0c)
// WARNING: Removing unreachable block (ram,0x80071468)
// WARNING: Removing unreachable block (ram,0x80071470)
// WARNING: Removing unreachable block (ram,0x80070d54)
// WARNING: Removing unreachable block (ram,0x80070d5c)
// WARNING: Removing unreachable block (ram,0x80070d38)
// WARNING: Removing unreachable block (ram,0x80070d44)


// RenderBucket_QueueDraw
void FUN_80070950(undefined4 param_1,undefined4 param_2,int param_3)

{
  short sVar1;
  short sVar2;
  undefined4 in_zero;
  int in_at;
  int extraout_v1;
  int iVar3;
  uint uVar4;
  undefined4 extraout_v1_00;
  undefined4 extraout_v1_01;
  int extraout_v1_02;
  undefined *puVar5;
  short *psVar6;
  ushort uVar7;
  short *psVar8;
  int iVar9;
  uint uVar10;
  uint *puVar11;
  undefined *puVar12;
  undefined4 uVar13;
  int iVar14;
  uint uVar15;
  undefined4 uVar16;
  uint *puVar17;
  undefined4 uVar18;
  int iVar19;
  uint *puVar20;
  uint uVar21;
  uint uVar22;
  uint uVar23;
  uint uVar24;
  uint uVar25;
  int unaff_s3;
  int iVar26;
  int iVar27;
  uint *puVar28;
  undefined *puVar29;
  undefined *unaff_s8;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];
  short param_8_00;
  undefined4 param_8;
  short sStack0000001e;
  short param_9_00;
  undefined4 param_9;
  undefined2 uStack00000022;
  int param_16;
  int param_17;
  int param_18;
  char param_19;
  char param_20;
  byte param_21;
  undefined4 param_19_00;
  uint param_22;
  short sStack00000056;
  undefined4 param_23;
  undefined4 param_24;
  undefined4 param_25;
  undefined4 param_26;
  uint param_28;

  puVar29 = &_gp_4;

  // tileView
  psVar6 = *(short **)(unaff_s8 + 0x74);

  *(undefined4 *)(in_at + 0x40) = unaff_retaddr;

  // $gp temporarily overwritten
  if (((*(uint *)(in_at + 0x50) & $gp) != 0) &&
     (psVar8 = *(short **)(in_at + 0x58), psVar6 != (short *)0x0)) {
    *(short **)(in_at + 0x58) = psVar6;
    if (psVar8 != psVar6) {
      FUN_8006c600();

	  // copy tileView position to instance
      sVar1 = psVar6[1];
      sVar2 = psVar6[2];
      *(int *)(in_at + 0x44) = (int)*psVar6;
      *(int *)(in_at + 0x48) = (int)sVar1;
      *(int *)(in_at + 0x4c) = (int)sVar2;

	  sVar1 = psVar6[0x11];
      uVar13 = *(undefined4 *)(psVar6 + 0xc);
      uVar18 = *(undefined4 *)(psVar6 + 0x7a);
      *(undefined2 *)(in_at + 0x3c) = (short)extraout_v1;
      *(short *)(in_at + 0x3e) = sVar1;
	  
      gte_ldOFX(extraout_v1 << 0xf);
      gte_ldOFY((int)sVar1 << 0xf);
      gte_ldH(uVar13);
      
	  *(undefined4 *)(in_at + 0x30) = uVar18;
    }
    puVar29 = &_gp_4;
    *(int *)(in_at + 0x7c) = param_17;
    *(undefined2 *)(unaff_s8 + 0xbc) = uStack00000022;
    *(int *)(in_at + 0x8c) = param_18;
    iVar19 = 0;
    iVar3 = param_16;
    iVar9 = param_17;
    iVar14 = param_18;
    if (param_18 + -0x1000 < 0) {
      iVar19 = 2;
      iVar3 = param_16 << 2;
      iVar9 = param_17 << 2;
      iVar14 = param_18 << 2;
    }

	// model -> headers
	iVar26 = *(int *)(unaff_s3 + 0x14);

	*(int *)(unaff_s8 + 0x8c) = iVar3;
    *(int *)(unaff_s8 + 0x90) = iVar9;

	// Model -> numHeaders
    iVar27 = (int)*(short *)(unaff_s3 + 0x12);

    *(int *)(unaff_s8 + 0x94) = iVar14;
	
	gte_ldtr(iVar3,iVar9,iVar14);
    
	iVar9 = gte_stH();
    iVar3 = 0;

	// loop through all headers
	do
	{
	  // keep count of headers
      iVar27 = iVar27 + -1;

	  // make comparison with header->maxDistanceLOD,
	  // loop until the first LOD is found with a higher distance,
	  // than the current camera distance to this instance
      if ((int)((((int)*(short *)(in_at + 0x3c) >> 1) * *(int *)(in_at + 0x8c)) / iVar9 -
               (uint)*(ushort *)(iVar26 + 0x14)) < 0)
	  {
		// store pointer to which model header LOD is rendered
        *(int *)(unaff_s8 + 0xe0) = iVar26;

		// store which LOD index gets rendered
		*(int *)(unaff_s8 + 0xd8) = iVar3;

		// MATRIX_SET_r11r12r13r14r15
        FUN_8006c540();
		
        uVar15 = -iVar19 + 0x12;
        
		gte_ldLR1LR2((*(uint *)(iVar26 + 0x18) << 0x10) >> (uVar15 & 0x1f));
        gte_ldLR3LG1(0);
        gte_ldLG2LG3(*(uint *)(iVar26 + 0x18) >> (uVar15 & 0x1f));
        gte_ldLB1LB2(0);
        gte_ldLB3((int)(uint)*(ushort *)(iVar26 + 0x1c) >> (-iVar19 + 2U & 0x1f));
        
		gte_ldVXY0(param_8);
        gte_ldVZ0(param_9);
		
        iVar3 = (*(int *)(in_at + 0x8c) >> 1) + 0x1000;
		
        gte_ldVXY0(iVar3 * param_8_00 >> 0xc & 0xffffU | (iVar3 * sStack0000001e >> 0xc) << 0x10);
        gte_ldVZ0(iVar3 * param_9_00 >> 0xc);
        
		uVar22 = 0;
        uVar24 = 0;

		// lcv0     cop2 $04C6012  v0 * color matrix
		gte_lcv0_b();

        uVar21 = gte_stIR1();
        uVar23 = gte_stIR2();
        uVar25 = gte_stIR3();
		
        *(undefined2 *)(in_at + 0x74) = (short)uVar21;
        *(undefined2 *)(in_at + 0x76) = (short)uVar23;
        *(uint *)(in_at + 0x78) = uVar25;
        uVar21 = uVar21 & 0xffff;
        uVar23 = uVar23 & 0xffff;
        uVar25 = uVar25 & 0xffff;
        FUN_8006c49c();
        *(int *)(in_at + 0xbc) = (int)param_19;
        *(int *)(in_at + 0xc0) = (int)param_20;
        uVar15 = *(uint *)(in_at + 0x5c);
        
		if ((param_28 != 0) && (uVar15 != param_28 >> 0x18)) 
		{
          gte_ldLR3LG1((int)(param_28 << 8) >> 0x18);
          gte_ldLR1LR2((int)(char)param_28 & 0xffffU |
                      ((int)(param_28 << 0x10) >> 0x18) << 0x10);
					  
          gte_ldVXY0(*(undefined4 *)(in_at + 0xb4));
          gte_ldVZ0(*(undefined4 *)(in_at + 0xb8));
		  
          uVar15 = *(uint *)(in_at + 0xc0);

		  // lcv0     cop2 $04C6012  v0 * color matrix
		  gte_lcv0_b();

          iVar3 = gte_stMAC1();
          if (0 < iVar3) {
            uVar15 = uVar15 + 10;
            *(int *)(in_at + 0xbc) = *(int *)(in_at + 0xbc) + 10;
            *(uint *)(in_at + 0xc0) = uVar15;
          }
        }

        psVar8 = (short *)0x0;

		// if no animation data
		if (*(int *)(iVar26 + 0x38) == 0) {
          puVar5 = &_gp_4;
          psVar8 = (short *)0x0;

		  // vertex data of non-animated model
		  puVar28 = *(uint **)(iVar26 + 0x24);

          *(undefined4 *)(unaff_s8 + 0xd4) = *(undefined4 *)(iVar26 + 0x30);
        }

		// if animation data
        else
		{
		  // pointer to animation
          iVar3 = *(int *)(*(int *)(iVar26 + 0x38) + (uint)param_21 * 4);

		  // current animation frame
		  uVar4 = param_22 & 0xffff;

		  // number of frames in animation
		  sVar1 = *(short *)(iVar3 + 0x10);

		  // frame size
		  uVar15 = (uint)*(ushort *)(iVar3 + 0x12);

		  // model -> anim -> offset0x14
		  *(undefined4 *)(unaff_s8 + 0xd4) = *(undefined4 *)(iVar3 + 0x14);

		  // current animation frame
		  *(uint *)(in_at + 0x80) = uVar4;

		  // last frame index
		  uVar10 = ((int)sVar1 & 0x7fffU) - 1;

		  // last frame index
          *(uint *)(in_at + 0x84) = uVar10;

		  // if negative number of frames in animation,
		  // 60fps
          if ((int)sVar1 < 0)
		  {
			// cut last frame in half
            uVar10 = uVar10 >> 1;

			// cut current frame in half
            uVar4 = param_22 >> 1 & 0x7fff;

			// odd numbered frames
            if ((param_22 & 1) != 0) {
              psVar8 = (short *)0xffffffff;
            }
          }

		  // if current frame is bigger than last frame
          if ((int)(uVar10 - uVar4) < 0)
		  {
			// set current frame to last frame
            uVar4 = uVar10;
          }

          if (((*(int *)(in_at + 0x90) == 0) && ((undefined *)register0x00000074 == unaff_s8)) &&
             (param_22 = *(int *)(in_at + 0x80) - 1, *(int *)(in_at + 0x80) < 1)) {
            puVar29 = (undefined *)0x8008cf7c;
            param_22 = 1;
          }

		  // model -> anim -> offset0x18, plus frame index * frame size ???
		  puVar28 = (uint *)(iVar3 + 0x18 + uVar4 * uVar15);

		  puVar5 = puVar29;
        }

		// short pos[x,y,z]
        uVar10 = *puVar28;
        iVar3 = (int)*(short *)(puVar28 + 1);

        uVar4 = 0xfff8ffff;

        *(short **)(in_at + 100) = psVar8;

		// if 60fps mode
		if (psVar8 != (short *)0x0)
		{
		  // origin data of next frame
          psVar8 = (short *)((int)puVar28 + uVar15);

		  // interpolate between
          uVar10 = ((int)psVar8[1] + ((int)uVar10 >> 0x10) >> 2) << 0x11 |
                   (int)*psVar8 + (int)(short)uVar10 >> 1 & 0xffffU;

		  // interpolate between
          iVar3 = iVar3 + psVar8[2] >> 1;
        }

		// origin data
        *(uint **)(unaff_s8 + 0xc0) = puVar28;

		// origin next frame?
        *(short **)(unaff_s8 + 0xc4) = psVar8;

        *(uint *)(unaff_s8 + 0x98) = uVar21;
        *(uint *)(unaff_s8 + 0x9c) = uVar22;
        *(uint *)(unaff_s8 + 0xa0) = uVar23;
        *(uint *)(unaff_s8 + 0xa4) = uVar24;
        *(uint *)(unaff_s8 + 0xa8) = uVar25;
        *(undefined4 *)(in_at + 0x68) = 0;
        *(undefined4 *)(in_at + 0x6c) = 0;
        if (((uint)puVar5 & 0x7000) == 0) {
LAB_80070f6c:

		  // model -> flags
          uVar7 = *(ushort *)(iVar26 + 0x16);

          puVar29 = puVar5;
LAB_80070f70:
          uVar4 = 0xfff8ffff;
          if ((((uint)puVar29 & 0x800) == 0) && ((uVar7 & 1) == 0)) {
            FUN_8006c558();
            *(uint *)(unaff_s8 + 0x78) = uVar21;
            *(uint *)(unaff_s8 + 0x7c) = uVar22;
            *(uint *)(unaff_s8 + 0x80) = uVar23;
            *(uint *)(unaff_s8 + 0x84) = uVar24;
            *(uint *)(unaff_s8 + 0x88) = uVar25;
			
			// MATRIX_SET_r11r12r13r14r15
            FUN_8006c540();
          }
          else {
LAB_80070f84:
            uVar4 = 0xfff8ffff;
            iVar9 = gte_stTRX();
            iVar14 = gte_stTRZ();
            if (((uint)puVar29 & 0x8000) != 0) {
              iVar9 = -iVar9;
            }
			
            gte_ldIR1(iVar9);
            gte_ldIR2(iVar14);
            gte_sqr0(0);
            iVar19 = gte_stMAC1();
            iVar27 = gte_stMAC2();

			// instance
			*(undefined4 *)(in_at + 0x88) = param_1;

			iVar19 = SquareRoot0(iVar19 + iVar27);
            uVar13 = 0x1000;
            uVar21 = (iVar14 << 0xc) / iVar19 & 0xffff;
            uVar22 = (iVar9 << 0xc) / iVar19 & 0xffff;
            uVar23 = -uVar22 & 0xffff;
            uVar15 = uVar21;

			// instance
            FUN_8006c49c(*(undefined4 *)(in_at + 0x88));

            gte_ldR11R12(0x1000);
            gte_ldR13R21(0);
            gte_ldR22R23(0xfffff600);
            gte_ldR31R32(0);
            gte_ldR33(0x1000);

			// same instance?
			FUN_8006c49c();

            *(uint *)(unaff_s8 + 0x78) = uVar21;
            *(uint *)(unaff_s8 + 0x7c) = uVar22;
            *(undefined4 *)(unaff_s8 + 0x80) = uVar13;
            *(uint *)(unaff_s8 + 0x84) = uVar23;
            *(uint *)(unaff_s8 + 0x88) = uVar15;
          }
        }
        else {
          *(undefined4 *)(in_at + 0x70) = 0;
          iVar9 = (int)sStack00000056 -
                  (*(int *)(in_at + 0x7c) +
                  (((int)uVar10 >> 0x10) / (int)*(short *)(in_at + 0x76) >> 0xc));
          if ((uVar21 | uVar22 | uVar23 | uVar24 | uVar25) == 0x1000) {
            iVar9 = (iVar9 * 0x1000) / (int)*(short *)(in_at + 0x76) << 2;
            *(short *)(unaff_s8 + 0xbe) = (short)iVar9;
            *(int *)(in_at + 0x68) = iVar9;
            puVar5 = (undefined *)((uint)puVar5 & 0xfffffeff);
            goto LAB_80070f6c;
          }
          iVar9 = iVar9 * 4;
          *(short *)(unaff_s8 + 0xbe) = (short)iVar9;
          if (((uint)puVar5 & 0x4000) == 0)
		  {
			// model -> flags
            uVar7 = *(ushort *)(iVar26 + 0x16);

			puVar29 = puVar5;
            if (-1 < iVar9 + 0x16a) goto code_r0x80070e84;
            goto LAB_80070f70;
          }

		  // model -> flags
          uVar7 = *(ushort *)(iVar26 + 0x16);

code_r0x80070e84:
          puVar29 = (undefined *)((uint)puVar5 & 0xfffffeff);
          *(undefined4 *)(in_at + 0x6c) = 0xfffffeff;
          
		  if ((((uint)puVar5 & 0x800) != 0) || ((uVar7 & 1) != 0)) goto LAB_80070f84;
		  
          FUN_8006c558();
		  
          uVar13 = gte_stL11L12();
          uVar18 = gte_stL13L21();
          uVar16 = gte_stL22L23();
          *(undefined4 *)(unaff_s8 + 0x78) = uVar13;
          *(undefined4 *)(unaff_s8 + 0x7c) = uVar18;
          *(undefined4 *)(unaff_s8 + 0x80) = uVar16;
          uVar13 = gte_stL31L32();
          uVar18 = gte_stL33();
		  
		  *(undefined4 *)(unaff_s8 + 0x84) = uVar13;
		  
		  // MATRIX_SET_r11r12r13r14r15
          FUN_8006c540();
          
		  *(undefined4 *)(unaff_s8 + 0x88) = uVar18;
        }
        iVar9 = (uVar10 & 0x3ffe3fff) * 4;
        iVar3 = iVar3 << 2;

        gte_ldVXY0(iVar9);
        gte_ldVZ0(iVar3);
        uVar4 = iVar9 + 0x3fcU & uVar4;
        gte_ldVXY1(uVar4);
        gte_ldVZ1(iVar3);
        gte_ldVXY2(uVar4 + 0x3fc0000);
        gte_ldVZ2(iVar3);
        gte_rtpt_b();
        iVar9 = gte_stSXY0();
        iVar27 = gte_stSZ1();
        iVar19 = iVar9 >> 0x10;
        uVar21 = (uint)(short)iVar9;

        gte_stSXY1();
        gte_stSZ2();

        uVar15 = uVar21;
        iVar9 = iVar19;
        iVar14 = iVar27;

        FUN_80071524();
        gte_stSXY2();
        gte_stSZ3();
        FUN_80071524();
        gte_ldVZ0(extraout_v1_00);
        gte_ldVZ1(extraout_v1_00);
        gte_ldVZ2(extraout_v1_00);
        gte_rtpt_b();
        gte_stSXY0();
        gte_stSZ1();
        FUN_80071524();
        gte_stSXY1();
        gte_stSZ2();
        FUN_80071524();
        gte_stSXY2();
        gte_stSZ3();
        FUN_80071524();
        gte_ldVXY0(extraout_v1_01);
        gte_ldVZ0(iVar3);
        gte_ldVXY1(extraout_v1_01);
        gte_ldVXY2(0);
        gte_ldVZ2(0);
        gte_rtpt();
        gte_stSXY0();
        gte_stSZ1();
        gte_stH();
        FUN_80071524();
        gte_stSXY1();
        gte_stSZ2();
        FUN_80071524();

        if (((uint)puVar29 & 0x100) != 0) {
          *(uint *)(psVar6 + 0x80) = iVar19 << 0x10 | uVar21 & 0xffff;
          uVar22 = uVar15 - uVar21 & 0xffff;
          *(uint *)(psVar6 + 0x82) = (iVar9 - iVar19) * 0x10000 | uVar22;
          if ((((((int)uVar21 < 0) || (iVar19 < 0)) || (0 < (iVar9 - iVar19) + -0x40)) ||
              ((0 < (int)(uVar22 - 0x60) || (-1 < (int)(uVar15 - (int)*(short *)(in_at + 0x3c))))))
             || (-1 < iVar9 - *(short *)(in_at + 0x3e))) {
            puVar29 = (undefined *)((uint)puVar29 & 0xfffffeff);
          }
        }
        if (((-1 < (int)uVar15) && (-1 < iVar9)) &&
           ((-1 < iVar27 - extraout_v1_02 &&
            (((int)(uVar21 - *(ushort *)(in_at + 0x3c)) < 1 &&
             ((int)(iVar19 - (uint)*(ushort *)(in_at + 0x3e)) < 1)))))) {
          iVar3 = (iVar14 >> 5) + -2;
          iVar9 = (iVar27 >> 5) + 1;
          *(short *)(unaff_s8 + 0xdc) = (short)iVar3;
          *(short *)(unaff_s8 + 0xde) = (short)iVar9;
          puVar28 = *(uint **)(in_at + 0x34);
          puVar11 = puVar28 + (iVar9 - iVar3);
          if (0 < *(int *)(in_at + 0x38) - (int)(puVar11 + 1)) {
            *(uint **)(in_at + 0x34) = puVar11 + 1;
            iVar14 = *(int *)(in_at + 0x8c) >> 6;
            puVar17 = puVar28;
            if (((uint)puVar29 & 0x100) == 0) {
              iVar14 = *(int *)(in_at + 0xbc) + iVar14;
              iVar19 = iVar14 * 4;
              if (iVar14 < 0) {
                iVar19 = 0;
              }
              else {
                if (0 < iVar19 + -0xffc) {
                  iVar19 = 0xffc;
                }
              }
              puVar20 = (uint *)(*(int *)(in_at + 0x30) + iVar19);
              uVar15 = *puVar20;
              *puVar20 = (uint)puVar11 & 0xffffff;
              *puVar28 = uVar15;
            }
            else {
              iVar14 = *(int *)(in_at + 0xbc) + iVar14;
              iVar19 = iVar14 * 4;
              if (iVar14 < 0) {
                iVar19 = 0;
              }
              else {
                if (0 < iVar19 + -0xffc) {
                  iVar19 = 0xffc;
                }
              }
              *(uint **)(psVar6 + 0x7a) = puVar28;
              *(uint **)(psVar6 + 0x7c) = puVar11;
              *(int *)(psVar6 + 0x7e) = iVar19;
              *puVar28 = 0;
            }
            while (puVar17 != puVar11) {
              puVar17[1] = (uint)puVar17 & 0xffffff;
              puVar17 = puVar17 + 1;
            }
            *(uint **)(unaff_s8 + 0xe4) = puVar28 + iVar3 * 0x3fffffff;
            *(uint **)(unaff_s8 + 0xe8) = puVar28 + iVar3 * 0x3fffffff;
            if ((((uint)puVar29 & 0x100) != 0) || (((uint)puVar29 & 0x6000) == 0)) {
LAB_80071478:
			  // RenderBucket_DrawFunc_Normal
              puVar5 = &FUN_8006a52c;

              goto LAB_80071480;
            }
            if (((uint)puVar29 & 0x4000) == 0) {
              puVar28 = *(uint **)(in_at + 0x34);
              if ((*(uint *)(in_at + 0x68) | *(uint *)(in_at + 0x6c)) == 0) goto LAB_80071478;
            }
            else {
              puVar28 = *(uint **)(in_at + 0x34);
            }
            puVar11 = puVar28 + (iVar9 - iVar3);
            if (*(int *)(in_at + 0x38) - (int)(puVar11 + 1) < 1) goto LAB_80071514;
            *(uint **)(in_at + 0x34) = puVar11 + 1;
            iVar9 = *(int *)(in_at + 0xc0) + (*(int *)(in_at + 0x8c) >> 6);
            iVar14 = iVar9 * 4;
            if (iVar9 < 0) {
              iVar14 = 0;
            }
            else {
              if (0 < iVar14 + -0xffc) {
                iVar14 = 0xffc;
              }
            }
            puVar17 = (uint *)(*(int *)(in_at + 0x30) + iVar14);
            uVar15 = *puVar17;
            *puVar17 = (uint)puVar11 & 0xffffff;
            *puVar28 = uVar15;
            puVar17 = puVar28;
            while (puVar17 != puVar11) {
              puVar17[1] = (uint)puVar17 & 0xffffff;
              puVar17 = puVar17 + 1;
            }
            uVar15 = *(uint *)(in_at + 0x68);
            if (((uint)puVar29 & 0x6000) == 0) goto LAB_80071478;
            uVar21 = *(uint *)(in_at + 0x6c);
            *(uint **)(unaff_s8 + 0xe8) = puVar28 + iVar3 * 0x3fffffff;
            if ((uVar15 | uVar21) == 0) {
code_r0x80071450:
              puVar5 = &LAB_8006bbc0;
LAB_80071480:
              puVar12 = &LAB_8006a8e0; // reference to FUN_8006a8e0(void), called later in this function indirectly. normal rendering, no special case like reflection, water/mud and or near clip
              if (*(int *)(in_at + 100) != 0) {
                puVar12 = &LAB_8006b24c; // reference to undefinedFunction_8006b24c(void), called later in this function indirectly, near clip maybe?
              }
            }
            else {
              if (uVar21 == 0) {
                if ((int)uVar15 < 0) {
                  if (((uint)puVar29 & 0x4000) == 0) goto LAB_80071478;
                  goto code_r0x80071450;
                }

				if (((uint)puVar29 & 0x4000) == 0)
				{
				  // RenderBucket_DrawFunc_Split
                  puVar5 = &UNK_8006b030;
                }

                else
				{
				  // Draw_KartBodyReflection
                  puVar5 = &LAB_8006c9c4; // reference to FUN_8006c9c4(void), called later in this function indirectly, reflection rendering

				  puVar29 = (undefined *)((uint)puVar29 | 0x100000);
                }

                goto LAB_80071480;
              }

              if (((uint)puVar29 & 0x4000) == 0)
			  {
				// RenderBucket_DrawFunc_Split
                puVar5 = &UNK_8006b030;
              }

			  else
			  {
				// Draw_KartBodyReflection
                puVar5 = &LAB_8006c9c4; // reference to FUN_8006c9c4(void), called later in this function indirectly, reflection rendering

				puVar29 = (undefined *)((uint)puVar29 | 0x100000);
              }

			  // Draw_KartInWaterMud
			  puVar12 = &LAB_8006bf30; // reference to FUN_8006bf30(void), called later in this function indirectly, under water or mud

			  if (*(int *)(in_at + 100) != 0) {
                puVar12 = &LAB_8006cdec; // reference to FUN_8006cdec(void), called later in this function indirectly. underwater or in mud something and near clip??
              }
            }
            *(BADSPACEBASE **)param_3 = register0x00000074;
            *(undefined **)(param_3 + 4) = unaff_s8;
            puVar29 = (undefined *)((uint)puVar29 | 0x40);

			// function to render the instance
            *(undefined **)(unaff_s8 + 0xec) = puVar5;

			// function for something else?
			*(undefined **)(unaff_s8 + 0xf0) = puVar12;

			// ptrCommandList, ptrTexLayout, and ptrColors
            uVar13 = *(undefined4 *)(iVar26 + 0x28);
            uVar18 = *(undefined4 *)(iVar26 + 0x2c);
            *(undefined4 *)(unaff_s8 + 200) = *(undefined4 *)(iVar26 + 0x20);
            *(undefined4 *)(unaff_s8 + 0xcc) = uVar13;
            *(undefined4 *)(unaff_s8 + 0xd0) = uVar18;
          }
        }
        goto LAB_80071514;
      }

	  // keep count of model header
      iVar3 = iVar3 + 1;

	  // next model header
      iVar26 = iVar26 + 0x40;

    } while (iVar27 != 0);

	// erase pointer to model header
    *(undefined4 *)(unaff_s8 + 0xe0) = 0;
  }
LAB_80071514:
  *(undefined **)(unaff_s8 + 0xb8) = puVar29;
  return;
}


void FUN_80071524(void)
{
        80071524 03 44 09 00     sra        t0,t1,0x10
        80071528 23 40 0d 01     subu       t0,t0,t5
        8007152c 02 00 01 05     bgez       t0,LAB_80071538
        80071530 03 44 09 00     _sra       t0,t1,0x10
        80071534 03 6c 09 00     sra        t5,t1,0x10
                             LAB_80071538                                    XREF[1]:     8007152c(j)  
        80071538 23 40 0e 01     subu       t0,t0,t6
        8007153c 02 00 00 19     blez       t0,LAB_80071548
        80071540 00 00 00 00     _nop
        80071544 03 74 09 00     sra        t6,t1,0x10
                             LAB_80071548                                    XREF[1]:     8007153c(j)  
        80071548 00 4c 09 00     sll        t1,t1,0x10
        8007154c 03 44 09 00     sra        t0,t1,0x10
        80071550 23 40 0b 01     subu       t0,t0,t3
        80071554 02 00 01 05     bgez       t0,LAB_80071560
        80071558 03 44 09 00     _sra       t0,t1,0x10
        8007155c 03 5c 09 00     sra        t3,t1,0x10
                             LAB_80071560                                    XREF[1]:     80071554(j)  
        80071560 23 40 0c 01     subu       t0,t0,t4
        80071564 02 00 00 19     blez       t0,LAB_80071570
        80071568 23 40 4f 01     _subu      t0,t2,t7
        8007156c 03 64 09 00     sra        t4,t1,0x10
                             LAB_80071570                                    XREF[1]:     80071564(j)  
        80071570 02 00 01 05     bgez       t0,LAB_8007157c
        80071574 23 40 50 01     _subu      t0,t2,s0
        80071578 21 78 40 01     move       t7,t2
                             LAB_8007157c                                    XREF[1]:     80071570(j)  
        8007157c 02 00 00 19     blez       t0,LAB_80071588
        80071580 00 00 00 00     _nop
        80071584 21 80 40 01     move       s0,t2
                             LAB_80071588                                    XREF[1]:     8007157c(j)  
        80071588 08 00 e0 03     jr         ra
        8007158c 00 00 00 00     _nop

}


// copies data to scratchpad
void FUN_80071590(void)

{
  bool bVar1;
  int in_at;
  int iVar2;
  undefined **ppuVar3;
  undefined4 *puVar4;
  undefined *puVar5;

  // in_at = 0x1F800000

  iVar2 = 7;
  ppuVar3 = &PTR_LAB_8008a428;
  puVar4 = (undefined4 *)(in_at + 0x94);
  do {
    puVar5 = *ppuVar3;
    ppuVar3 = ppuVar3 + 1;
    *(undefined **)puVar4 = puVar5;
    puVar4 = puVar4 + 1;
    bVar1 = 0 < iVar2;
    iVar2 = iVar2 + -1;
  } while (bVar1);

  iVar2 = 7;
  ppuVar3 = &PTR_LAB_8008a444;
  puVar4 = (undefined4 *)(in_at + 0xc4);
  do {
    puVar5 = *ppuVar3;
    ppuVar3 = ppuVar3 + 1;
    *(undefined **)puVar4 = puVar5;
    puVar4 = puVar4 + 1;
    bVar1 = 0 < iVar2;
    iVar2 = iVar2 + -1;
  } while (bVar1);

  return;
}



// WARNING: Removing unreachable block (ram,0x80071690)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// execute all thread update functions
// in one thread bucket
void FUN_800715e8(undefined4 param_1)

{
  undefined4 *puVar1;
  int iVar2;
 
  // this must be $a0 to work
  int iVar3;
  
  int iVar4;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  undefined4 unaff_s7;
  undefined4 unaff_s8;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];

  _DAT_1f8000d0 = &_gp_4;
  
  // start of thread hierarchy stack
  DAT_1f8000e4 = &DAT_1f800004;
  
  _DAT_1f8000b0 = unaff_s0;
  DAT_1f8000b4 = unaff_s1;
  DAT_1f8000b8 = unaff_s2;
  DAT_1f8000bc = unaff_s3;
  DAT_1f8000c0 = unaff_s4;
  DAT_1f8000c4 = unaff_s5;
  DAT_1f8000c8 = unaff_s6;
  DAT_1f8000cc = unaff_s7;
  DAT_1f8000d4 = (undefined *)register0x00000074;
  _DAT_1f8000d8 = unaff_s8;
  
  // backup $ra manually
  DAT_1f8000dc = unaff_retaddr;
  
  // first thread to execute in thread bucket
  _DAT_1f8000e8 = param_1;
  
  while( true )
  {
	// get thread on stack
    iVar3 = DAT_1f8000e4[0x39];

	// check if we go out of range
    if ((int)(DAT_1f8000e4 + -0x7e00001) < 0) break;

	// thread -> next
    iVar2 = *(int *)(iVar3 + 0x10);

	// cooldown
    iVar4 = *(int *)(iVar3 + 0x18);

	// set next thread to sibling
    DAT_1f8000e4[0x39] = iVar2;

	// shift stack back, go back to parent,
	// if this thread has no more siblings,
	// and if this was a child thread
    puVar1 = DAT_1f8000e4 + -1;
	
	// or if there is a sibling
    if (iVar2 != 0) 
	{
	  // continue with sibling
      puVar1 = DAT_1f8000e4;
    }
	
	// next thread
    DAT_1f8000e4 = puVar1;

	// if cooldown is not negative
    if (-1 < iVar4)
	{
	  // if there is no cooldown, execute thread
      if (iVar4 == 0)
	  {
		// if thread has per-frame funcPtr
        if (*(code **)(iVar3 + 0x2c) != (code *)0x0)
		{
          DAT_1f8000e0 = iVar3;

		  // execute ThTick funcPtr,
		  // most of these can't JR RA back, cause $RA
		  // is not backed up on stack memory, so the
		  // threads JAL back to one of two labels...
		  (**(code **)(iVar3 + 0x2c))(iVar3);

// ThTick_SetAndExec, called from ThTick,
// cancels the previous ThTick, and goes here,
// or if you did an ordinary JR RA from a ThTick,
// like TNT thread does
LAB_80071678:

		  // return here, only if you can't 
		  // call JAL 80071694 with thread 
		  // as a1, cause then thread has
		  // to be pulled off scratchpad
		  iVar3 = DAT_1f8000e0;
        }

// where threads JAL in an infinite loop,
// iVar3 is set to what it was before ThTick
// ran, because ThTick passed thread as 
// paramter to this JAL
LAB_80071694:

		// child thread
        iVar3 = *(int *)(iVar3 + 0x14);
		
		// set child thread as next hierarchy in the stack
        DAT_1f8000e4[0x3a] = iVar3;

		if (iVar3 != 0) 
		{
		  // advance stack, treat child as current,
		  // and continue advancing the stack for 
		  // further hierarchal children
          DAT_1f8000e4 = DAT_1f8000e4 + 1;
        }
      }

	  // if cooldown exists
      else
	  {
		// reduce cooldown
        *(int *)(iVar3 + 0x18) = iVar4 + -1;
      }
    }
  }
  
  // go back a generation
  DAT_1f8000e4 = DAT_1f8000e4 + -1;
  
  // $ra resets to value at 1f8000dc,
  // then function returns
  return;
}


// ThTick_SetAndExec
void FUN_800716ec(int param_1,code *UNRECOVERED_JUMPTABLE)

{
  // Set per-frame funcPtr
  *(code **)(param_1 + 0x2c) = UNRECOVERED_JUMPTABLE;

  // Execute the weapon's function pointer
  // with JR $a1
  (*UNRECOVERED_JUMPTABLE)();
  
  // $ra is set to 80071678 and executes
  // when the thread is finished
}


// ThTick_Set
void FUN_80071704(int param_1,undefined4 param_2)

{
  *(undefined4 *)(param_1 + 0x2c) = param_2;
  return;
}

// compiler-generated entry
void start(void)

{
  int iVar1;
  undefined4 *puVar2;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined *puVar3;
  undefined4 unaff_retaddr;
  undefined4 uVar4;

  // memset BSS to zero
  puVar2 = &DAT_8008d668;
  do {
    *puVar2 = 0;
    puVar2 = puVar2 + 1;
  } while (puVar2 < &DAT_8009f6fc);

  puVar3 = (undefined *)(DAT_8008cb38 - 8U | 0x80000000);
  DAT_8008c058 = ((DAT_8008cb38 - 8U) - DAT_8008cb34) + -0x9f6fc;

  // end of BSS, start of overlay1
  DAT_8008c054 = &DAT_8009f6fc;

  // save $ra
  DAT_8008da04 = unaff_retaddr;

  InitHeap(&DAT_8009f700,DAT_8008c058,*puVar3);
  uVar4 = 0x800779e0;

  // start the "main" function
  main();

  iVar1 = DAT_8008c050;
  trap(1);
  *(undefined4 *)(puVar3 + -0xc) = unaff_s0;
  *(undefined4 *)(puVar3 + -8) = unaff_s1;
  *(undefined4 *)(puVar3 + -4) = uVar4;
  if (iVar1 == 0) {
    DAT_8008c050 = 1;
  }

  // $ra is not restored from 8008da04,
  // so this just goes back to trap(1),
  // and the game can never really "end"
  return;
}



// WARNING: Removing unreachable block (ram,0x80077a24)

void __main(void)

{
  if (DAT_8008c050 == 0) {
    DAT_8008c050 = 1;
  }
  return;
}

// .text
// ram:800123e0-ram:8008099f
