// This project began March 30, 2020

// exe: 825/872

// all:
// (824+10+86+130+37+49)/(871+10+86+130+37+49)
// 96.02%

typedef unsigned char   undefined;

typedef unsigned char    byte;
typedef unsigned int    dword;
typedef unsigned char    uchar;
typedef unsigned long    ulong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined4;
typedef unsigned short    ushort;
typedef unsigned short    word;
typedef unsigned short    wchar16;
typedef uchar u_char;

typedef ushort u_short;

typedef ulong u_long;

typedef struct MATRIX MATRIX, *PMATRIX;

struct MATRIX {
    short m[3][3];
    long t[3];
};

typedef struct VECTOR VECTOR, *PVECTOR;

struct VECTOR {
    long vx;
    long vy;
    long vz;
    long pad;
};

typedef struct SVECTOR SVECTOR, *PSVECTOR;

struct SVECTOR {
    short vx;
    short vy;
    short vz;
    short pad;
};

typedef uchar PACKET;

typedef struct DIRENTRY DIRENTRY, *PDIRENTRY;

// Part of parsing directories in BIGFILE
struct DIRENTRY {
    char name[20];
    long attr;
    long size;
    struct DIRENTRY * next;
    long head;
    char system[4];
};

typedef struct SpuDecodedData SpuDecodedData, *PSpuDecodedData;

struct SpuDecodedData {
    short cd_left[512];
    short cd_right[512];
    short voice1[512];
    short voice3[512];
};

typedef struct SpuReverbAttr SpuReverbAttr, *PSpuReverbAttr;

typedef struct SpuVolume SpuVolume, *PSpuVolume;

struct SpuVolume {
    short left;
    short right;
};

struct SpuReverbAttr {
    ulong mask;
    long mode;
    struct SpuVolume depth;
    long delay;
    long feedback;
};

typedef void (* SpuIRQCallbackProc)(void);

typedef void (* SpuTransferCallbackProc)(void);

typedef struct CdlLOC CdlLOC, *PCdlLOC;

struct CdlLOC {
    u_char minute;
    u_char second;
    u_char sector;
    u_char track;
};

typedef struct CdlFILE CdlFILE, *PCdlFILE;

struct CdlFILE {
    struct CdlLOC pos;
    u_long size;
    char name[16];
};

typedef void (* CdlCB)(u_char, u_char *);

typedef struct RECT RECT, *PRECT;

struct RECT {
    short x;
    short y;
    short w;
    short h;
};

typedef struct DR_ENV DR_ENV, *PDR_ENV;

struct DR_ENV {
    u_long tag;
    u_long code[15];
};

typedef struct DR_MOVE DR_MOVE, *PDR_MOVE;

struct DR_MOVE {
    u_long tag;
    u_long code[5];
};

typedef struct DISPENV DISPENV, *PDISPENV;

struct DISPENV {
    struct RECT disp;
    struct RECT screen;
    u_char isinter;
    u_char isrgb24;
    u_char pad0;
    u_char pad1;
};

typedef struct DRAWENV DRAWENV, *PDRAWENV;

struct DRAWENV {
    struct RECT clip;
    short ofs[2];
    struct RECT tw;
    u_short tpage;
    u_char dtd;
    u_char dfe;
    u_char isbg;
    u_char r0;
    u_char g0;
    u_char b0;
    struct DR_ENV dr_env;
};

// .text
// ram:800123e0-ram:8008099f
// BOTS.c: 			800123e0 - 800175cb 
// CAM.c: 			800175cc - 8001c35f
// CDSYS.c:			8001c360 - 8001d093
// COLL.c:			8001d094 - 800214ff
// CTR.c:			80021500 - 800222df
// DEBUGFONT.c:		800222e0 - 800223f3
// DECALFONT.c:		800223f4 - 80022b93
// DECALGLOBAL.c:	80022b94 - 80022daf
// DECALHUD.c:		80022db0 - 80023487
// DECALMP.c:		80023488 - 80023a3f
// DISPLAY.c:		800a3a40 - 8002406b
// DOTLIGHTS.c:		8002406c - 80024463
// EffectSfxRain.c:	80024464 - 80024523
// ElimBG.c:		80024524 - 80024c4b
// FLARE.c:			80024c4c - 800251ab
// GAMEPAD.c:		800251ac - 800265bf
// GAMEPROG.c:		800265c0 - 80026ed7
// GHOSTBUFFER.c:	80026ed8 - 8002843b
// HOWL.c:			8002843c - 80030777

// INSTANCE_Birth
// param1 ptrInstance
// param2 ptrModel
// param3 name string
// param4 thread
// param5 instance flags
void FUN_80030778(int param_1,undefined4 param_2,undefined *param_3,undefined4 param_4,
                 undefined4 param_5)

{
  bool bVar1;
  undefined *puVar2;
  undefined *puVar3;
  int iVar4;
  int iVar5;

  // name gets stored 8 bytes into instance
  puVar3 = (undefined *)(param_1 + 8);

  // name can be 16 bytes long, max
  puVar2 = (undefined *)(param_1 + 0x17);

  // loop through 16 characters
  bVar1 = puVar2 < puVar3;
  if (puVar3 < puVar2) {

	// copy string from parameter into instance
	do {
      *puVar3 = *param_3;
      puVar3 = puVar3 + 1;
      param_3 = param_3 + 1;
    } while (puVar3 < puVar2);
    bVar1 = puVar2 < puVar3;
  }

  while (!bVar1) {
    *puVar3 = 0;
    puVar3 = puVar3 + 1;
    bVar1 = puVar2 < puVar3;
  }
  *(undefined *)(param_1 + 0x50) = 0xfe;
  *(undefined *)(param_1 + 0x51) = 0xc;

  // animation
  *(undefined *)(param_1 + 0x52) = 0;

  *(undefined *)(param_1 + 0x53) = 1;

  puVar3 = PTR_DAT_8008d2ac;

  // model pointer
  *(undefined4 *)(param_1 + 0x18) = param_2;

  // set scale (x, y, z)
  *(undefined2 *)(param_1 + 0x1c) = 0x1000;
  *(undefined2 *)(param_1 + 0x1e) = 0x1000;
  *(undefined2 *)(param_1 + 0x20) = 0x1000;

  *(undefined2 *)(param_1 + 0x22) = 0;
  *(undefined4 *)(param_1 + 0x24) = 0;
  *(undefined4 *)(param_1 + 0x2c) = 0;
  *(undefined2 *)(param_1 + 0x54) = 0;
  *(undefined2 *)(param_1 + 0x56) = 0;
  *(undefined4 *)(param_1 + 0x58) = 0x7f7f7f;

  // set thread
  *(undefined4 *)(param_1 + 0x6c) = param_4;

  *(undefined4 *)(param_1 + 0x70) = 0;

  // set flags
  *(undefined4 *)(param_1 + 0x28) = param_5;

  // loop counter
  iVar4 = 0;

  // if number of screens is not zero
  if (puVar3[0x1ca8] != '\0')
  {
	// offset of 8008d2ac where camera110 structs
	// are held for each player (pos, size, etc)
    iVar5 = 0x168;

	// loop for the number of screens,
	// each instance's InstDrawPerPlayer
    do
	{
	  // pointer to camera110 struct
      puVar2 = puVar3 + iVar5;

	  // increment pointer to next winow struct
      iVar5 = iVar5 + 0x110;

	  // pointer to LOD ModelHeader
      *(undefined4 *)(param_1 + 0xe0) = 0;

	  // camera110
      *(undefined **)(param_1 + 0x74) = puVar2;

	  // inst flags per player
	  *(undefined4 *)(param_1 + 0xb8) = 0;

	  // increment loop counter
      iVar4 = iVar4 + 1;

	  // next InstDrawPerPlayer
      param_1 = param_1 + 0x88;

    } while (iVar4 < (int)(uint)(byte)puVar3[0x1ca8]);
  }
  return;
}


// param1 = model pointer
// param2 = name string
// param3 = thread (can be null)
// INSTANCE_Birth3D
int FUN_8003086c(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  int iVar1;

  // PTR_DAT_8008d2ac + 0x18f8
  // Instance Pool

  // AllocPool_Add in Instance Pool
  iVar1 = FUN_800310d4(PTR_DAT_8008d2ac + 0x18f8);

  // check if the instance allocated properly
  if (iVar1 != 0)
  {
	// INSTANCE_Birth
	// 0xf instance flags, means model will draw
    FUN_80030778(iVar1,param_1,param_2,param_3,0xf);
  }
  return iVar1;
}

// param1 = model pointer
// param2 = name string
// param3 = thread (can be null)
// INSTANCE_Birth2D
int FUN_800308e4(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  int iVar1;
  undefined *puVar2;
  int iVar3;
  int iVar4;

  // AllocPool_Add in Instance Pool
  iVar3 = FUN_800310d4(PTR_DAT_8008d2ac + 0x18f8);

  // check if the instance allocated properly
  if (iVar3 != 0)
  {
	// INSTANCE_Birth
	// iVar3 is instance allocated
	// instance flag & 0x400, means screenspace
    FUN_80030778(iVar3,param_1,param_2,param_3,0x40f);
  }

  puVar2 = PTR_DAT_8008d2ac;

  // camera110_UI
  *(undefined **)(iVar3 + 0x74) = PTR_DAT_8008d2ac + 5000;

  // iteration counter starts at 1, not 0
  iVar4 = 1;

  // copy pointer to instance
  iVar1 = iVar3;

  // if number of screens is more than 1
  if (1 < (byte)puVar2[0x1ca8])
  {
	// for iVar4 = 1 (not zero); iVar4 < numScreens; iVar4++)
    do 
	{
	  // cam110 pointer for P2, P3, P4
      *(undefined4 *)(iVar1 + 0xfc) = 0;

	  // increment loop counter
      iVar4 = iVar4 + 1;

	  // next InstDrawPerPlayer
      iVar1 = iVar1 + 0x88;
    } while (iVar4 < (int)(uint)(byte)puVar2[0x1ca8]);
  }
  return iVar3;
}


// INSTANCE_BirthWithThread -- ND name
// Create Thread, Object, and Instance
// param1 is model ID (see 96b20+2160)
// param2 is a string
// param3 is stackSize (small medium large)
// param4 is bucket type
// param5 is perFrame update func
// param6 is size in bytes, and relation to param7
// param7 is parent thread (driver shooting weapon), can be nullptr
undefined4
FUN_800309a4(int param_1,undefined4 param_2,uint param_3,uint param_4,undefined4 param_5,
            uint param_6,undefined4 param_7)

{
  undefined4 uVar1;
  int iVar2;
  int iVar3;

  // Get model pointer, given index in array from param1
  iVar3 = *(int *)(PTR_DAT_8008d2ac + param_1 * 4 + 0x2160);

  // Do nothing if the model is garbage
  if (iVar3 == 0)
  {
	// June 1999
	// printf("INSTANCE_BirthWithThread: object type %d not found!\n",param_1);

    uVar1 = 0;
  }

  // if model is valid
  else
  {
	// If the desired size is aligned 4 bytes
    if ((param_6 & 3) == 0)
	{
	  // bit shift and use
      param_6 = param_6 << 0x10;
    }

	// if the desired size is not aligned
    else
	{
	  // round up to the nearest 4 bytes, then bit shift
      param_6 = (param_6 - ((param_6 & 3) - 4)) * 0x10000;
    }

	// THREAD_BirthWithObject
    iVar2 = FUN_8004205c(param_3 | param_6 | param_4,param_5,param_2,param_7);

	/*

	June 1999
    if (iVar2 == 0) {
      printf("%s thread create failed (b)\n",param_2);
      do {
                    // WARNING: Do nothing block with infinite loop
      } while( true );
    }

	*/

	// set model index
	*(undefined2 *)(iVar2 + 0x44) = (short)param_1;

	// INSTANCE_Birth3D -- ptrModel, name, thread
    uVar1 = FUN_8003086c(iVar3,param_2,iVar2);

	/*

    if (iVar3 == 0) {
      printf("%s instance create failed (b)\n",param_2);
      do {
                    // WARNING: Do nothing block with infinite loop
      } while( true );
    }

	*/

	// set instance to the allocation in the pool
	*(undefined4 *)(iVar2 + 0x34) = uVar1;
  }

  // return instance
  return uVar1;
}


// INSTANCE_BirthWithThread_Stack
void FUN_80030a50(undefined4 *param_1)

{
  // same as previous function, but this time with struct instead of typing parameters by hand
  FUN_800309a4(*param_1,param_1[1],param_1[2],param_1[3],param_1[4],param_1[5],param_1[6]);
  return;
}


// param1 is an instance
// INSTANCE_Death
void FUN_80030aa8(undefined4 param_1)

{
  // AllocPool_Remove
  // 18f8 = Instance Pool
  FUN_8003112c(PTR_DAT_8008d2ac + 0x18f8,param_1);
  return;
}


// INSTANCE_LevInitAll
// copy InstDef to InstancePool
// param1 - pointer to Instance Descriptions
// param2 - number of instances
void FUN_80030ad4(undefined4 *param_1,int param_2)

{
  char cVar1;
  ushort uVar2;
  undefined *puVar3;
  undefined4 *puVar4;
  short sVar5;
  int iVar6;
  undefined4 *puVar7;
  undefined4 *puVar8;
  undefined *puVar9;
  short sVar10;
  undefined4 *puVar11;
  int iVar12;
  int iVar13;
  int iVar14;
  undefined4 uVar15;
  undefined4 uVar16;
  undefined4 uVar17;
  int *piVar18;
  int iVar19;

  iVar19 = 0;

  // loop through all instances
  if (0 < param_2)
  {
	// InstDef starting address of important data
	// (skip name[0x10])
    piVar18 = param_1 + 4;

	do
	{
	  // LIST_RemoveFront
	  // get first free item in Instance Pool
      iVar6 = FUN_8003186c(PTR_DAT_8008d2ac + 0x18f8);

	  // NOT writing to model
	  // InstDef + 0x10 + 0x1c
	  // InstDef -> 0x2C = ptrInstance
	  piVar18[7] = iVar6;

	  // if allocation failed
	  if (iVar6 == 0)
	  {
		// June 1999
		// printf("OOPS! more instdefs than instances");

		// quit
        return;
      }

	  // pointer to InstDef in LEV
	  puVar8 = param_1;

	  // pointer to instance in pool,
	  // add 8 bytes to skip Prev and Next
      puVar4 = (undefined4 *)(iVar6 + 8);

	  // copy InstDef data from LEV to instance pool
      do
	  {
        puVar11 = puVar4;
        puVar7 = puVar8;
        uVar15 = puVar7[1];
        uVar16 = puVar7[2];
        uVar17 = puVar7[3];
        *puVar11 = *puVar7;
        puVar11[1] = uVar15;
        puVar11[2] = uVar16;
        puVar11[3] = uVar17;
        puVar8 = puVar7 + 4;
        puVar4 = puVar11 + 4;
      } while (puVar8 != param_1 + 8);

      uVar15 = puVar7[5];
      uVar16 = puVar7[6];
      puVar11[4] = *puVar8;
      puVar11[5] = uVar15;
      puVar11[6] = uVar16;
      *(char *)(iVar6 + 0x50) = *(char *)(piVar18 + 5) + -2;
      cVar1 = *(char *)(piVar18 + 5);

	  // reflect color
	  *(undefined4 *)(iVar6 + 0x58) = 0x7f7f7f;

      *(undefined *)(iVar6 + 0x52) = 0;
      *(undefined2 *)(iVar6 + 0x54) = 0;

	  // instace -> ptrInstDef
	  // the two are now linked on both ends
      *(undefined4 **)(iVar6 + 0x2c) = param_1;

	  *(undefined2 *)(iVar6 + 0x56) = 0;
      *(undefined *)(iVar6 + 0x53) = 1;
      *(undefined4 *)(iVar6 + 0x70) = 0;
      *(char *)(iVar6 + 0x51) = cVar1 + '\f';

	   // convert 3 rotation shorts into rotation matrix,
	   // offset 0x36 is InstDef rotation data
      FUN_8006c2a4(iVar6 + 0x30,(int)param_1 + 0x36);

      puVar3 = PTR_DAT_8008d2ac;

	  // instance posX and posY
      *(int *)(iVar6 + 0x44) = (int)*(short *)(piVar18 + 8);
      *(int *)(iVar6 + 0x48) = (int)*(short *)((int)piVar18 + 0x22);

	  // instance posZ
      sVar10 = *(short *)(piVar18 + 9);

	  // instance -> thread = nullptr;
      *(undefined4 *)(iVar6 + 0x6c) = 0;

	  // instance posZ
      *(int *)(iVar6 + 0x4c) = (int)sVar10;

	  // loop iteration counter
      iVar13 = 0;

	  // if number of screens is not zero
      if (puVar3[0x1ca8] != '\0')
	  {
		// offset of 8008d2ac where camera110 structs
		// are held for each player (pos, size, etc)
        iVar14 = 0x168;

        iVar12 = iVar6;

		// loop through InstDrawPerPlayer
		// for iVar13 = 0; iVar13 < numScreens; iVar13++
        do
		{
		  // pointer to camera110 struct
          puVar9 = puVar3 + iVar14;

		  // increment pointer to next camera110 struct
          iVar14 = iVar14 + 0x110;

		  // LOD ModelHeader
          *(undefined4 *)(iVar12 + 0xe0) = 0;

		  // camera110
          *(undefined **)(iVar12 + 0x74) = puVar9;

		  // increment counter
          iVar13 = iVar13 + 1;

		  // next InstDrawPerPlayer
          iVar12 = iVar12 + 0x88;
		  
        } while (iVar13 < (int)(uint)(byte)puVar3[0x1ca8]);
      }

      if (
		  (
			// Only continue if LEV instances are enabled,
			// they may be disabled due to podium scene on adv hub
			((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x100) == 0) &&

			(
				// ThreadMeta
				iVar13 = FUN_8001d094((int)*(short *)(*piVar18 + 0x10)),

				// if pointer is not nulllptr
				iVar13 != 0
			)
		  ) &&

		  // If funcLevInstDefBirth
          (*(code **)(iVar13 + 4) != (code *)0x0)
		 )
	  {
		// call funcLevInstDefBirth, make thread for this instance
        (**(code **)(iVar13 + 4))(iVar6);
      }

      if (
			(
				// If you're not in Time Trial
				(*(uint *)PTR_DAT_8008d2ac & 0x20000) == 0
			) ||

			// OR, if you're in time trial, with these conditions...
			(
				(
					(
						// model ID
						uVar2 = *(ushort *)(*piVar18 + 0x10),

						// if PU_TIME_CRATE (1,2,3)
						1 < (uint)uVar2 - 7 &&

						// if not wumpa fruit
						(uVar2 != 2)
					) &&
					(
						(
							// not STATIC_TIME_CRATE_01
							uVar2 != 0x5c &&
							(
								(
									// not STATIC_TIME_CRATE_02
									uVar2 != 100 &&

									// not STATIC_TIME_CRATE_03
									(uVar2 != 0x65)
								)
							)
						)
					)
				)
			)
		 )
	  {

		// If you're not in a Relic Race
        if ((*(uint *)PTR_DAT_8008d2ac & 0x4000000) == 0)
		{
		  // model ID
          sVar10 = *(short *)(*piVar18 + 0x10);

		  // time crate (1,2,3)
		  if ((sVar10 != 0x5c) && (sVar5 = 0x65, sVar10 != 100)) {
LAB_80030d94:
            if (sVar10 != sVar5) goto LAB_80030dac;
          }
          goto LAB_80030d9c;
        }

		// model ID
        sVar10 = *(short *)(*piVar18 + 0x10);

		// time crate (1,2,3)
		if ((sVar10 != 0x5c) && ((sVar10 != 100 && (sVar10 != 0x65))))
		{
          sVar5 = 2;

		  // PU_TIME_CRATE (what's the difference)?
          if (1 < (ushort)(*(short *)(*piVar18 + 0x10) - 7U)) goto LAB_80030d94;

		  goto LAB_80030d9c;
        }

		// increase count in time crates
        *(int *)(PTR_DAT_8008d2ac + 0x1e2c) = *(int *)(PTR_DAT_8008d2ac + 0x1e2c) + 1;
      }

	  // in time trial, and conditions are not met
      else
	  {
		// do not draw instance
LAB_80030d9c:
        *(uint *)(iVar6 + 0x28) = *(uint *)(iVar6 + 0x28) & 0xfffffff0;
      }
LAB_80030dac:
	  // If you're not in Crystal Challenge (in adventure mode)
      if ((*(uint *)PTR_DAT_8008d2ac & 0x8000000) == 0)
	  {
		// modelID
        sVar10 = *(short *)(*piVar18 + 0x10);

		// disable anything that isn't Crystal, TNT, or Nitro
        if ((sVar10 != 0x60) && (sVar5 = 0x27, sVar10 != 6)) goto LAB_80030e18;
LAB_80030e20:
        *(uint *)(iVar6 + 0x28) = *(uint *)(iVar6 + 0x28) & 0xfffffff0;
      }

	  // If you're in crystal challenge
      else
	  {
		// get model ID
        sVar10 = *(short *)(*piVar18 + 0x10);

		// fruit crate
		sVar5 = 7;

		// if modelID is crystal
		if (sVar10 == 0x60)
		{
		  // increase numCrystals in LEV
          *(int *)(PTR_DAT_8008d2ac + 0x1e28) = *(int *)(PTR_DAT_8008d2ac + 0x1e28) + 1;
        }

		// if not crystal
		else
		{
LAB_80030e18:

		  // if model is fruit crate,
		  // dont draw instance, dont collide, etc
          if (sVar10 == sVar5) goto LAB_80030e20;
        }
      }


      if (
			(
				// If you're not in Adventure Mode
				((*(uint *)PTR_DAT_8008d2ac & 0x80000) == 0) ||

				// If you're not in a CTR Token race
				((*(uint *)(PTR_DAT_8008d2ac + 8) & 8) == 0)
			) &&

			// If any of the C-T-R letter instances appear
			((uint)*(ushort *)(*piVar18 + 0x10) - 0x93 < 3)
			)
	  {
		// disable them
        *(uint *)(iVar6 + 0x28) = *(uint *)(iVar6 + 0x28) & 0xfffffff0;
      }

	  // loop counter
      iVar19 = iVar19 + 1;

      piVar18 = piVar18 + 0x10;

	  // next InstDef
      param_1 = param_1 + 0x10;

    } while (iVar19 < param_2);
  }
  return;
}

// INSTANCE_LevRestartLInBs
// only for lev swap, or podium->driving (233->232)
void FUN_80030ed4(int param_1,int param_2)

{
  int iVar1;
  undefined4 *puVar2;
  int iVar3;

  iVar3 = 0;

  // if numInstance is more than zero
  if (0 < param_2)
  {
	// first instance -> InstDef
    puVar2 = (undefined4 *)(param_1 + 0x2c);

	// loop through all instances
	do
	{
	  // ThreadMeta
	  // model -> modelID
      iVar1 = FUN_8001d094((int)*(short *)(puVar2[-7] + 0x10));

	  if (
			// if pointer is not nullptr
			(iVar1 != 0) &&

			// if funcLevInstDefBirth
			(*(code **)(iVar1 + 4) != (code *)0x0))
	  {
		// execute funcLevInstDefBirth, make thread for this instance
        (**(code **)(iVar1 + 4))(*puVar2);
      }

	  // index counter
	  iVar3 = iVar3 + 1;

	  // next InstDef
      puVar2 = puVar2 + 0x10;

    } while (iVar3 < param_2);
  }
  return;
}

// INSTANCE_GetNumAnimFrames
// param_1 is instance
// param_2 is animation index (for models with many animations)
undefined4 FUN_80030f58(int param_1,int param_2)

{
  int iVar1;

  // instance -> model
  iVar1 = *(int *)(param_1 + 0x18);

  if (
		(
			(
				// if model is valid
				(iVar1 != 0) &&

				// if model has more than one model_header
				(0 < *(short *)(iVar1 + 0x12))
			) &&
			(
				// get pointer to first model_header
				iVar1 = *(int *)(iVar1 + 0x14),

				// if pointer to model_header is valid
				iVar1 != 0
			)
		) &&

		// param_2 is less than numAnimations
		(param_2 < *(int *)(iVar1 + 0x34))
	  )
  {
	// if pointer to animatino data is valid
    if (*(int *)(iVar1 + 0x38) != 0)
	{
	  // get pointer to animation, from array of animation pointers
      iVar1 = *(int *)(param_2 * 4 + *(int *)(iVar1 + 0x38));

	  // if animation data is valid
      if (iVar1 != 0)
	  {
		// return number of frames
        return (uint)*(ushort *)(iVar1 + 0x10) & 0x7fff;
      }
      return 0;
    }
  }
  return 0;
}

// AllocPool_Clear
void FUN_80030fdc(int param_1)

{
  uint uVar1;
  int iVar2;

  // Ptr to first element in pool
  iVar2 = *(int *)(param_1 + 0x24);

  // loop counter
  uVar1 = 0;

  // LIST_Clear free
  FUN_80031734(param_1);

  // LIST_Clear taken
  FUN_80031734(param_1 + 0xc);

  // If there are elements in the array
  if (*(int *)(param_1 + 0x18) != 0)
  {
	// loop through every element
    do
	{
	  // LIST_AddFront
	  // add to free list
      FUN_80031744(param_1,iVar2);

	  // increment loop counter
	  uVar1 = uVar1 + 1;

	  // Add the size of each element
      iVar2 = iVar2 + (*(uint *)(param_1 + 0x1c) & 0xfffffffc);

    } while (uVar1 < *(uint *)(param_1 + 0x18));
  }
  return;
}

// AllocPool_Init
// param_1 = pointer
// param_2 = width or array length
// param_3 = height or sizeof(struct)
// param_4 = name
void FUN_8003105c(int param_1,int param_2,int param_3,undefined4 param_4)
{
  memset(param_1,0,0x28);

  // max items
  // size of item
  // size of pool
  *(int *)(param_1 + 0x18) = param_2;
  *(int *)(param_1 + 0x1c) = param_3;
  *(int *)(param_1 + 0x20) = param_2 * param_3;

  // MEMPACK_AllocMem
  uVar1 = FUN_8003e874(param_2 * param_3,param_4);

  // pointer to first element in pool
  *(undefined4 *)(param_1 + 0x24) = uVar1;

  // AllocPool_Clear
  FUN_80030fdc(param_1);

  return;
}


// AllocPool_Add
int FUN_800310d4(int *param_1)

{
  int iVar1;

  iVar1 = *param_1;

  if (iVar1 == 0)
  {
    iVar1 = 0;
  }

  else
  {
	// remove member from free
    // LIST_RemoveMember
    FUN_800317e4(param_1,iVar1);

	// add member to taken
    // LIST_AddFront
    FUN_80031744(param_1 + 3,iVar1);
  }

  return iVar1;
}


// AllocPool_Remove
// param1 is element pool (pointer varies)
// param2 is element (type varies)
void FUN_8003112c(int param_1,undefined4 param_2)

{
  // remove member from taken
  // LIST_RemoveMember
  FUN_800317e4(param_1 + 0xc);

  // add member to free
  // LIST_AddFront
  FUN_80031744(param_1,param_2);

  return;
}


// INSTANCE_LevInstancesStart
void FUN_8003116c(int *param_1)

{
  int *piVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;

  // First quadblock
  // ptrQuadBlockArray
  uVar3 = param_1[3];

  // Last quadblock
  // ptrQuadBlockArray + numQuadBlock * sizeof(QuadBlock)
  uVar4 = uVar3 + *param_1 * 0x5c;

  // loop through all quadblocks
  while (uVar3 < uVar4)
  {
    if (
			// quadblock -> ptr_add_tex
			(*(int *)(uVar3 + 0x44) != 0) &&

			(
				// array of InstDef pointers
				piVar1 = *(int **)(*(int *)(uVar3 + 0x44) + 8),

				piVar1 != (int *)0x0
			)
		)
	{
      iVar2 = *piVar1;

	  // loop through all
      while (iVar2 != 0)
	  {
		// InstDef = InstDef -> Instance
        *piVar1 = *(int *)(*piVar1 + 0x2c);

        piVar1 = piVar1 + 1;
        iVar2 = *piVar1;
      }
    }

	// go to next quadblock
    uVar3 = uVar3 + 0x5c;
  }

  // get pointer to array of InstDef
  piVar1 = *(int **)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x24);

  // if pointer is valid
  if (piVar1 != (int *)0x0)
  {
	// get the first instance in array
    iVar2 = *piVar1;

	while (iVar2 != 0)
	{
	  // item = InstDef->instance
      *piVar1 = *(int *)(*piVar1 + 0x2c);

      piVar1 = piVar1 + 1;
      iVar2 = *piVar1;
    }
  }
  return;
}


// INSTANCE_LevInstancesStop
void FUN_80031268(int *param_1,int param_2)

{
  int *piVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;

  // First quadblock
  // ptrQuadBlockArray
  uVar5 = param_1[3];

  // Last quadblock
  // ptrQuadBlockArray + numQuadBlock * sizeof(QuadBlock)
  uVar3 = uVar5 + *param_1 * 0x5c;

  // loop through all quadblocks
  while (uVar5 < uVar3)
  {
    if (
			// quadblock -> ptr_add_tex
			(*(int *)(uVar5 + 0x44) != 0) &&

			(
				// array of instances visible from quadblock
				piVar1 = *(int **)(*(int *)(uVar5 + 0x44) + 8),

				piVar1 != (int *)0x0
			)
		)
	{

	  iVar2 = *piVar1;

	  // loop through all
	  while (iVar2 != 0)
	  {
		// convert back to InstDef
        *piVar1 = *(int *)(*piVar1 + 0x2c);

        piVar1 = piVar1 + 1;
        iVar2 = *piVar1;
      }
    }

	// go to next quadblock
    uVar5 = uVar5 + 0x5c;
  }

  // get pointer to array of instance pointers
  piVar1 = *(int **)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x24);

  // if pointer is valid
  if (piVar1 != (int *)0x0)
  {
	// get the first instance in array
    iVar2 = *piVar1;

	// loop through all
    while (iVar2 != 0)
	{
	  // get InstDef
      iVar2 = *(int *)(*piVar1 + 0x2c);

	  // if this function is called when
	  // swapping LEVs in Adventure hub
	  if (param_2 != 0)
	  {
		// get thread from instance
        iVar4 = *(int *)(*piVar1 + 0x6c);

		// if thread is attached to this instance
        if (iVar4 != 0)
		{
		  // 0x800 = this thread needs to be deleted
          *(uint *)(iVar4 + 0x1c) = *(uint *)(iVar4 + 0x1c) | 0x800;
        }

		// LIST_AddFront
		// free list of instance pool
        FUN_80031744(PTR_DAT_8008d2ac + 0x18f8,*piVar1);
      }

	  // instance = InstDef
      *piVar1 = iVar2;

      piVar1 = piVar1 + 1;
      iVar2 = *piVar1;
    }
  }

  // THREAD_CheckAllForDead
  FUN_80041ff4();

  return;
}


// INSTANCE_ParentInstance
// param1 - instance_dst
// param2 - instance_src
// param3 - transform vector (x,y,z)
void FUN_800313c8(int param_1,int param_2,undefined4 *param_3)

{
  undefined4 in_zero;
  undefined4 in_at;
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;

  // each matrix has 3x3 shorts, which is 9 shorts,
  // which is 18 bytes, or 0x12 bytes

  // Copy rotation from one instance to another
  uVar1 = *(undefined4 *)(param_2 + 0x34);
  uVar2 = *(undefined4 *)(param_2 + 0x38);
  uVar3 = *(undefined4 *)(param_2 + 0x3c);
  *(undefined4 *)(param_1 + 0x30) = *(undefined4 *)(param_2 + 0x30);
  *(undefined4 *)(param_1 + 0x34) = uVar1;
  *(undefined4 *)(param_1 + 0x38) = uVar2;
  *(undefined4 *)(param_1 + 0x3c) = uVar3;

  // Get position from one instance
  uVar1 = *(undefined4 *)(param_2 + 0x44);
  uVar2 = *(undefined4 *)(param_2 + 0x48);
  uVar3 = *(undefined4 *)(param_2 + 0x4c);

  // one more rotation variable
  *(undefined4 *)(param_1 + 0x40) = *(undefined4 *)(param_2 + 0x40);

  // set position to the other instance
  *(undefined4 *)(param_1 + 0x44) = uVar1;
  *(undefined4 *)(param_1 + 0x48) = uVar2;
  *(undefined4 *)(param_1 + 0x4c) = uVar3;

  // set the new matrix

  SetRotMatrix((MATRIX *)(param_1 + 0x30));
  SetTransMatrix((MATRIX *)(param_1 + 0x30));

  // (x,y,z,0)
  setCopReg(2,cop_r0,param_3[0]);
  setCopReg(2,cop_r1,param_3[1]);

  // rtv0tr   cop2 $0480012  v0 * rotmatrix + tr vector
  copFunction(2,0x480012);

  uVar1 = getCopReg(2,0x19);
  *(undefined4 *)(param_1 + 0x44) = uVar1;
  uVar1 = getCopReg(2,0x1a);
  *(undefined4 *)(param_1 + 0x48) = uVar1;
  uVar1 = getCopReg(2,0x1b);
  *(undefined4 *)(param_1 + 0x4c) = uVar1;
  return;
}


// param1 is gGT (8008d2ac)
// param2 is numModels in LEV
// param3 is array of model pointers
// INSTANCE_ModelGlobal_Store
void FUN_8003147c(int param_1,int param_2,int *param_3)

{
  int iVar1;

  if (param_2 != 0) {
    do
	{
	  // Model pointer
      iVar1 = *param_3;

	  // if model is nullptr
      if (iVar1 == 0)
	  {
		// quit
        return;
      }

	  // if model -> ID is not -1
      if ((int)*(short *)(iVar1 + 0x10) != -1)
	  {
		// Set pointer in array of models
		// modelPtr[model->id] = pointer
        *(int *)(param_1 + (int)*(short *)(iVar1 + 0x10) * 4 + 0x2160) = iVar1;
      }

      param_2 = param_2 + -1;
      param_3 = param_3 + 1;
    } while (param_2 != 0);
  }
  return;
}


// param1 is PTR_DAT_8008d2ac
// INSTANCE_ModelGlobal_Clear
void FUN_800314c0(int param_1)

{
  int iVar1;

  iVar1 = 0xe1;
  param_1 = param_1 + 900;
  do
  {
    *(undefined4 *)(param_1 + 0x2160) = 0;
    iVar1 = iVar1 + -1;
    param_1 = param_1 + -4;
  } while (-1 < iVar1);
  return;
}

// INSTANCE_CollBucket_Radius
// param_1 instance
// param_2 thread of param_1's instance (unused)
// param_3 thread (thread bucket)
// param_4 collision radius
int FUN_800314e0(int param_1,undefined4 param_2,int param_3,uint param_4)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;

  // only continue if thread is valid
  if (param_3 != 0)
  {
	// loop through every thread
	// in the linked list
    do
	{
	  // get instance from thread
      iVar4 = *(int *)(param_3 + 0x34);

	  // get difference in X, Y, and Z, from both instances
      iVar3 = *(int *)(iVar4 + 0x44) - *(int *)(param_1 + 0x44);
      iVar2 = *(int *)(iVar4 + 0x48) - *(int *)(param_1 + 0x48);
      iVar1 = *(int *)(iVar4 + 0x4c) - *(int *)(param_1 + 0x4c);

	  // check for a particular model, which has cylinderical collision
      if (*(short *)(*(int *)(param_1 + 0x18) + 0x10) == 0x21) {
        if (((uint)(iVar3 * iVar3 + iVar1 * iVar1) < param_4) && (-0x20 < iVar2)) {
          return iVar4;
        }
      }

	  // all other models to spherical collision
      else
	  {
		// if distance is less than collision radius
        if ((uint)(iVar3 * iVar3 + iVar1 * iVar1 + iVar2 * iVar2) < param_4)
		{
		  // return the instance it collided with
          return iVar4;
        }
      }

	  // go to the next thread in the list
      param_3 = *(int *)(param_3 + 0x10);

	// until there are no more threads
    } while (param_3 != 0);
  }

  // no collision
  return 0;
}


// INSTANCE_CollBucket_Hitbox_Desc
void FUN_800315ac(undefined4 *param_1)

{
  FUN_80031608(*param_1,param_1[1],param_1[2],param_1[3],param_1[4],param_1[5]);
  return;
}


// param_1 instance
// param_2 thread of param_1's instance
// param_3 thread (thread bucket)
// param_4 hitbox_X
// param_5 hitbox_Y
// param_6 hitbox_Z
// INSTANCE_CollBucket_Hitbox
int FUN_80031608(int param_1,undefined4 param_2,int param_3,undefined4 param_4,undefined4 param_5,
                undefined4 param_6)

{
  int iVar1;
  int iVar2;
  short local_resc;
  short sStackX14;
  MATRIX MStack88;
  SVECTOR local_38;
  VECTOR local_30;
  long alStack32 [2];

  if (param_3 != 0) {
    do
	{
	  // thread->instance
      iVar1 = *(int *)(param_3 + 0x34);

	  // instance position
      local_38.vx = *(short *)(iVar1 + 0x44);
      local_38.vy = *(short *)(iVar1 + 0x48);
      local_38.vz = *(short *)(iVar1 + 0x4c);

	  iVar2 = *(int *)(iVar1 + 0x48) - *(int *)(param_1 + 0x48);

	  // output: ???
	  // input: instance matrix
	  // MATH_HitboxMatrix
	  FUN_8003d264(&MStack88,param_1 + 0x30);

      SetRotMatrix(&MStack88);
      SetTransMatrix(&MStack88);

	  // local_38 - input
	  // local_30 - output
	  // alStack32 - flag
      RotTrans(&local_38,&local_30,alStack32);

      if (
			(
				(
					(local_30.vx < param_5._2_2_) &&
					(
						local_resc = (short)param_4,
						local_resc < local_30.vx
					)
				) &&
				(local_30.vz < param_6._2_2_)
			) &&
			(
				(
					(
						(short)param_5 < local_30.vz &&
						(
							sStackX14 = (short)((uint)param_4 >> 0x10),
							sStackX14 <= iVar2
						)
					) &&
					(iVar2 < (short)param_6)
				)
			)
		  )
	  {
		// return instance that collided with thread
        return iVar1;
      }

	  // thread -> sibling
      param_3 = *(int *)(param_3 + 0x10);

    } while (param_3 != 0);
  }
  return 0;
}


// LIST_Clear
void FUN_80031734(undefined4 *param_1)

{
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  return;
}


// LIST_AddFront
// param_1 is linkedList
// param_2 is item
void FUN_80031744(int **param_1,int *param_2)

{
  int *piVar1;

  // If pointer is not nullptr
  if (param_2 != (int *)0x0)
  {
	// newMember->prev
    param_2[1] = 0;

	// list->first
	piVar1 = param_1[0];

	// newMember->next = list->first
	param_2[0] = piVar1;

	// if there is no first,
	// making this the first item
	if (piVar1 == (int *)0x0)
	{
	  // list->last = newMember
      param_1[1] = param_2;
    }

	// if a member is already on the list
	else
	{
	  // list->first->prev = newMember
      param_1[0]->offset4 = param_2;
    }

	// list->first = newMember
    param_1[0] = param_2;

	// increase member count
    param_1[2] = param_1[2] + 1;
  }
  return;
}


// LIST_AddBack
// param_1 is linkedList
// param_2 is item
void FUN_80031788(undefined4 *param_1,undefined4 *param_2)

{
  int iVar1;

  // If pointer is not nullptr
  if (param_2 != (undefined4 *)0x0)
  {
	// newMember->next
    param_2[0] = 0;

	// list->last
    iVar1 = param_1[1];

	// newMember->prev = last
    param_2[1] = iVar1;

	// if list->last does not exist,
	// making this the first member of list
	if (iVar1 == 0)
	{
	  // list->first = newMember
      *(undefined4 **)param_1 = param_2;
    }

	// if list->last exists
	else
	{
	  // list->last->next = newMember
      param_1[1]->offset0 = param_2;
    }

	// list->last = newMember
    param_1[1] = param_2;

	// increase member count
    param_1[2] = param_1[2] + 1;
  }
  return;
}


// LIST_GetNextItem
undefined4 FUN_800317cc(undefined4 *param_1)

{
  return *param_1;
}


// LIST_GetFirstItem
undefined4 FUN_800317d8(undefined4 *param_1)

{
  return *param_1;
}


// LIST_RemoveMember
int * FUN_800317e4(int *param_1,int *param_2)

{
  // if pointer is valid
  if (param_2 != (int *)0x0)
  {
	// list->first is valid
    if (*param_1 != 0)
	{
	  // if member->prev is null
	  // member is the first on list
      if (param_2[1] == (int *)0x0)
	  {
		// list->first = member->next
        param_1[0] = param_2[0];
      }

	  // if member->prev is valid
	  else
	  {
		// member->prev->next = member->next
        param_2[1]->offset0 = param_2[0];
      }

	  // if member->next is null
	  // member is last on list
      if (param_2[0] == 0)
	  {
		// list->last = member->prev
        param_1[1] = param_2[1];
      }

	  // if member->next is valid
	  else
	  {
		// member->next->prev = member->prev
        param_2[0]->offset4 = param_2[1];
      }

	  // decrease item count
      param_1[2] = param_1[2] + -1;
    }

	// erase links
    *param_2 = 0;
    param_2[1] = 0;
  }
  return param_2;
}


// LIST_RemoveFront
int * FUN_8003186c(int **param_1)

{
  int **ppiVar1;

  // member = list->first
  ppiVar1 = (int *)param_1[0];

  // This was a lazy copy/paste of LIST_RemoveMember,
  // replacing the parameterized member with first member

  // if member exist
  if (ppiVar1 != (int **)0x0)
  {
	// member->prev is null
    if (ppiVar1[1] == (int *)0x0)
	{
	  // list->first = member->next
      param_1[0] = ppiVar1[0];
    }

	// if member->prev exists
    else
	{
	  // member->prev->next = member->next
      ppiVar1[1]->offset0 = ppiVar1[0];
    }

	// if member->next is null
    if (*ppiVar1 == (int *)0x0)
	{
	  // list->last = member->prev
      param_1[1] = ppiVar1[1];
    }

	// if member->next is valid
    else
	{
	  // member->next->prev = member->prev
      ppiVar1[0]->offset4 = ppiVar1[1];
    }

	// decrease item count
    param_1[2] = param_1[2] + -1

	// erase links
    *(int *)ppiVar1 = 0;
    *(int *)(ppiVar1 + 1) = 0;
  }
  return (int *)ppiVar1;
}


// only from 231
// LIST_RemoveBack
int * FUN_800318ec(int *param_1)

{
  int *piVar1;

  // This was a lazy copy/paste of LIST_RemoveMember,
  // replacing the parameterized member with last member

  // member = list->last
  piVar1 = (int *)param_1[1];

  // if it exists
  if (piVar1 != (int *)0x0)
  {
	// if list->first exists
    if (*param_1 != 0)
	{
	  // if member->prev is null
	  // member is the first on list
      if ((int *)piVar1[1] == (int *)0x0)
	  {
		// list->first = member->next
        param_1[0] = piVar1[0];
      }

	  // if member->prev is valid
      else
	  {
		// member->prev->next = member->next
        piVar1[1]->offset0 = piVar1[0];
      }

	  // if member->next is null
	  // member is last on list
      if (*piVar1 == 0)
	  {
		// list->last = member->prev
        param_1[1] = piVar1[1];
      }

      else
	  {
		// member->next->prev = member->prev
        piVar1[0]->offset4 = piVar1[1];
      }

	  // decrease item count
      param_1[2] = param_1[2] + -1;
    }

	// erase links
    *piVar1 = 0;
    piVar1[1] = 0;
  }
  return piVar1;
}


// LIST_Init
// param_1 pointer to linked list
// param_2 pointer to member
// param_3 size of each member
// param_4 number of members
void FUN_8003197c(undefined4 param_1,int param_2,int param_3,int param_4)

{
  int iVar1;

  // reduce remainig amount by one
  iVar1 = param_4 + -1;

  // if there is at least one member
  if (param_4 != 0)
  {
	// keep going until done
    do
	{
	  // LIST_AddBack
      // add to freeItems
      FUN_80031788(param_1,param_2);

	  // reduce remaining amount by one
      iVar1 = iVar1 + -1;

	  // increment pointer to next member
	  param_2 = param_2 + param_3;

    } while (iVar1 != -1);
  }
  return;
}

// generic overlay callback
void FUN_800319e8(void)

{
  // gp -> 0x138
  // sdata.load_inProgress = 0;
  uGp00000138 = 0;

  return;
}

// 230 overlay callback
void FUN_800319f4(void)

{
  // dll 230 is now loaded
  PTR_DAT_8008d2ac[0x2541] = 0;

  // gp -> 0x138
  // sdata.load_inProgress = 0;
  uGp00000138 = 0;

  return;
}

// 231 overlay callback
void FUN_80031a08(void)

{
  // dll 231 is now loaded
  PTR_DAT_8008d2ac[0x2541] = 1;

  // gp -> 0x138
  // sdata.load_inProgress = 0;
  uGp00000138 = 0;

  return;
}

// 232 overlay callback
void FUN_80031a20(void)

{
  // dll 232 is now loaded
  PTR_DAT_8008d2ac[0x2541] = 2;

  // gp -> 0x138
  // sdata.load_inProgress = 0;
  uGp00000138 = 0;

  return;
}

// 233 overlay callback
void FUN_80031a38(void)

{
  // dll 233 is now loaded
  PTR_DAT_8008d2ac[0x2541] = 3;

  // gp -> 0x138
  // sdata.load_inProgress = 0;
  uGp00000138 = 0;

  return;
}

// callback maskhint3D
// param_1 - LoadQueueSlot
void FUN_80031a50(int param_1)

{
  // gp -> 0x138
  // sdata.load_inProgress = 0;
  uGp00000138 = 0;

  // gp->184
  // sdata.modelMaskHints3D modelptr

  // param_1 -> 0xC
  // LoadQueueSlot -> ptrDestination
  uGp00000184 = *(undefined4 *)(param_1 + 0xc);

  return;
}

// LOAD_Callback_Podiums
// param_1 - LoadQueueSlot
void FUN_80031a64(int param_1)
{
  // param_1 -> 0xC
  // LoadQueueSlot -> ptrDestination
  DAT_80083a38 = *(undefined4 *)(param_1 + 0xc);

  // gp -> 0x138
  // sdata.load_inProgress = 0;
  uGp00000138 = 0;

  return;
}

// LOAD_Callback_LEV
// param_1 - LoadQueueSlot
void FUN_80031a78(int param_1)

{
  // flags
  if ((*(ushort *)(param_1 + 4) & 2) == 0)
  {
    // gp -> 0x138
    // sdata.load_inProgress = 0;
    uGp00000138 = 0;
  }

  // pointer to LEV
  // param_1 -> 0xC
  // LoadQueueSlot -> ptrDestination
  uGp00000120 = *(undefined4 *)(param_1 + 0xc);

  return;
}

// LOAD_Callback_LEV_Adv
// param_1 - LoadQueueSlot
void FUN_80031aa4(int param_1)

{
  // game is done loading
  DAT_8008d0a4 = 0;

  // LOAD_RunPtrMap
  // 8008d08c is pointer to LEV
  FUN_800326b4(DAT_8008d08c,*(int **)(param_1 + 0xc) + 1,**(int **)(param_1 + 0xc) >> 2);

  // change active allocation system to #1
  // used for whole game (except adventure arena)
  FUN_8003e80c(0);

  // MEMPACK_ClearHighMem
  // Erase Credits from RAM
  FUN_8003e938();

  // change active allocation system
  // swap 1 and 2 during adventure mode
  FUN_8003e80c((int)*(short *)(PTR_DAT_8008d2ac + 0x254a));
  return;
}

// LOAD_Callback_DriverModels
// param_1 - LoadQueueSlot
void FUN_80031b00(int param_1)

{
  // address of loading drivers
  // 8008D088
  uGp0000011c = *(undefined4 *)(param_1 + 0xc);

  // gp -> 0x138
  // sdata.load_inProgress = 0;
  uGp00000138 = 0;
  return;
}


// Sep review copy calls this
// LOAD_HubCallback
void FUN_80031b14(void)

{
  short *psVar1;

  // game is done loading
  DAT_8008d0a4 = 0;

  FUN_80031aa4();

  // swap 1 and 2 during adventure mode
  psVar1 = (short *)(PTR_DAT_8008d2ac + 0x254a);

  // set the pointer of the LEV being loaded, that
  // you are about to enter, in Adventure Hub
  *(undefined4 *)(PTR_DAT_8008d2ac + 0x164) = DAT_8008d08c;

  // change active allocation system
  FUN_8003e80c((int)*psVar1);

  return;
}


// LOAD_GlobalModelPtrs_MPK
void FUN_80031b50(void)

{
  undefined *puVar1;
  int iVar2;
  int *piVar3;
  int iVar4;

  puVar1 = PTR_DAT_8008d2ac;

  // loop counter
  iVar4 = 0;

  // extra drivers in VS mode
  piVar3 = &DAT_80083a10;

  // for iVar4 = 0; iVar4 < 3; iVar4++
  do
  {
	// model pointer
    iVar2 = *piVar3;

    if (
		// if model is valid
		(iVar2 != 0) &&

		// if model-> id is not -1
		((int)*(short *)(iVar2 + 0x10) != -1)
	   )
	{
	  // store model in GameTracker's array of model IDs
      *(int *)(puVar1 + (int)*(short *)(iVar2 + 0x10) * 4 + 0x2160) = iVar2;
    }

	// increment loop counter
    iVar4 = iVar4 + 1;

    piVar3 = piVar3 + 1;
  } while (iVar4 < 3);

  // if PLYROBJECTLIST is valid
  if (DAT_8008d870 != 0)
  {
	// store model pointers until hitting nullptr
    FUN_8003147c(PTR_DAT_8008d2ac, 0xffffffff, DAT_8008d870);
  }
  return;
}


// LOAD_HubSwapPtrs
void FUN_80031bdc(int param_1)

{
  undefined4 uVar1;
  undefined4 uVar2;

  // If the secondary LEV in adv hub is valid
  if (*(int *)(param_1 + 0x164) != 0)
  {
	// swap 0x160 and 0x164, so that the
	// secondary LEV becomes active

	// pointer to active LEV
    uVar1 = *(undefined4 *)(param_1 + 0x160);

	// called VISMEM in prototypes
    uVar2 = *(undefined4 *)(param_1 + 0x1a38);

	// set active LEV to inactive LEV
	*(int *)(param_1 + 0x160) = *(int *)(param_1 + 0x164);

	// record that hub has been swapped at least once
	*(undefined2 *)(param_1 + 0x2548) = 1;

	// set inactive LEV to previously-active LEV
    *(undefined4 *)(param_1 + 0x164) = uVar1;

	// called VISMEM in prototypes
	*(undefined4 *)(param_1 + 0x1a38) = *(undefined4 *)(param_1 + 0x1a3c);

	// called VISMEM in prototypes
    *(undefined4 *)(param_1 + 0x1a3c) = uVar2;
  }
  return;
}


// capitalize string
void FUN_80031c1c(byte *param_1)

{
  byte bVar1;

  bVar1 = *param_1;

  // while you haven't reached the end
  while (bVar1 != 0)
  {
	// if you detect a lowercase letter
    if ((uint)bVar1 - 0x61 < 0x1a)
	{
	  // make it uppercase
      *param_1 = bVar1 - 0x20;
    }

	// go to the next character
    param_1 = param_1 + 1;

	// set pVar1 to this character so it
	// can check for null terminator
    bVar1 = *param_1;
  }
  return;
}

// Aug 5 says
// "CD Init Error!"
void FUN_80031c58(void)

{
  // CDSYS_Init
  FUN_8001c360(1);
  return;
}


// Aug 5 calls this
// LOAD_ReadDirectory
u_long * FUN_80031c78(char *param_1)

{
  CdlFILE *pCVar1;
  u_long *buf;
  int iVar2;
  u_long uVar3;
  u_char auStack48 [8];
  CdlFILE CStack40;

  // CDSYS_SetMode_StreamData
  FUN_8001c470();

  // cpVar1 and CStack40 are the same
  // param_1 is the string of the file searched,
  // pCVar1 is the CdlFILE that corresponds
  pCVar1 = CdSearchFile(&CStack40,param_1);

  // if BIGFILE was found on disc
  if (pCVar1 != (CdlFILE *)0x0)
  {
	// MEMPACK_AllocMem,
	// dont worry about size, we realloc in a minute
    buf = (u_long *)FUN_8003e874(0x4000,param_1);

	// 2 = CdlSetloc
    CdControl('\x02',(u_char *)&CStack40,auStack48);

	iVar2 = CdRead(8,buf,0x80);
    if (iVar2 != 0) {
      iVar2 = CdReadSync(0,(u_char *)0x0);
      if (iVar2 != 0) {
        return (u_long *)0;
      }

	  // get CD position of param_1 file
      uVar3 = CdPosToInt((CdlLOC *)&CStack40);

	  // save cdpos of bigfile, in header of bigfile
      *buf = uVar3;

	  // MEMPACK_ReallocMem,
	  // size of two int's, plus number of BigEntry
      FUN_8003e94c(buf[1] * 8 + 8);

	  // According to Aug 5:
	  // uvar3 = buf[0] = firstSector
	  // buf[1] = numFiles

	  // save it in another variable
	  DAT_8008d09c = buf;

	  // return CD position
      return buf;
    }
  }

  // not found, return false
  return (u_long *)0;
}


// LOAD_DramFileCallback
void FUN_80031d30(int param_1)

{
  int *piVar1;
  int *piVar2;
  code *pcVar3;
  int iVar4;

  piVar1 = *(int **)(param_1 + 0xc);

  if (piVar1 != (int *)0x0)
  {
    iVar4 = *piVar1;
    if (iVar4 < 0)
	{
	  // add flag
      *(ushort *)(param_1 + 4) = *(ushort *)(param_1 + 4) | 2;
    }
    else {
      piVar2 = (int *)((int)(piVar1 + 1) + iVar4);

	  // LOAD_RunPtrMap
      FUN_800326b4(piVar1 + 1,piVar2 + 1,*piVar2 >> 2);

	  // if this needs to be erased
      if ((*(ushort *)(param_1 + 4) & 1) != 0)
	  {
		// MEMPACK_ReallocMem
        FUN_8003e94c(iVar4 + 4);
      }
    }
    *(int *)(param_1 + 0xc) = *(int *)(param_1 + 0xc) + 4;
  }

  // get callback funcPtr
  pcVar3 = *(code **)(param_1 + 0x14);

  // check that callback is not zero, and has value 0x80xxxxxx
  if ((pcVar3 != (code *)0x0) && (((uint)pcVar3 & 0xff000000) == 0x80000000))
  {
	// execute funcPtr
    (*pcVar3)(param_1);
  }

  // ready to load next file
  DAT_8008d0a0 = 1;

  return;
}


// In Aug 5 prototype, this is
// called LOAD_DramFile
undefined4
FUN_80031e00(undefined4 param_1,undefined4 param_2,undefined4 *param_3,undefined4 *param_4,
            int param_5)

{
	// param1 is Pointer to "cd position of bigfile"

  undefined4 local_28;
  undefined2 local_24;
  undefined2 local_22;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;

  if (param_5 == -1) {

	// offset 0x4: flags
	local_24 = 0;

	// offset 0x6: type
    local_22 = 2;

	// offset 0x0: bigfilePtr
    local_28 = param_1;

	// offset 0x8: subfileIndex
    local_20 = param_2;

	// called with same parameters as given to LOAD_DramFile
	// assembly shows those registers dont change

	// offset 0xC: ptrDestination
	// LOAD_ReadFile
    local_1c = FUN_800321b4();

	// offset 0x10: size
	local_18 = *param_4;

	// offset 0x14: callback
    local_14 = 0;

	// call the callback func
    FUN_80031d30(&local_28);
  }
  else {
    if (param_5 == -2)
	{
		// This function is called LOAD_ReadFile
		local_1c = FUN_800321b4(param_1,2,param_2,0,param_4,FUN_80031d30);

		DAT_80083a48 = local_1c;
		*param_3 = local_1c;
    }
    else
	{
		// This function is called LOAD_ReadFile
		local_1c = FUN_800321b4(param_1,2,param_2,param_3,param_4,FUN_80031d30);
    }
  }
  return local_1c;
}


//loads TIMs from ctr texture file to vram
//ctr texture file is either a single TIM, or multiple TIMS with a header
//https://github.com/CTR-tools/CTR-tools/blob/master/formats/txt_vram.txt
//param_1 = pointer to file queue slot
void FUN_80031ee4(int param_1)

{
  int iVar1;
  int *piVar2;
  int iVar3;
  //psy-q RECT struct
  undefined2 local_18;
  undefined2 local_16;
  undefined2 local_14;
  undefined2 local_12;

  //get file pointer from queue slot
  piVar2 = *(int **)(param_1 + 0xc);

  //if it's not empty
  if (piVar2 != (int *)0x0) {

    //are there multiple TIMs? (header 0x00000020)
    if (*piVar2 == 0x20) {

      //we got multiple TIMs, begin [readsize - load tim] loop

      iVar3 = piVar2[1];
      piVar2 = piVar2 + 2;

      //loop through all TIMs
      while (iVar3 != 0) {

        //read rect and load to vram (psy-q func)
        local_18 = *(undefined2 *)(piVar2 + 3);
        local_16 = *(undefined2 *)((int)piVar2 + 0xe);
        local_14 = *(undefined2 *)(piVar2 + 4);
        local_12 = *(undefined2 *)((int)piVar2 + 0x12);
        LoadImage(&local_18,piVar2 + 5);

        //calulate pointers for next iteration
        iVar1 = iVar3 >> 2;
        iVar3 = piVar2[iVar1];
        piVar2 = piVar2 + iVar1 + 1;
      }
    }
    else {

      //only 1 TIM in this file

      //read rect and load to vram (psy-q func)
      local_18 = *(undefined2 *)(piVar2 + 3);
      local_16 = *(undefined2 *)((int)piVar2 + 0xe);
      local_14 = *(undefined2 *)(piVar2 + 4);
      local_12 = *(undefined2 *)((int)piVar2 + 0x12);
      LoadImage(&local_18,piVar2 + 5);
    }
  }

  // record the frame that loading finished
  DAT_8008d0a8 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1ce4);

  return;
}

// In Aug 5 prototype, this is
// called LOAD_VramFile
//basically loads ctr texture file to vram in 3 different ways based on param_5 value
//param_1 = bigFilePtr
//param_2 = fileIndex
//param_3 = target pointer (where should we load the file, can be null)
//param_4 = ???
//param_5 = callback in other funcs/structs, also used to control execution by passing -1, -2 etc
undefined4
FUN_80031fdc(undefined4 param_1,undefined4 param_2,undefined4 *param_3,undefined4 *param_4,
            int param_5)

{
  //local queue slot
  undefined4 local_30;
  undefined2 local_2c;
  undefined2 local_2a;
  undefined4 local_28;
  undefined4 local_24;
  undefined4 local_20;
  undefined4 local_1c;

  // Used for "SCEA Presents", "Copyright", and "UI Textures"
  //if we're not given the address to use, create new temporary place to load
  if (param_3 == (undefined4 *)0x0) {

	// add a bookmark
    FUN_8003e978();
  }

  //case -1 = we don't want to use global file queue or store file in ram
  if (param_5 == -1) {

    //prepare local loading slot for the file
    local_2c = 0;
    local_2a = 3;
    local_30 = param_1;
    local_28 = param_2;
    local_24 = FUN_800321b4(); // LOAD_ReadFile
    local_20 = *param_4;
    local_1c = 0;

    //load all TIMs from ctr vram file (usually1 or 2)
    FUN_80031ee4(&local_30);

	VSync(2);

	// reset timer
    DAT_8008d0a8 = 0;

   //if we're not given the address to use, remove temporary space used before
    if (param_3 == (undefined4 *)0x0) {

	  // MEMPACK_PopState
	  FUN_8003e9d0();
    }
  }
  else {

    //case -2 = load file to ram and store to active slot of global file queue
    if (param_5 == -2)
	{
				// LOAD_ReadFile
      local_24 = FUN_800321b4(param_1,3,param_2,0,param_4,FUN_80031ee4);
      DAT_80083a48 = local_24;
      *param_3 = local_24;
    }
    else
	{
    //case not -1 or -2 = just return the pointer to loaded file

				// LOAD_ReadFile
      local_24 = FUN_800321b4(param_1,3,param_2,param_3,param_4,FUN_80031ee4);
    }
  }

  return local_24;
}


// In Sep Review copy, this is called
// LOAD_ReadFileASyncCallback
void FUN_80032110(char param_1)

{
  // Make the system forget the callback
  // function, because we will execute now
  CdReadCallback(0);

  if (param_1 == '\x02') {
    if ((DAT_80083a40 & 1) != 0)
	{
	  // MEMPACK_ReallocMem
      FUN_8003e94c(DAT_80083a4c);
    }

	// If a function pointer callback exists
    if (DAT_8008d85c != (code *)0x0)
	{
	  // Execute callback function
      (*DAT_8008d85c)(&DAT_80083a3c);
    }
  }
  else {
    if ((DAT_80083a40 & 1) != 0) {

	  // MEMPACK_PopState
      FUN_8003e9d0();
    }
    DAT_8008d0a1 = 1;
  }
  return;
}

// In Aug 5 prototype, this is
// called LOAD_ReadFile
// param1 is bigfile
// param2 is load type (ram, dram, vram)
// param3 is subfileIndex
// param4 is destination (can be nullptr)
// param5 is pointer to size
// param6 is callback
u_long * FUN_800321b4(int *param_1,undefined4 param_2,int param_3,u_long *param_4,int *param_5,
                     int param_6)

{
	// param1 is the Pointer to CD posiiton of BIGFILE

  bool bVar1;
  uint uVar2;
  int iVar3;
  code *pcVar4;
  uint uVar5;
  u_long *buf;
  CdlLOC aCStack56 [2];
  u_char auStack48 [8];

  bVar1 = true;

  // CDSYS_SetMode_StreamData
  FUN_8001c470();

  uVar5 = 0;

  // bigfile + subfileIndex
  // get size of file from bigfile header
  *param_5 = (param_1 + param_3 * 2)[3];

  // bigfile cdpos + subfileOffset
  CdIntToPos(*param_1 + (param_1 + param_3 * 2)[2],aCStack56);

  // if a destination pointer is not given
  if (param_4 == (u_long *)0x0)
  {
	// set flag that we used MEMPACK_AllocMem
	// to store this ReadFile somewhere random
    DAT_80083a40 = DAT_80083a40 | 1;

	// MEMPACK_AllocMem
	// 8008d0ac = "FILE"
    buf = (u_long *)FUN_8003e874(*param_5 + 0x7ffU & 0xfffff800,&DAT_8008d0ac);

	// if allocation failed
    if (buf == (u_long *)0x0)
	{
	  // function  failed
      return (u_long *)0;
    }
  }

  // if destination pointer is given
  else {
    DAT_80083a40 = DAT_80083a40 & 0xfffe;

	// use that
    buf = param_4;
  }
  while ((uVar5 == 0 || (!bVar1)))
  {
	// 2 = CdlSetloc
    uVar5 = CdControl('\x02',(u_char *)aCStack56,auStack48);

	// If no callback function pointer is given
	if (param_6 == 0)
	{
	  // Set function pointers to nullptr
      DAT_8008d85c = 0;
      pcVar4 = (code *)0x0;
    }

	// If you want a callback function pointer
	// to execute after LOAD_ReadFile is done
    else
	{
	  // Save the function pointer address
      DAT_8008d85c = param_6;

	  // LOAD_ReadFileASyncCallback
      pcVar4 = FUN_80032110;
    }

	// Save this function as a callback,
	// which does not execute the function pointer
	CdReadCallback(pcVar4);

    uVar2 = CdRead(*param_5 + 0x7ffU >> 0xb,buf,0x80);
    uVar5 = uVar5 & uVar2;
    if (param_6 == 0) {
      iVar3 = CdReadSync(0,(u_char *)0x0);
      bVar1 = iVar3 == 0;
    }
  }
  if ((param_6 == 0) && (param_4 == (u_long *)0x0))
  {
	// MEMPACK_ReallocMem
    FUN_8003e94c(*param_5);
  }
  return buf;
}


// Read file on disc, store in buffer
// LOAD_ReadFile_NoCallback
u_long * FUN_80032344(char *param_1,u_long *param_2,u_long *param_3)

{
  CdlFILE *pCVar1;
  int iVar2;
  u_long *buf;
  CdlFILE CStack56;
  u_char auStack32 [8];

  // capitalize string
  FUN_80031c1c(param_1);

  // CDSYS_SetMode_StreamData
  FUN_8001c470();

  // cpVar1 and CStack56 are the same
  // param_1 is the string of the file searched,
  // pCVar1 is the CdlFILE that corresponds
  pCVar1 = CdSearchFile(&CStack56,param_1);

  buf = param_2;

  // if the file was found
  if (pCVar1 != (CdlFILE *)0x0)
  {
	// return file size to parameter
    *param_3 = CStack56.size;

    if (
			(param_2 == (u_long *)0x0) &&

			(
				// MEMPACK_AllocMem
				buf = (u_long *)FUN_8003e874(CStack56.size + 0x7ff & 0xfffff800,param_1),

				// if allocation failed
				buf == (u_long *)0x0
			)
		)
	{
	  // function failed
      return (u_long *)0;
    }

	// 2 = CdlSetloc
    CdControl('\x02',(u_char *)&CStack56,auStack32);

	// read entire file into buf
    iVar2 = CdRead(CStack56.size + 0x7ff >> 0xb,buf,0x80);

    if ((iVar2 == 0) || (iVar2 = CdReadSync(0,(u_char *)0x0), iVar2 != 0)) {
      buf = (u_long *)0x0;
    }
    else {
      if (param_2 == (u_long *)0x0)
	  {
		// MEMPACK_ReallocMem
        FUN_8003e94c(CStack56.size);
      }
    }
  }
  return buf;
}


// find file on disc
// LOAD_FindFile
uint FUN_80032438(char *param_1,CdlFILE *param_2)

{
  uint uVar1;
  CdlFILE *pCVar2;

  // if filename is nullptr, or CdlFILE given is nullptr
  if ((param_1 == (char *)0x0) || (param_2 == (CdlFILE *)0x0))
  {
	// set to zero, so function returns zero
    uVar1 = 0;
  }
  else
  {
	// CDSYS_SetMode_StreamData
    FUN_8001c470();

	// capitalize the string
    FUN_80031c1c(param_1);

	// cpVar2 and param_2 are the same
	// param_2 is the string of the file searched,
	// pCVar2 is the CdlFILE that corresponds
    pCVar2 = CdSearchFile(param_2,param_1);

	// return if file was found
    uVar1 = (uint)(pCVar2 != (CdlFILE *)0x0);
  }
  return uVar1;
}

// same as 80032594, but doesn't store params and calls CdReadSync
// only called from howl_LoadHeader
// param_1 is the address to CdlFile of Kart.HWL
// param_2 is allocation of 0x800 bytes

// howl_readSectorSync
undefined4 FUN_80032498(CdlLOC *param_1,u_long *param_2,int param_3,int param_4)

{
  int iVar1;
  CdlLOC aCStack40 [2];
  u_char auStack32 [8];

  // CDSYS_SetMode_StreamData
  FUN_8001c470();

  if ((param_3 + param_4) * 0x800 - (int)param_1[1] < 0x800) {

	// Get CD Position of Kart.HWL
    iVar1 = CdPosToInt(param_1);

	// Convert (iVar1 + param_3) into
	// CD position, and store it in aCStack40
    CdIntToPos(iVar1 + param_3,aCStack40);

	// 2 = CdlSetloc
    CdControl('\x02',(u_char *)aCStack40,auStack32);

    iVar1 = CdRead(param_4,param_2,0x80);

	if (
		// if read is correct
		(iVar1 != 0) &&

		(
			// wait until read is complete
			iVar1 = CdReadSync(0,(u_char *)0x0),

			// if zero sectors remain
			iVar1 == 0
		)
	   )
	{
	  // it worked
      return 1;
    }
  }
  return 0;
}


// howl cd reading callback
void FUN_8003254c(char param_1)

{
  // disable callback
  CdReadCallback(0);

  //if psyq cdread status 2 (success?), set howl loading status to 0
  if (param_1 == '\x02') {
    DAT_8008d840 = 0;
  }
  else {
      //else error?
    DAT_8008d840 = 0xffffffff;
  }
  return;
}


// loads howl related data from CD, only called from howl funcs
// used to load sample banks and cseq data
// also stores current params and loading status to global struct at DAT_8008d840
// param_1 - CdlLoc, file cd location (Kart.HWL)
// param_2 - pointer to load data to
// param_3 - offset from the beginning of file in sectors
// param_4 - number of sectors to load
// howl_loadDataFromCd
uint FUN_80032594(CdlLOC *param_1,u_long *param_2,int param_3,int param_4)

{
  // stores func result
  uint uVar1;
  // hidden var, stores cd reading result
  int iVar2;
  CdlLOC aCStack40 [2];
  u_char auStack32 [8];

  // if no sectors to load, result = true
  if (param_4 == 0) {
    uVar1 = 1;
  }
  else
  {
	// save parameters for howl_loadDataFromCd_RetryOnError

    // this seems to be some 5 int howl struct at DAT_8008d840, 1st int being current loading status
    DAT_8008d844 = param_1;
    DAT_8008d848 = param_2;
    DAT_8008d84c = param_3;
    DAT_8008d850 = param_4;

    // CDSYS_SetMode_StreamData
    FUN_8001c470();

    // if amount of data you requested to load, does not
    // overflow the size of Kart.HWL
    if ((param_3 + param_4) * 0x800 - (int)param_1[1] < 0x800)
	{
	  // convert CD location of Kart.HWL to sector
	  iVar2 = CdPosToInt(param_1);

	  // get absolute offset in sectors and convert to cdlloc
	  // store position into aCStack40
      CdIntToPos(iVar2 + param_3,aCStack40);

	  // 2 = CdlSetloc
      //spin round round to data it wants to read
      CdControl('\x02',(u_char *)aCStack40,auStack32);

      //set howl loading from cd status to 1. possible values are 0, 1 and -1
	  DAT_8008d840 = 1;

	  // Let the system know that a callback is
	  // going to be called. This does not execute
	  // the callback, but just records that it exists

      // sets callback to be called when reading is done
      // callback func basically reports this info back to howl struct
      CdReadCallback(FUN_8003254c);

      // read sectors from given address
      iVar2 = CdRead(param_4,param_2,0x80);

      // cd reading result
      uVar1 = (uint)(iVar2 != 0);
    }
    else {
      // result = false if it overflows
      uVar1 = 0;
    }
  }
  return uVar1;
}


//loads pending data from cd
//basically wrapper for FUN_80032594

// howl_loadDataFromCd_RetryOnError
uint FUN_8003266c(void)

{
  uint uVar1;

  //if loading status is -1 (error?)
  if (DAT_8008d840 == -1) {
    //call load func again passing params stored from previous call
    FUN_80032594(DAT_8008d844,DAT_8008d848,DAT_8008d84c,DAT_8008d850);
    uVar1 = 0;
  }
  else {
    //return current loading status ( 1 or 0 )
    uVar1 = (uint)(DAT_8008d840 == 0);
  }
  return uVar1;
}


// LOAD_RunPtrMap
// Change file-relative pointers to RAM pointers
// param_1 - ptr data origin
// param_2 - ptr patch table array
// param_3 - patch table array size
void FUN_800326b4(int param_1,int *param_2,int param_3)

{
  int *piVar1;
  int *piVar2;

  //get ptrEnd
  piVar2 = param_2 + param_3;

  //basically if patch table array length > 0
  if (param_2 < piVar2) {
    do {
      //get next ptr to fix
      piVar1 = (int *)((*param_2 >> 2) * 4 + param_1);
      //for loop increment
      param_2 = param_2 + 1;
      //fix pointer
      *piVar1 = *piVar1 + param_1;
      //while not reached the end of the array
    } while (param_2 < piVar2);
  }
  return;
}


// Set AIs for 2P Arcade,
// and load MPK for AI models
// param_1 bigfile
// param_2 = P1 Character ID
// param_3 = P2 Character ID
// param_4 = load driver callback
void FUN_80032700(undefined4 param_1,uint param_2,uint param_3,undefined4 param_4)
{
  // There are 28 bytes, 7 sets of 4 bytes,
  // for any combination of 4 characters
  // that can be chosen in 2P race. It loops
  // through every combination of 4 racers
  // until it finds one that doesn't have
  // a character ID chosen by the players

  bool bVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  byte *pbVar6;

  iVar4 = 0;
  pbVar6 = &DAT_80083a54;
  iVar5 = 0;

  // Idk why they chose to do it this way...

  // Continue looping until all 6 characters
  // all have different character IDs.
  while( true ) {
    bVar1 = false;
    iVar2 = iVar5;

	// Keep count of AI index (0-3) for 4 AIs
    iVar3 = 0;

    do
	{
	  // if the characters you chose, match any AIs
      if ((param_2 == (uint)(byte)(&DAT_80083a54)[iVar2]) ||
         (param_3 == (uint)(byte)(&DAT_80083a54)[iVar2]))
	  {
		// remember that you failed
        bVar1 = true;
      }

	  // increment AI index counter
      iVar3 = iVar3 + 1;

	  // quit after...
    } while (
				// you've gotten through 4 AIs
				(iVar3 < 4) &&

				(
					// check the next set of 4 AIs
					iVar2 = iVar3 + iVar5,

					!bVar1
				)
			);

	// If there are no repeating Character IDs
	// Leave the loop
	if (!bVar1) break;

	// if you are here, then the list of 4 AIs,
	// wont work cause one of them is a player

	// check the next set of 4 AIs
    pbVar6 = pbVar6 + 4;
    iVar5 = iVar5 + 4;

	// increment number of fails
    iVar4 = iVar4 + 1;

	// if it failed to find 4 AIs in a row,
	// that doesn't have player characters,
	// more than 6 times...
    if (6 < iVar4)
	{
	  // Aug 5
	  //FUN_8006fbac("ERROR: Didn\'t find a suitable Robot4 Packet for Player1 = %d Player2 = %d!\n",
      //             param_2,param_3);

      return;
    }
  }

  // by this point, we must have
  // 4 AIs in a row that do not
  // match a character that the player chose

  // Set Character ID 3 -- 1st AI
  DAT_80086e88 = (ushort)*pbVar6;

  // Set Character ID 4 -- 2nd AI
  DAT_80086e8a = (ushort)pbVar6[1];

  // Set Character ID 5 -- 3rd AI
  DAT_80086e8c = (ushort)pbVar6[2];

  // Set Character ID 6 -- 4th AI
  DAT_80086e8e = (ushort)pbVar6[3];

  //add to load queue from range 324=packs\2P_arcade\*.mpk
  // '1' for dram
  FUN_80032d30(param_1,2,iVar4 + 0x144,0,param_4);
  return;
}


// Set Character IDs of AIs
// param_1 will always be P1 Character ID
void FUN_800327dc(int param_1)
{
  // Set P1 Character ID to P1 Character ID (kinda pointless)
  DAT_80086e84 = (undefined2)param_1;

  // Boolean for loop
  bool bVar1 = true;

  // Character ID to give to array index.
  // Start with ID 0 (crash bandicoot)
  int iVar2 = 0;

  // Index of Character ID array,
  // to give Character ID to.
  // Start with index 1 (first AI)
  int iVar4 = 1;

  // Pointer to Unsigned Short Address
  // where character ID will be set
  undefined2 *puVar3;

  // Set pointer to P2 Character ID
  puVar3 = &DAT_80086e86;

  do {

	// Quit the loop if this is false
    if (!bVar1) {
      return;
    }

	// If iVar2 != P1 Character ID
	// Meaning: Dont set an AI Character ID to P1's Character ID
    if (iVar2 != param_1) {

	  // Set Character ID to iVar2
      *puVar3 = (short)iVar2;

	  // Go to next index in Short Array
      puVar3 = puVar3 + 1;

	  // Keep count of how many AIs you've set
      iVar4 = iVar4 + 1;
    }

	// Go to next character ID value
	// 0 - Crash
	// 1 - Cortex
	// 2 - Tiny
	// etc
    iVar2 = iVar2 + 1;

	// Stop the loop when all 7 AIs are set
    bVar1 = iVar4 < 8;

	// Stop the loop when a character ID
	// is a secret character (should never happen)
  } while (iVar2 < 8);

  // Leave the function
  return;
}


// LOAD_DriverMPK
void FUN_8003282c(undefined4 param_1,int param_2,undefined4 param_3)

{
  uint uVar1;

  // 3P or 4P (because of unsigned)
  if (param_2 - 3U < 2)
  {
	//add to load queue 3 files from range 332=models\racers\low\*.ctr
	//add to load queue 1 file from range 348=packs\4player\*.mpk
	// second param '2' means load dram
    FUN_80032d30(param_1,2,(int)DAT_80086e84 + 0x14c,&DAT_80083a10,0xfffffffe);
    FUN_80032d30(param_1,2,(int)DAT_80086e86 + 0x14c,&DAT_80083a14,0xfffffffe);
    FUN_80032d30(param_1,2,(int)DAT_80086e88 + 0x14c,&DAT_80083a18,0xfffffffe);
    FUN_80032d30(param_1,2,(int)DAT_80086e8a + 0x15c,0,param_3);

    return;
  }

  if (
		// If there is only 1 player
		(param_2 == 1) &&

		(
			// assigns main struct flags to local var
			uVar1 = *(uint *)PTR_DAT_8008d2ac,

			// If not in time trial
			(uVar1 & 0x22000) != 0x20000)
		)
  {
    if (
		(
			// 2 is for cutscene
			// 1 is for If you're in Adventure Arena
			((uVar1 & 0x20100000) != 0) ||

			// if going to credits
			((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x80) != 0)
		) ||

		// If level ID is 40
		// If you are in Adventure Character Select Screen
		(*(int *)(PTR_DAT_8008d2ac + 0x1a10) == 0x28)
	   )
	{
	  //add to load queue from range 276=packs\1P_adventure\*.mpk
	  // second param '2' means load dram
      FUN_80032d30(param_1,2,(int)DAT_80086e84 + 0x114,0,param_3);

      return;
    }

	// if not a boss race
    if (-1 < (int)uVar1) {
      if (
			// If you are in Adventure cup
			((uVar1 & 0x10000000) != 0) &&

			// If this is the purple gem cup
			(*(int *)(PTR_DAT_8008d2ac + 0x1e58) == 4)
		 )
	  {
		//add to load queue from range 242=models\racers\hi\*.ctr
		//basically load hi model for P1
		// second param '2' means load dram
        FUN_80032d30(param_1,2,(int)DAT_80086e84 + 0xf2,&DAT_80083a10,0xfffffffe);

		// add to load queue fixed 331=packs\1P_gem_cups\331_bosses.mpk
		// second param '2' means load dram
        FUN_80032d30(param_1,2,0x14b,0,param_3);

		// Purple Gem Cup

		// Set P2 to Ripper Roo
        DAT_80086e86 = 10;

		// Set P3 to Papu Papu
        DAT_80086e88 = 9;

		// Set P4 to Komodo Joe
        DAT_80086e8a = 0xb;

		// Set P5 to Pinstripe
        DAT_80086e8c = 8;

        return;
      }

	  // If you got this far, the code has already determined
	  // That you are in 1P Mode

	  // If not in main menu
      if ((*(uint *)PTR_DAT_8008d2ac & 0x22000) != 0x2000) {

		// Calculate AI Character IDs for 1P Arcade
        FUN_800327dc((int)DAT_80086e84);
      }

	  // add to load queue from range 260=packs\1P_arcade\*.mpk
	  // second param '2' means load dram
      FUN_80032d30(param_1,2,(int)DAT_80086e84 + 0x104,0,param_3);

      return;
    }
  }
  else
  {
	// If you are in 2P mode
    if (
			(param_2 != 8) &&


			// If you're not in Time Trial
			((*(uint *)PTR_DAT_8008d2ac & 0x20000) == 0)
		)
	{
	  // add to load queue from range 308=models\racers\med\*.ctr
	  // second param '2' means load dram
      FUN_80032d30(param_1,2,(int)DAT_80086e84 + 0x134,&DAT_80083a10,0xfffffffe);
      FUN_80032d30(param_1,2,(int)DAT_80086e86 + 0x134,&DAT_80083a14,0xfffffffe);

	  // Calculate AI character IDs with the character IDs that players chose,
	  // then load MPK with the models of those AIs
      FUN_80032700(param_1,(int)DAT_80086e84,(int)DAT_80086e86,param_3);

      return;
    }
  }

  // For Time Trial, Relic Race, and Boss Race

  // add to load queue from range 242=models\racers\hi\*.ctr
  // second param '2' means load dram
  FUN_80032d30(param_1,2,(int)DAT_80086e84 + 0xf2,&DAT_80083a10,0xfffffffe);

  // add to load queue from range 292=packs\1P_timetrial\*.mpk
  // second param '2' means load dram
  FUN_80032d30(param_1,2,(int)DAT_80086e86 + 0x124,0,param_3);

  return;
}



// loads selected lng file by index
// param_1 - Pointer to "cd position of bigfile"
// param_2 - language index - 0 ja, 1 en, 2 en2, 3 fr, 4 de, 5 it, 6 es, 7 ne
// overflow will cause problems, it will read non lng file. as i see no checks are performed against it.

void FUN_80032b50(undefined4 param_1,int param_2)

{
  int *piVar1;
  int iVar2;
  int *piVar3;
  int iVar4;
  int iVar5;
  undefined auStack24 [8];

  // allocate buffer, if null
  // FUN_8003e874 is called MEMPACK_AllocMem in earlier builds
  if (DAT_8008d858 == 0) {
    DAT_8008d858 = FUN_8003e874(__gp_4,"lang buffer");
  }

  // piVar1 will equal DAT_8008d858 if load succeeds
  // FUN_800321b4 is called LOAD_ReadFile in earlier builds
  piVar1 = (int *)FUN_800321b4(param_1,1,param_2 + 0xea,DAT_8008d858,auStack24,0);

  // if file read successful
  if (piVar1 != (int *)0x0)
  {
    iVar4 = *piVar1;
    iVar2 = (int)piVar1 + piVar1[1];
    iVar5 = 0;
    DAT_8008d110 = iVar4; // number of strings in lng file
    DAT_8008d878 = iVar2; // pointer to string pointer array

	// if have strings to process
    if (0 < iVar4) {
		// make every string pointer absolute
		// this is actually a for loop, ivar5 is increment
      do {
        piVar3 = (int *)(((iVar5 << 0x10) >> 0xe) + iVar2); // basically, (pointer to array + increment * 4)
        iVar5 = iVar5 + 1;
        *piVar3 = *piVar3 + (int)piVar1;
      } while (iVar5 * 0x10000 >> 0x10 < iVar4); // index converted to short (2 bytes)
    }
  }
  return;
}


//returns file index in bigfile according to params
// param1 is level ID
// param2 is LOD number
// param3 is vram/lev/ptr selector.
int FUN_80032c24(uint param_1,int param_2,int param_3)
{
  // If Level ID is 0 - 17, if level_id is a race track - 18 in total
  if (param_1 < 0x12) {
    return param_1 * 8 + (uint)(byte)(&DAT_8008d0b3)[param_2] + param_3;
  }

  // If Level ID is 19 - 24, if level_id is a battle map - 7 in total
  if (param_1 - 0x12 < 7) {
    return (param_1 - 0x12) * 8 + (uint)(byte)(&DAT_8008d0b3)[param_2] + param_3 + 0x90;
  }

  // one of the intro cutscenes, 9 in total
  if (param_1 - 0x1e < 9) {
    return (param_1 - 0x1e) * 3 + param_3 + 0x203;
  }

  // other 2 oxide cutscenes, 2 in total
  if (param_1 - 0x2a < 2) {
    return (param_1 - 0x2a) * 2 + param_3 + 0x21e;
  }

  //adv_player_select, main menu lev
  if (param_1 == 0x28) {
    return param_3 + 0xd9;
  }

  //intro_box, intro box lev
  if (param_1 == 0x29) {
    return param_3 + 0x201;
  }

  // if credits, 20 in total (all chars + 4 trophy girls)
  if (param_1 - 0x2c < 0x14) {
    return (param_1 - 0x2c) * 3 + param_3 + 0x222;
  }

  // menu_models, chars and kart for adventure select screen
  if (param_1 == 0x27) {
    return param_3 + 0xd7;
  }

  // 0x19 - 0x1d are adventure hubs
  // if hub, 5 in total
  //the logic is that we already checked everything before, so it doesn't have to check param_1 - 0x19
  if (param_1 != 0x40) {
    return (param_1 - 0x19) * 3 + param_3 + 200;
  }

  //returns the very last empty lev file index. must be the last resort measure if nothing to load.
  return param_3 + 0x25e;
}



// LOAD_AppendQueue
// param1 is always the Pointer to "cd position of bigfile"
// param2 is type, 1 for readfile, 2 for dram, 3 for vram
// param3 is the index of the subfile within BIGFILE
// param4 is ptrDestination. If null, destination is Mempack_AllocMem
// param5 is callbackFuncPtr
void FUN_80032d30(undefined4 param_1,undefined2 param_2,undefined4 param_3,undefined4 param_4, undefined4 param_5)
{
  int iVar1;

  //read queue length
  iVar1 = (int)DAT_8008d0a2;

  //if we have less than 8 files in the queue
  if (iVar1 < 8) {

    // sizeof(LoadQueueSlot) = 24 bytes
	// the array is at 80096344
    *(undefined2 *)(&DAT_80096348 + iVar1 * 6) = 0;
    (&DAT_80096344)[iVar1 * 6] = param_1;	// Pointer to "cd position of bigfile"

	// param2 is type, 1 for readfile, 2 for dram, 3 for vram
    *(undefined2 *)((int)&DAT_80096348 + iVar1 * 0x18 + 2) = param_2;

	// index of subfile within BIGFILE
    (&DAT_8009634c)[iVar1 * 6] = param_3;

	// ptrDestination, if null, will be
	// set to Mempack_AllocMem
    (&DAT_80096350)[iVar1 * 6] = param_4;

	// size is set to zero, because size gets
	// written while loading queue executes,
	// it pulls from bigfile header
    (&DAT_80096354)[iVar1 * 6] = 0;

	// callback funcPtr
    (&DAT_80096358)[iVar1 * 6] = param_5;

	//increase queue length
    DAT_8008d0a2 = DAT_8008d0a2 + 1;
  }
  return;
}

// LOAD_CDRequestCallback
void FUN_80032d8c(int param_1)

{
  // Sep 3
  // printf("LOAD_CDRequestCallback\n");

  if (*(code **)(param_1 + 0x14) != (code *)0x0) {
    (**(code **)(param_1 + 0x14))();
  }

  // ready to load next file
  DAT_8008d0a0 = 1;

  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// LOAD_NextQueuedFile
// cycles through loading queue and executes, not sure how though
void FUN_80032dc0(void)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  int iVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;

  if (
		(
			// if queue is ready to load next file
			(DAT_8008d0a0 != '\0') &&
			(DAT_8008d708 == 0)
		) &&

		// if you have requests in your loading queue
		(DAT_8008d0a2 != 0)
	  )
  {
	// queue is not ready for next file, after this one
    DAT_8008d0a0 = '\0';

    iVar3 = 1;

	// if this is not a retry attempt of previous load,
	// then read the next file in the queue
    if (DAT_8008d0a1 == '\0')
	{
	  // Copy the first element of the queue
	  // into temporary addresses where it can be executed

	  // These 6 lines can be simplifed to
	  // 	memcpy(0x80083a3c, 0x80096344, 24);

      DAT_80083a3c = DAT_80096344;
      DAT_80083a40 = DAT_80096348;
      DAT_80083a44 = DAT_8009634c;
      DAT_80083a48 = DAT_80096350;
      DAT_80083a4c = DAT_80096354;
      DAT_80083a50 = DAT_80096358;

	  // if you have more than one request in the queue
      if (1 < DAT_8008d0a2)
	  {
        puVar2 = &DAT_8009635c;
        puVar1 = (undefined4 *)&DAT_8009632c;

		// for(iVar3 = 1; iVar3 < queueLength; iVar3++)
        do
		{
		  // shift members of the queue closer to the front

		  // These next 10 lines can be simplified to
		  //	memcpy(0x80096344 + (iVar3-1)*24, 0x80096344 + (iVar3)*24, 24);

          uVar4 = puVar2[1];
          uVar5 = puVar2[2];
          uVar6 = puVar2[3];
          puVar1[6] = *puVar2;
          puVar1[7] = uVar4;
          puVar1[8] = uVar5;
          puVar1[9] = uVar6;
          uVar4 = puVar2[5];
          puVar1[10] = puVar2[4];
          puVar1[0xb] = uVar4;

		  // increment pointer counter
          iVar3 = iVar3 + 1;
          puVar2 = puVar2 + 6;
          puVar1 = puVar1 + 6;
        } while (iVar3 < DAT_8008d0a2);
      }
    }

	// if it is a retry
	else
	{
	  // erase retry variable,
	  // it will be set back to 1 if it fails again
      DAT_8008d0a1 = '\0';
    }
    if (DAT_80083a42 == 2)
	{
					// LOAD_DramFile
		// DAT_80083a3c eventually changes back to BIGFILE, not queue ptr
      DAT_80083a48 = FUN_80031e00(DAT_80083a3c,DAT_80083a44,DAT_80083a48,&DAT_80083a4c,DAT_80083a50);
    }
    else {
      if (DAT_80083a42 < 3) {
        if (DAT_80083a42 == 1)
		{
						// LOAD_ReadFile
		  // DAT_80083a3c eventually changes back to BIGFILE, not queue ptr
          DAT_80083a48 = FUN_800321b4(DAT_80083a3c,1,DAT_80083a44,DAT_80083a48,&DAT_80083a4c,
                                      FUN_80032d8c);
        }
      }
      else {
        if (DAT_80083a42 == 3)
		{
						// LOAD_VramFile
		  // DAT_80083a3c eventually changes back to BIGFILE, not queue ptr
          DAT_80083a48 = FUN_80031fdc(DAT_80083a3c,DAT_80083a44,DAT_80083a48,&DAT_80083a4c,
                                      DAT_80083a50);
        }
      }
    }

	// subtract from queue length
    DAT_8008d0a2 = DAT_8008d0a2 + -1;
  }
  if (
		// if a timer exists
		(DAT_8008d0a8 != 0) &&

		// if two frames have passed since the file finished loading
		(2 < (uint)(*(int *)(PTR_DAT_8008d2ac + 0x1ce4) - DAT_8008d0a8))
	 )
  {

	// When each element is added to loading queue, it has
	// the option of having a function pointer to be called
	// as a callback when the element is done loading

	// if this function pointer is not nullptr
	if (DAT_80083a50 != (code *)0x0)
	{
	  // execute the function pointer
      (*DAT_80083a50)(&DAT_80083a3c);
    }

	// reset timer
    DAT_8008d0a8 = 0;

	// If we used MEMPACK_AllocMem,
	// rather than some other place
	// to store Readfile
    if ((_DAT_80083a40 & 1) != 0) {

	  // MEMPACK_PopState
      FUN_8003e9d0();
    }

	// ready to load next file
    DAT_8008d0a0 = '\x01';
  }
  return;
}


// LOAD_Hub_ReadFile
// param1 is the Pointer to "cd position of bigfile"
// param2 is levID to load
// param3 is mem allocator ID
void FUN_80032ffc(undefined4 param_1,int param_2,int param_3)

{
  undefined *puVar1;
  undefined4 uVar2;

  // If this sub-mempack does not already have this LEV loaded, then load it
  if ((int)*(short *)(PTR_DAT_8008d2ac + param_3 * 2 + 0x254c) != param_2)
  {
	// erase mask hint model pointer (why?)
    DAT_8008d0f0 = 0;

	// change active allocation system to ???
    FUN_8003e80c();

	// MEMPACK_ClearLowMem
    FUN_8003e9b8();

	puVar1 = PTR_DAT_8008d2ac;

	// game is now loading
    DAT_8008d0a4 = 1;

	// clear pointer to secondary LEV (for adv hub)
    *(undefined4 *)(PTR_DAT_8008d2ac + 0x164) = 0;

    *(short *)(puVar1 + param_3 * 2 + 0x254c) = (short)param_2;

	// Get index of VRAM sub-file within BIGFILE, given Level ID and LOD number
    uVar2 = FUN_80032c24(param_2,1,0);

	// param1 is the Pointer to "cd position of bigfile"
	// var2 is the subfile index within BIGFILE
	// add to loading queue
	// second parameter '3' means vram
    FUN_80032d30(param_1,3,uVar2,0,0);

	// Get index of LEV sub-file within BIGFILE, given Level ID and LOD number
	uVar2 = FUN_80032c24(param_2,1,1);

	// param1 is the Pointer to "cd position of bigfile"
	// var2 is the subfile index within BIGFILE
	// add to loading queue
	// second parameter '2' means dram
	FUN_80032d30(param_1,2,uVar2,0,&FUN_80031a78);

	// Get index of sub-file within BIGFILE, given Level ID and LOD number
	uVar2 = FUN_80032c24(param_2,1,2);

	// param1 is the Pointer to "cd position of bigfile"
	// var2 is the subfile index within BIGFILE
	// 8008d090 = highMem PatchTable
	// add to loading queue
	// Call LOAD_HubCallback when this is done
	// second parameter '1' means readfile
	FUN_80032d30(param_1,1,uVar2,DAT_8008d090,FUN_80031b14);
  }
  return;
}


// LOAD_Hub_SwapNow
void FUN_80033108(void)

{
  undefined *puVar1;
  int iVar2;

  // 8008d2ac + 0x164 is set as soon as
  // LOAD_HubCallback is executed, and it
  // is set to zero when loading a hub begins

  // This infinitely waits until the next
  // hub is finished loading

  iVar2 = *(int *)(PTR_DAT_8008d2ac + 0x164);
  while (iVar2 == 0)
  {
	// LOAD_NextQueuedFile
	// execute loading queue
    FUN_80032dc0();

    VSync(0);
    iVar2 = *(int *)(PTR_DAT_8008d2ac + 0x164);
  }

  // Aug 5
  // FUN_8006fbac("gGT->level2 = 0x%08x\n",*(undefined4 *)(PTR_DAT_8008d2ac + 0x164));
  // FUN_8006fbac("SWAPPING 1...\n");

  // INSTANCE_LevInstancesStop
  // also erase any threads attached to instances
  FUN_80031268(**(undefined4 **)(PTR_DAT_8008d2ac + 0x160),1);

  // Aug 5
  // FUN_8006fbac("SWAPPING 2...\n");

  // swap primary and secondary LEV pointers
  FUN_80031bdc(PTR_DAT_8008d2ac,1);

  puVar1 = PTR_DAT_8008d2ac;

  // This actually does the swapping
  // If it is 1, make it 2
  // If it is 2, make it 1
  *(short *)(PTR_DAT_8008d2ac + 0x254a) = 3 - *(short *)(PTR_DAT_8008d2ac + 0x254a);

  // make a backup of your levelID before exiting the level,
  // this is used to help you return to an adventure hub after finishing a race
  *(undefined4 *)(puVar1 + 0x1eb4) = *(undefined4 *)(puVar1 + 0x1a10);

  // Set Level ID
  *(int *)(puVar1 + 0x1a10) =
       (int)*(short *)(puVar1 + (int)*(short *)(puVar1 + 0x254a) * 2 + 0x254c);

  // Audio_AdvHub_SwapSong
  FUN_8002d50c();

  // Aug 5
  // FUN_8006fbac("SWAPPING 3...\n");

  // Clear all model pointers
  FUN_800314c0(PTR_DAT_8008d2ac);

  /*
  In Aug 5
  if (DAT_8008d870 == 0)
  {
    printf("ERROR: No PLYROBJECTLIST!\n");
  }
  */

  // if PLYROBJECTLIST is valid
  if (DAT_8008d870 != 0)
  {
	// LOAD_GlobalModelPtrs_MPK
    FUN_80031b50();
  }

  // Get next level
  iVar2 = *(int *)(PTR_DAT_8008d2ac + 0x160);

  /*
  In Aug 5
  if(== 0)
  {
     printf("ERROR: No LEVEL!\n");
  }
  */

  // If you have a level
  if (iVar2 != 0)
  {
	// store array of model pointers in GameTracker
    FUN_8003147c(PTR_DAT_8008d2ac,*(undefined4 *)(iVar2 + 0x14),*(undefined4 *)(iVar2 + 0x18));

	// INSTANCE_LevInitAll
	// copy InstDef to InstancePool
	FUN_80030ad4(*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x10),
                 *(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0xc));

	// INSTANCE_LevInstancesStart
	FUN_8003116c(**(undefined4 **)(PTR_DAT_8008d2ac + 0x160));

	// DecalGlobal_Store
	// Load Icons and IconGroups from LEV
    FUN_80022bdc(PTR_DAT_8008d2ac,*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x3c));
  }

  // change active allocation system
  // swap 1 and 2 during adventure mode
  FUN_8003e80c((int)*(short *)(PTR_DAT_8008d2ac + 0x254a));

  // VisMem_Clear
  FUN_8003af84(PTR_DAT_8008d2ac);

  puVar1 = PTR_DAT_8008d2ac;

  // called VISMEM in prototypes
  iVar2 = *(int *)(PTR_DAT_8008d2ac + 0x1a38);

  // quadblock under the camera
  *(undefined4 *)(PTR_DAT_8008d2ac + 0x14b4) = 0;

  *(undefined4 *)(puVar1 + 0x14c0) = 0;
  *(undefined4 *)(puVar1 + 0x14b8) = 0;
  *(undefined4 *)(puVar1 + 0x14bc) = 0;
  *(undefined4 *)(puVar1 + 0x14c4) = 0;
  *(undefined4 *)(puVar1 + 0x14c8) = 0;

  // clear VisMem pointers
  *(undefined4 *)(iVar2 + 0x40) = 0;
  *(undefined4 *)(*(int *)(puVar1 + 0x1a38) + 0x50) = 0;
  *(undefined4 *)(*(int *)(puVar1 + 0x1a38) + 0x60) = 0;
  *(undefined4 *)(*(int *)(puVar1 + 0x1a38) + 0x70) = 0;

  // uadblock under driver
  *(undefined4 *)(*(int *)(puVar1 + 0x24ec) + 0x350) = 0;

  *(undefined4 *)(puVar1 + 0x1cfc) = 0;
  *(undefined4 *)(puVar1 + 0x1d00) = 0;
  return;
}


// LOAD_Hub_Main
// check if secondary lev needs
// to load, or swap, param given is bigfile
void FUN_80033318(undefined4 param_1)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  int iVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  int iVar9;
  undefined4 local_50 [16];

  // copy array from RAM onto Stack
  puVar1 = &DAT_80011180;
  puVar2 = local_50;
  do {
    puVar4 = puVar2;
    puVar3 = puVar1;
    uVar6 = puVar3[1];
    uVar7 = puVar3[2];
    uVar8 = puVar3[3];
    *puVar4 = *puVar3;
    puVar4[1] = uVar6;
    puVar4[2] = uVar7;
    puVar4[3] = uVar8;
    puVar1 = puVar3 + 4;
    puVar2 = puVar4 + 4;
  } while (puVar3 + 4 != (undefined4 *)&DAT_800111b0);

  uVar6 = puVar3[5];
  uVar7 = puVar3[6];
  puVar4[4] = 0x1c;
  puVar4[5] = uVar6;
  puVar4[6] = uVar7;

  // loop counter
  iVar9 = 0;

  // if number of screens is not zero
  if (PTR_DAT_8008d2ac[0x1ca8] != '\0') {

    // for(int iVar9 = 0; iVar9 < numScreens; iVar9++)
    do
	{
	  // if game is not loading
      if (DAT_8008d0f8 == -1)
	  {
		// can be 0,1,2,3
		// 0: dont need to load hub
		// 1-3: index of which hub connects to this one
        iVar5 =

			// pointer to address of each player structure
			(int)(*(uint *)(*(int *)(PTR_DAT_8008d2ac + iVar9 * 4 + 0x24ec)

			// if need to load new lev
			+ 0xbc) & 0x30) >> 4;

		// if new lev does not need to load
        if (iVar5 == 0)
		{
          if (
				((int)(*(uint *)(*(int *)

					// pointer to address of each player structure
					(PTR_DAT_8008d2ac + iVar9 * 4 + 0x24ec)

						// if player needs to swap hub (adv)
						+ 0xbc) & 0xc0) >> 6 != 0)
				||

				// if you need to swap LEVs (global, like oxide intro)
				(PTR_DAT_8008d2ac[0x2574] != '\0')
			 )
		  {
			// reset bool
            PTR_DAT_8008d2ac[0x2574] = 0;

			// LOAD_Hub_SwapNow
            FUN_80033108();
          }
        }

		// if new lev needs to load
        else {

		  // if Level ID is somewhere on adventure arena
          if (*(int *)(PTR_DAT_8008d2ac + 0x1a10) - 0x19U < 5)
		  {
			// LOAD_Hub_ReadFile
            FUN_80032ffc(
							// param1 always DAT_8008d86c
							param_1,

							// levID from the array of hubs that connect to this one
							local_50[

								// Level ID (0 - 5) of adventure map, * 3
								(*(int *)(PTR_DAT_8008d2ac + 0x1a10) - 0x19U) * 3 + iVar5 + -1
							],

							// memory allocator ID (1 or 2)
							3 - (int)*(short *)(PTR_DAT_8008d2ac + 0x254a)
                        );
          }
        }
      }

	  // increment loop counter
      iVar9 = iVar9 + 1;

					// number of screens
    } while (iVar9 < (int)(uint)(byte)PTR_DAT_8008d2ac[0x1ca8]);
  }
  return;
}

// param1 alter which DLL loads
// DLL = 225 + param_1
void FUN_80033474(int param_1)

{
  // if overlayIndex_LOD loaded is not the one being requested
  if ((uint)(byte)PTR_DAT_8008d2ac[0x2540] != param_1 - 1U)
  {
	// load new overlay,
	// this means it skips loading if
	// the overlay was already loaded before

	// game is now loading
    DAT_8008d0a4 = 1;

	// Load DLL
	// add to load queue from range 225 (param1 + 0xe1)
	// DAT_8008d09c is the Pointer to "cd position of bigfile"
	// second parameter '1' means readfile
    FUN_80032d30(DAT_8008d09c,1,param_1 + 0xe1,&DAT_800a0cb8,&FUN_800319e8);

	// overlayIndex_LOD loaded
	PTR_DAT_8008d2ac[0x2540] = (char)(param_1 - 1U);

	// force overlayIndex_Threads to reload
    PTR_DAT_8008d2ac[0x2541] = 0xff;	// but why? what a waste
  }
  return;
}

// param1 alter which DLL loads
// DLL loaded = param_1 + 221
void FUN_800334f4(uint param_1)

{
  // if overlayIndex_EndOfRace is different than the overlay requested
  if ((uint)(byte)PTR_DAT_8008d2ac[0x2543] != param_1)
  {
	// load new overlay, this means
	// overlay wont load unless changed

	// game is now loading
    DAT_8008d0a4 = 1;

	// Load DLL
	//add to load queue from range 221 (param1 + 0xdd)
	// DAT_8008d09c is the Pointer to "cd position of bigfile"
	// second parameter '1' means readfile
    FUN_80032d30(DAT_8008d09c,1,param_1 + 0xdd,&DAT_8009f6fc,&FUN_800319e8);

	// save new overlayIndex_EndOfRace
	PTR_DAT_8008d2ac[0x2543] = (char)param_1;

	// force LOD overlay to reload,
	// by nullifying the saved index
    PTR_DAT_8008d2ac[0x2540] = 0xff;	// but why? what a waste
  }
  return;
}

// param1 alter which DLL loads
// DLL loaded = param_1 + 230
void FUN_80033570(uint param_1)

{
  // if overlayIndex_Threads changed from last time
  if ((uint)(byte)PTR_DAT_8008d2ac[0x2541] != param_1)
  {
	// load new overlay,
	// therefore, overlay shouldn't reload unless changed

	// game is now loading
    DAT_8008d0a4 = 1;

	// do not save overlayIndex_Threads,
	// the value will be written in a callback
	PTR_DAT_8008d2ac[0x2541] = 0xff;	// but why? why not do it here?

	// Load DLL to 0xab9f0
	// add to load queue from range 230 (param1 + 0xe6)
	// DAT_8008d09c is the Pointer to "cd position of bigfile"
	// second parameter '1' means readfile
    FUN_80032d30(DAT_8008d09c,1,param_1 + 0xe6,&DAT_800ab9f0,(&PTR_FUN_80083a70)[param_1]);
  }
  return;
}


// Get Memory Allocation System Index
undefined4 FUN_800335dc(void)

{
  if (
		// Level ID != 25
		// Not on GemStone Valley
		(*(int *)(PTR_DAT_8008d2ac + 0x1a10) != 0x19) &&

		// Level ID != 28
		// Not on Glacier Park
		(*(int *)(PTR_DAT_8008d2ac + 0x1a10) != 0x1c)
     )
  {
    return 1;
  }
  return 2;
}

// case 0 - splashscreens / cutscenes
// case 1 - overlay level1
// case 2 - overlay level2
// case 3 - overlay level3
// case 4 - leave main menu, load drivers
// case 5 - model pointers (2160)
// case 6 - load LEV
// case 7 - load icons and models from LEV
// case 8 - adventure swap hubs
// case 9 - enable loading screen (checkered flag)

// LOAD_TenStages
// param_1 is gGT
// param_2 is loading stage
// param_3 is the Pointer to "cd position of bigfile"
int FUN_80033610(undefined4 param_1,int param_2,undefined4 param_3)

{
  byte *pbVar1;
  undefined uVar2;
  undefined *puVar3;
  short sVar4;
  int iVar5;
  undefined4 uVar6;
  code *pcVar7;
  undefined4 *puVar8;
  int iVar9;
  uint uVar10;
  byte bVar11;
  int iVar12;
  char *pcVar13;
  undefined *puVar14;
  int *piVar15;
  undefined4 uVar16;
  undefined4 uVar17;
  undefined auStack40 [8];

  puVar3 = PTR_DAT_8008d2ac;

  // pointer to LEV
  iVar9 = DAT_8008d08c;

  // if game is loading
  if (DAT_8008d0a4 != 0) {
    return param_2;
  }

  // if game is not loading, continue

  switch(param_2) {
  case 0:

	// if level is not in range of 0x28 and 0x28+1,
	// if level is not AdvGarage or Naughty Dog Box Scene
    if (1 < *(int *)(PTR_DAT_8008d2ac + 0x1a10) - 0x28U)
	{
	  // Cutscene_VolumeBackup
      FUN_8002c18c();
    }

	// CDSYS_XAPauseRequest
    FUN_8001cf98();

	// if you've already drawn intro frames
	// "sony computer entertainment" + "copyright page"
    if (DAT_8008d0bc == 0)
	{
	  // change active allocation system to #1
	  // used for whole game (except adventure arena)
      FUN_8003e80c(0);

	  // FUN_8003c1d4 converts string to level ID
	  // "proto8" -> 0 (dingo canyon)
	  // "proto9" -> 1 (dragon mines)
	  // "desert2" -> 2 (blizard bluff)
	  // "island1" -> 3 (crash cove)
	  // etc

	  // DAT_8008d83e = Get Level ID from String
      DAT_8008d83e = FUN_8003c1d4(PTR_DAT_8008d2ac + 0x1a14);

	  // erase all memory past this bookmark
      FUN_8003ea08(DAT_8008d098);
    }

	// if you have not drawn the intro frames yet
    else
	{
	  // Record that you've seen the logos,
	  // so that you do not see them again
      DAT_8008d0bc = 0;

	  // Load Intro TIM for Sony Presents from VRAM file
	  // Add a bookmark before loading (param_3 is 0 in the call)
      FUN_80031fdc(param_3,0x1fe,0,auStack40,0xffffffff);

	  // refresh screen during Intro
      FUN_8003c310();

	  // set isbg of both DBs to false
      PTR_DAT_8008d2ac[0x30] = 0;
      PTR_DAT_8008d2ac[0xd4] = 0;
    }

    puVar3 = PTR_DAT_8008d2ac;

	// Turn off HUD
    PTR_DAT_8008d2ac[0x1d31] = PTR_DAT_8008d2ac[0x1d31] & 0xfe;

    puVar14 = PTR_DAT_8008d2ac;

	// disable all rendering except loading screen
	*(uint *)(puVar3 + 0x256c) = *(uint *)(puVar3 + 0x256c) & 0x1000;

    puVar14[0x1d31] = puVar14[0x1d31] & 0xf7;
    puVar3 = PTR_DAT_8008d2ac;

	// uvar2 = number of players
    uVar2 = PTR_DAT_8008d2ac[0x1ca9];

	// set pointer of current LEV to zero
    *(undefined4 *)(PTR_DAT_8008d2ac + 0x160) = 0;

	// set pointer of 2nd LEV (used in adv hub) to zero
    *(undefined4 *)(puVar3 + 0x164) = 0;

	// set number of screens to number of players
    puVar3[0x1ca8] = uVar2;

	// copy level name into global string
	strcpy(PTR_DAT_8008d2ac + 0x1a14,
           (&PTR_s_proto8_80083a84)[*(int *)(PTR_DAT_8008d2ac + 0x1a10) * 6]);

	// add a bookmark, the index of the bookmark is
	// saved into 0x8d098, which is used to erase later
    DAT_8008d098 = FUN_8003e978();

	DrawSync(0);
    puVar3 = PTR_DAT_8008d2ac;

	// no overlay transition
	PTR_DAT_8008d2ac[0x2579] = 0;

    puVar14 = PTR_DAT_8008d2ac;
    pcVar13 = PTR_DAT_8008d2ac + 0x1a14;
    *(uint *)puVar3 = *(uint *)puVar3 & 0xdfcfdfff;
    *(uint *)(puVar3 + 8) = *(uint *)(puVar3 + 8) & 0xfffffe5f;

	// called VISMEM in prototypes
    *(undefined4 *)(puVar14 + 0x1a38) = 0;
    *(undefined4 *)(puVar14 + 0x1a3c) = 0;

	// DAT_8008d0c0
	// "ndi"
    iVar9 = strncmp(pcVar13,&DAT_8008d0c0,3);

    if (
			// If you're in Naughty Dog Box Scene
			(iVar9 == 0) ||
			(
				// s_ending_8008d0c4
				// "ending"
				iVar9 = strncmp(PTR_DAT_8008d2ac + 0x1a14,s_ending_8008d0c4,6),
				iVar9 == 0
			)
       ) {
      puVar3 = PTR_DAT_8008d2ac;
      pbVar1 = PTR_DAT_8008d2ac + 0x1d31;

	  // Enable cutscene flag (disable controls)
      *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac | 0x20000000;

      puVar3[0x1d31] = *pbVar1 & 0xfe;
    }
    else
	{
	  // s_intro_8008d0cc
	  // "intro"
	  iVar9 = strncmp(PTR_DAT_8008d2ac + 0x1a14,s_intro_8008d0cc,5);

	  // pointer to main game structure
	  puVar3 = PTR_DAT_8008d2ac;

	  // if you are loading oxide intro cutscene (from main menu)
      if (iVar9 == 0)
	  {
		// Turn off HUD
        PTR_DAT_8008d2ac[0x1d31] = PTR_DAT_8008d2ac[0x1d31] & 0xfe;

        puVar14 = PTR_DAT_8008d2ac;
        *(uint *)puVar3 = *(uint *)puVar3 | 0x20000000;

		// lev swap will be needed
        *(uint *)(puVar14 + 8) = *(uint *)(puVar14 + 8) | 0x20;
      }

	  // if you are not loading oxide intro
      else
	  {
		// s_screen_8008d0d4
		// "screen"
        iVar9 = strncmp(PTR_DAT_8008d2ac + 0x1a14,s_screen_8008d0d4,6);

	  if (
			// if you are loading any menu of any kind
			(iVar9 == 0) ||
			(
				// s_garage_8008d0dc
				// "garage"
				iVar9 = strncmp(PTR_DAT_8008d2ac + 0x1a14,s_garage_8008d0dc,6),

				// if you are loading into adventure character selection screen
				iVar9 == 0
			)
		  )
		{
          puVar3 = PTR_DAT_8008d2ac;
          uVar10 = *(uint *)PTR_DAT_8008d2ac;

		  // Turn off HUD
          PTR_DAT_8008d2ac[0x1d31] = PTR_DAT_8008d2ac[0x1d31] & 0xfe;

          puVar14 = PTR_DAT_8008d2ac;

		  // enable flag that shows you are in main menu
          *(uint *)puVar3 = uVar10 | 0x2000;

		  // set number of players to number of screens
          puVar14[0x1ca9] = puVar14[0x1ca8];

		  // set number of screens to 4
		  // Either 4P mode or main menu
          PTR_DAT_8008d2ac[0x1ca8] = 4;

		  // s_garage_8008d0dc
		  // "garage"
          iVar9 = strncmp(PTR_DAT_8008d2ac + 0x1a14,s_garage_8008d0dc,6);

		  // if you are loading into character selection screen
          if (iVar9 == 0)
		  {
			// set number of screens to 1
            PTR_DAT_8008d2ac[0x1ca8] = 1;

			// Enter Adventure Character Selection
            DAT_8008d97c = 4;
          }
        }

		// if you are not loading menu or adventure character selection
		else {

		  // DAT_8008d0e4
		  // "hub"
          iVar9 = strncmp(PTR_DAT_8008d2ac + 0x1a14,&DAT_8008d0e4,3);

		  // pointer to main game structure
		  puVar3 = PTR_DAT_8008d2ac;

		  // if you are loading into adventure map:
		  // any of the hubs: "hub1", "hub2", etc
		  if (iVar9 == 0)
		  {
			// Set Number of Players to 1
            PTR_DAT_8008d2ac[0x1ca9] = 1;

			// set Number of Screens to 1
			puVar3[0x1ca8] = 1;

            puVar14 = PTR_DAT_8008d2ac;

			// Change mode to Adventure Arena
            *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac | 0x100000;
            bVar11 = puVar14[0x1d31];

			// lev swap will be needed
            uVar10 = *(uint *)(puVar14 + 8) | 0x20;
          }

		  // if you are not loading adventure hub
		  else {

			// check to see if you are loading credits
            iVar9 = strncmp(PTR_DAT_8008d2ac + 0x1a14,s_credit_8008d0e8,6);

            puVar3 = PTR_DAT_8008d2ac;

			if (iVar9 != 0)
			{
			  // Turn off HUD
              PTR_DAT_8008d2ac[0x1d31] = PTR_DAT_8008d2ac[0x1d31] & 0xfe;
              goto LAB_80033a70;
            }

			// set Number of Players to 1
            PTR_DAT_8008d2ac[0x1ca9] = 1;

			// set Number of Screens to 1
            puVar3[0x1ca8] = 1;

            puVar14 = PTR_DAT_8008d2ac;

			// enable cutscene flag
            *(uint *)puVar3 = *(uint *)puVar3 | 0x20000000;

            bVar11 = puVar14[0x1d31];
			
			// lev swap (&20) and credits (&80)
            uVar10 = *(uint *)(puVar14 + 8) | 0xa0;
          }
          *(uint *)(puVar14 + 8) = uVar10;
          puVar14[0x1d31] = bVar11 & 0xfe;
        }
      }
    }
LAB_80033a70:

	// Enable HUD Instances
    PTR_DAT_8008d2ac[0x1d31] = PTR_DAT_8008d2ac[0x1d31] | 2;

	// Debug_ToggleNormalSpawn
    PTR_DAT_8008d2ac[0x253f] = 1;

	// Set LOD level to 1P level
    DAT_8008d83c = 1;

    if (
			// If not in main menu (character selection, track selection, any part of it)
			((*(uint *)PTR_DAT_8008d2ac & 0x2000) == 0) &&
			(
				// set LOD level to 8P level (does this exist??)
				DAT_8008d83c = 8,

				// if not loading, and not in time trial
				(*(uint *)PTR_DAT_8008d2ac & 0x4020000) == 0)
		)
	{
	  // Set LOD level to number of screens
	  DAT_8008d83c = (ushort)(byte)PTR_DAT_8008d2ac[0x1ca8];
    }

	// SetPrimMemSize
    FUN_8003b0f0(PTR_DAT_8008d2ac);

	// SetOTMemSize
    FUN_8003b334(PTR_DAT_8008d2ac);

	// 2 is for cutscene
	// 1 is for If you're in Adventure Arena
    if (((*(uint *)PTR_DAT_8008d2ac & 0x20100000) != 0) ||

		// if going to credits
       ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x80) != 0))
	{

	  // AllocateAllPools
	  // (now, at beginning of mempack)
      FUN_8003b43c( /*PTR_DAT_8008d2ac*/ );

      return param_2 + 1;
    }
    break;
  case 1:

	// if XA has not paused yet,
	// since the request above,
	// due to IRQ not being hit yet
    if (DAT_8008d708 == 4)
	{
	  // quit, try again next frame
      return param_2;
    }

    uVar10 = *(uint *)PTR_DAT_8008d2ac;

	// If you're in Crystal Challenge (in adventure mode)
    if ((uVar10 & 0x8000000) != 0)
	{
	  // DLL 221 (221 + 0)
      uVar16 = 0;
LAB_80033bd8:

	  // Load 221 + uVar16
      FUN_800334f4(uVar16);
      return param_2 + 1;
    }

    // If you're in Time Trial
    if ((uVar10 & 0x20000) != 0)
	{
	  // DLL 224 (221 + 3)
      uVar16 = 3;

	  // Load 221 + uVar16
      goto LAB_80033bd8;
    }

	// If you're in Arcade Mode
    if ((uVar10 & 0x400000) != 0)
	{
	  // DLL 222 (221 + 1)
      uVar16 = 1;

	  // Load 221 + uVar16
      goto LAB_80033bd8;
    }

	// If you're in a Relic Race
    if ((uVar10 & 0x4000000) != 0)
	{
	  // DLL 223 (221 + 2)
      uVar16 = 2;

	  // Load 221 + uVar16
      goto LAB_80033bd8;
    }

	// If you're in Adventure Mode
	if ((uVar10 & 0x80000) != 0)
	{
	  // DLL 222 (221 + 1)
      uVar16 = 1;

	  // Load 221 + uVar16
      goto LAB_80033bd8;
    }

	// DLL 225 (221 + 4)
	uVar16 = 4;

	// If you are not in Arcade or VS cup				DLL 221 + uVar16
    if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x10) == 0) goto LAB_80033bd8;
    break;
  case 2:

	// 225 is for Naughty Dog Box

	// Load DLL 225 + number of screens
	// 226 - 229
    FUN_80033474((uint)(byte)PTR_DAT_8008d2ac[0x1ca8]);
    break;
  case 3:

	// If in main menu (character selection, track selection, any part of it)
    if (((*(uint *)PTR_DAT_8008d2ac & 0x2000) != 0) &&


       (
			// DLL 230 (230 + 0)
			uVar16 = 0,

			// LevelID != 40, not on adventure character selection
			*(int *)(PTR_DAT_8008d2ac + 0x1a10) != 0x28)
	   )
	{
LAB_80033ccc:
	  // Load DLL 230 + uVar6
      FUN_80033570(uVar16);
      return param_2 + 1;
    }

	// If you're in Adventure Arena
    if ((*(uint *)PTR_DAT_8008d2ac & 0x100000) != 0)
	{
	  // By default, load Podium DLL

	  // DLL 233 (230 + 3)
      uVar16 = 3;

	  // podium reward
      if (*(short *)(PTR_DAT_8008d2ac + 0x2572) == 0)
	  {
		// Load a different DLL

		// DLL 232 (230 + 2)
        uVar16 = 2;
      }

	  // Load DLL 230 + uVar16
      goto LAB_80033ccc;
    }

	// podium reward
    if ((((*(short *)(PTR_DAT_8008d2ac + 0x2572) != 0) ||

		  // If you are in a cutscene
         ((*(uint *)PTR_DAT_8008d2ac & 0x20000000) != 0)) ||

		// if going to credits
        ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x80) != 0)) ||

		// If LevelID is 40
		// If you're in Adventure Character Select Screen
       (*(int *)(PTR_DAT_8008d2ac + 0x1a10) == 0x28))
	{
	  // DLL 233 (230 + 3)
      uVar16 = 3;

	  // Load DLL 230 + uVar16
      goto LAB_80033ccc;
    }

	// DLL 231 (230 + 1)
    uVar16 = 1;
    if (PTR_DAT_8008d2ac[0x2541] != '\x01') goto LAB_80033ccc;
    break;
  case 4:

	// if level is not in range of 0x28 and 0x28+1,
	// if level is not AdvGarage or Naughty Dog Box Scene
    if (1 < *(int *)(PTR_DAT_8008d2ac + 0x1a10) - 0x28U)
	{
	  // Music_Restart
      FUN_8002e4c0();
    }

	// If in main menu (character selection, track selection, any part of it)
    if ((*(uint *)PTR_DAT_8008d2ac & 0x2000) != 0)
	{
	  // all these are 230 except
	  // for adv garage, 233

      switch(DAT_8008d97c)
	  {
	  // main menu
      case 0:
	    // MM_JumpTo_Title_FirstTime
        FUN_800b4364();
        break;

	  case 1:
	    // MM_JumpTo_Characters
        FUN_800b446c();
        break;

	  // track selection
	  case 2:
	    // MM_JumpTo_TrackSelect
        FUN_800b4430();
        break;

	  // battle selection
	  case 3:
	    // MM_JumpTo_BattleSetup
        FUN_800b43f4();
        break;

	  // Character Selection 3D (Adventure)
      case 4:
	    // CS_Garage_Init
        FUN_800b8558();
        break;

	  // scrapbook
      case 5:
		// MM_JumpTo_Scrapbook
        FUN_800b44a8(param_3);
      }
    }
    DAT_80083a10 = 0;
    DAT_80083a14 = 0;
    DAT_80083a18 = 0;
    DAT_8008d088 = (int *)0x0;

	// game is now loading
    DAT_8008d0a4 = 1;

	// LOAD_DriverMPK
	// 8008d83c = LOD level (num players, plus Time Trial flag)
    FUN_8003282c(param_3,(int)(short)DAT_8008d83c,&FUN_80031b00);
    break;
  case 5:

	// Clear all model pointers
    FUN_800314c0(PTR_DAT_8008d2ac);

	// set value of PLYROBJECTLIST,
	// the array of model pointers from MPK 
	// that was loaded in loading stage 4
    DAT_8008d870 = DAT_8008d088 + 1;
    if (DAT_8008d088 == (int *)0x0) {
      DAT_8008d870 = (int *)0x0;
    }

	// LOAD_GlobalModelPtrs_MPK
    FUN_80031b50();

	// DecalGlobal_Clear
    FUN_80022b9c(PTR_DAT_8008d2ac);

    if ((DAT_8008d088 == (int *)0x0) || (*DAT_8008d088 == 0)) {
      *(undefined4 *)(PTR_DAT_8008d2ac + 0x1b28) = 0;
    }
    else 
	{
	  // DecalGlobal_Store
      FUN_80022bdc(PTR_DAT_8008d2ac);
      *(int *)(PTR_DAT_8008d2ac + 0x1b28) = *DAT_8008d088;
    }

	// if level is not in range of 0x28 and 0x28+1,
	// if level is not AdvGarage or Naughty Dog Box Scene
    if (1 < *(int *)(PTR_DAT_8008d2ac + 0x1a10) - 0x28U) {

	  // Music_Stop
	  FUN_8002e4ec();

	  // CseqMusic_StopAll
	  FUN_80029258();

	  // Music_LoadBanks
      FUN_8002dd74();

      return param_2 + 1;
    }
    break;
  case 6:

	// if level is not in range of 0x28 and 0x28+1,
	// if level is not AdvGarage or Naughty Dog Box Scene
    if (1 < *(int *)(PTR_DAT_8008d2ac + 0x1a10) - 0x28U)
	{
	  // Music_AsyncParseBanks
      iVar9 = FUN_8002de48();

      if (iVar9 == 0) {
        return param_2;
      }

	  // Cutscene_VolumeRestore
      FUN_8002c1d0();
    }

	// loop counter
    iVar9 = 0;

	// loop through models
    piVar15 = &DAT_80083a10;

	// for iVar9 = 0; iVar9 < 3; iVar9++
	do 
	{
	  // if pointer is valid
      if (*piVar15 != 0) 
	  {
		// increment pointer by 4,
		// change pointer to file (starting at pointer map)
		// into a pointer to the model itself
        *piVar15 = *piVar15 + 4;
      }

	  // increment loop counter
      iVar9 = iVar9 + 1;

      piVar15 = piVar15 + 1;
    } while (iVar9 < 3);

	// If the world you're in is made of multiple LEV files
    if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x20) != 0)
	{
	  // ivar9 is the size of one allocation pool
	  // ivar12 is the size of another

	  // Intro cutscene with oxide spaceship and all racers
      iVar9 = 0x6b000;

	  // If you're in Adventure Arena
      if ((*(uint *)PTR_DAT_8008d2ac & 0x100000) != 0) {
        iVar9 = 0x68800;
      }

	  // Intro cutscene with oxide spaceship and all racers
	  iVar12 = 0x40000;

	  // If you're in Adventure Arena
      if ((*(uint *)PTR_DAT_8008d2ac & 0x100000) != 0) {
        iVar12 = 0x68800;
      }

	  // Size needed for HUB is var9 + var12
	  // Pointer to hub is var5

	  // Allocate Adventure Arena
	  // MEMPACK_AllocMem
      iVar5 = FUN_8003e874(iVar9 + iVar12,"HUB ALLOC");

	  // Set 8008d854 to pointer that hub will use
      DAT_8008d854 = iVar5;

	  // Change active allocation system to #2
	  FUN_8003e80c(1);

	  // Build a new allocation system from
	  // iVar5 address with a size of iVar9
	  FUN_8003e830(iVar5,iVar9);

	  // Change active allocation system to #3
	  FUN_8003e80c(2);

	  // Build a new allocation system from
	  // address (ivar5 + ivar9), which comes after
	  // the previous allocation system, with
	  // a size of iVar12 bytes
	  FUN_8003e830(iVar5 + iVar9,iVar12);

	  // Get Game Mode structure
	  puVar3 = PTR_DAT_8008d2ac;

	  // Intro cutscene with oxide spaceship and all racers
      if ((*(uint *)PTR_DAT_8008d2ac & 0x100000) == 0)
	  {
		// Always start with pool 1
        sVar4 = 1;
      }

	  // If you're in Adventure Arena
	  else
	  {
		// Get 1 or 2, depending on map
        sVar4 = FUN_800335dc();

		// Then swap:
		// Turn 1 into 2
		// Turn 2 into 1
        sVar4 = 3 - sVar4;
      }

      puVar14 = PTR_DAT_8008d2ac;

	  // set the memory pool system ID
      *(short *)(puVar3 + 0x254a) = sVar4;

	  // globally store the Level ID for this mempack
      *(undefined2 *)(puVar14 + (int)*(short *)(puVar14 + 0x254a) * 2 + 0x254c) =
           *(undefined2 *)(puVar14 + 0x1a10);

	  // globally erase the Level ID in the other mempack
      *(undefined2 *)(puVar14 + (3 - (int)*(short *)(puVar14 + 0x254a)) * 2 + 0x254c) = 0xffff;

	  // change active allocation system to #1
	  // used for whole game (except adventure arena)
	  FUN_8003e80c(0);

	  // Get amount of free memory in CTR
      DAT_8008d094 = FUN_8003e85c();

	  // MEMPACK_AllocHighMem
      DAT_8008d090 = FUN_8003e8e8(DAT_8008d094,"Patch Table Memory");

	  // change active allocation system
	  // Swap 1 and 2 while on adventure map
      FUN_8003e80c((int)*(short *)(PTR_DAT_8008d2ac + 0x254a));
    }

	// game is now loading
    DAT_8008d0a4 = 1;

	// get VRAM subfile index within BIGFILE,
	// of the track you want to load
    uVar16 = FUN_80032c24(

			// Level ID you want to load
			*(undefined4 *)(PTR_DAT_8008d2ac + 0x1a10),

			// LOD of level you want to load
			(int)(short)DAT_8008d83c,0);

	// adds VRAM to loading queue
	// second parameter '3' means vram
	FUN_80032d30(param_3,3,uVar16,0,0);

	// Level ID you want to load
    iVar9 = *(int *)(PTR_DAT_8008d2ac + 0x1a10);

	// if level ID some cutscene, with a super high value
	// 25-39, or
	// 44-64
    if ((iVar9 - 0x19U < 0xe) || (iVar9 - 0x2cU < 0x14))
	{
	  // get LEV subfile index within BIGFILE,
	  // of the track you want to load
      uVar16 = FUN_80032c24(

			// Level ID you want to load
			iVar9,

			// LOD of level you want to load
			(int)(short)DAT_8008d83c,1);

	  // adds LEV to loading queue
	  // '2' means dram
      FUN_80032d30(param_3,2,uVar16,0,&FUN_80031a78);

	  // get .ptr subfile from BIGFILE
	  // last param 0 for vram, 1 for lev, 2 for .ptr
      uVar6 = FUN_80032c24(

			// Level ID you want to load
			*(undefined4 *)(PTR_DAT_8008d2ac + 0x1a10),

			// LOD of level you want to load
			(int)(short)DAT_8008d83c,2);

	  // '1' means readfile
      uVar17 = 1;

	  // callback for adv levs (not HubCallback)
      pcVar7 = FUN_80031aa4;

	  // HighMem patch table
      uVar16 = DAT_8008d090;
    }

	// if Level ID is not something insane

	// Load ordinary track (arcade, battle, ND box)
    else
	{
	  // get LEV subfile index within BIGFILE,
	  // of the track you want to load
      uVar6 = FUN_80032c24(

			// Level ID you want to load
			iVar9,

			// LOD of level you want to load
			(int)(short)DAT_8008d83c,1);

	  // 2 for dram
      uVar17 = 2;

      uVar16 = 0;

	  // callback for normal levs
      pcVar7 = (code *)&FUN_80031a78;
    }

	// add LEV to loading queue
    FUN_80032d30(param_3,uVar17,uVar6,uVar16,pcVar7);
    break;
  case 7:

	// Set LEV pointer
    *(int *)(PTR_DAT_8008d2ac + 0x160) = DAT_8008d08c;

	// iVar9 is set to DAT_8008d08c at the top of the function

	// gGT->VisMem = lev->VisMem (400 = 0x190)
    *(undefined4 *)(puVar3 + 0x1a38) = *(undefined4 *)(iVar9 + 400);

	// if LEV is valid
	if (*(int *)(puVar3 + 0x160) != 0)
	{
	  // DecalGlobal_Store
	  // Load Icons and IconGroups from LEV
      FUN_80022bdc(puVar3,*(undefined4 *)(*(int *)(puVar3 + 0x160) + 0x3c));
    }

	// DebugFont_Init
	FUN_800222e0(PTR_DAT_8008d2ac);

	// get level pointer
	iVar9 = *(int *)(PTR_DAT_8008d2ac + 0x160);

	// if level is not nullptr
    if (iVar9 != 0)
	{
	  // store array of model pointers in GameTracker
      FUN_8003147c(PTR_DAT_8008d2ac,*(undefined4 *)(iVar9 + 0x14),*(undefined4 *)(iVar9 + 0x18));

	  // search for icon by string
	  uVar16 = FUN_80022c88(*(undefined4 *)(PTR_DAT_8008d2ac + 0x160),"circle");
      puVar8 = (undefined4 *)(PTR_DAT_8008d2ac + 0x160);
      *(undefined4 *)(PTR_DAT_8008d2ac + 0x1b14) = uVar16;

	  // search for icon by string
      uVar16 = FUN_80022c88(*puVar8,"clod"); // &DAT_800111ec = "clod"
	  puVar8 = (undefined4 *)(PTR_DAT_8008d2ac + 0x160);
      *(undefined4 *)(PTR_DAT_8008d2ac + 0x1b18) = uVar16;

	  // search for icon by string
	  uVar16 = FUN_80022c88(*puVar8,"dustpuff");
      puVar8 = (undefined4 *)(PTR_DAT_8008d2ac + 0x160);
      *(undefined4 *)(PTR_DAT_8008d2ac + 0x1b1c) = uVar16;

	  // search for icon by string "Smoke Ring"
	  uVar16 = FUN_80022c88(*puVar8,"smokering");
      puVar8 = (undefined4 *)(PTR_DAT_8008d2ac + 0x160);
      *(undefined4 *)(PTR_DAT_8008d2ac + 0x1b20) = uVar16;

	  // search for icon by string
	  uVar16 = FUN_80022c88(*puVar8,"sparkle");
      *(undefined4 *)(PTR_DAT_8008d2ac + 0x1b24) = uVar16;
    }

	// if linked list of icons exists
	if (*(int *)(PTR_DAT_8008d2ac + 0x1b28) != 0) {

	  // search for icon by string
	  uVar16 = FUN_80022d2c(*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x1b28) + 4),"lightredoff");
	  piVar15 = (int *)(PTR_DAT_8008d2ac + 0x1b28);
      *(undefined4 *)(PTR_DAT_8008d2ac + 0x1ecc) = uVar16;

	  // search for icon by string
	  uVar16 = FUN_80022d2c(*(undefined4 *)(*piVar15 + 4),"lightredon");
      piVar15 = (int *)(PTR_DAT_8008d2ac + 0x1b28);
      *(undefined4 *)(PTR_DAT_8008d2ac + 0x1ed0) = uVar16;

	  // search for icon by string
	  uVar16 = FUN_80022d2c(*(undefined4 *)(*piVar15 + 4),"lightgreenoff");
      piVar15 = (int *)(PTR_DAT_8008d2ac + 0x1b28);
      *(undefined4 *)(PTR_DAT_8008d2ac + 0x1ed4) = uVar16;

	  // search for icon by string
	  uVar16 = FUN_80022d2c(*(undefined4 *)(*piVar15 + 4),"lightgreenon");
      *(undefined4 *)(PTR_DAT_8008d2ac + 0x1ed8) = uVar16;
    }
    puVar3 = PTR_DAT_8008d2ac;
    *(undefined4 *)(PTR_DAT_8008d2ac + 4) = 1;

    if (
			// 2 is for cutscene
			// 1 is for If you're in Adventure Arena
			((*(uint *)puVar3 & 0x20100000) == 0) &&

			// if not going to credits
			((*(uint *)(puVar3 + 8) & 0x80) == 0)
		)
	{
	  // AllocateAllPools
	  // (now, at end of mempack)
      FUN_8003b43c( /*PTR_DAT_8008d2ac*/ );

      return param_2 + 1;
    }
    iVar9 = 7;

	// podium reward
    if (*(short *)(PTR_DAT_8008d2ac + 0x2572) != 0)
	{
	  // clear all podium model pointers
      puVar8 = &DAT_80083a38;
      do {
        *puVar8 = 0;
        iVar9 = iVar9 + -1;
        puVar8 = puVar8 + -1;
      } while (-1 < iVar9);
	  
	  // Get Memory Allocation System Index
      iVar9 = FUN_800335dc();

	  // change active allocation system
	  // Swap 1 and 2 while on adventure map
      FUN_8003e80c(3 - (int)*(short *)(PTR_DAT_8008d2ac + 0x254a));

	  // game is now loading
      DAT_8008d0a4 = 1;

	  // add something to loading queue
	  // '3' for vram
      FUN_80032d30(param_3,3,iVar9 + 0x16b,0,0);

	  // podium first place
      bVar11 = PTR_DAT_8008d2ac[0x2575];

      if (
			// if this exists
			(bVar11 != 0) && 
			
			// if not 0x7e + 0xF
			// if not oxide
			(bVar11 != 0x8d)
		 )
	  {
		// add something to loading queue
		// '2' for dram
        FUN_80032d30(param_3,2,iVar9 + ((uint)bVar11 - 0x7e) * 2 + 0x16d,&DAT_80083a1c,0xfffffffe);
      }

	  // podium second place exists
      if (PTR_DAT_8008d2ac[0x2576] != 0)
	  {
		// adds to loading queue
		// '2' for dram
        FUN_80032d30(param_3,2,iVar9 + ((uint)(byte)PTR_DAT_8008d2ac[0x2576] - 0x7e) * 2 + 0x18d,
                     &DAT_80083a20,0xfffffffe);
      }
	  
	  // podium third place exists
      if (PTR_DAT_8008d2ac[0x2577] != 0)
	  {
		// add something to loading queue
		// '2' for dram
        FUN_80032d30(param_3,2,iVar9 + ((uint)(byte)PTR_DAT_8008d2ac[0x2577] - 0x7e) * 2 + 0x18d,
                     &DAT_80083a24,0xfffffffe);
      }

	  // add TAWNA to loading queue
	  // '2' for dram
      FUN_80032d30(param_3,2,iVar9 + ((uint)(byte)PTR_DAT_8008d2ac[0x2578] - 0x8f) * 2 + 0x1ad,
                   &DAT_80083a28,0xfffffffe);

	  // -0x7d = 0x83
	  // 0x83 - 0x7e = 5 (dingo)
      if (PTR_DAT_8008d2ac[0x2575] == -0x7d)
	  {
		// add "DingoFire" to loading queue
		// '2' for dram
        FUN_80032d30(param_3,2,iVar9 + 0x1bd,&DAT_80083a30,0xfffffffe);
      }

	  // add Podium
	  // '2' for dram
      FUN_80032d30(param_3,2,iVar9 + 0x1bf,0,&FUN_80031a64);

	  // Disable LEV instances on Adv Hub, for podium scene
      *(uint *)(PTR_DAT_8008d2ac + 8) = *(uint *)(PTR_DAT_8008d2ac + 8) | 0x100;
    }
    break;
  case 8:

    // If you're in Adventure Arena
    if (
			((*(uint *)PTR_DAT_8008d2ac & 0x100000) != 0) &&
			(
				// loop counter
				iVar9 = 0,

				// podium reward
				*(short *)(PTR_DAT_8008d2ac + 0x2572) != 0
			)
	   ) {
      piVar15 = &DAT_80083a1c;

	  // for iVar9 = 0; iVar9 < 8; iVar9++
      do {
        iVar12 = *piVar15;
        if (iVar12 != 0) {
          if (iVar9 < 7) {
            *piVar15 = iVar12 + 4;
            iVar12 = *piVar15;
          }
          if ((int)*(short *)(iVar12 + 0x10) != -1) {
            *(int *)(puVar3 + (int)*(short *)(iVar12 + 0x10) * 4 + 0x2160) = iVar12;
          }
        }

		// increment loop counter
        iVar9 = iVar9 + 1;

        piVar15 = piVar15 + 1;
      } while (iVar9 < 8);

	  // change active allocation system
	  // Swap 1 and 2 while on adventure map
      FUN_8003e80c((int)*(short *)(PTR_DAT_8008d2ac + 0x254a));
    }

	// Level ID
    iVar9 = *(int *)(PTR_DAT_8008d2ac + 0x1a10);

	// Main Menu
    if (iVar9 == 0x27) {
      uVar16 = 7;
LAB_800346b0:

	  // Audio_SetState_Safe
      FUN_8002d4cc(uVar16);

      return param_2 + 1;
    }

	// One of the maps on Adventure Arena
    if (iVar9 - 0x19U < 5) {
      uVar16 = 6;

	  // podium reward
      if (*(short *)(PTR_DAT_8008d2ac + 0x2572) == 0) {
        uVar16 = 5;
      }
      goto LAB_800346b0;
    }

	// oxide intro
    if (iVar9 == 0x1e) {
      uVar16 = 3;
      goto LAB_800346b0;
    }

	// credits
    if (iVar9 == 0x2c) {
      uVar16 = 2;
      goto LAB_800346b0;
    }

	// Naughty Dog Box
    if (iVar9 == 0x29) {
      uVar16 = 4;
      goto LAB_800346b0;
    }

	// stop/pause cseq music
	uVar16 = 1;

    if (iVar9 - 0x2aU < 2) goto LAB_800346b0;
    break;
  case 9:
    if (DAT_8008d708 != 2) {

      if (

			// If not in main menu (not in 2D character selection, track selection, or any part of it)
			((*(uint *)PTR_DAT_8008d2ac & 0x2000) == 0) ||

			// If level ID == 40
			// If you are in Adventure Character Selection
			(*(int *)(PTR_DAT_8008d2ac + 0x1a10) == 0x28)

		 )
	  {
		// if not going to credits
        if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x80) == 0)
		{
		  // enable all flags except loading screen
          uVar10 = *(uint *)(PTR_DAT_8008d2ac + 0x256c) | 0xffffefff;
        }

		// if going to credits
        else
		{
		  // disable everything (except loading screen if still there)
		  // enable drawing render bucket
          uVar10 = *(uint *)(PTR_DAT_8008d2ac + 0x256c) & 0x1000 | 0x20;
        }

		// apply desired value
        *(uint *)(PTR_DAT_8008d2ac + 0x256c) = uVar10;
      }
      else
	  {
		  // disable everything (except loading screen if still there)
		  // enable pause menu? Or enable 3D cars on track?
        *(uint *)(PTR_DAT_8008d2ac + 0x256c) = *(uint *)(PTR_DAT_8008d2ac + 0x256c) & 0x1000 | 0x20;

		// CheckeredFlag_IsFullyOffScreen
        iVar9 = FUN_80043f28();
        if (iVar9 == 1)
		{
		  // checkered flag, begin transition on-screen
          FUN_80043fb0(1);
        }
      }
      PTR_DAT_8008d2ac[0x1d31] = PTR_DAT_8008d2ac[0x1d31] | 8;
      puVar3 = PTR_DAT_8008d2ac;
      *(undefined4 *)(PTR_DAT_8008d2ac + 0x1cfc) = 0;
      *(undefined4 *)(puVar3 + 0x1d00) = 0;

	  // deactivate pause
      FUN_80024c08();

	  param_2 = -2;
    }
  default:
    goto switchD_80033660_caseD_a;
  }
  param_2 = param_2 + 1;
switchD_80033660_caseD_a:
  return param_2;
}

// LOAD_TalkingMask
// param1 is mempack index
// param2 is aku or uka
void FUN_800347d0(int param_1,int param_2)

{
  int iVar1;

  // erase mask hint model pointer (why?)
  DAT_8008d0f0 = 0;

  *(undefined2 *)(PTR_DAT_8008d2ac + param_1 * 2 + 0x254c) = 0xffff;

  // change active allocation system to ???
  FUN_8003e80c();

  // MEMPACK_ClearLowMem
  FUN_8003e9b8();

  // aku or uka file index
  iVar1 = (param_1 + -1) * 2;

  // Game is now loading
  DAT_8008d0a4 = 1;

  // iVar1 alters LOD
  // param2*4 alters aku vs uka

  // load the vram for 3D mask hints
  // DAT_8008d09c is the Pointer to "cd position of bigfile"
  // '3' for vram
  FUN_80032d30(DAT_8008d09c,3,param_2 * 4 + iVar1 + 0x1b6,0,0);

  // load the model for 3D mask hints,
  // see the callback function for proof
  // '2' for dram
  FUN_80032d30(DAT_8008d09c,2,param_2 * 4 + iVar1 + 0x1b7,0,&FUN_80031a50);
  return;
}


// param1 is lev ID being loaded
// start loading level
void FUN_80034874(undefined4 param_1)

{
  undefined *puVar1;
  undefined *puVar2;
  undefined4 uVar3;
  int iVar4;

  puVar1 = PTR_DAT_8008d2ac;

  // erase mask hint model pointer (why?)
  DAT_8008d0f0 = 0;

  // Turn off HUD
  PTR_DAT_8008d2ac[0x1d31] = PTR_DAT_8008d2ac[0x1d31] & 0xfe;

  puVar2 = PTR_DAT_8008d2ac;

  // Level ID
  // set active lev ID to the lev ID being loaded
  uVar3 = *(undefined4 *)(puVar1 + 0x1a10);
  *(undefined4 *)(puVar1 + 0x1a10) = param_1;

  // make a backup of your levelID before exiting the level,
  // this is used to help you return to an adventure hub after finishing a race
  *(undefined4 *)(puVar1 + 0x1eb4) = uVar3;

  // disable loading screen's flag,
  // what? why?
  // is & 0x1000 only for the transition?
  *(uint *)(puVar2 + 0x256c) = *(uint *)(puVar2 + 0x256c) & 0x1000;

  // CheckeredFlag_IsFullyOffScreen
  iVar4 = FUN_80043f28();
  if (iVar4 == 1)
  {
	// checkered flag, begin transition on-screen
    FUN_80043fb0(1);
  }

  // set loading state to begin
  DAT_8008d0f8 = 0;

  return;
}


//4 functions below check if game has proper DLL loaded in slot 3 (230-233)
//the game calls these before calling the dll functions
//if (some_condition && call_result) { dll_function(); }
//an example can be found in render function: FUN_80035e70

// LOAD_IsOpen_RacingOrBattle
uint FUN_800348e8(void)
//231.dll
{
  return (uint)(PTR_DAT_8008d2ac[0x2541] == '\x01');
}


// LOAD_IsOpen_MainMenu
uint FUN_80034908(void)
//230.dll
{
  return (uint)(PTR_DAT_8008d2ac[0x2541] == '\0');
}


// LOAD_IsOpen_AdvHub
uint FUN_80034920(void)
//232.dll
{
  return (uint)(PTR_DAT_8008d2ac[0x2541] == '\x02');
}


// LOAD_IsOpen_Podiums
uint FUN_80034940(void)
//233.dll
{
  return (uint)(PTR_DAT_8008d2ac[0x2541] == '\x03');
}


// param_1 is levelID
// param_2 is number of screens
undefined4 FUN_80034960(undefined4 param_1,int param_2)

{
  switch(param_1) {

  // If papu's pyramid or polar pass
  case 5:
  case 0xc:

    // if 3 or 4 players
    if (2 < param_2) {
      return 0x9c4;
    }
    break;

  // if sewer speedway
  case 8:
    return 6000;

  // if mystery caves
  case 9:
    return 0x9c4;

  // main menu
  case 0x27:
    return 0x10;

  // adventure character selection
  case 0x28:
    return 24000;
  }
  return 3000;
}


// Alloc_PrimMem
// param_1 is &gGT->DB[x].primMem
void FUN_800349c4(uint *param_1,uint param_2)

{
  uint uVar1;

  // MEMPACK_AllocMem
  uVar1 = FUN_8003e874(param_2,s_PrimMem_8008d2b8);

  // size
  *param_1 = param_2;

  // unk 0x18
  param_1[6] = uVar1;

  // curr
  param_1[3] = uVar1;

  // start
  param_1[1] = uVar1;

  // start + size
  uVar1 = uVar1 + (param_2 & 0xfffffffc);

  // end
  param_1[2] = uVar1;

  // end - 0x100 (why?)
  param_1[4] = uVar1 - 0x100;
  return;
}

// Alloc_OTMem
// param_1 is &gGT->DB[x].otMem
void FUN_80034a28(uint *param_1,uint param_2)

{
  uint uVar1;

  // MEMPACK_AllocMem
  uVar1 = FUN_8003e874(param_2,s_OTMem_8008d2c0);

  // size
  *param_1 = param_2;

  // curr
  param_1[3] = uVar1;

  // start
  param_1[1] = uVar1;

  // end
  param_1[2] = uVar1 + (param_2 & 0xfffffffc);

  return;
}

// drawsync callback
void FUN_80034a80(void)

{
  // if OT was submitted
  if (*(char *)(8008D2AC + 0x1d30) == '\x01')
  {
	// now it's finished
    *(undefined *)(8008D2AC + 0x1d30) = 0;
  }
  return;
}

// vsync callback
void FUN_80034aa4(void)

{
  undefined *puVar1;
  long lVar2;
  uint uVar3;

  puVar1 = PTR_DAT_8008d2ac;
  uVar3 = *(uint *)PTR_DAT_8008d2ac;

  // frame timer
  *(int *)(PTR_DAT_8008d2ac + 0x1ce4) = *(int *)(PTR_DAT_8008d2ac + 0x1ce4) + 1;

  // If game is not paused
  if ((uVar3 & 0xf) == 0) {

	// Frame Counter for particles
	*(int *)(puVar1 + 0x1cf0) = *(int *)(puVar1 + 0x1cf0) + 1;
  }

  // frame duplicator
  DAT_8008d2b4 = DAT_8008d2b4 + -1;

  // count vsync calls between drawsync
  *(int *)(PTR_DAT_8008d2ac + 0x1ce0) = *(int *)(PTR_DAT_8008d2ac + 0x1ce0) + 1;

  // elapsed units since previous vsync
  // 1 unit = 1/16th millisecond
  lVar2 = GetRCnt(0xf2000001);

  // increment system
  // 1 second = ~16,000 units
  DAT_8008d988 = DAT_8008d988 + lVar2;

  // reset timer
  ResetRCnt(0xf2000001);

  // howl_PlayAudio_PerFrame
  FUN_8002c208();

  // check for unplugged controllers
  FUN_80025410(PTR_DAT_8008d2b0);

  return;
}


//toggles sound (used by pause menu)
//0 = unpause, 1 = pause
//howl_TogglePause
void FUN_80034b48(int param_1)

{
  //if we want to unpause
  if (param_1 == 0) {
    //if sound is paused
    if (DAT_8008d8a4 != 0)
	{
      // howl_StopAudio (stops menu sounds)
	  // keep backup,
	  // keep music (no music to stop),
	  // stop all fx
      FUN_8002c8a8(0,0,1);

	  // unpause audio (restore gameplay sounds)
      FUN_8002c784();

	  //set sound to unpaused
      DAT_8008d8a4 = 0;
    }
  }
  else {
    //if sound is paused
    if (DAT_8008d8a4 == 0)
	{
      // OtherFX_Stop2
      FUN_80028844(1);

	  //pause audio
      FUN_8002c510();

	  //set sound to paused
      DAT_8008d8a4 = 1;
    }
  }
  return;
}


// StartNewFrame
void FUN_80034bbc(int param_1)

{
  undefined *puVar1;
  int iVar2;
  int iVar3;
  int iVar4;

  // LOAD_Hub_Main
  // check if secondary lev needs
  // to load, or swap, param given is bigfile
  FUN_80033318(DAT_8008d86c);

  // 1 - [swapchain index]
  iVar3 = 1 - *(int *)(param_1 + 0xc);

  // set pointer to DCB
  *(int *)(param_1 + 0x10) = param_1 + iVar3 * 0xa4 + 0x18;

  // flip the swapchain index
  *(int *)(param_1 + 0xc) = iVar3;

  // number of frames drawn
  *(int *)(param_1 + 0x1cf8) = *(int *)(param_1 + 0x1cf8) + 1;

  *(undefined *)(*(int *)(param_1 + 0x10) + 0x70) = 0;

  // Reeset PrimMem
  // CurrByte = FirstByte
  *(undefined4 *)(*(int *)(param_1 + 0x10) + 0x80) =
  *(undefined4 *)(*(int *)(param_1 + 0x10) + 0x78);

  *(undefined4 *)(*(int *)(param_1 + 0x10) + 0x88) = 0;

  // Reset OTMem
  // CurrByte = FirstByte
  *(undefined4 *)(*(int *)(param_1 + 0x10) + 0x9c) =
  *(undefined4 *)(*(int *)(param_1 + 0x10) + 0x94);

  // Empty placeholder, not a Ghidra fail
  FUN_80021c8c();

  // Empty placeholder, not a Ghidra fail
  FUN_80022b94(param_1);

  ClearOTagR(*(undefined4 *)(param_1 + *(int *)(param_1 + 0xc) * 4 + 0x18c8),

				// number of screens << 10 | 6
               (uint)(byte)PTR_DAT_8008d2ac[0x1ca8] << 10 | 6);

  puVar1 = PTR_DAT_8008d2ac;

  // loop iteration counter
  iVar4 = 0;

  iVar3 = param_1;

  // if number of screens is not zero
  if (PTR_DAT_8008d2ac[0x1ca8] != '\0')
  {
	// Initialize OTMem of each player, each 0x1000 apart,
	// overflowing OTMem of one player will impact graphics of another

	// for iVar4 = 0; iVar4 < numScreens; iVar4++
    do {
      iVar2 = (uint)(byte)puVar1[0x1ca8] - iVar4;

	  // increment loop iteration counter
      iVar4 = iVar4 + 1;

	  // pointer to Camera110->OTMem (25c-168=0xf4)
      *(int *)(iVar3 + 0x25c) =

			// ptrOT depending on swapchain index, plus playerIndex * 0x1000
           *(int *)(param_1 + *(int *)(param_1 + 0xc) * 4 + 0x18c8) + (iVar2 + -1) * 0x1000 + 0x18;

	  // next camera110
      iVar3 = iVar3 + 0x110;

    } while (iVar4 < (int)(uint)(byte)puVar1[0x1ca8]);
  }

  // Initialize OTMem of non-present players to be out of bounds

  // if less than 4 players (yes, I'm certain)
  if (iVar4 < 4)
  {
	// camera110 (at max [3])
    iVar3 = iVar4 * 0x110 + param_1;

	// for iVar4 = iVar4 (not typo); iVar4 < 4; iVar4++
    do {

	  // increment loop counter
      iVar4 = iVar4 + 1;

	  // pointer to Camera110->OTMem (25c-168=0xf4)
      *(int *)(iVar3 + 0x25c) =

			// the OTMem after 3rd player,
			// pointer to OTMem of (non-present) 4th player
			*(int *)(param_1 + *(int *)(param_1 + 0xc) * 4 + 0x18c8) + 0x3018;

	  // next camera110
      iVar3 = iVar3 + 0x110;

    } while (iVar4 < 4);
  }

  // something to do with OT pointers in GameTracker
  iVar3 = *(int *)(param_1 + *(int *)(param_1 + 0xc) * 4 + 0x18c8) + 4;

  // pointer to OT mem
  *(int *)(param_1 + 0x147c) = iVar3;

  // setting OT pointer in DCB
  *(int *)(*(int *)(param_1 + 0x10) + 0xa0) = iVar3;
  return;
}


// GameplayUpdateLoop
// param1 = 8008d2ac - main game struct
// param2 = 8008d2b0 - controller struct
void FUN_80034d54(uint *param_1,int param_2)

{
  bool bVar1;
  short sVar2;
  code *pcVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  undefined *puVar9;
  int iVar10;
  uint *puVar11;

  // assume game is paused
  bVar1 = true;

  // If game is not paused
  if ((*param_1 & 0xf) == 0)
  {
	// game is not paused
    bVar1 = false;

	// pointer to first Player thread
    iVar10 = *(int *)(PTR_DAT_8008d2ac + 0x1b2c);

	// pointer to P1's camera110 struct (pos, size, etc)
    puVar9 = PTR_DAT_8008d2ac + 0x168;

	// loop through players
    while (iVar10 != 0) {
                    // WARNING: Read-only address (ram,0x8008d874) is written

	  //iVar7 = Racer struct Pointer
	  // grab object from thread
      iVar7 = *(int *)(iVar10 + 0x30);

	  // clockSend? what is clockSend?
      if (*(char *)(iVar7 + 0x45) != '\0')
	  {
		// decrease timer
        *(char *)(iVar7 + 0x45) = *(char *)(iVar7 + 0x45) + -1;
      }

      if (*(byte *)(iVar7 + 0x367) == 0)
	  {
        //if racer has not received a clock effect
        if (*(short *)(iVar7 + 0xc) == 0)
		{
          uVar5 = (uint)*(byte *)(iVar7 + 0x45);
          if (*(byte *)(iVar7 + 0x45) == 0) {
            if ((*(ushort *)(PTR_DAT_8008d2ac + 0x2570) & 1) == 0) goto LAB_80034e74;
            uVar5 = 10000;
          }
        }

		//if racer is receiving a clock effect
        else
		{
          //if racer finished the race
          if ((*(uint *)(iVar7 + 0x2c8) & 0x2000000) != 0)
		  {
            //prevent clock effect from happening
            *(undefined2 *)(iVar7 + 0xc) = 0;
          }
          uVar5 = SEXT24(*(short *)(iVar7 + 0xc));
        }

		// DISPLAY_Blur_Main
        FUN_80023d4c(puVar9,uVar5);
      }

      else
	  {
		// DISPLAY_Blur_Main
        FUN_80023d4c(puVar9,-(uint)*(byte *)(iVar7 + 0x367));

		// decrease timer
        *(char *)(iVar7 + 0x367) = *(char *)(iVar7 + 0x367) + -1;
      }
LAB_80034e74:

	  // player -> next
      iVar10 = *(int *)(iVar10 + 0x10);

	  // increment pointer to next camera110 struct
      puVar9 = puVar9 + 0x110;
    }

	// frame timer since boot
    param_1[0x73b] = param_1[0x73b] + 1;

	// not camera110 struct anymore, now main game struct
    puVar9 = PTR_DAT_8008d2ac;

	// frame timer since end of loading
    param_1[0x73f] = param_1[0x73f] + 1;

    *(undefined4 *)(puVar9 + 0x1cd4) = 0;

	// RCNT_GetTime_Elapsed
	// basically, get root counter and divide by ~5
    iVar10 = FUN_8004b41c(param_1[0x742],&param_1[0x742]);

	// multiply 32, divide 100
	// divide by ~3
	uVar5 = (iVar10 << 5) / 100;

	// 1000 * 16000 units / 5246 / 3 = 1000ms
	// 1000 * elapsedUnits / 5246 / 3 = milliseconds

	// elapsed milliseconds per frame
    param_1[0x741] = uVar5;

	// if negative time elapsed somehow
    if ((int)uVar5 < 0)
	{
	  // assume 32ms passed
      param_1[0x741] = 0x20;
    }

	// 64ms = 15fps
	// if more than 64 milliseconds elapsed
    if (0x40 < (int)param_1[0x741])
	{
	  // assume only 64 milliseconds passed,
	  // let the game slow down, so physics dont break
      param_1[0x741] = 0x40;
    }

	// 32ms = 30fps
	// if millisecond timers should be forced to be frame timers
	if ((*(uint *)(PTR_DAT_8008d2ac + 4) & 0xf) != 0)
	{
	  // assume elapsed time is 32 milliseconds
      param_1[0x741] = 0x20;
    }

	// milliseconds since end of loading
    param_1[0x740] = param_1[0x740] + param_1[0x741];

    puVar9 = PTR_DAT_8008d2ac;
    if ((int)param_1[0x743] < 1)
	{
	  // if PauseAllThreads is diabled
      if ((*(uint *)PTR_DAT_8008d2ac & 0x10) == 0) {

        // if amount of frozen time left (relic races) is less or equal than zero
        if ((int)param_1[0x788] < 1) {

          // If you're not in End-Of-Race menu
          if ((*(uint *)PTR_DAT_8008d2ac & 0x200000) == 0) {
            param_1[0x744] = param_1[0x744] + param_1[0x741];
          }
        }

        // if you still have time frozen time left...
        else {

          // uVar5 = amount of frozen time left - a value that changes constantly between 31/32 (tick rate?)
          uVar5 = param_1[0x788] - param_1[0x741];

          // amount of frozen time left = new amount of time left
          param_1[0x788] = uVar5;

          // if new amount of frozen time left is less than zero
          if ((int)uVar5 < 0) {

            // amount of frozen time left equals zero
            param_1[0x788] = 0;
          }

          // if the amount of frozen time left is non negative
          else {
            uVar5 = *(uint *)(puVar9 + 0x1cec);

			// every six frames, play a sound
            if (uVar5 == (uVar5 / 6) * 6)
			{
			  // alternate between sounds each 6 frames

			  // multiple of 12
              if (uVar5 == (uVar5 / 0xc) * 0xc)
			  {
				// OtherFX_Play_LowLevel
				// Play "tick" sound
                FUN_800284d0(0x40,0,0x8c9080);
              }

			  // multiple of only 6
              else
			  {
				// OtherFX_Play_LowLevel
				// Play "tick" sound
                FUN_800284d0(0x40,0,0x8c8880);
              }
            }
          }
        }
      }
    }
    else {
      param_1[0x744] = 0;
    }

	// animate textures on PLYROBJECTLIST,
	// such as blinking eyes on Crash in main menu
    FUN_80021ac0(0xffffffff,DAT_8008d870,param_1[0x73b]);

	// animate textures for LEV related models,
	// including the ND Box Scne 1010101010101
    FUN_80021ac0(*(undefined4 *)(param_1[0x58] + 0x14),*(undefined4 *)(param_1[0x58] + 0x18),
                 param_1[0x73b]);
    iVar10 = 0;

	// pointer to first Player thread
    iVar7 = *(int *)(PTR_DAT_8008d2ac + 0x1b2c);

    iVar6 = 0;

	// loop through all players
    while (iVar7 != 0)
	{
	  // thread -> object
      iVar4 = *(int *)(iVar7 + 0x30);
      iVar8 = iVar6;

	  // Player / AI structure + 0x4a shows driver index (0-7)

	  // If this is Player 1
      if (*(char *)(iVar4 + 0x4a) == '\0') {
LAB_80035098:
        iVar10 = iVar4;
        iVar6 = iVar8;
      }
      else
	  {
		// If this is Player 2, or first AI (boss, ghost, etc)
        if (*(char *)(iVar4 + 0x4a) == '\x01') {
          iVar6 = iVar4;
        }
        iVar8 = iVar10;
        if (*(byte *)(iVar4 + 0x559) < *(byte *)(iVar10 + 0x559)) goto LAB_80035098;
      }

	  // player -> next
      iVar7 = *(int *)(iVar7 + 0x10);
    }

    if (((iVar10 != 0) && (iVar6 != 0)) &&
       (iVar7 = (uint)*(byte *)(iVar6 + 0x559) - (uint)*(byte *)(iVar10 + 0x559),
       *(short *)(iVar10 + 0x4f2) < iVar7)) {
      *(undefined2 *)(iVar10 + 0x4f2) = (short)iVar7;
    }
    iVar6 = 0;

	// loop counter
    iVar10 = 0;

	// pointer to threadbucket
    iVar7 = 0x1b2c;

    puVar11 = param_1;

	// for iVar10 = 0; iVar10 < 0x11; iVar10++
	do
	{

      if (
			(
				// if PauseAllThreads is diabled
				((*(uint *)PTR_DAT_8008d2ac & 0x10) == 0) ||

				// if this bucket cannot be paused
				((((int *)((int)param_1 + iVar7))[3] & 1U) != 0)
			) &&

		  // If threadbucket has threads
		  (*(int *)((int)param_1 + iVar7) != 0)
         )
	  {
		// if this is player threadbucket
        if (iVar10 == 0)
		{
		  // pointer to first Player thread
          iVar8 = *(int *)(PTR_DAT_8008d2ac + 0x1b2c);

		  // repeat until you're done with every player structure,
		  // you'll know you're done when you reach nullptr
          while (iVar8 != 0)
		  {
            // WARNING: Read-only address (ram,0x8008d874) is written

			// Weapon_Shoot_OnCirclePress
            FUN_800666e4(*(undefined4 *)(iVar8 + 0x30));

			// increment pointer to go to next player
            iVar8 = *(int *)(iVar8 + 0x10);
          }
                    // WARNING: Read-only address (ram,0x8008d874) is written

		  // loop iteration counter
          iVar8 = 0;

		  // execute every function in the array of function
		  // pointers that is within the player struct,
		  // 0xD (13) function pointers

		  // for iVar8 = 0; iVar8 < 0xd; iVar8++
          do
		  {
			// pointer to first Player thread
            iVar4 = *(int *)(PTR_DAT_8008d2ac + iVar6 + 0x1b2c);
            if (iVar4 != 0) {
              do {
                if ((*(int *)(iVar4 + 0x2c) == 0) &&

					// iVar4 + 0x30 = pointer to player struct
					// 0x54 is the offset of first function pointer,
					// iVar8 * 4, becuase each function pointer is 4 bytes
                   (pcVar3 = *(code **)(*(int *)(iVar4 + 0x30) + iVar8 * 4 + 0x54),

				   // If this pointer is not nullptr
                   pcVar3 != (code *)0x0))
				{
				  // execute the function pointer
                  (*pcVar3)(iVar4);
                }

				// go to next player
                iVar4 = *(int *)(iVar4 + 0x10);

              } while (iVar4 != 0);
            }

			// increment loop counter
            iVar8 = iVar8 + 1;
          } while (iVar8 < 0xd);
        }

		// execute all thread update functions
        FUN_800715e8(puVar11[0x6cb]);
      }

	  // next threadbucket
      puVar11 = puVar11 + 5;

	  // next threadbucket (again)
      iVar6 = iVar6 + 0x14;

	  // increment loop counter
      iVar10 = iVar10 + 1;

	  // next threadbucket
      iVar7 = iVar7 + 0x14;

	// loop through all threadbuckets
    } while (iVar10 < 0x11);

	// BOTS_UpdateGlobals
    FUN_80013374(PTR_DAT_8008d2ac);

	// Record ghost data
    FUN_80027f20(0);

    *(uint *)(PTR_DAT_8008d2ac + 0x1cd4) =
         (uint)(*(int *)(PTR_DAT_8008d2ac + 0x1cd4) * 10000) / 0x147e;

	// Particle_UpdateAllParticles
    FUN_8003f434();
  }

  // if game is paused
  else
  {
	// aku threadbucket
    if (param_1[0x711] != 0)
	{
	  // execute all thread update functions
      FUN_800715e8();
    }
  }

  // Check if 231.dll is loaded
  iVar10 = FUN_800348e8();

  // If it is loaded
  if (iVar10 != 0) {

	// If game is not paused
    if ((*(uint *)PTR_DAT_8008d2ac & 0xf) == 0)
	{
	  // RB_Bubbles_RoosTubes
      FUN_800b39dc();
    }

	// pointer to first burst thread
    if (*(int *)(PTR_DAT_8008d2ac + 0x1bb8) != 0) 
	{
	  // RB_Burst_DrawAll
      FUN_800b25b8();
    }
  }

  // THREAD_CheckAllForDead
  FUN_80041ff4();

  // If game is not paused
  if ((*(uint *)PTR_DAT_8008d2ac & 0xf) == 0)
  {
	// Audio_PerFrame
    FUN_8002d67c();
  }
  puVar9 = PTR_DAT_8008d2b0;
  param_1[1] = *param_1;

  // Check for change in the amount of controllers connected
  iVar10 = FUN_800255b4(puVar9);


  uVar5 = *(uint *)PTR_DAT_8008d2ac;


  // If you're not in End-Of-Race menu
  if ((uVar5 & 0x200000) == 0)
  {
    if (

			// if game is paused
			(bVar1) ||

			// or		???

			// if game is paused
			((*param_1 & 0xf) != 0)
		)
	{
	  // if game has been paused for more than 5 frames,
	  // this is here so you dont spam pause button
      if (PTR_DAT_8008d2ac[0x1d38] == '\0')
	  {
        if (
			(
				// If active MenuBox is not Options
				(DAT_8008d908 != &DAT_80084190) &&

				// If active MenuBox is not AkuAku Hints
				(DAT_8008d908 != &DAT_800b518c)
			) &&

			// If you press Start
			((DAT_8008d950 & 0x1000) != 0)
		   )
		{
		  // clear controller input (for menus)
          FUN_80046404();

		  // Unpause game
          *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac & 0xfffffffe;

		  // unpause audio
          FUN_80034b48(0);

		  // OtherFX_Play
          FUN_80028468(1,1);

		  // AdvPause_SafeDestroy
          FUN_800399fc();

		  // deactivate pause
          FUN_80024c08(PTR_DAT_8008d2ac);

		  // make MenuBox invisible
          FUN_800469c8(DAT_8008d908);

		  // set countdown since unPaused,
		  // must wait 5 frames before pausing again
          PTR_DAT_8008d2ac[0x1d39] = 5;
        }
      }
      else
	  {
		// decrease frame timer since start of pause
        PTR_DAT_8008d2ac[0x1d38] = PTR_DAT_8008d2ac[0x1d38] + -1;
      }
    }
    else
	{
	  // If you are allowed to pause the game,
	  // after waiting 5 frames since last unpause
      if (PTR_DAT_8008d2ac[0x1d39] == '\0') {
        if (
				(
					// if not in cutscene,
					// end-of-race, or main menu
					((uVar5 & 0x20202000) == 0) &&

					// if no menuBox
					(DAT_8008d908 == (undefined *)0x0)
				) &&
				(
					(
						DAT_8008d874 == 0 &&
						(
							(
								// CheckeredFlag_IsFullyOnScreen
								iVar7 = FUN_80043f1c(),

								// if not fully on screen
								iVar7 == 0 &&

								(
									// loop counter
									iVar7 = 0,

									// (72a*4 = 1ca8), numPlayers
									*(char *)(param_1 + 0x72a) != '\0'
								)
							)
						)
					)
				)
			 )
		{
		  // for iVar7 = 0; iVar7 < ??? iVar7++
          do {
            if (
				(
					(
						// if there is a change in the number
						// of controllers that are connected
						(iVar10 != 0) &&
						(
							(
								// check for missing controllers, depending on numPlayers
								uVar5 = FUN_80035d70((uint)(byte)PTR_DAT_8008d2ac[0x1ca9]),

								// if a controller is missing that is needed
								(uVar5 & 0xffff) == 0

								// If the game is not paused
								&& ((*param_1 & 0xf) == 0)
							)
						)
					) ||

					// If anyone tries to pause the game by pressing Start
					((*(uint *)(param_2 + 0x14) & 0x1000) != 0)
				) &&

				// If an overlay is loaded in slot 230-233
               (PTR_DAT_8008d2ac[0x2541] != -1)
			  )
			{
			  // This pauses the game somehow

              *(uint *)(PTR_DAT_8008d2ac + 0x1d44) = *(uint *)PTR_DAT_8008d2ac & 0x3e0020 | 1;

			  // Pause the game
			  FUN_80039e98();

			  // wait 5 frames after pausing,
			  // before allowing functionality
			  // in the pause menu, so you dont
			  // copy input from gameplay into menu
              PTR_DAT_8008d2ac[0x1d38] = 5;
            }

			// increment loop counter
            iVar7 = iVar7 + 1;

            param_2 = param_2 + 0x50;

			// (72a*4 = 1ca8), numPlayers
          } while (iVar7 < (int)(uint)*(byte *)(param_1 + 0x72a));
        }
      }
      else
	  {
		// reduce frame counter since previous unpause
        PTR_DAT_8008d2ac[0x1d39] = PTR_DAT_8008d2ac[0x1d39] + -1;
      }
    }
  }

  // If you're in End-Of-Race menu
  else
  {
	// if cooldown after end of VS game is zero
    if (*(short *)(PTR_DAT_8008d2ac + 0x1d36) == 0)
	{
	  // Remove on-screen comments and give
	  // menu for Retry, Change Level, etc

      uVar5 = *(uint *)(PTR_DAT_8008d2ac + 0x1d44);
      if ((uVar5 & 0x1000000) == 0) {
        if ((uVar5 & 0x8000000) == 0) {
          if (*(short *)(PTR_DAT_8008d2ac + 0x1d34) == 0) {
            return;
          }
        }
        else {
          if (*(short *)(PTR_DAT_8008d2ac + 0x1d34) == 0) {
            if ((uVar5 & 2) == 0) {
              return;
            }

			// OSK_DrawMenu
			sVar2 = FUN_8004aa60(0x140);

            if (sVar2 == 0) {
              return;
            }
            if (sVar2 == 1) {
              DAT_8008d918 = 0;

			  // Set Load/Save to "Slot selected" mode
              FUN_80048e2c(0x41);

			  // make menu visible
              FUN_80046990(&DAT_80085be0);

              *(uint *)(PTR_DAT_8008d2ac + 0x1d44) =
                   *(uint *)(PTR_DAT_8008d2ac + 0x1d44) | 0x1000000;
              return;
            }

			// no new high score
			PTR_DAT_8008d2ac[0x1d49] = 0xff;

            *(uint *)(PTR_DAT_8008d2ac + 0x1d44) = *(uint *)(PTR_DAT_8008d2ac + 0x1d44) & 0xf3ffffff
            ;
            return;
          }
        }
        *(short *)(PTR_DAT_8008d2ac + 0x1d34) = *(short *)(PTR_DAT_8008d2ac + 0x1d34) + -1;
      }
    }
    else {
      if ((uVar5 & 0x400000) == 0) {

		// If race ended a few seconds ago, start drawing comments,
		// after cooldown had some time to go down (under 0x96)
        if (*(short *)(PTR_DAT_8008d2ac + 0x1d36) < 0x96)
		{
		  // EndOfRace_DrawAllComments
          FUN_800550f4();

		  // Wait for players to press X to continue
          FUN_800552a4();
        }

		// if counter is higher than 0x1e
        if (0x1e < *(short *)(PTR_DAT_8008d2ac + 0x1d36))
		{
		  // reduce countdown by one frame, every frame
          *(short *)(PTR_DAT_8008d2ac + 0x1d36) = *(short *)(PTR_DAT_8008d2ac + 0x1d36) + -1;
        }
      }

      else
	  {
		// Proceed to VS menu with Retry, Change Level, etc
        *(undefined2 *)(PTR_DAT_8008d2ac + 0x1d36) = 0;
      }
    }
  }
                    // WARNING: Read-only address (ram,0x8008d874) is written
  return;
}


// param1 is PTR_DAT_8008d2ac
// param2 is screen ID (0, 1, 2, 3)
void FUN_80035684(int param_1,int param_2)

{
  uint *puVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int *piVar6;

  // convert index to pointer offset
  iVar4 = param_2 * 4;

  // pointer to player structure
  iVar5 = *(int *)(param_1 + iVar4 + 0x24ec);

  // get quadblock under driver
  iVar2 = *(int *)(iVar5 + 0x350);

  // lev -> ptr_mesh_info
  piVar6 = **(int ***)(param_1 + 0x160);

  if (
		// if quadblock exists
		(iVar2 != 0) &&
		(
			// quadblock -> ptr_add_tex
			puVar1 = *(uint **)(iVar2 + 0x44),

			puVar1 != (uint *)0x0
		)
	  )
  {
	// ptr_add_tex->offset0
    uVar3 = *puVar1;

    if (uVar3 != 0) {
      if ((uVar3 & 1) == 0) {
        FUN_80021ea8(
		
					// VisMem 0x0-0xF
					*(undefined4 *)(*(int *)(param_1 + 0x1a38) + iVar4),
		
					uVar3,

					 // June 1999 calls this "visLeafList"
					 // ptr_mesh_info -> numVisData?
                     (piVar6[7] + 0x1f >> 5) << 2);
      }
      else {
        FUN_80021e1c(
		
					// VisMem 0x0-0xF
					*(undefined4 *)(*(int *)(param_1 + 0x1a38) + iVar4),
					
					uVar3 & 0xfffffffc);
      }
    }

	// driver -> ptr_add_tex -> offset4
    uVar3 = *(uint *)(*(int *)(*(int *)(iVar5 + 0x350) + 0x44) + 4);

	if (uVar3 != 0) {
      if ((uVar3 & 1) == 0) 
	  {
        FUN_80021ea8(
		
					// VisMem 0x10-0x1F
					*(undefined4 *)(*(int *)(param_1 + 0x1a38) + param_2 * 4 + 0x10),
					
					uVar3,

					 // June 1999 calls this "visFaceList"
					 // ptr_mesh_info -> numQuadBlock?
					 (*piVar6 + 0x1f >> 5) << 2);
      }
      else {
        FUN_80021e1c(
						// VisMem 0x10-0x1F
						*(undefined4 *)(*(int *)(param_1 + 0x1a38) + param_2 * 4 + 0x10),
                        uVar3 & 0xfffffffc);
      }
    }
  }
  return;
}

// VisMem_FullFrame
// param1 is PTR_DAT_8008d2ac
void FUN_800357b8(int param_1,int param_2)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  undefined4 uVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;

  if (
		(
			// called VISMEM in prototypes
			(*(int *)(param_1 + 0x1a38) != 0) &&

			// if lev exists
			(param_2 != 0)
		) &&
		(
			// loop counter
			iVar9 = 0,

			// if number of screens is not zero
			*(char *)(param_1 + 0x1ca8) != '\0'
		)
	)
  {
	// pointer offset (increment by 4 each iteration of loop)
    iVar7 = 0;

	// offset of 8008d2ac where P1 camera is
    iVar10 = 0x1498;

	// loop through all four cameras

	// for iVar9 = 0; iVar9 < numScreens; iVar9++
    do
	{
	  // CameraDC
      iVar6 = param_1 + iVar10;

	  // pointer to structure of each player
      iVar8 = *(int *)(param_1 + iVar7 + 0x24ec);

	  // CameraDC 0x20 (vismem->0x40)
      iVar2 = *(int *)(iVar6 + 0x20);

	  // remove flag 0x4000
      *(uint *)(iVar6 + 0x70) = *(uint *)(iVar6 + 0x70) & 0xffffbfff;

	  // if camera can't figure out what to draw on it's own,
	  // if not following warpball path like track select videos,
	  if (iVar2 == 0)
	  {
        if (
				(
					// driver -> quadblock under driver
					(*(int *)(iVar8 + 0x350) != 0) &&

					// quadblock -> ptr_add_tex
					(piVar1 = *(int **)(*(int *)(iVar8 + 0x350) + 0x44), piVar1 != (int *)0x0)
				) &&

				// pull vismem data from quadblock + 0x44
				(iVar2 = *piVar1, iVar2 != 0)
			)
		{
		  // VisMem 0x40-0x4F
          *(int *)(*(int *)(param_1 + 0x1a38) + iVar7 + 0x40) = iVar2;

		  // quadblock -> ptr_add_tex -> 0x0
          uVar5 = **(uint **)(*(int *)(iVar8 + 0x350) + 0x44);

		  if ((uVar5 & 1) == 0) goto LAB_80035900;
LAB_800358e0:
          FUN_80021da0(
		  
			// VisMem 0x0-0xF
			*(undefined4 *)(*(int *)(param_1 + 0x1a38) + iVar7),
			uVar5 & 0xfffffffc);
        }
      }

	  // if camera can figure out what to draw on it's own,
	  // if following warpball path like track select videos,
      else
	  {
		// VisMem 0x0-0xF
        iVar3 = *(int *)(param_1 + 0x1a38) + iVar7;

		// if this changed from previous frame
        if (*(int *)(iVar3 + 0x40) != iVar2)
		{
          *(int *)(iVar3 + 0x40) = iVar2;

		  // CameraDC 0x20
		  uVar5 = *(uint *)(iVar6 + 0x20);

		  if ((uVar5 & 1) != 0) goto LAB_800358e0;
LAB_80035900:

		  // called VISMEM in prototypes
          memcpy(
					// destination
					// VisMem 0x0-0xF
					*(int *)(param_1 + 0x1a38) + iVar7,

					// source
					uVar5,

					// unk size
				);
        }
      }

	  // CameraDC 0x24
	  iVar2 = *(int *)(iVar6 + 0x24);

	  // if camera can't figure out what to draw on it's own,
	  // if not following warpball path like track select videos,
	  if (iVar2 == 0)
	  {
        if (
				(
					// driver -> quadblock under driver
					(*(int *)(iVar8 + 0x350) != 0) &&

					(
						// quadblock -> ptr_add_tex
						iVar2 = *(int *)(*(int *)(iVar8 + 0x350) + 0x44),
						iVar2 != 0
					)
				) &&

				(iVar2 = *(int *)(iVar2 + 4), iVar2 != 0)
		   )
		{
		  // VisMem 0x50-0x5F
          *(int *)(*(int *)(param_1 + 0x1a38) + iVar7 + 0x50) = iVar2;

		  // quadblock -> ptr_add_tex -> 0x4
          uVar5 = *(uint *)(*(int *)(*(int *)(iVar8 + 0x350) + 0x44) + 4);

		  if ((uVar5 & 1) == 0)
		  {
			// called VISMEM in prototypes
            memcpy(
					// VisMem 0x0-0xF
					*(int *)(param_1 + 0x1a38) + iVar7,
					uVar5,
					// unk size
				  );
          }
          else 
		  {
			// VisMem 0x10-0x1F
            FUN_80021da0(*(undefined4 *)(*(int *)(param_1 + 0x1a38) + iVar7 + 0x10),
                               uVar5 & 0xfffffffc);
          }
        }
      }

	  // if camera can figure out what to draw on it's own,
	  // if following warpball path like track select videos,
      else
	  {
		// VisMem 0x0-0xF
        iVar3 = *(int *)(param_1 + 0x1a38) + iVar7;

		// if this changed from the previous frame
		if (*(int *)(iVar3 + 0x50) != iVar2)
		{
          *(int *)(iVar3 + 0x50) = iVar2;

		  // CameraDC 0x24
		  if ((*(uint *)(iVar6 + 0x24) & 1) == 0)
		  {
            memcpy(
					// VisMem 0x10-0x1F
					*(int *)(param_1 + 0x1a38) + iVar7 + 0x10
					
					iVar6 + 0x24,
					// unk size
					);
          }

          else
		  {
            FUN_80021da0(

					// VisMem 0x10-0x1F
					*(undefined4 *)(*(int *)(param_1 + 0x1a38) + iVar7 + 0x10),

					// CameraDC 0x24
					*(uint *)(iVar6 + 0x24) & 0xfffffffc);
          }

		  // quadblock under driver
          iVar2 = *(int *)(iVar8 + 0x350);

          if (
				// if no quadblock exists, or quadblock -> ptr_add_tex does not exist
				((iVar2 == 0) || (piVar1 = *(int **)(iVar2 + 0x44), piVar1 == (int *)0x0)) ||
				(
					// data from quadblock -> ptr_add_tex is invalid
					(*piVar1 == 0 || (((piVar1[1] == 0 || (piVar1[2] == 0)) ||

					// LEV -> mesh_info -> ptrQuadBlockArray
					(iVar2 = (iVar2 - *(int *)(**(int **)(param_1 + 0x160) + 0xc)) * -0x1642c859,

					// VisMem 0x10-0x1F
					(*(uint *)((iVar2 >> 7) * 4 + *(int *)(*(int *)(param_1 + 0x1a38) + iVar7 + 0x10)) &
					1 << (iVar2 >> 2 & 0x1fU)) != 0))))
				)
			  )
		  {
            uVar5 = *(uint *)(iVar6 + 0x70) & 0xffffdfff;
          }

          else
		  {
			// camera is moving on path, not followinig driver
            uVar5 = *(uint *)(iVar6 + 0x70) | 0x2000;
          }

          *(uint *)(iVar6 + 0x70) = uVar5;

		  // if driver quadblock is wall, therefore need to improvise?
		  if ((*(uint *)(iVar6 + 0x70) & 0x2000) != 0)
		  {
			// param1 is PTR_DAT_8008d2ac
			// ivar9 is screen ID (0,1,2,3)
            FUN_80035684(param_1,iVar9);
            *(uint *)(iVar6 + 0x70) = *(uint *)(iVar6 + 0x70) | 0x4000;
          }
        }
      }

	  if ((*(uint *)(iVar6 + 0x70) & 0x5000) == 0x1000)
	  {
		// param1 is PTR_DAT_8008d2ac
		// ivar9 is screen ID (0,1,2,3)
        FUN_80035684(param_1,iVar9);
      }

	  if (
			(
				// if camera is following driver "normally"
				(*(short *)(iVar6 + 0x9a) == 0) &&
                // and not wall
				((*(uint *)(iVar6 + 0x70) & 0x2000) != 0)
			) &&
			(
				(
					// quadblock under driver
					*(int *)(iVar8 + 0x350) != 0 &&

					(
						// driver -> quadblock -> ptr_add_tex
						(iVar2 = *(int *)(*(int *)(iVar8 + 0x350) + 0x44), iVar2 != 0 &&

						(iVar2 = *(int *)(iVar2 + 8), iVar2 != 0))
					)
				)
			)
		 )
	  {
		// CameraDC 0x28
        *(int *)(iVar6 + 0x28) = iVar2;
      }
	  
	  // if no animated vertices
      if ((*(uint *)(param_2 + 0xdc) & 4) == 0)
	  {
		// VisMem 0x0-0xF
        iVar2 = *(int *)(param_1 + 0x1a38) + iVar7;

		// + 0x60
		iVar8 = *(int *)(iVar2 + 0x60);

		// CameraDC 0x2C
        if (iVar8 == *(int *)(iVar6 + 0x2c)) {
          if (iVar8 == 0) goto LAB_80035ce0;
        }

		// if change since last frame
		else
		{
		  // camera 0x2C
          *(int *)(iVar2 + 0x60) = *(int *)(iVar6 + 0x2c);

          uVar5 = *(uint *)(iVar6 + 0x2c);

		  if ((uVar5 & 1) == 0) goto LAB_80035ce0;

		  // VisMem 0x20-0x2F (visOVertList)
		  uVar4 = *(undefined4 *)(*(int *)(param_1 + 0x1a38) + iVar7 + 0x20);
LAB_80035c98:
          FUN_80021da0(uVar4,uVar5 & 0xfffffffc);
        }
      }
	  
	  // if animated lev vertices
      else
	  {
		// VisMem 0x0-0xF
        iVar2 = *(int *)(param_1 + 0x1a38) + iVar7;
        iVar8 = *(int *)(iVar2 + 0x70);

		// CameraDC 0x30
        if (iVar8 == *(int *)(iVar6 + 0x30)) {
          if (iVar8 != 0) goto LAB_80035cec;
        }

		// if change since previous frame
        else
		{
		  // VisMem + playerIndex*4 + 0x70 = CameraDC 0x30
          *(int *)(iVar2 + 0x70) = *(int *)(iVar6 + 0x30);
          uVar5 = *(uint *)(iVar6 + 0x30);

          if ((uVar5 & 1) != 0)
		  {
			// VisMem 0x30-0x3F
            uVar4 = *(undefined4 *)(*(int *)(param_1 + 0x1a38) + iVar7 + 0x30);
            goto LAB_80035c98;
          }
        }
LAB_80035ce0:
        memcpy(
				uVar4,
				// camDC offset 0x2c or 0x30
				// unk size
				);
      }
LAB_80035cec:

	  // increment pointer
      iVar7 = iVar7 + 4;

	  // increment loop counter
      iVar9 = iVar9 + 1;

	  // increment pointer to next player's camera,
	  // each camera is 0xdc bytes large
      iVar10 = iVar10 + 0xdc;

    } while (iVar9 < (int)(uint)*(byte *)(param_1 + 0x1ca8));
  }
  return;
}

// VideoSTR_Init
void FUN_80035d30
               (undefined4 param_1,undefined2 *param_2,undefined2 param_3,undefined2 param_4)

{
  // 8008d2c8, boolVideoStrPlay
  uGp0000035c = param_1;

  // 8008d880, videoSTR_src_vramRect
  // type RECT, which is 8 bytes
  uGp00000914 = *param_2;
  uGp00000916 = param_2[1];
  uGp00000918 = param_2[2];
  uGp0000091a = param_2[3];

  // 8008d89c, videoSTR_dst_vramX
  uGp00000930 = param_3;

  // 8008d8a0, videoSTR_dst_vramY
  uGp00000934 = param_4;
  return;
}

// CheckMissingControllers
int FUN_80035d70(short param_1)

{
  bool bVar1;
  int iVar2;
  short sVar3;
  uint uVar4;
  int iVar5;

  uVar4 = 1;
  sVar3 = 1;

  // if game is not loading
  if (DAT_8008d0f8 == -1)
  {
	// numbers of players in a game
    iVar2 = (int)param_1;

	// if there are no players (cutscene)
	if (iVar2 == 0)
	{
	  // return 0 means controller is missing
      sVar3 = 0;
    }

	// if number of players is not zero
    else
	{
	  // loop counter
      iVar5 = 0;

	  // if there are players in this game
      if (0 < iVar2)
	  {
		// loop through all players and make sure
		// all their controllers are connected

		// iVar5 = 0; iVar5 < numPlayers; iVar5++
        do
		{
		  // only continue checking controllers if
		  // all previous controllers are connected
          bVar1 = uVar4 != 0;

          uVar4 = 0;
          if (
				// if there are no other controllers unplugged (so far)
				(bVar1) &&

				// if this controller is plugged in
				(*(char **)(PTR_DAT_8008d2b0 + (int)(short)iVar5 * 0x50 + 0x20) != (char *)0x0)
			 )
		  {
			// Check if controller is compatible with game (not a gun or mouse)
			uVar4 = (uint)(**(char **)(PTR_DAT_8008d2b0 + (int)(short)iVar5 * 0x50 + 0x20) == '\0');
          }

		  // save the result
          sVar3 = (short)uVar4;

		  // increment loop counter
          iVar5 = iVar5 + 1;

        } while (iVar5 * 0x10000 >> 0x10 < iVar2);
      }
    }

	// return 0 only if a controller is missing
	// that is currently needed in the game
    return (int)sVar3;
  }
  return 1;
}

// Request Aku Hint, doesn't start till FUN_800b3dd8
// param1:
//	0x00 - Welcome to Adventure Arena
//	0x01 - using a warp pad (part of welcome)
// 	0x02 - Need more trophies
//	0x03 - Need 4 trophies for Boss
//	0x04 - Need 4 keys for oxide
//	0x05 - Must have 1 Boss Key
//	0x06 - This is the load/save screen
// 	0x07 - Congrats on opening new area
//	0x12 - Must have 2 Boss Key
//	0x19 - Collect every crystal in arena
//	0x1a - CTR Token
//	0x1b - Gem Cups
//	0x1c - Must get 10 relics
//	0x1d - Relic
// param2:
//	0x00 - not interrupting a warppad load screen
// 	0x01 - interrupting (CTR, Relic, or Crystal hints)
void FUN_80035e20(short param_1,undefined2 param_2)

{
  if (
		// *8008D2AC = 80096b20
		// if game is not paused
		((*puGp00000340 & 0xf) == 0) &&

		// 8008D2CC
		(sGp00000360 == -1)
	 )
  {
	// 8008D874
	// aku is now giving a hint
    uGp00000908 = 1;

	// 8008d2ac[0x93b] + 0x54
	// 8009900C + 0x54
	// driver funcPtrInit, Player_Freeze_Init
    *(undefined **)(puGp00000340[0x93b] + 0x54) = &FUN_80062d04;

	// 8008d2cc
	// requestedAkuHint
	sGp00000360 = param_1;

	// 8008d2ce
	// bool_AkuHint_InterruptWarppad
	uGp00000362 = param_2;
  }
  return;
}



// RenderFrame
// param1 is PTR_DAT_8008d2ac - GameTracker
void FUN_80035e70(uint *param_1)
{
  uint *puVar1;
  byte bVar2;
  char cVar3;
  bool bVar4;
  undefined *puVar5;
  int iVar6;
  uint uVar7;
  undefined4 uVar8;
  undefined4 *puVar9;
  short sVar10;
  int local_54;
  int iVar11;
  uint *puVar12;
  void *p;
  int iVar13;
  undefined *puVar14;
  int iVar15;
  int iVar16;
  short sVar17;
  uint *puVar18;
  int iVar19;
  int iVar20;
  int *piVar21;
  int iVar22;
  undefined2 local_40;
  short local_3e;
  undefined2 local_3c;
  short local_3a;
  short local_38;
  short local_36;
  undefined2 local_30;
  undefined2 local_2e;
  undefined2 local_2c;
  undefined2 local_2a;

  iVar22 = 0;

  // param1 is PTR_DAT_8008d2ac
  // 0x58*4 = 0x160, pointer to LEV
  piVar21 = (int *)param_1[0x58];

  bVar4 = false;

  // check if 230 dll is loaded
  iVar6 = FUN_80034908();

  // check if in main menu
  if (
		// If it is loaded
		(iVar6 != 0) &&

		// check if you are in the main menu
		(DAT_8008d908 == -0x7ff4bac0) // 0x800B4540
	 )
  {
	// is main menu at highest level of hierarchy?
	// if so, dont give missing controllers error
    bVar4 = (uRam800b4548 & 0x10) == 0;
  }

  // Missing Controllers error dialog
  if (
		(
			(

				// If you are not in a cutscene
				((*(uint *)PTR_DAT_8008d2ac & 0x20000000) == 0) &&
				(
					// uvar7 = function(Number Of Players)
					uVar7 = FUN_80035d70((uint)(byte)PTR_DAT_8008d2ac[0x1ca9]),


					(uVar7 & 0xffff) == 0
				)
			) &&

			// If you're not in Demo Mode
			(PTR_DAT_8008d2ac[0x1d32] == '\0')
		) &&

		// if main menu is not highest level of hierarchy,
		// that is assuming player is in main menu
		(!bVar4)
	  )
	{

	// Get Y position to place the error message
    sVar17 = *(short *)(&DAT_80084250 + (int)DAT_8008d88c * 2);

	local_3a = 0xe;

    if (
			(PTR_DAT_8008d2b0[0x2d1] == -0x80) ||

			(
				// pointer goes to "controller 1" or "controller 2"
				sVar10 = 0,

				// if number of players is more than 2
				2 < (byte)PTR_DAT_8008d2ac[0x1ca9]
			)
		)
	{
	  // pointer goes to "1A", "1B", "1C", "1D"
      sVar10 = 2;
    }

	// loop counter
    iVar6 = 0;

	// if Number of Players is not zero
    if (PTR_DAT_8008d2ac[0x1ca9] != '\0')
	{
	  // offset into main controller buffer for all players.
	  // 0 for p1, 0x30 for p2, etc
      iVar19 = 0;

      local_3a = 0xe;

	  // for(int iVar6 = 0; iVar6 < Number of Players; iVar6++)

      do
	  {
		// check each player's controller buffer
        if ((*(char **)(PTR_DAT_8008d2b0 + iVar19 + 0x20) == (char *)0x0) ||
           (**(char **)(PTR_DAT_8008d2b0 + iVar19 + 0x20) != '\0')) {
          iVar13 = (int)sVar17;
          local_3a = local_3a + 8;
          sVar17 = sVar17 + 8;

		  // One of 6 strings for "Controller x is Unplugged
          FUN_80022878(*(undefined4 *)			//  -0x7ff7bdbc should be 80084244
                        ((int)*(short *)((iVar6 + sVar10) * 2 + -0x7ff7bdbc) * 4 + DAT_8008d878),
                       0x100,iVar13,2,0xffff8000);
        }

		// increment loop counter
        iVar6 = iVar6 + 1;

		// increment offest to next player's controller buffer
        iVar19 = iVar19 + 0x50;

						// Number of Players
      } while (iVar6 < (int)(uint)(byte)PTR_DAT_8008d2ac[0x1ca9]);
    }

	// DAT_8008d878 + 0xac
	// PLEASE INSERT A CONTROLLER
    FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0xac),0x100,(int)sVar17,2,0xffff8000);

    local_40 = 0xffec;
    local_3c = 0x228;

	// Get Y position to place error message
    local_3e = *(short *)(&DAT_80084250 + (int)DAT_8008d88c * 2) + -3;

	// Draw 2D Menu rectangle background
    FUN_800457b0(&local_40,1,*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0));
  }
  iVar19 = 0;

  // loop counter
  iVar13 = 0;

  // offset of 8008d2ac where camera110 structs
  // are held for each player (pos, size, etc)
  iVar20 = 0x168;

  // NOT for camera110
  // offset in another array of 0x110-byte structs
  iVar6 = iVar13;

  // "FINAL LAP!" for all players
  // for iVar13 = 0; iVar13 < 4; iVar13++
  do
  {
	// pointer to array of camera110 structs
    puVar14 = PTR_DAT_8008d2ac + iVar20;

	// If there is time remaining in the "Final Lap" animation
    if (*(ushort *)((int)&DAT_8008d2a0 + iVar19) != 0)
	{
	  // total animation is 0x5a frames
	  // 0x5a = 90

	  // 0x5a - [frames remaining] is frame index in the animation
      local_54 = (int)((0x5a - (uint)*(ushort *)((int)&DAT_8008d2a0 + iVar19)) * 0x10000) >> 0x10;

	  // if you are less than 81 frames into the animation
      if (local_54 < 0x51) {

		// if you are less than 11 frames into the animation
        if (local_54 < 0xb)
		{
		  // Bring the text on-screen from the right

          iVar11 = (int)(((uint)*(ushort *)(puVar14 + 0x20) + 100) * 0x10000) >> 0x10;
          iVar15 = (int)((uint)*(ushort *)(puVar14 + 0x22) << 0x10) >> 0x12;
          iVar16 = (int)((uint)*(ushort *)(puVar14 + 0x20) << 0x10) >> 0x11;
        }

		// if you are 11-81 frames in the animation
        else
		{
		  // keep the text still, in the center

          local_54 = local_54 + -10;
          iVar11 = (int)((uint)*(ushort *)(puVar14 + 0x20) << 0x10) >> 0x11;
          iVar15 = (int)((uint)*(ushort *)(puVar14 + 0x22) << 0x10) >> 0x12;
          iVar16 = iVar11;
        }
      }

	  // if you are more than 81 frames into the animation
      else
	  {
		// Move the text off-screen to the left

        local_54 = local_54 + -0x50;
        iVar11 = (int)((uint)*(ushort *)(puVar14 + 0x20) << 0x10) >> 0x11;
        iVar15 = (int)((uint)*(ushort *)(puVar14 + 0x22) << 0x10) >> 0x12;
        iVar16 = -100;
      }

	  // Interpolate the position of "Final Lap"
      FUN_8004ecd4(&local_38,iVar11,iVar15,iVar16,iVar15,local_54,10);

	  // DAT_8008d878 + 0x8cc
	  // FINAL LAP!

	  // need to specify OT, or else "FINAL LAP" will draw on top of character icons,
	  // and by doing this, "FINAL LAP" draws under the character icons instead

	  // DecalFont_DrawLineOT
      FUN_800228c4(*(undefined4 *)(DAT_8008d878 + 0x8cc),(int)local_38,(int)local_36,1,0xffff8000,

					// first Camera110 is at 0x168,
					// 0x25c - 0x110 is 0xF4, known camera110 ptrOT
                   *(undefined4 *)(PTR_DAT_8008d2ac + iVar6 + 0x25c));

	  // subtract a frame from the animation
	  *(short *)((int)&DAT_8008d2a0 + iVar19) = *(short *)((int)&DAT_8008d2a0 + iVar19) + -1;
    }
    iVar19 = iVar19 + 2;

	// NOT for camera110
	// increment some other pointer that also holds 0x110 structs
    iVar6 = iVar6 + 0x110;

	// increment loop counter
    iVar13 = iVar13 + 1;

	// increment pointer to next camera110 struct
    iVar20 = iVar20 + 0x110;

  } while (iVar13 < 4);

  // ElimBG_HandleState
  FUN_80024974(PTR_DAT_8008d2ac);

  // if LEV exists
  if (piVar21 != (int *)0x0)
  {
	// get pointer to LEV info
    iVar22 = *piVar21;
  }

  // VisMem
  // gGT->256c & (renderBucket || drawLev)
  if ((param_1[0x95b] & 0x21) != 0)
  {
	// VisMem_FullFrame
	// use quadblock offset 0x44 with camera data
    FUN_800357b8(param_1,piVar21);
  }

  // scrolling textures
  if (
		(
			// gGT->256c & drawLev
			((param_1[0x95b] & 1) != 0) &&

			// called VISMEM in prototypes
			(*(int *)(PTR_DAT_8008d2ac + 0x1a38) != 0)
		) &&

		// if ptrLEV is valid
		(piVar21 != (int *)0x0)
	  )
  {
	// param1 is lev->ptr_tex_array,
	// param2 is 1cec (frame timer)

	// CTR_CycleTex_LEV
	// turbo pads, waterfalls, lava, etc
    FUN_80021984(piVar21[2],param_1[0x73b]);
  }

  // MenuBox input
  if (
		// if there is an active menuBox
		(DAT_8008d908 != 0) ||

		// If you're in End-Of-Race menu
		((*(uint *)PTR_DAT_8008d2ac & 0x200000) != 0)
	)
  {
	// MenuBox_CollectInput
    FUN_80046458();
  }

  // MenuBox logic
  if (
		// if any MenuBox is active
		(DAT_8008d908 != 0) &&

		// if game is not loading
		(DAT_8008d0f8 == -1)
	  )
  {
	// MenuBox_ProcessState
    FUN_8004680c();
  }

  // loop counter
  iVar6 = 0;

  // Camera Frustums
  // gGT->1ca8(numPlayers) != 0
  if (*(char *)(param_1 + 0x72a) != '\0')
  {
	// offset of 8008d2ac where camera110 structs
	// are held for each player (pos, size, etc)
	iVar19 = 0x168;

    puVar18 = param_1;
    puVar12 = param_1;

	// for iVar6 = 0; iVar6 < numPlayers; iVar6++
    do
	{
	  // Camera110_UpdateFrustum
	  // pointer to camera110 struct
      FUN_800430f0((int)param_1 + iVar19);

	  // 0x5d2 = 0x14b4, cameraDC = 0x1498,
	  // gGT->CameraDC[i].ptrQuadBlock
      if (puVar18[0x52d] != 0) 
	  {
		// gGT->CameraDC[i].ptrQuadBlock->weather_intensity
        uVar7 = (uint)*(byte *)(puVar18[0x52d] + 0x39);

		// (72a*4 = 1ca8), numPlayers
        bVar2 = *(byte *)(param_1 + 0x72a);

        if (bVar2 == 0) {
          trap(0x1c00);
        }
        if (((uint)bVar2 == 0xffffffff) && (uVar7 == 0x20000000)) {
          trap(0x1800);
        }

		// gGT -> 0x1a44
		// gGT->RainBuffer[i].numParticles_max
        *(short *)(puVar12 + 0x691) = (short)((int)(uVar7 << 2) / (int)(uint)bVar2);

		// (72a*4 = 1ca8), numPlayers
		bVar2 = *(byte *)(param_1 + 0x72a);

		if (bVar2 == 0) {
          trap(0x1c00);
        }
        if (((uint)bVar2 == 0xffffffff) && ((uint)*(byte *)(puVar18[0x52d] + 0x3a) == 0x20000000)) {
          trap(0x1800);
        }

		// gGT -> 0x1a46? (rainBuffer 0x6 = quadblock 0x3a)
        *(undefined2 *)((int)puVar12 + 0x1a46) =
             (short)((int)((uint)*(byte *)(puVar18[0x52d] + 0x3a) << 2) / (int)(uint)bVar2);
      }
      
	  // 0xc*4 = 0x30, next RainBuffer
	  puVar12 = puVar12 + 0xc;
	  
	  // 0x37*4 = 0xDC, next CameraDC
      puVar18 = puVar18 + 0x37;

	  // increment loop counter
      iVar6 = iVar6 + 1;

	  // increment camera110 pointer to next camera110
      iVar19 = iVar19 + 0x110;

	  // (72a*4 = 1ca8), numPlayers
    } while (iVar6 < (int)(uint)*(byte *)(param_1 + 0x72a));
  }

  // param1 is PTR_DAT_8008d2ac
  // EffectSfxRain_MakeSound
  FUN_80024464(param_1);

  // frame timer for MenuBox row highlight
  uVar7 = (int)DAT_8008d970 << 7;

  // approximate trigonometry
  iVar6 = *(int *)(&DAT_800845a0 + (uVar7 & 0x3ff) * 4);

  // 0-90 or 180-270 degrees
  if ((uVar7 & 0x400) == 0) {
    iVar6 = iVar6 << 0x10;
  }

  iVar6 = iVar6 >> 0x10;

  // 180 - 360 degrees
  if ((uVar7 & 0x800) != 0) {
    iVar6 = -iVar6;
  }

  // red and yellow highlight menu bars
  iVar6 = (iVar6 << 6) >> 0xc;

  // if normal menu, filter out blue light in highlight
  DAT_8008d94c = (iVar6 + 0x40) * 0x100 | 0x80;

  // if save/load screen, filter out red+blue light in highlight
  DAT_8008d948 = (iVar6 + 0xa0) * 0x100 | 0x400040;

  // weather
  if (
		(
			// gGT->256c & weather
			(param_1[0x95b] & 2) != 0
		) &&
		(
			// if number of screens is less than 2
			(byte)PTR_DAT_8008d2ac[0x1ca8] < 2
		)
	  )
  {
	// RenderWeather
    FUN_8006f9a8(
					// pointer to start of camera110 buffers
					PTR_DAT_8008d2ac + 0x168,

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

					// &gGT->rainBuffer[0]
					PTR_DAT_8008d2ac + 0x1a40,

					// number of screens
					(uint)(byte)PTR_DAT_8008d2ac[0x1ca8],

					// check if the game is paused
					*(uint *)PTR_DAT_8008d2ac & 0xf
				);
  }

  // confetti
  if (
		// gGT->256c & confetti
		((param_1[0x95b] & 4) != 0) &&
		(
			// loop counter
			iVar6 = 0,

			// if at least one person needs confetti
			0 < *(int *)(PTR_DAT_8008d2ac + 0x2568)
		)
	)
  {
    iVar19 = 0;

	// loop through all confetti drivers
    do
	{
	  // draw confetti
      FUN_80069ffc(

					// camera110 of the player that won
					PTR_DAT_8008d2ac + *(int *)(PTR_DAT_8008d2ac + iVar19 + 0x2558) * 0x110 + 0x168,

				   // pointer to PrimMem struct
				   *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

				   // &gGT->confetti
				   PTR_DAT_8008d2ac + 0x1b00,

				   // confetti frame timer
                   *(undefined4 *)(PTR_DAT_8008d2ac + 0x1cf0),

				   // boolean for if the game is paused (1 for yes, 0 for no)
				   *(uint *)PTR_DAT_8008d2ac & 0xf);

	  // increment loop counter
      iVar6 = iVar6 + 1;

      iVar19 = iVar6 * 4;
    } while (iVar6 < *(int *)(PTR_DAT_8008d2ac + 0x2568));
  }

  // stars
  if (
		// gGT->256c & stars
		((param_1[0x95b] & 8) != 0) &&

		// if numStars is not zero
		(*(short *)(PTR_DAT_8008d2ac + 0x1b0c) != 0)
	)
  {
	// renders stars in night sky
    FUN_8006e26c(
					// pointer to start of camera110 buffers
					PTR_DAT_8008d2ac + 0x168,

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

					// &gGT->stars
					PTR_DAT_8008d2ac + 0x1b0c,

					// number of screens
					(uint)(byte)PTR_DAT_8008d2ac[0x1ca8]
				);
  }


  if (
		// param1 is PTR_DAT_8008d2ac
		((param_1[0x95b] & 0x100) != 0) &&

		// number of screens > 1
		(1 < (byte)PTR_DAT_8008d2ac[0x1ca8])
	)
  {
	// param1 is PTR_DAT_8008d2ac
    FUN_80023488(param_1);
  }

  // Gameplay HUD:
  // if not drawing intro-race title bars,
  if (
		(
			((PTR_DAT_8008d2ac[0x1d31] & 8) == 0) ||

			// if number of screens is not 1
			// if you're in multiplayer
			(PTR_DAT_8008d2ac[0x1ca8] != '\x01')
		) ||

		// If not drawing intro-race cutscene
		((*(uint *)PTR_DAT_8008d2ac & 0x40) == 0)
	  )
	{

    // hud flags
    bVar2 = PTR_DAT_8008d2ac[0x1d31];

	// if there is no hud (race is over)
    if ((bVar2 & 1) == 0)
	{
	  // if drawing cup standings
      if ((bVar2 & 4) != 0)
	  {
		// update and draw cup standings
        FUN_800562fc();
      }
    }

	// if hud is drawing
    else {

      uVar7 = *(uint *)PTR_DAT_8008d2ac;

	  // If you're not in Adventure Arena
      if ((uVar7 & 0x100000) == 0) {
        if (

			// If you're not in End-Of-Race menu
			((uVar7 & 0x200000) == 0) ||

			// If cooldown after end of race is not done
			(*(short *)(PTR_DAT_8008d2ac + 0x1d36) != 0)
		)
		{
			// If you're not in Crystal Challenge (in adventure mode)
			if ((uVar7 & 0x8000000) == 0)
			{
				// DrawHUD_Racing
				FUN_80052f98();
			}

			// If you're in Crystal Challenge (in adventure mode)
			else
			{
				// DrawHUD_CrystalChallenge
				FUN_8005435c();
			}
        }

		// If you're in the End-Of-Race Menu
        else {
          if (1 < DAT_8008d0f8 + 5U) {

			// If you're not in Crystal Challenge
            if ((uVar7 & 0x8000000) == 0) {

			  // If you're not in Time Trial
              if ((uVar7 & 0x20000) == 0) {

				// If you're not in Arcade Mode
                if ((uVar7 & 0x400000) == 0) {

				  // If you're not in a Relic Race
                  if ((uVar7 & 0x4000000) == 0) {

					// If you're in Adventure Mode
                    if ((uVar7 & 0x80000) != 0) goto LAB_800367d4;

					// If you are not in Arcade or VS cup,
					// which leaves Single VS or Battle
                    if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x10) == 0)
					{
					  // VB_EndEvent_DrawMenu
                      FUN_8009f718();
                    }

					// If you are in Arcade or VS cup
                    else
					{
					  // disable drawing HUD
                      PTR_DAT_8008d2ac[0x1d31] = bVar2 & 0xfe;

					  // draw "standings"
					  // everyone's position in the cup, score, how many tracks
					  // you've driven, how many are left, name of cup, name of track, etc
                      PTR_DAT_8008d2ac[0x1d31] = PTR_DAT_8008d2ac[0x1d31] | 4;
                    }
                  }

				  // If you're in a Relic Race
				  else
				  {
					// RR_EndEvent_DrawMenu
                    FUN_800a01d8();
                  }
                }

				// If you're in Arcade Mode, or Adventure Mode
				else {
LAB_800367d4:
				  // AA_EndEvent_DrawMenu
                  FUN_8009f704();
                }
              }

			  // If you're in Time Trial
			  else
			  {
				// TT_EndEvent_DrawMenu
                FUN_8009fdc8();
              }
            }

			// If you're in Crystal Challenge
			else
			{
			  // CC_EndEvent_DrawMenu
              FUN_8009f710();
            }
          }
        }
      }

	  // If you're in Adventure Arena
	  else
	  {
		// handle transition from 233 to 232 (podium to advhub)
        if ((1 < (byte)PTR_DAT_8008d2ac[0x2579]) &&
           (PTR_DAT_8008d2ac[0x2579] = PTR_DAT_8008d2ac[0x2579] - 1,
           PTR_DAT_8008d2ac[0x2579] == '\x01'))
		{
		  // load DLL 232 (230 + 2)
          FUN_80033570(2);
        }

		// Check if 232 is loaded
        iVar6 = FUN_80034920();

		// If it is not loaded
        if (iVar6 == 0)
		{
		  // if any fade-in-from-black transition is over
          if (0xfff < *(short *)(PTR_DAT_8008d2ac + 0x139a))
		  {
			// DrawHUD_AdvStrings
            FUN_80054298();
          }
        }

		// If 232 dll is loaded
        else
		{
		  // if any fade-in-from-black transition is over
          if (0xfff < *(short *)(PTR_DAT_8008d2ac + 0x139a))
		  {
			// AH_Map_Main (map, icons, etc)
            FUN_800b1c90();

			// if aku is not giving a hint
            if ((int)DAT_8008d2cc != -1)
			{
			  // AH_MaskHint_Start
              FUN_800b3dd8((int)DAT_8008d2cc,(int)DAT_8008d2ce);

			  // erase queued hint
              DAT_8008d2cc = -1;
              DAT_8008d2ce = 0;
            }
          }

		  // if this is first frame of 232 loaded
          if (PTR_DAT_8008d2ac[0x2579] != '\0')
		  {
			// INSTANCE_LevRestartLInBs
            FUN_80030ed4(*(undefined4 *)(param_1[0x58] + 0x10),
				*(undefined4 *)(param_1[0x58] + 0xc));

            puVar14 = PTR_DAT_8008d2ac;
            puVar18 = (uint *)(PTR_DAT_8008d2ac + 8);

			// nullify transition
            PTR_DAT_8008d2ac[0x2579] = 0;

			puVar5 = PTR_DAT_8008d2ac;
            *(uint *)(puVar14 + 8) = *puVar18 & 0xfffffeff;
            *(undefined2 *)(puVar5 + 0x139c) = 0x1000;
            *(undefined2 *)(puVar5 + 0x139e) = 0x2aa;
          }
        }
      }
    }
  }


  // Intro-Race title bars:
  // If drawing intro-race cutscene, only 1P, no crystal challenge
  else
  {
	// Draw the text on the top
	// and bottom of the screen
    FUN_80055840();
  }

  // rain (red beaker)
  if (
		(
			// gGT->256c & Rain
			(param_1[0x95b] & 0x10) != 0
		) &&
		(
			// if number of screens is less than 3
			(byte)PTR_DAT_8008d2ac[0x1ca8] < 3)
		)
  {
	// RedBeaker_RenderRain
    FUN_8006dc30(
					// 0x5a*4 = 0x168 (camera110 structs)
					param_1 + 0x5a,

					// gGT->backBuffer->primMem
					param_1[4] + 0x74,

					// Rain Pool
					PTR_DAT_8008d2ac + 0x19e8,

					// number of screens
					(uint)(byte)PTR_DAT_8008d2ac[0x1ca8],

					// check if game is paused
					*(uint *)PTR_DAT_8008d2ac & 0xf
				);
  }

  // check if 233 dll is loaded
  iVar6 = FUN_80034940();

  // ND Box split-lines
  if (
		// if it is loaded
		(iVar6 != 0) &&

		// If Level ID == 41
		// If you are at Naughty Dog Box
		(*(int *)(PTR_DAT_8008d2ac + 0x1a10) == 0x29)
	)
  {
	// CS_BoxScene_InstanceSplitLines
    FUN_800b0b38();
  }

  // gGT->256c & renderBucket (instances)
  if ((param_1[0x95b] & 0x20) != 0)
  {
	// This block of code draws characters on screen,
	// as well as all boxes (Weapon boxes + Wumpa boxes),
	// and weapons, I think all 3D geometry except for track
	// Does not include tire sprites

	// number of screens - 1
    uVar7 = (uint)(byte)PTR_DAT_8008d2ac[0x1ca8] - 1;

	// If you're in a Relic Race
    if ((*(uint *)PTR_DAT_8008d2ac & 0x4000000) != 0)
	{
	  // modify array index
      uVar7 = uVar7 | 4;
    }

	// returns RBI pointer
	// RenderBucket_QueueLevInstances
	uVar8 = FUN_80070720(
							// 0x526*4 = 0x1498 = cameraDC array
							param_1 + 0x526,

							// gGT->backBuffer->otMem
							*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x90,

							// render bucket instance
							*(undefined4 *)(PTR_DAT_8008d2ac + 0x1c94),

							// track LOD
							(uint)(byte)(&DAT_8008d2d0)[uVar7],

							// number of screens
							(uint)(byte)PTR_DAT_8008d2ac[0x1ca8],

							// check if you paused the game
							*(uint *)PTR_DAT_8008d2ac & 0xf);

	// number of screens - 1
    uVar7 = (uint)(byte)PTR_DAT_8008d2ac[0x1ca8] - 1;

	// If you're in a Relic Race
    if ((*(uint *)PTR_DAT_8008d2ac & 0x4000000) != 0)
	{
	  // modify array index
      uVar7 = uVar7 | 4;
    }

	// 1904 is in InstancePool, which starts at 18f8,
	// not sure what kind of data it is specifically

	// returns RBI pointer
	// RenderBucket_QueueNonLevInstances
    puVar9 = (undefined4 *)
             FUN_8007084c(
							// first taken item in InstancePool
							*(undefined4 *)(PTR_DAT_8008d2ac + 0x1904),

							// gGT->backBuffer->otMem
							*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x90,

							// render bucket instance
							uVar8,

							// track LOD
							(uint)(byte)(&DAT_8008d2d0)[uVar7],

							// number of screens
							(uint)(byte)PTR_DAT_8008d2ac[0x1ca8],

							// check if game is paused
							*(uint *)PTR_DAT_8008d2ac & 0xf);

	// Aug prototype
#if 0
		// ptrEnd of otmem is less than ptrCurr otmem
    if (*(uint *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x98) <
        *(uint *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x9c)) {
      printf("OTMEM OVERFLOW!\n");
    }
#endif

	// erase first variable in RenderBucketInstance
	*puVar9 = 0;
  }

  // gGT->256c & particles
  if ((param_1[0x95b] & 0x200) != 0)
  {
	// This block of code draws Exhaust
	// Only if param_1[0x95b] & 0x20 also happens

	  // (72a*4 = 1ca8), numPlayers
    cVar3 = *(char *)(param_1 + 0x72a);

	// loop counter
    iVar6 = 0;

    if (cVar3 == '\0') goto code_r0x800369d8;

	// offset of 8008d2ac where camera110 structs
	// are held for each player (pos, size, etc)
    iVar19 = 0x168;

	// for iVar6 = 0; iVar6 < numPlayers iVar6++
	do
	{
	  // pointer to camera110 struct
	  iVar13 = (int)param_1 + iVar19;

	  // increment offset to next camera110 struct
      iVar19 = iVar19 + 0x110;

	  // Draw particle List
      FUN_8003f590(iVar13,*(undefined4 *)(PTR_DAT_8008d2ac + 0x1c9c));

	  // increment loop counter
      iVar6 = iVar6 + 1;

    } while (iVar6 < (int)(uint)*(byte *)(param_1 + 0x72a));
  }

  // (72a*4 = 1ca8), numPlayers
  cVar3 = *(char *)(param_1 + 0x72a);

code_r0x800369d8:

  // loop counter
  iVar6 = 0;

  // link OT of all four player camera110's
  if (cVar3 != '\0')
  {
	// offset of 8008d2ac where camera110 structs are held
    iVar19 = 0x168;

	// param1 is PTR_DAT_8008d2ac

	// 0x5a*4 = 0x168 (camera110 structs)
    puVar12 = param_1 + 0x5a;
    puVar18 = param_1;
    do
	{
	  // increment offset to next camera110 struct
      iVar19 = iVar19 + 0x110;

      puVar1 = puVar18 + 0x97;
      puVar18 = puVar18 + 0x44;

	  // Camera110_LinkOT_Normal
	  // param1 otmem
	  // param2 camera110
	  // param3 backbuffer
      FUN_80042a8c(*puVar1 + 0xffc,puVar12,param_1[4],0,0);

	  // increment loop counter
	  iVar6 = iVar6 + 1;

	  // pointer to camera110 struct
      puVar12 = (uint *)((int)param_1 + iVar19);

	// (72a*4 = 1ca8), numPlayers
	} while (iVar6 < (int)(uint)*(byte *)(param_1 + 0x72a));
  }

  if (
		// param1 is PTR_DAT_8008d2ac
		((param_1[0x95b] & 0x100) != 0) &&

		// if number of screens is more than 1
		(1 < (byte)PTR_DAT_8008d2ac[0x1ca8])
	)
  {
	// param1 is PTR_DAT_8008d2ac
    FUN_80023640(param_1);
  }

  // gGT->256c & battle
  // what? no it's not, happens in Cortex Castle Arcade
  if ((param_1[0x95b] & 0x40) != 0)
  {
	// Check if 231.dll is loaded
    iVar6 = FUN_800348e8();

	// if it is loaded
    if (iVar6 != 0)
	{
	  // RB_Player_ToggleInvisible (battle powerup)
      FUN_800b0dbc();

	  // RB_Player_ToggleFlicker (after damage in battle mode)
      FUN_800b0e68();

	  // RB_Burst_ProcessBucket
      FUN_800b1bd8(*(undefined4 *)(PTR_DAT_8008d2ac + 0x1bb8));

	  // RB_Blowup_ProcessBucket
      FUN_800b1714(*(undefined4 *)(PTR_DAT_8008d2ac + 0x1bcc));

	  // RB_Spider_DrawWebs
	  // pointer to first spider thread
      FUN_800b95fc(*(undefined4 *)(PTR_DAT_8008d2ac + 0x1bf4),param_1 + 0x5a);

	  // RB_Follower_ProcessBucket
      FUN_800b6d58(*(undefined4 *)(PTR_DAT_8008d2ac + 0x1c08));

	  // RB_StartText_ProcessBucket
      FUN_800b9dd8(*(undefined4 *)(PTR_DAT_8008d2ac + 0x1c1c));
    }

	// Check if DLL 232 is loaded
    iVar6 = FUN_80034920();

    if (
			// If it is loaded
			(iVar6 != 0) &&

			// If you're in Adventure Arena
			((*(uint *)PTR_DAT_8008d2ac & 0x100000) != 0)
		)
	{
	  // AH_WarpPad_AllWarppadNum
      FUN_800abbdc();
    }

	// loop counter
    iVar6 = 0;

	// Process Turbo ThreadBucket
    FUN_80069284(*(undefined4 *)(PTR_DAT_8008d2ac + 0x1be0));

	// param1 is PTR_DAT_8008d2ac
	// (72a*4 = 1ca8), numPlayers
    if (*(char *)(param_1 + 0x72a) != '\0')
	{
	  // offset of 8008d2ac where camera110 structs are stored
      iVar19 = 0x168;

      do
	  {
		// pointer to camera110 struct
        iVar13 = (int)param_1 + iVar19;

		// Draw Skidmarks of all Player threads
        FUN_8005c354(*(undefined4 *)(PTR_DAT_8008d2ac + 0x1b2c),iVar13);

		// increment pointer to next camera110 struct
        iVar19 = iVar19 + 0x110;

		// Draw Skidmarks of all robotcar threads
        FUN_8005c354(*(undefined4 *)(PTR_DAT_8008d2ac + 0x1b40),iVar13);

		// increment loop counter
		iVar6 = iVar6 + 1;

		// (72a*4 = 1ca8), numPlayers
      } while (iVar6 < (int)(uint)*(byte *)(param_1 + 0x72a));
    }
  }

  // title screen, crash and trophy
  if (
		// If in main menu (character selection, track selection, any part of it)
		((*(uint *)PTR_DAT_8008d2ac & 0x2000) != 0) &&

		(
			// Check if 230 dll is loaded
			iVar6 = FUN_80034908(),
			iVar6 != 0
		)
	  )
  {
	// MM_Title_SetTrophyDPP
    FUN_800ac178();
  }

  // gGT->256c & RenderBucket
  if ((param_1[0x95b] & 0x20) != 0)
  {
	// RenderBucket_Execute
    FUN_8006aaa8(
					// render bucket instance
					*(undefined4 *)(PTR_DAT_8008d2ac + 0x1c94),

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74
                );
  }

  // gGT->256c & wheels
  if ((param_1[0x95b] & 0x80) != 0)
  {
	// This block of code draws tires
	// Only if param_1[0x95b] & 0x20 is also true

	// pointer to first Player thread
    if (*(int *)(PTR_DAT_8008d2ac + 0x1b2c) != 0)
	{
	  // Draw normal tires (no reflection)
      FUN_8006e588(
					// pointer to first Player thread
					*(int *)(PTR_DAT_8008d2ac + 0x1b2c),

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

					// (72a*4 = 1ca8), numPlayers
                   (uint)*(byte *)(param_1 + 0x72a));

	  //Draws reflected wheels (visible on ice terrain)
      FUN_8006f004(
					// pointer to first Player thread
					*(undefined4 *)(PTR_DAT_8008d2ac + 0x1b2c),

				   // pointer to PrimMem struct
				   *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

				   // (72a*4 = 1ca8), numPlayers
				   (uint)*(byte *)(param_1 + 0x72a));
    }

	// If number of AIs is not zero
    if (PTR_DAT_8008d2ac[0x1cab] != '\0')
	{
	  // Draw normal tires (no reflection)
      FUN_8006e588(
					// pointer to first robotcar thread
					*(undefined4 *)(PTR_DAT_8008d2ac + 0x1b40),

				   // pointer to PrimMem struct
				   *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

				   // (72a*4 = 1ca8), numPlayers
				   (uint)*(byte *)(param_1 + 0x72a));

	  //Draws reflected wheels (visible on ice terrain)
	  FUN_8006f004(
					// pointer to first robotcar thread
					*(undefined4 *)(PTR_DAT_8008d2ac + 0x1b40),

				   // pointer to PrimMem struct
				   *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

				   // (72a*4 = 1ca8), numPlayers
				   (uint)*(byte *)(param_1 + 0x72a));
    }

	// if pointer to first ghost thread is valid
    if (*(int *)(PTR_DAT_8008d2ac + 0x1b54) != 0)
	{
	  // Draw tires directly on screen (no reflection)
      FUN_8006e588(
					// pointer to first ghost thread
					*(int *)(PTR_DAT_8008d2ac + 0x1b54),

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

					// (72a*4 = 1ca8), numPlayers
                   (uint)*(byte *)(param_1 + 0x72a));

	  //Draws reflected wheels (visible on ice terrain)
      FUN_8006f004(
					// pointer to first ghost thread
					*(undefined4 *)(PTR_DAT_8008d2ac + 0x1b54),

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

					// (72a*4 = 1ca8), numPlayers
					(uint)*(byte *)(param_1 + 0x72a));
    }
  }

  // gGT->256c & shadows
  if ((param_1[0x95b] & 0x400) != 0)
  {
	// This draws shadows
    FUN_8005b720();
  }

  // gGT->256c & heat particles
  if ((param_1[0x95b] & 0x800) != 0)
  {
	// draw heat effect (tiger temple fire, behind rockets, etc)
    FUN_8004b470(*(undefined4 *)(PTR_DAT_8008d2ac + 0x1ca0),

				// 0x5a*4 = 0x168 (camera110 structs)
				param_1 + 0x5a,

				 // pointer to PrimMem struct
				 *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

				 // (72a*4 = 1ca8), numPlayers
				 (uint)*(byte *)(param_1 + 0x72a),

				 // swapchain index * 0x128
                 *(int *)(PTR_DAT_8008d2ac + 0xc) * 0x128);
  }

  // Camera110_FadeAllWindows
  FUN_80043ab8();

  // draw level
  if (
		// gGT->256c & drawLev
		((param_1[0x95b] & 1) != 0) &&

		// if LEV info is valid
		(iVar22 != 0)
	 )
  {

	// number of players
    bVar2 = PTR_DAT_8008d2ac[0x1ca8];

	// if there are two players
    if (bVar2 == 2)
	{
	  // CTR_ClearRenderLists_1P2P
      FUN_80021bbc(param_1,2);

	  // lev offset 0xDC
      if ((piVar21[0x37] & 4U) == 0)
	  {
		// animates water, 2P mode
        FUN_8006d864(param_1[0x73b],piVar21[0xd],piVar21[0xe],piVar21[0x11],
		
					// VisMem 0x20 - 0x2f (visOVertList)
                     *(undefined4 *)(param_1[0x68e] + 0x20),
					 *(undefined4 *)(param_1[0x68e] + 0x24));
      }

	  // loop counter
      iVar19 = 0;

	  // called before every FindLevVisData
      FUN_800702d4();

	  // offset 0x1CC0,
	  // numVisDataLinks for all render lists of all players combined
      param_1[0x730] = 0;

	  // render lists
      iVar13 = 0x1808;

	  // offset of 8008d2ac where camera110 structs are held
      iVar6 = 0x168;

	  // for iVar19 = 0; iVar19 < 2; iVar19++
      do
	  {
		// pointer to camera110 structs
        iVar20 = (int)param_1 + iVar6;

	    // VisMem = 
		// gGT 0x1a38 (68e*4)
		// lev + 0x190
		// also CameraDC

		// Vismem 0x0-0xF
        puVar9 = (undefined4 *)(param_1[0x68e] + iVar19 * 4);

		// render lists
		local_54 = (int)param_1 + iVar13;
        iVar13 = iVar13 + 0x30;

		// increment offset to next camera110 struct
        iVar6 = iVar6 + 0x110;

		// CreateRenderLists_1P2P
        iVar20 = FUN_8006fe70(

						// LEV->mesh_info->ptrVisDataArray
						*(undefined4 *)(iVar22 + 0x18),

						// Vismem 0x0-0xF
						*puVar9,

						// camera110
						iVar20,

						// render lists
						local_54,

						// VisMem 0x80-0x8F
						puVar9[0x20],

						// (72a*4 = 1ca8), numPlayers
						(uint)*(byte *)(param_1 + 0x72a));

		// increment loop counter
		iVar19 = iVar19 + 1;

		// offset 0x1CC0,
		// numVisDataLinks for all render lists of all players combined
        param_1[0x730] = param_1[0x730] + iVar20;

	  } while (iVar19 < 2);

	  // loop counter
      iVar6 = 0;

	  // pointer to camera110 struct
      iVar19 = 0x168;

	  // param1 is PTR_DAT_8008d2ac

	  // Draw 2p LEV geometry
	  // does not include individual models like boxes
      FUN_800a0cbc(
					// 1808, render lists
					param_1 + 0x602,

					// 0x5a*4 = 0x168 (camera110 structs)
					param_1 + 0x5a,

					// LEV -> ptr_mesh_info
					iVar22,

					// gGT->backBuffer->primMem
					param_1[4] + 0x74,

					// Vismem 0x10-0x1F
					*(undefined4 *)(param_1[0x68e] + 0x10),
					*(undefined4 *)(param_1[0x68e] + 0x14),

					// level -> ptr_restart_main
					piVar21[0x11]
					);

      puVar18 = param_1;

	  // for iVar6 = 0; iVar6 < 2; iVar6++
	  do
	  {
		// pointer to camera110 struct
        iVar22 = (int)param_1 + iVar19;

		// gGT + 0x25C
		// camera110->ptrOT
        puVar12 = puVar18 + 0x97;

		// gGT + 0x25C + 0x110
		// camera110(next)->ptrOT
        puVar18 = puVar18 + 0x44;

		// increment offset to next camera110 struct
		iVar19 = iVar19 + 0x110;

		// increment loop counter
        iVar6 = iVar6 + 1;

		// CAM_SkyboxGlow
        FUN_800175cc(

			// LEV -> skyboxGlowData
			piVar21 + 0x12,

			// camera110
			iVar22,

			// gGT->backBuffer->primMem
			param_1[4] + 0x74,

			// ptrOT + 0xffc?
			*puVar12 + 0xffc);

      } while (iVar6 < 2);
    }

	// param1 is PTR_DAT_8008d2ac

	// if there are not two players
    else
	{
	  // if there are less than 3 players
      if (bVar2 < 3)
	  {
		// if there is one player
        if (bVar2 == 1)
		{
		  // CTR_ClearRenderLists_1P2P
          FUN_80021bbc(param_1,1);

		  // lev offset 0xDC
		  if (((piVar21[0x37] & 4U) == 0) && (piVar21 != (int *)0x0))
		  {
			// animates water, 1P mode
            FUN_8006d79c(param_1[0x73b],piVar21[0xd],piVar21[0xe],piVar21[0x11],
                         
						 // Vismem 0x20-0x2F (visOVertList)
						 *(undefined4 *)(param_1[0x68e] + 0x20));
          }

		  else
		  {
			// roo's pipe floors
			
			// AnimateQuads
            FUN_80069e70(
			
						// timer
						param_1[0x73b] << 7,
			
						// lev -> 0x174 and 0x178,
						// numSCVert, and ptrSCVert
						piVar21[0x5d],
						piVar21[0x5e],
			
						// Vismem 0x30-0x3F (visSCVertList)
                        *(undefined4 *)(param_1[0x68e] + 0x30));
          }

		  // camera110 -> 0x18, distToScreen
          DAT_1f80001c = *(int *)(PTR_DAT_8008d2ac + 0x180);

		  // If Level ID == 40
		  // If you are in Adventure Character Selection Screen
          if ((*(int *)(PTR_DAT_8008d2ac + 0x1a10) == 0x28) ||

			 // If you are in a cutscene
             (((*(uint *)PTR_DAT_8008d2ac & 0x20000000) != 0 &&

			  // Level ID != 37
			  // If it is not Crash Bandicoot intro (he's sleeping and snoring)
              (*(int *)(PTR_DAT_8008d2ac + 0x1a10) != 0x25))))
		  {
            DAT_1f800014 = 0x1e00;
            DAT_1f800018 = 0x640;
            DAT_1f80001c = 0x640;
            DAT_1f800020 = 0x500;
            DAT_1f800024 = 0x280;
            DAT_1f800028 = 0x140;
            DAT_1f80002c = 0x780;
          }
          else {
            DAT_1f800014 = DAT_1f80001c * 0x2080;
            if (DAT_1f800014 < 0) {
              DAT_1f800014 = DAT_1f800014 + 0xff;
            }
            DAT_1f800024 = DAT_1f80001c * 7;
            DAT_1f800028 = DAT_1f80001c * 0x380;
            DAT_1f800014 = DAT_1f800014 >> 8;
            DAT_1f800020 = DAT_1f80001c * 0xc;
            DAT_1f800018 = DAT_1f80001c * 0x1a;
            DAT_1f80001c = DAT_1f80001c * 0x18;
            if (DAT_1f800028 < 0) {
              DAT_1f800028 = DAT_1f800028 + 0xff;
            }
            DAT_1f800028 = DAT_1f800028 >> 8;
            DAT_1f80002c = DAT_1f800018 + 0x140;
          }

		  // called before every FindLevVisData
          FUN_800702d4();

		  // param1 is PTR_DAT_8008d2ac

		  // 0x5a*4 = 0x168 (camera110 structs)
          puVar18 = param_1 + 0x5a;

		  // iVar22 is LEV->mesh_info,
		  // iVar22+0x18 = LEV->mesh_info->ptrVisDataArray

		  // CreateRenderLists_1P2P
          uVar7 = FUN_8006fe70(

						// LEV->mesh_info->ptrVisDataArray
						*(undefined4 *)(iVar22 + 0x18),

						// Vismem 0x0-0xF
						*(undefined4 *)param_1[0x68e],

						// camera110
						puVar18,

						// render lists
						param_1 + 0x602,

						// VisMem 0x80-0x8F
						((undefined4 *)param_1[0x68e])[0x20],

						// (72a*4 = 1ca8), numPlayers
						(uint)*(byte *)(param_1 + 0x72a));

		  // offset 0x1CC0,
		  // numVisDataLinks for all render lists of all players combined
          param_1[0x730] = uVar7;

		  // draw 1p LEV geometry
		  // does not include individual models like boxes
          FUN_800a0cbc(
						// 1808, render lists
						param_1 + 0x602,

						// camera110 structs
						puVar18,

						// LEV -> ptr_mesh_info
						*piVar21,

						// gGT->backBuffer->primMem
						param_1[4] + 0x74,

						// Vismem 0x10-0x1F
					   *(undefined4 *)(param_1[0x68e] + 0x10),

					   piVar21[0x11]
					   );

		  // Draw full level skybox
		  FUN_80069bb0(
						// level ptr_skybox
						piVar21[1],

						// camera110
						puVar18,

						// gGT->backBuffer->primMem
						param_1[4] + 0x74);

		  // lev offset 0xDC,
		  // if gradient is enabled
		  if ((piVar21[0x37] & 1U) != 0)
		  {
			// CAM_SkyboxGlow
            FUN_800175cc(

				// LEV -> skyboxGlowData
				piVar21 + 0x12,

				// camera110
				puVar18,

				// gGT->backBuffer->primMem
				param_1[4] + 0x74,

				// gGT+0x25C
				// camera110->ptrOT
				param_1[0x97] + 0xffc);
          }
        }
      }

	  // if there are not less than 3 players
      else
	  {
		// param1 is PTR_DAT_8008d2ac

		// if there are 3 players
        if (bVar2 == 3)
		{
		  // CTR_ClearRenderLists_3P4P
          FUN_80021c2c(param_1,3);

		  // lev offset 0xDC
          if ((piVar21[0x37] & 4U) == 0)
		  {
			// animates water, 3P mode
            FUN_8006d948(param_1[0x73b],piVar21[0xd],piVar21[0xe],piVar21[0x11],
			
						// Vismem 0x20-0x2F (visOVertList)
                         *(undefined4 *)(param_1[0x68e] + 0x20),
                         *(undefined4 *)(param_1[0x68e] + 0x24),
                         *(undefined4 *)(param_1[0x68e] + 0x28));
          }

		  // loop counter
          iVar19 = 0;

		  // called before every FindLevVisData
          FUN_800702d4();

		  // offset 0x1CC0,
		  // numVisDataLinks for all render lists of all players combined
          param_1[0x730] = 0;

		  // 1808, render lists
          iVar13 = 0x1808;

		  // offset of 8008d2ac where camera110 structs are held
          iVar6 = 0x168;

		  // for iVar9 = 0; iVar9 < 3; iVar9++
          do
		  {
			// pointer to camera110 struct
            iVar20 = (int)param_1 + iVar6;

			// gGT -> render list for player
            local_54 = (int)param_1 + iVar13;

			// Vismem 0x0-0xF
            puVar9 = (undefined4 *)(param_1[0x68e] + iVar19 * 4);

			// next render list
			iVar13 = iVar13 + 0x30;

			// increment offset to next camera110 struct
            iVar6 = iVar6 + 0x110;

			// CreateRenderLists_3P4P
            iVar20 = FUN_80070388(

				// LEV->mesh_info->ptrVisDataArray
				*(undefined4 *)(iVar22 + 0x18),

				// Vismem 0x0-0xF
				*puVar9,

				// camera110
				iVar20,

				// render list to generate
				local_54,

				// VisMem 0x80-0x8F
				puVar9[0x20]);

			// increment loop counter
            iVar19 = iVar19 + 1;

			// offset 0x1CC0,
			// numVisDataLinks for all render lists of all players combined
            param_1[0x730] = param_1[0x730] + iVar20;

		  } while (iVar19 < 3);

		  // loop counter
          iVar6 = 0;

		  // offset of 8008d2ac where camera110 structs
		  // are held for each player (pos, size, etc)
          iVar19 = 0x168;

		  // param1 is PTR_DAT_8008d2ac

		  // draw 3p LEV geometry
		  // does not include models like boxes
          FUN_800a0cbc(
						// 1808, render lists
						param_1 + 0x602,

						// 0x5a*4 = 0x168 (camera110 structs)
						param_1 + 0x5a,

						// LEV -> ptr_mesh_info
						iVar22,

						// gGT->backBuffer->primMem
						param_1[4] + 0x74,

						// Vismem 0x10-0x1F
						*(undefined4 *)(param_1[0x68e] + 0x10),
						*(undefined4 *)(param_1[0x68e] + 0x14),
						*(undefined4 *)(param_1[0x68e] + 0x18),

						piVar21[0x11]
						);

          puVar18 = param_1;

		  // for iVar6 = 0; iVar6 < 3; iVar6++
          do
		  {
			// pointer to camera110 struct
            iVar22 = (int)param_1 + iVar19;

			// gGT + 0x25C
			// camera110->ptrOT
            puVar12 = puVar18 + 0x97;

			// gGT + 0x25C + 0x110
			// camera110(next)->ptrOT
            puVar18 = puVar18 + 0x44;

			// increment pointer to next camera110 struct
			iVar19 = iVar19 + 0x110;

			// increment loop counter
            iVar6 = iVar6 + 1;

			// CAM_SkyboxGlow
            FUN_800175cc(

				// LEV -> skyboxGlowData
				piVar21 + 0x12,

				// camera110
				iVar22,

				// gGT->backBuffer->primMem
				param_1[4] + 0x74,

				// ptrOT + 0xffc?
				*puVar12 + 0xffc);

          } while (iVar6 < 3);
        }

		// if there are not 3 players
		else
		{
		  // if there are four players
          if (bVar2 == 4) {

			// param1 is PTR_DAT_8008d2ac

			// CTR_ClearRenderLists_3P4P
            FUN_80021c2c(param_1,4);

			// lev offset 0xDC
            if ((piVar21[0x37] & 4U) == 0)
			{
			  // animates water, 4P mode
              FUN_8006da50(param_1[0x73b],piVar21[0xd],piVar21[0xe],piVar21[0x11],
			  
							// Vismem 0x20-0x2F (visOVertList)
                           *(undefined4 *)(param_1[0x68e] + 0x20),
                           *(undefined4 *)(param_1[0x68e] + 0x24),
                           *(undefined4 *)(param_1[0x68e] + 0x28),
                           *(undefined4 *)(param_1[0x68e] + 0x2c));
            }

			// loop counter
            iVar19 = 0;

			// called before every FindLevVisData
            FUN_800702d4();

			// offset 0x1CC0,
			// numVisDataLinks for all render lists of all players combined
            param_1[0x730] = 0;

			// render list
            iVar13 = 0x1808;

			// offset to next camera110 struct
            iVar6 = 0x168;

			// for iVar19 = 0; iVar19 < 4; iVar19++
            do
			{
			  // pointer to camera110 struct
              iVar20 = (int)param_1 + iVar6;

			  // render list
              local_54 = (int)param_1 + iVar13;
			  
			  // Vismem 0x0-0xF
              puVar9 = (undefined4 *)(param_1[0x68e] + iVar19 * 4);
              
			  // render list
			  iVar13 = iVar13 + 0x30;

			  // increment pointer to next camera110 structure
              iVar6 = iVar6 + 0x110;

			  // CreateRenderLists_3P4P
              iVar20 = FUN_80070388(

					// LEV->mesh_info->ptrVisDataArray
					*(undefined4 *)(iVar22 + 0x18),

					// Vismem 0x0-0xF
					*puVar9,

					// camera110
					iVar20,

					// render list being generated
					local_54,

					// VisMem 0x80-0x8F
                    puVar9[0x20]);

			  // increment loop counter
              iVar19 = iVar19 + 1;

			  // offset 0x1CC0,
			  // numVisDataLinks for all render lists of all players combined
              param_1[0x730] = param_1[0x730] + iVar20;

            } while (iVar19 < 4);

			// param1 is PTR_DAT_8008d2ac

			// loop counter
            iVar6 = 0;

			// offset of 8008d2ac to camera110 structs
            iVar19 = 0x168;

			// draw 4p LEV geometry
			// does not include models like boxes
            FUN_800a0cbc(
			
						// 1808, render lists
						param_1 + 0x602,

						// 0x5a*4 = 0x168 (camera110 structs)
						param_1 + 0x5a,

						// LEV -> ptr_mesh_info
						iVar22,

						// gGT->backBuffer->primMem
						param_1[4] + 0x74,

						// Vismem 0x10-0x1F
                        *(undefined4 *)(param_1[0x68e] + 0x10),
                        *(undefined4 *)(param_1[0x68e] + 0x14),
                        *(undefined4 *)(param_1[0x68e] + 0x18),
                        *(undefined4 *)(param_1[0x68e] + 0x1c),

						piVar21[0x11]
					);

			puVar18 = param_1;

			// for iVar6 = 0; iVar6 < 4; iVar6++
            do
			{
			  // pointer to camera110 struct
              iVar22 = (int)param_1 + iVar19;

			  // gGT + 0x25C
			  // camera110->ptrOT
              puVar12 = puVar18 + 0x97;

			  // gGT + 0x25C + 0x110
			  // camera110(next)->ptrOT
              puVar18 = puVar18 + 0x44;

			  // increment offset to next camera110
			  iVar19 = iVar19 + 0x110;

			  // increment loop counter
              iVar6 = iVar6 + 1;

			  // CAM_SkyboxGlow
              FUN_800175cc(

				// LEV -> skyboxGlowData
				piVar21 + 0x12,

				// camera110
				iVar22,

				// gGT->backBuffer->primMem
				param_1[4] + 0x74,

				// ptrOT + 0xffc?
				*puVar12 + 0xffc);

            } while (iVar6 < 4);
          }
        }
      }
    }

	// param1 is PTR_DAT_8008d2ac

	// loop counter
    iVar6 = 0;

	// (72a*4 = 1ca8), numPlayers
    if (*(char *)(param_1 + 0x72a) != '\0')
	{
	  // offset of 8008d2ac where camera110 structs are stored
      iVar22 = 0x168;

	  // pointer to the "full screen" camera110, which comes 0x110
	  // bytes before each player's individual internal camera110
      puVar12 = param_1 + 0x5a;

      puVar18 = param_1;
      do {

		// increment offset to next camera110 struct
        iVar22 = iVar22 + 0x110;

        puVar1 = puVar18 + 0x97;
        puVar18 = puVar18 + 0x44;

		// Camera110_LinkOT_Normal
		// param1 otmem
		// param2 camera110
		// param3 backbuffer
        FUN_80042a8c(*puVar1 + 0xffc,puVar12,param_1[4],0,0);

		// increment loop counter
        iVar6 = iVar6 + 1;

        puVar12 = (uint *)((int)param_1 + iVar22);

		// (72a*4 = 1ca8), numPlayers
      } while (iVar6 < (int)(uint)*(byte *)(param_1 + 0x72a));
    }

	// multiplayer wumpa hud 3D
    if (
			// gGT->hudFlags & 1
			((PTR_DAT_8008d2ac[0x1d31] & 1) != 0) &&

			// if number of screens is more than 1
			(1 < (byte)PTR_DAT_8008d2ac[0x1ca8])
		)
	{
	  // DrawHUD_Wumpa3D_2P3P4P
	  // param1 is gGT
      FUN_8005465c(param_1);
    }

    if (
		// param1 is PTR_DAT_8008d2ac
		((param_1[0x95b] & 0x100) != 0) &&

		// if number of screens is more than 1
		(1 < (byte)PTR_DAT_8008d2ac[0x1ca8])
		)
	{
	  // param1 is PTR_DAT_8008d2ac
      FUN_80023784(param_1);
    }

	if (
			// if not loading
			// if not in adventure arena
			// if not in main menu
			((*param_1 & 0x20102000) == 0) &&

			// If loading is 100% finished
			(DAT_8008d0f8 != -4)
		)
	{
	  // DotLights_AudioAndVideo
      FUN_800242b8(param_1);
    }

	// if drawing 2D lines between multiplayer screens
    if ((*(uint *)(PTR_DAT_8008d2ac + 0x256c) & 0x8000) != 0) {

      if (
			(
				// If you're in Battle Mode
				((*(uint *)PTR_DAT_8008d2ac & 0x20) != 0) &&

				// if number of screens is more than 2
				(2 < (byte)PTR_DAT_8008d2ac[0x1ca8])
			) &&
			(
				// set loop counter to zero
				iVar6 = 0,

				// number of screens is not zero
				PTR_DAT_8008d2ac[0x1ca8] != '\0'
			)
		 )
	  {
        iVar22 = 0;

	    // for(int iVar6 = 0; iVar6 < numScreens; iVar6++)
        do {
          puVar14 = PTR_DAT_8008d2ac + iVar22;

		  // Get dimensions of each window (camera110)
          local_30 = *(undefined2 *)(puVar14 + 0x184);	// startX
          local_2e = *(undefined2 *)(puVar14 + 0x186);	// startY
          local_2c = *(undefined2 *)(puVar14 + 0x188);	// sizeX
          local_2a = *(undefined2 *)(puVar14 + 0x18a);	// sizeY

		  // Draw a 2D box made of four rectangles
		  FUN_80045534(&local_30,4,2,

					   // Get Color based on...
					   (&PTR_DAT_80081d70)
											// Battle Team that the player is on
                       [*(int *)(*(int *)(PTR_DAT_8008d2ac + iVar6 * 4 + 0x24ec) + 0x4e8) + 0x18],

					   0,

					   // pointer to OT mem -> curr
					   *(int *)(PTR_DAT_8008d2ac + 0x147c) + 0xc);

		  // increment loop counter
          iVar6 = iVar6 + 1;

          iVar22 = iVar22 + 0x110;

						// number of screens
        } while (iVar6 < (int)(uint)(byte)PTR_DAT_8008d2ac[0x1ca8]);
      }

	  // if number of screens is more than 1
      if (1 < (byte)PTR_DAT_8008d2ac[0x1ca8])
	  {
		// backBuffer->primMem.curr
        p = *(void **)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80);

		// psyq macro setPolyF4
        *(undefined *)((int)p + 3) = 5;
        *(undefined *)((int)p + 7) = 0x28;

		// RGB (black)
        *(undefined *)((int)p + 6) = 0;
        *(undefined *)((int)p + 5) = 0;
        *(undefined *)((int)p + 4) = 0;

        puVar14 = PTR_DAT_8008d2ac;

		// Make four (x,y) coordinates
        *(undefined2 *)((int)p + 10) = 0x6a;
        *(undefined2 *)((int)p + 0xe) = 0x6a;
        *(undefined2 *)((int)p + 8) = 0;
        *(undefined2 *)((int)p + 0xc) = 0x200;
        *(undefined2 *)((int)p + 0x10) = 0;
        *(undefined2 *)((int)p + 0x12) = 0x6e;
        *(undefined2 *)((int)p + 0x14) = 0x200;
        *(undefined2 *)((int)p + 0x16) = 0x6e;

		// Draw a bar from left to right,
		// dividing the screen in half on top and bottom
        AddPrim((void *)(*(int *)(puVar14 + 0x147c) + 0xc),p);

		// backBuffer->primMem.curr
        *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80) =
             *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80) + 0x18;
      }

	  // if number of screens is more than 2
      if (2 < (byte)PTR_DAT_8008d2ac[0x1ca8])
	  {
		// backBuffer->primMem.curr
        p = *(void **)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80);
		
		// psyq macro setPolyF4
        *(undefined *)((int)p + 3) = 5;
        *(undefined *)((int)p + 7) = 0x28;
        
		// RGB (black)
		*(undefined *)((int)p + 6) = 0;
        *(undefined *)((int)p + 5) = 0;
        *(undefined *)((int)p + 4) = 0;

        puVar14 = PTR_DAT_8008d2ac;

		// Make four (x,y) coordinates
		*(undefined2 *)((int)p + 8) = 0xfd;
        *(undefined2 *)((int)p + 0x10) = 0xfd;
        *(undefined2 *)((int)p + 10) = 0;
        *(undefined2 *)((int)p + 0xc) = 0x103;
        *(undefined2 *)((int)p + 0xe) = 0;
        *(undefined2 *)((int)p + 0x12) = 0xd8;
        *(undefined2 *)((int)p + 0x14) = 0x103;
        *(undefined2 *)((int)p + 0x16) = 0xd8;

		// Draw a bar from top to bottom,
		// dividing the screen in half on left and right
        AddPrim((void *)(*(int *)(puVar14 + 0x147c) + 0xc),p);

		// backBuffer->primMem.curr
		*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80) =
             *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80) + 0x18;
      }

	  // if number of screens is 3
      if (PTR_DAT_8008d2ac[0x1ca8] == '\x03')
	  {
		// backBuffer->primMem.curr
        p = *(void **)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80);

		// psyq macro setPolyF4
        *(undefined *)((int)p + 3) = 5;
        *(undefined *)((int)p + 7) = 0x28;
		
		// RGB (black)
        *(undefined *)((int)p + 6) = 0;
        *(undefined *)((int)p + 5) = 0;
        *(undefined *)((int)p + 4) = 0;
		
		// xy0
        *(undefined2 *)((int)p + 8) = 0x100;
        *(undefined2 *)((int)p + 0x10) = 0x100;

        puVar14 = PTR_DAT_8008d2ac;

		// Make three more (x,y) coordinates
		*(undefined2 *)((int)p + 10) = 0x6c;
        *(undefined2 *)((int)p + 0xe) = 0x6c;
        *(undefined2 *)((int)p + 0xc) = 0x200;
        *(undefined2 *)((int)p + 0x12) = 0xd8;
        *(undefined2 *)((int)p + 0x14) = 0x200;
        *(undefined2 *)((int)p + 0x16) = 0xd8;

		// Draw black quad, map wil be rendered on top of this
        AddPrim((void *)(*(int *)(puVar14 + 0x147c) + 0xc),p);

		// backBuffer->primMem.curr
		*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80) =
             *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80) + 0x18;
      }
    }

	// if game is not loading
    if (DAT_8008d0f8 == -1) {

	  // If game is not paused
      if ((*(uint *)PTR_DAT_8008d2ac & 0xf) == 0)
	  {
		// RivalWeapons_PerFrame
        FUN_800408b8();
      }

	  // StartLine_PerFrame
      FUN_800414f4();
    }
  }

  // If in main menu, or in adventure arena,
  // or in End-Of-Race menu
  if ((*(uint *)PTR_DAT_8008d2ac & 0x302000) != 0) {
    FUN_80047d64();
  }

  // clear swapchain
  if (
		// gGT->256c & clear swapchain
		((*(uint *)(PTR_DAT_8008d2ac + 0x256c) & 0x2000) != 0) &&

		// if lev has clear-color data, for clearing screen without skybox
		((*(char *)(param_1[0x58] + 0x163) != '\0' || (*(char *)(param_1[0x58] + 0x167) != '\0')))
	 )
  {
	// CAM_ClearScreen
    FUN_8001861c(param_1);
  }

  // gGT->256c & checkered flag
  if ((*(uint *)(PTR_DAT_8008d2ac + 0x256c) & 0x1000) != 0)
  {
    // draw checkered flag
	FUN_800444e8();
  }

  // param1 is PTR_DAT_8008d2ac

  // Camera110_LinkOT_Normal
  // param1 otmem
  // param2 camera110
  // param3 backbuffer
  // 0x4e2 = 0x1388 = camera110_UI
  // 0x51f = 0x147c = camera110_UI + 0xf4 (ptrOT)
  FUN_80042a8c(param_1[0x51f] + 0x10,param_1 + 0x4e2,param_1[4],0,0);

  // RCNT_GetTime_Total
  uVar7 = FUN_8004b3a4();
  puVar14 = PTR_DAT_8008d2ac;
  param_1[0x737] = uVar7;

  // gGT->256c & checkered flag
  if ((*(uint *)(puVar14 + 0x256c) & 0x1000) != 0) {
    VSync(0);
  }

  // determine if drawsync has finished
  cVar3 = PTR_DAT_8008d2ac[0x1d30];

  // Pause CPU, at least until two VSyncCallback's are done (30fps),
  // or force drawing to stop if six VsyncCallback's are done (6fps)
  while( true )
  {
	// if drawSync is finished, and two VsyncCallback's have run
    if ((cVar3 == '\0') && (DAT_8008d2b4 < 1)) goto LAB_800378d0;

	// If VsyncCallback executes 6 times, and DrawSync is still not done,
	// then game is under 6fps, BreakDraw
	if (6 < *(uint *)(PTR_DAT_8008d2ac + 0x1ce0)) break;

	// check again
	cVar3 = PTR_DAT_8008d2ac[0x1d30];
  }

  // Dont finish the last DrawOTag
  // request, just stop drawing
  BreakDraw();

LAB_800378d0:

  // draw video:
  // if a STR video is playing
  if (DAT_8008d2c8 == 1)
  {
	// MM_Video_CheckIfFinished
    FUN_800b6674(1);

	// draw STR on screen by copying a rectangle from
	// one place in VRAM (offscreen) to another (in the swapchain image)
	MoveImage(&DAT_8008d880,(int)DAT_8008d89c,(int)DAT_8008d8a0);

	DrawSync(0);
  }

  // param1 is PTR_DAT_8008d2ac

  // 737 -> 1cdc
  // RCNT_GetTime_Elapsed
  uVar7 = FUN_8004b41c(param_1[0x737],0);
  param_1[0x737] = uVar7;

  // if frontBuffer exists
  if (param_1[5] != 0)
  {
	// frame duplicator
    DAT_8008d2b4 = 2;

	// debug variable
    uVar7 = DAT_8008cff0 & 1;

	// unused debug timer
	*(undefined4 *)(PTR_DAT_8008d2ac + 0x1cd8) = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1cc4);

	// if not debug
	if (uVar7 == 0)
	{
	  // GameTracker frontBuffer dispEnv
      puVar14 = (undefined *)(param_1[5] + 0x5c);
    }

	// if debug
	else
	{
	  // blank dispEnv, all zeros
      puVar14 = &DAT_8008e6d4;
    }

	PutDispEnv(puVar14);

	// GameTracker frontBuffer drawEnv
    PutDrawEnv(param_1[5]);

	// wipe pointer to frontBuffer
	param_1[5] = 0;
  }

  puVar14 = PTR_DAT_8008d2ac;

  // calculate new frontBuffer based on swapchainIndex
  // swap=0, get db[1]
  // swap=1, get db[0]
  *(uint **)(param_1 + 5) = (uint *)((int)param_1 - (param_1[3] * 0xa4 + -0xbc));

  // Record that an OT has been submitted
  puVar14[0x1d30] = 1;

  // camera110[0]->ptrOT + 0xffc,
  // draws from end to start
  DrawOTag(param_1[0x97] + 0xffc);

  // frame timer
  param_1[0x73a] = param_1[0x739];

  return;
}


// Draw NPC-105 wheel
void FUN_800379f4(short param_1,short param_2,short param_3,int param_4,undefined4 param_5,
                 undefined4 *param_6,undefined4 param_7,undefined4 param_8)

{
  short sVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  undefined4 local_48;
  undefined4 local_44;
  undefined4 local_40;
  short local_38;
  short local_36;
  short local_34;
  short local_32;
  short local_30;
  short local_2e;

  uVar6 = 0;
  local_48 = *param_6;
  local_44 = local_48;
  local_40 = local_48;
  local_38 = param_1;
  local_36 = param_2;
  do {
    uVar5 = (int)(short)uVar6 + (int)(short)param_5;

	// approximate trigonometry
	sVar1 = (short)*(int *)(&DAT_800845a0 + (uVar5 & 0x3ff) * 4);
    iVar4 = *(int *)(&DAT_800845a0 + (uVar5 & 0x3ff) * 4) >> 0x10;

	if ((uVar5 & 0x400) == 0) {
      iVar2 = (int)sVar1;
      if ((uVar5 & 0x800) != 0) {
        iVar3 = -iVar4;
        goto LAB_80037b18;
      }
    }
    else {
      iVar3 = (int)sVar1;
      iVar2 = iVar4;
      if ((uVar5 & 0x800) == 0) {
        iVar4 = -iVar3;
      }
      else {
LAB_80037b18:
        iVar2 = -iVar2;
        iVar4 = iVar3;
      }
    }
    local_30 = param_1 + (short)((((int)param_3 << 3) / 5) * iVar4 >> 0xc);
    local_2e = param_2 + (short)((int)param_3 * iVar2 >> 0xc);

	if ((uVar6 & 0xffff) != 0)
	{
	  // DrawTriangle
      FUN_800453e8(&local_38,&local_48,param_7,param_8);
    }

	uVar6 = uVar6 + param_4;
    local_34 = local_30;
    local_32 = local_2e;
    if (0x1000 < (int)(uVar6 * 0x10000) >> 0x10) {
      return;
    }
  } while( true );
}


// Draw left and right arrows around text
// Param1 - PosX
// Param2 - PosY
// Param3 - string
void FUN_80037bc0(short param_1,short param_2,undefined4 param_3)

{
  int iVar1;
  int iVar2;
  undefined **ppuVar3;

  // orange color
  iVar2 = 0;

  if ((DAT_8008d970 & 4) == 0)
  {
	// red color
    iVar2 = 3;
  }

  // DecalFont_GetLineWidth
  iVar1 = FUN_800224d0(param_3,1);

  iVar1 = ((iVar1 << 0x10) >> 0x10) - ((iVar1 << 0x10) >> 0x1f) >> 1;

  // get color data
  ppuVar3 = &PTR_DAT_80081d70 + iVar2;

  // Draw left arrow
  FUN_80023190(
				// largeFont
				*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x2124) + 0xf4),

				(param_1 - iVar1) + -0x14
               ,(int)param_2 + 7,

			   // pointer to PrimMem struct
			   *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

			   // pointer to OT memory
			   *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

			   // color data
			   *(undefined4 *)*ppuVar3,
               *(undefined4 *)(*ppuVar3 + 4),
			   *(undefined4 *)(*ppuVar3 + 8),
               *(undefined4 *)(*ppuVar3 + 0xc),

			   0,0x1000,0x800);

  // Draw right arrow
  FUN_80023190(

				// largeFont
				*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x2124) + 0xf4),

				param_1 + iVar1 + 0x12,
               (int)param_2 + 7,

			   // pointer to PrimMem struct
			   *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

			   // pointer to OT memory
			   *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

			   // color data
			   *(undefined4 *)*ppuVar3,
               *(undefined4 *)(*ppuVar3 + 4),
			   *(undefined4 *)(*ppuVar3 + 8),
               *(undefined4 *)(*ppuVar3 + 0xc),

			   0,0x1000,0);
  return;
}


// Racing Wheel Configuration
void FUN_80037da0(void)

{
  bool bVar1;
  short sVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  char *pcVar6;
  int iVar7;
  uint uVar8;
  undefined2 *puVar9;
  undefined4 uVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  ushort uVar14;
  short local_48 [8];
  undefined2 local_38;
  short local_36;
  undefined2 local_34;
  undefined2 local_32;
  undefined2 local_30;
  short local_2e;
  undefined2 local_2c;
  undefined2 local_2a;

  // If you press Triangle or Square
  if ((DAT_8008d950 & 0x40020) != 0) {

	// Leave configuration
    DAT_8008d864 = 0;
    return;
  }

  // Get controller ID from whoever opened
  // the configuration menu (0, 1, 2, 3)
  iVar11 = (int)DAT_8008d87c;

  pcVar6 = *(char **)(PTR_DAT_8008d2b0 + iVar11 * 0x50 + 0x20);

  if (pcVar6 == (char *)0x0) {

	// leave configuration
	DAT_8008d864 = 0;
    return;
  }

  if (*pcVar6 != '\0') {

	// Leave configuration
	DAT_8008d864 = 0;
    return;
  }

  // If this is NPC-105 controller
  bVar1 = pcVar6[1] == -0x1d;

  // make a copy
  uVar8 = (uint)bVar1;

  // If you're in the 2nd stage of configuration
  // If you're selecting Dead Zone
  if (DAT_8008d898 == 1)
  {
	// Get controller input from
    uVar3 = (&DAT_8009a990)[iVar11];

	// If you dont press Up or Left
    if ((uVar3 & 5) == 0)
	{
	  // If you dont press Down or Right
      if ((uVar3 & 10) == 0)
	  {
		// If you press Cross or Circle
        if ((uVar3 & 0x50) != 0)
		{
		  // Move to 3rd stage of configuration
          DAT_8008d898 = 2;

		  // Save the Dead Zone selected
          *(undefined2 *)((int)&DAT_800841fc + iVar11 * 6 + 2) =
               (&DAT_8008425c)[(int)(short)DAT_8008d868 * 3];
        }
      }

	  // If you press Down or Right
      else
	  {
		// Cycle through options
        DAT_8008d868 = DAT_8008d868 + 1;

		// If you go too far right
        if (3 < (short)DAT_8008d868)
		{
		  // cycle back to the beginning
          DAT_8008d868 = 0;
        }
      }
    }

	// If you press Up or Left
    else
	{
	  // cycle through options
      DAT_8008d868 = DAT_8008d868 - 1;

	  // if you go too far left
      if ((int)((uint)DAT_8008d868 << 0x10) < 0)
	  {
		// cycle back to the end
        DAT_8008d868 = 3;
      }
    }

	// DAT_8008d878 + 0x88c
	// SELECT DEAD ZONE AND PRESS *

	// DecalFont_DrawMultiLine
    FUN_80022b34(*(undefined4 *)(DAT_8008d878 + 0x88c),0x100,
                 (int)*(short *)(&DAT_8008d2e0 + uVar8 * 4),0x1cc,1,0xffff8000);

	FUN_80022878(

			// string
			*(undefined4 *)					// should be 0x80084258 \/
			((int)*(short *)((int)(short)DAT_8008d868 * 6 + -0x7ff7bda8) * 4 + DAT_8008d878),

			// PosX
			0x100,

			// PosY
			(int)*(short *)(&DAT_8008d2e8 + uVar8 * 4),

			1,0xffff8000);

	// Draw left and right arrows around text
	FUN_80037bc0(

		// PosX
		0x100,

		// PosY
		(int)*(short *)(&DAT_8008d2e8 + uVar8 * 4),

		// String
                 *(undefined4 *)					// should be 0x80084258 \/
                  ((int)*(short *)((int)(short)DAT_8008d868 * 6 + -0x7ff7bda8) * 4 + DAT_8008d878));

													// should be 0x8008425A \/
	DAT_8008d2f0 = SEXT24(*(short *)((int)(short)DAT_8008d868 * 6 + -0x7ff7bda6));
  }

  // If you are not in 2nd stage (value of 1)
  else
  {
	// If you are not in the 3rd stage (value of 2)
    if (DAT_8008d898 < 2)
	{
	  // If you're in the first stage of configuration
      if (DAT_8008d898 == 0)
	  {
		// DAT_8008d878 + 0x888
		// CENTER THE CONTROLLER AND PRESS *

		// DecalFont_DrawMultiLine
        FUN_80022b34(*(undefined4 *)(DAT_8008d878 + 0x888),0x100,
                     (int)*(short *)(&DAT_8008d2e0 + uVar8 * 4),0x1cc,1,0xffff8000);

		// Get controller ID from whoever opened
		// the configuration menu (0, 1, 2, 3)
        iVar11 = (int)DAT_8008d87c;

		// If you press Cross or Circle
        if (((&DAT_8009a990)[iVar11] & 0x50) != 0)
		{
		  // Move to 2nd stage of configuration
          DAT_8008d898 = DAT_8008d898 + 1;

		  // If this is NPC-105 controller
          if (bVar1) {
            PTR_DAT_8008d2b0[iVar11 * 0x50 + 0x44] = 4;
            *(undefined2 *)((int)&DAT_800841fc + (int)DAT_8008d87c * 6) = 0x80;
          }

		  // If this is not NPC-105 controller
          else {
            *(ushort *)((int)&DAT_800841fc + iVar11 * 6) =
                 (ushort)*(byte *)(*(int *)(PTR_DAT_8008d2b0 + iVar11 * 0x50 + 0x20) + 4);
          }

		  // clear controller input (for menus)
          FUN_80046404();
        }
        DAT_8008d2f0 = 0;
      }
    }

	// If you're on 2nd page of configuration (or farther)
	else
	{
	  // If you're on 3rd stage of configuration
	  // Select Range configuration
      if (DAT_8008d898 == 2)
	  {
		// get controller input
        uVar3 = (&DAT_8009a990)[iVar11];

		// If you dont press Up or Left
        if ((uVar3 & 5) == 0)
		{
		  // If you dont press Down or Right
          if ((uVar3 & 10) == 0)
		  {
			// If you press Cross or Circle
            if ((uVar3 & 0x50) != 0)
			{
			  // Leave Racing Configuration Menu
			  // Go back to Options Menu
              DAT_8008d864 = 0;

			  // Save "Range" value
              (&DAT_80084200)[iVar11 * 3] = (&DAT_80084274)[(int)(short)DAT_8008d894 * 3];

			  // clear controller input (for menus)
			  FUN_80046404();
            }
          }

		  // If you dont press Down or Right
          else
		  {
			// cycle through options
            DAT_8008d894 = DAT_8008d894 + 1;

			// If you go too far right
            if (*(short *)(&DAT_80084290 + uVar8 * 2) < (short)DAT_8008d894)
			{
			  // cycle back to the beginning
              DAT_8008d894 = 0;
            }
          }
        }

		// If you dont press Up or Left
        else
		{
		  // cycle through options
          DAT_8008d894 = DAT_8008d894 - 1;

		  // if you go too far left
          if ((int)((uint)DAT_8008d894 << 0x10) < 0)
		  {
			// cycle back to the end
            DAT_8008d894 = *(ushort *)(&DAT_80084290 + uVar8 * 2);
          }
        }

        DAT_8008d2f0 = SEXT24((short)(&DAT_80084272)[(int)(short)DAT_8008d894 * 3]);

		// DAT_8008d878 + 0x8a0
		// SELECT RANGE AND PRESS *

		// DecalFont_DrawMultiLine
        FUN_80022b34(*(undefined4 *)(DAT_8008d878 + 0x8a0),0x100,
                     (int)*(short *)(&DAT_8008d2e0 + uVar8 * 4),0x1cc,1,0xffff8000);

		// DecalFont_DrawLine
		FUN_80022878(

					// String
					*(undefined4 *)
                      ((int)*(short *)(&DAT_80084270 + (int)(short)DAT_8008d894 * 6) * 4 +
                      DAT_8008d878),

				// PosX
				0x100,

				// PosY
				(int)*(short *)(&DAT_8008d2e8 + uVar8 * 4),

				1,0xffff8000);

		// Draw left and right arrows around text
		FUN_80037bc0(

			// PosX
			0x100,

			// PosY
			(int)*(short *)(&DAT_8008d2e8 + uVar8 * 4),

			// String
                     *(undefined4 *)
                      ((int)*(short *)(&DAT_80084270 + (int)(short)DAT_8008d894 * 6) * 4 +
                      DAT_8008d878));
      }
    }
  }
  uVar8 = DAT_8008d2f0;
  iVar11 = 0;

  // If this is not NPC-105 controller
  if (!bVar1)
  {
	// loop counter
    iVar11 = 0;

    uVar3 = DAT_8008d2f0 & 0x3ff;

	// for iVar11 = 0; iVar11 < 3; iVar11++
	do {

	  // approximate trigonometry
      iVar7 = *(int *)(&DAT_800845a0 + uVar3 * 4);
      if ((uVar8 & 0x400) == 0) {
        iVar7 = iVar7 << 0x10;
      }
      iVar7 = iVar7 >> 0x10;
      if ((uVar8 & 0x800) != 0) {
        iVar7 = -iVar7;
      }

	  // pointer to OT mem
      iVar13 = *(int *)(PTR_DAT_8008d2ac + 0x147c);

      iVar7 = (DAT_8008d2d8 + (iVar7 * ((int)(short)iVar11 + -1) * 0x20 >> 0xc) + 0x20) * 0x10000 >>
              0x10;
      if (((int)(short)iVar11 != 1) && (uVar8 == 0x600)) {
        iVar13 = iVar13 + 0xc;
      }

	  // CTR_Box_DrawWirePrims
      FUN_80021500(
					0xe2,iVar7,
					0x11e,iVar7,
					0,0xff,0,iVar13,

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

	  // increment loop counter
	  iVar11 = iVar11 + 1;

    } while (iVar11 * 0x10000 >> 0x10 < 3);

    iVar7 = 0;
    iVar11 = 0;
    do {

	  // approximate trigonometry
	  uVar3 = (int)DAT_8008d970 * 0x40 + (iVar11 >> 5);
      iVar11 = *(int *)(&DAT_800845a0 + (uVar3 & 0x3c0) * 4);

	  if ((uVar3 & 0x400) == 0) {
        iVar11 = iVar11 << 0x10;
      }
      iVar11 = iVar11 >> 0x10;
      if ((uVar3 & 0x800) != 0) {
        iVar11 = -iVar11;
      }
      uVar3 = (int)(uVar8 * iVar11) >> 0xc;

	  // approximate trigonometry
      iVar11 = *(int *)(&DAT_800845a0 + (uVar3 & 0x3ff) * 4);

	  if ((uVar3 & 0x400) == 0) {
        iVar11 = iVar11 << 0x10;
      }
      iVar11 = iVar11 >> 0x10;
      if ((uVar3 & 0x800) != 0) {
        iVar11 = -iVar11;
      }
      iVar13 = 0;
      iVar12 = (int)(short)iVar7 * 0xc;
      do {
        iVar4 = (iVar13 << 0x10) >> 0xe;
        if ((int)(short)iVar7 == 0) {
          sVar2 = 0x114;
        }
        else {
          sVar2 = 0xec;
        }
        *(short *)((int)local_48 + iVar4) = *(short *)((int)&DAT_80084294 + iVar4 + iVar12) + sVar2;
        iVar4 = iVar13 << 0x10;
        iVar13 = iVar13 + 1;
        iVar4 = iVar4 >> 0xe;
        *(short *)((int)local_48 + iVar4 + 2) =
             (short)DAT_8008d2d8 + (short)((iVar11 << 5) >> 0xc) + 0x20 +
             *(short *)((int)&DAT_80084296 + iVar4 + iVar12);
      } while (iVar13 * 0x10000 >> 0x10 < 3);

	  // Draw arrows on either side of green bar
      FUN_800453e8(local_48,&DAT_800842ac,

					// pointer to OT mem
					*(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

      iVar7 = iVar7 + 1;
      iVar11 = iVar7 * 0x10000;

    } while (iVar7 * 0x10000 >> 0x10 < 2);

    local_38 = 0xec;
    local_34 = 0x28;
    local_32 = 0x41;
    local_36 = (short)DAT_8008d2d8;

	// BackgroundBlueRect
    FUN_80045254(&local_38,&DAT_800842b8,

					// pointer to OT mem
					*(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

    puVar9 = &local_30;
    local_30 = 0xffec;
    local_2c = 0x228;
    local_2a = 0x91;
    local_2e = (short)DAT_8008d2d8 + -0x14;

	// "return", basically
    goto LAB_80038b24;
  }

  // If this is NPC-105

  // we would have "return'd"
  // if we didn't have an NPC-105
  // at this point

  uVar3 = -DAT_8008d2f0;
  iVar7 = 0;
  do {
    uVar5 = uVar8;
    if (iVar7 == 0) {
      uVar5 = uVar3;
    }
    uVar5 = uVar5 - 0x400;

	// approximate trigonometry
    sVar2 = (short)*(int *)(&DAT_800845a0 + (uVar5 & 0x3ff) * 4);
    iVar7 = *(int *)(&DAT_800845a0 + (uVar5 & 0x3ff) * 4) >> 0x10;

	if ((uVar5 & 0x400) == 0) {
      iVar13 = (int)sVar2;
      if ((uVar5 & 0x800) != 0) {
        iVar12 = -iVar7;
        goto LAB_80038620;
      }
    }
    else {
      iVar12 = (int)sVar2;
      iVar13 = iVar7;
      if ((uVar5 & 0x800) == 0) {
        iVar7 = -iVar12;
      }
      else {
LAB_80038620:
        iVar13 = -iVar13;
        iVar7 = iVar12;
      }
    }

	// CTR_Box_DrawWirePrims
    FUN_80021500(((iVar7 * 400) / 0x5000 + 0x100) * 0x10000 >> 0x10,
                 (int)(((uint)DAT_8008d2dc + (iVar13 * 0x32 >> 0xc)) * 0x10000) >> 0x10,
                 ((iVar7 * 0x118) / 0x5000 + 0x100) * 0x10000 >> 0x10,
                 (int)(((uint)DAT_8008d2dc + (iVar13 * 0x23 >> 0xc)) * 0x10000) >> 0x10,0,0xff,0,

				 // pointer to OT mem
                 *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				// pointer to PrimMem struct
				 *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74
                );
    iVar11 = iVar11 + 1;
    iVar7 = iVar11 * 0x10000;
  } while (iVar11 * 0x10000 >> 0x10 < 2);

  uVar3 = (int)DAT_8008d970 << 6;

  // approximate trigonometry
  iVar11 = *(int *)(&DAT_800845a0 + (uVar3 & 0x3c0) * 4);

  if ((uVar3 & 0x400) == 0) {
    iVar11 = iVar11 << 0x10;
  }
  iVar11 = iVar11 >> 0x10;
  if ((uVar3 & 0x800) != 0) {
    iVar11 = -iVar11;
  }
  uVar8 = ((int)(iVar11 * uVar8) >> 0xc) - 0x400;
  uVar3 = uVar8 & 0xfff;

  // approximate trigonometry
  iVar11 = *(int *)(&DAT_800845a0 + (uVar8 & 0x3ff) * 4) >> 0x10;
  sVar2 = (short)*(int *)(&DAT_800845a0 + (uVar8 & 0x3ff) * 4);

  if ((uVar8 & 0x400) == 0) {
    iVar13 = (int)sVar2;
    iVar7 = iVar11;
    if ((uVar8 & 0x800) != 0) {
      iVar7 = -iVar11;
      goto LAB_800387c4;
    }
  }
  else {
    iVar7 = (int)sVar2;
    iVar13 = iVar11;
    if ((uVar8 & 0x800) == 0) {
      iVar7 = -iVar7;
    }
    else {
LAB_800387c4:
      iVar13 = -iVar13;
    }
  }
  do {
    iVar11 = 0;
    do {
      iVar12 = iVar11;
      iVar11 = (iVar12 << 0x10) >> 0xe;

	  // Draw NPC-105
      FUN_800379f4((int)(((uint)*(ushort *)((int)&DAT_800842dc + iVar11) +
                         (iVar7 * 200) / 0x5000 + 0x100) * 0x10000) >> 0x10,
                   (int)(((uint)*(ushort *)((int)&DAT_800842de + iVar11) + (uint)DAT_8008d2dc +
                         (iVar13 * 0x19 >> 0xc)) * 0x10000) >> 0x10,10,0x80,uVar3,
                   &DAT_800842d0 + iVar11,

				   // pointer to OT mem
				   *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				   // pointer to PrimMem struct
				   *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

      iVar11 = iVar12 + 1;
    } while ((iVar12 + 1) * 0x10000 >> 0x10 < 3);
    iVar11 = 0;
  } while ((iVar12 + 2) * 0x10000 >> 0x10 < 3);
  do {
    iVar7 = 0;
    do {
      uVar10 = 0x32;
      if ((short)iVar11 != 0) {
        uVar10 = 0x50;
      }
      uVar8 = uVar3 + iVar7 + iVar11;

	  // approximate trigonometry
      sVar2 = (short)*(int *)(&DAT_800845a0 + (uVar8 & 0x3ff) * 4);
      iVar13 = *(int *)(&DAT_800845a0 + (uVar8 & 0x3ff) * 4) >> 0x10;

	  if ((uVar8 & 0x400) == 0) {
        iVar12 = (int)sVar2;
        if ((uVar8 & 0x800) != 0) {
          iVar4 = -iVar13;
          goto LAB_8003892c;
        }
      }
      else {
        iVar4 = (int)sVar2;
        iVar12 = iVar13;
        if ((uVar8 & 0x800) == 0) {
          iVar13 = -iVar4;
        }
        else {
LAB_8003892c:
          iVar12 = -iVar12;
          iVar13 = iVar4;
        }
      }
      iVar4 = iVar13;
      if (iVar13 < 0) {
        iVar4 = iVar13 + 0x3f;
      }

	  // CTR_Box_DrawWirePrims
      FUN_80021500(((iVar4 >> 6) + 0x100) * 0x10000 >> 0x10,
                   (int)(((uint)DAT_8008d2dc + (iVar12 * 0x28 >> 0xc)) * 0x10000) >> 0x10,
                   ((iVar13 * 0x120) / 0x5000 + 0x100) * 0x10000 >> 0x10,
                   (int)(((uint)DAT_8008d2dc + (iVar12 * 0x24 >> 0xc)) * 0x10000) >> 0x10,uVar10,
                   uVar10,uVar10,

				   // pointer to OT mem
				   *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				   // pointer to PrimMem struct
				   *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

      iVar7 = iVar7 + 0x400;
      iVar13 = iVar11 + 0xaa;
    } while (iVar7 * 0x10000 >> 0x10 < 0x1000);
    iVar11 = iVar13;
  } while (iVar13 * 0x10000 >> 0x10 < 0x400);
  uVar14 = 0;
  do {
    iVar7 = 0;
    iVar11 = (int)((uint)uVar14 << 0x10) >> 0xe;
    iVar13 = 0;
    do {
      iVar13 = iVar13 >> 0xe;
      uVar8 = (uint)*(ushort *)((int)&DAT_800842ea + iVar11);

	  // Draw NPC-105
      FUN_800379f4((int)((*(ushort *)((int)&DAT_80084300 + iVar13) * uVar8 + 0x100) * 0x10000) >>
                   0x10,(int)(((uint)DAT_8008d2dc + *(ushort *)((int)&DAT_80084302 + iVar13) * uVar8
                              ) * 0x10000) >> 0x10,(int)*(short *)((int)&DAT_800842e8 + iVar11),0x80
                   ,uVar3,&DAT_800842f4 + iVar13,

				   // pointer to OT mem
				   *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				   // pointer to PrimMem struct
				   *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

      iVar7 = iVar7 + 1;
      iVar13 = iVar7 * 0x10000;
    } while (iVar7 * 0x10000 >> 0x10 < 3);

    uVar14 = uVar14 + 1;
  } while (uVar14 < 3);
  puVar9 = &local_38;
  local_38 = 0xffec;
  local_34 = 0x228;
  local_32 = 0xa0;
  local_36 = DAT_8008d2dc - 0x3c;
LAB_80038b24:

  // Draw 2D Menu rectangle background
  FUN_800457b0(puVar9,4,

		// pointer to OT mem
		*(undefined4 *)(PTR_DAT_8008d2ac + 0x147c));
  return;
}


// MenuBoxFuncPtr_Options
void FUN_80038b5c(int param_1)

{
  bool bVar1;
  short sVar2;
  short sVar3;
  undefined *puVar4;
  ushort uVar5;
  int iVar6;
  short sVar7;
  char *pcVar8;
  int iVar9;
  ushort uVar10;
  undefined4 *puVar11;
  int iVar12;
  int iVar13;
  uint uVar14;
  int iVar15;
  undefined4 local_b8;
  ushort local_b0 [4];
  ushort local_a8 [4];
  undefined2 local_a0 [4];
  short local_98;
  short local_96;
  undefined2 local_94;
  undefined2 local_92;
  short local_90;
  short local_8e;
  short local_8c;
  short local_8a;
  short local_88;
  short local_86;
  undefined2 local_80;
  short local_7e;
  undefined2 local_7c;
  short local_7a;
  int local_78;
  short local_70;
  ushort local_68;
  ushort local_60;

  // number of racing wheels
  ushort local_58;

  // number of analog controllers
  ushort local_50;

  ushort local_48;
  short local_38;
  int local_30;

  local_70 = 0;

  // zero racing wheels by default
  local_58 = 0;

  // controller buffer
  local_48 = (ushort)(PTR_DAT_8008d2b0[0x2d1] == -0x80) << 1;

  local_78 = param_1;

  // AdvPause_SafeDestroy
  FUN_800399fc();

  iVar12 = 0;

  // zero analog controllers by default
  local_50 = 0;

  // If you are in the racing wheel configuration
  if (DAT_8008d864 != 0)
  {
	// Racing Wheel Configuration
    FUN_80037da0();
    return;
  }

  // If you are not in racing wheel configuration,
  // since you did not hit "return", you will
  // continue with the rest of the Options menu

  // loop counter
  iVar13 = 0;

  // if number of screens is not zero
  if (PTR_DAT_8008d2ac[0x1ca8] != '\0') {
    iVar6 = 0;

	// for iVar13 = 0; iVar13 < numScreens; iVar13++
    do
	{
      pcVar8 = *(char **)(PTR_DAT_8008d2b0 + (iVar6 >> 0x10) * 0x50 + 0x20);

	  // If this controller is not a racing wheel
      if (
			((pcVar8 == (char *)0x0) || (*pcVar8 != '\0')) ||

			(

				(
					// If this is not NPC-105 controller
					pcVar8[1] != -0x1d &&

					// If this is not madcatz racing wheel
					(pcVar8[1] != '#')
				)
			)
		 )
	  {
        uVar14 = (uint)local_58;

		// increment number of analog controllers
        local_58 = local_58 + 1;

        *(undefined2 *)((int)local_a8 + ((int)(uVar14 << 0x10) >> 0xf)) = (short)iVar13;
        *(undefined2 *)((int)local_a0 + ((iVar13 << 0x10) >> 0xf)) = 0;
      }

	  // if this is a racing wheel
      else {
        uVar14 = (uint)local_50;

		// increment number of racing wheels
        local_50 = local_50 + 1;

        *(undefined2 *)((int)local_b0 + ((int)(uVar14 << 0x10) >> 0xf)) = (short)iVar13;
        local_a0[iVar6 >> 0x10] = 1;
      }

	  // increment loop counter
      iVar13 = iVar13 + 1;

      iVar6 = iVar13 * 0x10000;
										// number of screens
    } while (iVar13 * 0x10000 >> 0x10 < (int)(uint)(byte)PTR_DAT_8008d2ac[0x1ca8]);
  }

  // 0 for no racing wheels
  // 1 for racing wheels
  uVar5 = 0;

  // if there are any analog controllers
  if (local_58 != 0)
  {
	// check to see if there are any racing wheels
    uVar5 = (ushort)(local_50 != 0);
  }

						// number of screens
  sVar7 = (4 - uVar5) - (ushort)(byte)PTR_DAT_8008d2ac[0x1ca8];
  uVar5 = sVar7 * 10;

  // if there are no analog controllers
  if (local_58 == 0) {
    local_60 = 0;
  }

  // if there are analog controllers
  else {
    local_60 = (local_58 + 1) * 10;
  }

  iVar6 = (int)((uint)uVar5 << 0x10) >> 0x11;
  DAT_80084364 = sVar7 * -10 + 0x77;

  // loop counter
  iVar13 = 0;

  // if there are analog controllers
  if (0 < (int)(short)local_58)
  {
	// loop counter
    iVar9 = 0;

	// for iVar13 = 0; iVar13 < numAnalog; iVar13++
    do
	{
      *(short *)(&DAT_80084344 + ((iVar9 >> 0x10) + 4) * 4) =
           (short)((uint)iVar9 >> 0x10) * 10 + 0x4f;

	  // increment loop counter
	  iVar13 = iVar13 + 1;

      iVar9 = iVar13 * 0x10000;
    } while (iVar13 * 0x10000 >> 0x10 < (int)(short)local_58);
  }

  // bit shift number of racing wheels
  iVar9 = (uint)local_50 << 0x10;

  // loop counter
  iVar13 = 0;

  // if there are racing wheels
  if (0 < iVar9) {

	// for iVar13 = 0; iVar13 < numWheels; iVar13++
    do
	{
      uVar10 = 0;
      sVar7 = (short)iVar13;

	  // if there are analog controllers
      if ((int)(short)local_58 != 0) {
        uVar10 = (ushort)(iVar9 != 0);
      }

	  // increment loop counter
      iVar13 = iVar13 + 1;

      *(ushort *)(&DAT_80084344 + ((int)(short)local_58 + (int)sVar7 + 4) * 4) =
           (sVar7 + local_58 + uVar10) * 10 + 0x4f;
      iVar9 = (uint)local_50 << 0x10;

    } while (iVar13 * 0x10000 < iVar9);
  }
  puVar4 = PTR_DAT_8008d2ac;
  uVar10 = *(ushort *)(local_78 + 0x14) & 0xfeff;
  *(ushort *)(local_78 + 0x14) = uVar10;

  // if more than 2 screens
  if (2 < (byte)puVar4[0x1ca8]) {
    *(ushort *)(local_78 + 0x14) = uVar10 | 0x100;
  }

  local_68 = uVar5;

  // If you do not press Up
  if ((DAT_8008d950 & 1) == 0) {

	// If you do not press Down
    if ((DAT_8008d950 & 2) == 0) {

	  // if you prses Left or Right

      switch(*(undefined2 *)(local_78 + 0x1a))
	  {

	  // Do the same for all 3 sliders in Options menu

	  // FX slider
      case 0:

	  // Music slider
      case 1:

	  // Voice
      case 2:

		// Get row highlighted
        iVar13 = (int)*(short *)(local_78 + 0x1a);

		// enable OptionsMenu_TestSound
        FUN_8002b208(iVar13,1);

		// If you dont press Left
        if ((DAT_8008d974 & 4) == 0) {

		  // If you press Right
          if ((DAT_8008d974 & 8) != 0)
		  {
			// Get value of slider
            uVar14 = howl_VolumeGet(iVar13);

			// Add to the slider
            uVar14 = (uVar14 & 0xff) + 4;

			// Set maximum value at 0xff
            if (0xff < uVar14) {
              uVar14 = 0xff;
            }

			// Set the new value to the slider
            howl_VolumeSet(iVar13,uVar14 & 0xff);
          }
        }

		// If you press Left
        else
		{
		  // Get value of slider
          uVar14 = howl_VolumeGet(iVar13);

		  // Subtract from the slider
          uVar14 = (uVar14 & 0xff) - 4;

		  // Set minimum at 0
          if ((int)uVar14 < 0) {
            uVar14 = 0;
          }

		  // Set the new value to the slider
          howl_VolumeSet(iVar13,uVar14 & 0xff);
        }
        break;

	  // Mode toggle
      case 3:

		// disable OptionsMenu_TestSound
        FUN_8002b208(0,0);

		// If you press Cross or Circle
        if ((DAT_8008d950 & 0x50) != 0)
		{
		  // OtherFX_Play
          FUN_80028468(1,1);

		  // get mode, flip value, and set

		  // howl_ModeGet
          uVar14 = FUN_8002b1f0();

		  // howl_ModeSet
          FUN_8002b1fc((uint)((uVar14 & 0xff) == 0));
        }
        break;

      case 4:
      case 5:
      case 6:
      case 7:

	    // disable OptionsMenu_TestSound
        FUN_8002b208(0,0);

		// If you press Cross or Circle
        if ((DAT_8008d950 & 0x50) != 0)
		{
          uVar10 = *(ushort *)(local_78 + 0x1a);

		  // OtherFX_Play
          FUN_80028468(1,1);

		  // row selected - 4, controller ID
          iVar13 = (int)(((uint)uVar10 - 4) * 0x10000) >> 0x10;

		  // If the row you've selected is for configuring
		  // an analog controller
		  // (row - 4) < numAnalog
          if (iVar13 < (short)local_58) {
            *(uint *)PTR_DAT_8008d2ac =
                 *(uint *)PTR_DAT_8008d2ac ^
                 *(uint *)(&DAT_8008430c + (int)(short)local_a8[iVar13] * 4);
          }

		  // if the row selected is for a racing wheel controller
          else
		  {
			// set the racing wheel ID to configure
            DAT_8008d87c = local_b0[iVar13 - (short)local_58];

			// open racing wheel configuration
            DAT_8008d864 = 1;

			// set config page index to the first page
            DAT_8008d898 = 0;
          }
        }
        break;
      case 8:

		// disable OptionsMenu_TestSound
        FUN_8002b208(0,0);

		// If you press Cross or Circle
        if ((DAT_8008d950 & 0x50) != 0)
		{
		  // OtherFX_Play
          FUN_80028468(1,1);

          local_70 = 1;
        }
      }
      goto switchD_80038f90_caseD_9;
    }

	// if you press Down

	// OtherFX_Play
    FUN_80028468(0,1);

	// change which row is selected
    sVar7 = *(short *)(local_78 + 0x1a) + 1;
    *(short *)(local_78 + 0x1a) = sVar7;

	// if you scroll past Exit
    if (8 < (int)sVar7)
	{
	  // go back to the top
      *(undefined2 *)(local_78 + 0x1a) = 0;
      goto switchD_80038f90_caseD_9;
    }

						// number of players + 4
    if ((int)sVar7 < (int)((uint)(byte)PTR_DAT_8008d2ac[0x1ca8] + 4)) goto switchD_80038f90_caseD_9;
  }

  // if you press Up
  else
  {
	// OtherFX_Play
    FUN_80028468(0,1);

	// change which row is selected
    sVar7 = *(short *)(local_78 + 0x1a) + -1;
    *(short *)(local_78 + 0x1a) = sVar7;

	// if row is valid
    if (-1 < sVar7)
	{
	  // if you are on exit row
      if (sVar7 == 7) {

		// go to the last row above "Exit" depending on number of players
        *(short *)(local_78 + 0x1a) = (ushort)(byte)PTR_DAT_8008d2ac[0x1ca8] + 3;
      }
      goto switchD_80038f90_caseD_9;
    }
  }
  *(undefined2 *)(local_78 + 0x1a) = 8;
switchD_80038f90_caseD_9:
  uVar14 = 0;
  iVar13 = 0;
  do
  {
	// DecalFont_GetLineWidth
    iVar13 = FUN_800224d0(*(undefined4 *)
                           ((int)*(short *)((int)&DAT_80084328 + (iVar13 >> 0xf)) * 4 + DAT_8008d878
                           ),2);

    if (iVar12 << 0x10 < iVar13 << 0x10) {
      iVar12 = iVar13;
    }
    uVar14 = uVar14 + 1;
    iVar13 = uVar14 * 0x10000;
  } while ((uVar14 & 0xffff) < 3);

  // loop counter
  iVar9 = 0;

  local_b8 = 0xffff8000;

  // DAT_8008d878 + 0x510
  // OPTIONS
  FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x510),0x100,(iVar6 + 0x1a) * 0x10000 >> 0x10,1,
               0xffff8000);

  iVar13 = 0x17c - (iVar12 + 0x1e);
  local_38 = (short)iVar13;
  local_30 = (iVar13 * 0x10000 >> 0x10) + -5;

  // used to get strings
  iVar13 = 0;

  // for iVar9 = 0; iVar9 < 3; iVar9++
  do {
    iVar13 = iVar13 >> 0x10;
    uVar14 = howl_VolumeGet(iVar13);
    iVar15 = (uVar14 & 0xff) * local_30;
    iVar15._1_2_ = (short)((uint)iVar15 >> 8);
    sVar3 = (short)uVar5 >> 1;
    sVar7 = sVar3 + (short)(iVar13 * 10);
    if (iVar15 < 0) {
      iVar15._1_2_ = (short)((uint)(iVar15 + 0xff) >> 8);
    }
    sVar2 = (short)(iVar12 + 0x1e);
    iVar15._1_2_ = sVar2 + iVar15._1_2_ + 0x38;
    local_98 = iVar15._1_2_ + 1;
    local_94 = 3;
    local_92 = 10;
    local_96 = sVar7 + 0x30;

	// CTR_Box_DrawSolidBox
    FUN_80021894(&local_98,&DAT_8008433c,
				*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0),

				// pointer to PrimMem struct
				 *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,
				 local_b8);

    local_96 = sVar7 + 0x2f;
    local_94 = 5;
    local_92 = 0xc;
    local_98 = iVar15._1_2_;

	// CTR_Box_DrawSolidBox
    FUN_80021894(&local_98,&DAT_80084340,

					*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0),

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

    local_90 = sVar2 + 0x38;
    local_8e = sVar7 + 0x3a;
    local_8c = sVar2 + local_38 + 0x38;
    local_8a = sVar7 + 0x30;
    local_88 = local_8c;
    local_86 = local_8e;

	// Draw sliders in Options
    FUN_800453e8(&local_90,&DAT_80084330,

					*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0),

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);
    local_b8 = 0;

	// iVar13 = 0: FX:
	// iVar13 = 1: MUSIC:
	// iVar13 = 2: VOICE:
    FUN_80022878(*(undefined4 *)((int)(short)(&DAT_80084328)[iVar13] * 4 + DAT_8008d878),0x4c,
                 (iVar13 * 10 + iVar6 + 0x32) * 0x10000 >> 0x10,2);

	// increment loop counter
    iVar9 = iVar9 + 1;

	// increment pointer
    iVar13 = iVar9 * 0x10000;

  } while (iVar9 * 0x10000 >> 0x10 < 3);

  // DAT_8008d878 + 0x530
  // MODE:
  FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x530),0x4c,(iVar6 + 0x50) * 0x10000 >> 0x10,2,0);

  // howl_ModeGet
  uVar14 = FUN_8002b1f0();

  // if mode is zero
  if ((uVar14 & 0xff) == 0)
  {
    // DAT_8008d878 + 0x534
	// MONO
	puVar11 = (undefined4 *)(DAT_8008d878 + 0x534);
  }

  // if mode is not zero
  else
  {
	// DAT_8008d878 + 0x538
	// STEREO
	puVar11 = (undefined4 *)(DAT_8008d878 + 0x538);
  }

  // Draw "MONO" or "STEREO"
  FUN_80022878(*puVar11,0x1b4,(iVar6 + 0x50) * 0x10000 >> 0x10,2,0x4004);

  uVar5 = local_58;
  if (local_58 != 0)
  {
	// DAT_8008d878 + 0x528
	// DUAL SHOCK:
    FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x528),0x4c,(iVar6 + 0x5a) * 0x10000 >> 0x10,2,0);

	// Controller 1A
	// DecalFont_GetLineWidth
	iVar13 = FUN_800224d0(*(undefined4 *)((int)DAT_80084320 * 4 + DAT_8008d878),2);

	// DAT_8008d878 + 0x518
	// VIBRATE OFF
	// DecalFont_GetLineWidth
	iVar9 = FUN_800224d0(*(undefined4 *)(DAT_8008d878 + 0x518),2);

	// DAT_8008d878 + 0x514
	// VIBRATE ON
	// DecalFont_GetLineWidth
	iVar12 = FUN_800224d0(*(undefined4 *)(DAT_8008d878 + 0x514),2);

	iVar15 = 0;
    if (iVar12 << 0x10 < iVar9 << 0x10) {
      iVar12 = iVar9;
    }
    iVar12 = (iVar13 + iVar12 + 10) * 0x10000;
    iVar12 = 0x100 - ((iVar12 >> 0x10) - (iVar12 >> 0x1f) >> 1);
    if (0 < (short)uVar5) {
      iVar9 = 0;
      do {
        bVar1 = false;
        uVar5 = *(ushort *)((int)local_a8 + (iVar9 >> 0xf));
        uVar14 = (uint)uVar5;

        if (
				(*(char **)(PTR_DAT_8008d2b0 + (int)(short)uVar5 * 0x50 + 0x20) == (char *)0x0) ||
				(**(char **)(PTR_DAT_8008d2b0 + (int)(short)uVar5 * 0x50 + 0x20) != '\0')
		   ) {
          bVar1 = true;
        }
        if (bVar1) {
          local_b8 = 0x17;
        }
        else {
          local_b8 = 0;
        }

		// might be printing string for
		// "Controller 1", "Controller 2", 1A 1B 1C 1D, etc
        FUN_80022878(*(undefined4 *)
                      ((int)*(short *)(&DAT_8008431c + ((int)((uVar14 + local_48) * 0x10000) >> 0xf)
                                      ) * 4 + DAT_8008d878),iVar12 * 0x10000 >> 0x10,
                     ((int)(short)iVar15 * 10 + iVar6 + 100) * 0x10000 >> 0x10,2,local_b8);

		// if vibration is enabled,
		// gGT->gameMode1 & 0x0000X000
		if ((*(uint *)PTR_DAT_8008d2ac & *(uint *)(&DAT_8008430c + ((int)(uVar14 << 0x10) >> 0xe)))

			// == 0 means enabled,
			// == 1 means disabled (seriously, not a mistake)
            == 0)
		{
		  // DAT_8008d878 + 0x514
		  // VIBRATE ON
          puVar11 = (undefined4 *)(DAT_8008d878 + 0x514);
        }

		else
		{
		  // DAT_8008d878 + 0x518
		  // VIBRATE OFF
          puVar11 = (undefined4 *)(DAT_8008d878 + 0x518);
        }

		local_b8 = 0x17;

        if (
				(!bVar1) &&
				(
					// color red
					local_b8 = 3,

					// if vibration is enabled
					// == 0 means enabled,
					// == 1 means disabled (seriously, not a mistake)
					(*(uint *)PTR_DAT_8008d2ac & *(uint *)(&DAT_8008430c +
					((int)(uVar14 << 0x10) >> 0xe))) == 0))
		{
		  // color = white
          local_b8 = 4;
        }

		// Draw string for vibrate on and off
        FUN_80022878(*puVar11,(iVar12 + iVar13 + 10) * 0x10000 >> 0x10,
                     ((int)(short)iVar15 * 10 + iVar6 + 100) * 0x10000 >> 0x10,2,local_b8);

		iVar15 = iVar15 + 1;
        iVar9 = iVar15 * 0x10000;
      } while (iVar15 * 0x10000 < (int)((uint)local_58 << 0x10));
    }
  }
  iVar12 = (int)(short)local_50;
  if (iVar12 != 0) {
    iVar13 = 0;

	// DAT_8008d878 + 0x540
	// CONFIGURE ANALOG:
    FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x540),0x4c,
                 (int)(((uint)local_60 + iVar6 + 0x5a) * 0x10000) >> 0x10,2,0);

    if (0 < iVar12) {
      do {
        FUN_80022878(*(undefined4 *)
                      ((int)*(short *)(&DAT_8008431c +
                                      ((int)(((uint)local_b0[(int)(short)iVar13] + (uint)local_48) *
                                            0x10000) >> 0xf)) * 4 + DAT_8008d878),0x100,
                     (int)((iVar6 + (uint)local_60 + (int)(short)iVar13 * 10 + 100) * 0x10000) >>
                     0x10,2,0xffff8000);
        iVar13 = iVar13 + 1;
      } while (iVar13 * 0x10000 >> 0x10 < iVar12);
    }
  }

  // DAT_8008d878 + 0x52c
  // EXIT
  FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x52c),0x4c,
               (int)(((iVar6 + 0x8c) - (uint)local_68) * 0x10000) >> 0x10,2,0);

  local_80 = 0x4a;
  local_7c = 0x16c;
  local_7e = *(short *)(&DAT_80084344 + (int)*(short *)(local_78 + 0x1a) * 4) + sVar3 + 0x14;
  local_7a = *(short *)(&DAT_80084346 + (int)*(short *)(local_78 + 0x1a) * 4);

  // CTR_Box_DrawClearBox
  FUN_8002177c(&local_80,&DAT_8008d94c,1,

				*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0),

				// pointer to PrimMem struct
				*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

  local_80 = 0x42;
  local_7e = sVar3 + 0x2b;
  local_7c = 0x17c;
  local_7a = 2;

  // DrawRectangle (transparent)
  FUN_80044f90(&local_80,&DAT_8008d438,0x20,
               *(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0));

  local_80 = 0x38;
  local_7c = 400;
  local_7a = 0x87 - local_68;
  local_7e = sVar3 + 0x14;

  // Draw 2D Menu rectangle background
  FUN_800457b0(&local_80,4,*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0));

  if (
		(local_70 != 0) ||

		// If you press Triangle, Square, or Start
		((DAT_8008d950 & 0x41020) != 0)
	 )
  {
	// OtherFX_Play
    FUN_80028468(1,1);

	// disable OptionsMenu_TestSound
    FUN_8002b208(0,0);

	// clear controller input (for menus)
    FUN_80046404();

	// set desired MenuBox to pause MenuBox
    DAT_8008d924 = FUN_80039dcc();
  }
  return;
}


// MenuFuncPtr_Quit
void FUN_80039908(int param_1)

{
  short sVar1;
  undefined *puVar2;
  ushort uVar3;

  puVar2 = PTR_DAT_8008d2ac;
  if (*(short *)(param_1 + 0x1e) == 0) {
    sVar1 = *(short *)(param_1 + 0x1a);
    if (sVar1 == 0)
	{
	  // Erase ghost of previous race from RAM
      FUN_80028410();

	  // when loading is done
	  // add bit for "in menu"
      DAT_8008d100 = DAT_8008d100 | 0x2000;

	  // go to main menu
      DAT_8008d97c = 0;

	  // when loading is done
	  // remove bit for "In Adventure Arena"
      DAT_8008d104 = DAT_8008d104 | 0x100000;

	  // Unpause game
      *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac & 0xfffffffe;

	  // Level ID for main menu (39)
      FUN_8003cfc0(0x27);
    }
    else {
      if (sVar1 < 1) {
        if (sVar1 != -1) {
          return;
        }
      }
      else {
        if (sVar1 != 1) {
          return;
        }
      }

	  // Change active MenuBox to pause MenuBox
      DAT_8008d924 = FUN_80039dcc();
    }
  }
  else
  {
    uVar3 = *(ushort *)(param_1 + 0x14) & 0xfeff;
    *(ushort *)(param_1 + 0x14) = uVar3;

	// if more than 2 screens
	if (2 < (byte)puVar2[0x1ca8])
	{
      *(ushort *)(param_1 + 0x14) = uVar3 | 0x100;
    }

	// AdvPause_SafeDestroy
	FUN_800399fc();
  }
  return;
}


// AdvPause_SafeDestroy
void FUN_800399fc(void)

{
  int iVar1;

  if (
		// If you're in Adventure Arena
		((*(uint *)PTR_DAT_8008d2ac & 0x100000) != 0) &&

		(
			// If 232 dll is loaded
			iVar1 = FUN_80034920(),
			iVar1 != 0
		)
	)
  {
	// AH_Pause_Destroy (and destroy thread)
    FUN_800b1ef8();
  }
  return;
}


// MenuFuncPtr_ElimBG_Universal
void FUN_80039a44(int param_1)

{
  uint uVar1;
  undefined *puVar2;
  int iVar3;
  ushort *puVar4;
  uint uVar5;
  ushort uVar6;
  uint uVar7;

  puVar2 = PTR_DAT_8008d2ac;

  // if you have not waited 5 frames
  // since the game was paused
  if (PTR_DAT_8008d2ac[0x1d38] != '\0') {

	// quit
	return;
  }

  // assume 5 frames have passed since paused

  if (*(short *)(param_1 + 0x1e) != 0) {
    uVar6 = *(ushort *)(param_1 + 0x14) & 0xfeff;
    *(ushort *)(param_1 + 0x14) = uVar6;

	// if more than 2 screens
	if (2 < (byte)puVar2[0x1ca8])
	{
      *(ushort *)(param_1 + 0x14) = uVar6 | 0x100;
    }

	// If you're not in Adventure Arena
    if ((*(uint *)PTR_DAT_8008d2ac & 0x100000) == 0) {
      return;
    }

    if ((*(uint *)(param_1 + 8) & 0x1000) != 0) {
      return;
    }

	// Check if 232 dll is loaded
    iVar3 = FUN_80034920();

	// quit if it is not
    if (iVar3 == 0) {
      return;
    }

	// AH_Pause_PerFrame
    FUN_800b3144();

    return;
  }
  if ((int)*(short *)(param_1 + 0x1a) < 0) {
    return;
  }
  puVar4 = (ushort *)((int)*(short *)(param_1 + 0x1a) * 6 + *(int *)(param_1 + 0xc));
  uVar6 = *puVar4;
  uVar7 = (uint)*puVar4;

  if (uVar6 == 0xe)
  {
	// Set desired MenuBox to racingWheel
    DAT_8008d924 = &DAT_80084190;

    DAT_800841aa = 8;
    return;
  }

  if ((uVar7 - 0xb & 0xffff) < 2) {
    DAT_8008d924 = &DAT_800b518c;
    return;
  }

  if (uVar6 == 3)
  {
	// Set active MenuBox to Quit
    DAT_8008d924 = &DAT_800841d0;
    DAT_800841ea = 1;
    return;
  }

  // must wait 5 frames until next pause
  PTR_DAT_8008d2ac[0x1d39] = 5;

  // make MenuBox invisible
  FUN_800469c8(param_1);

  // AdvPause_SafeDestroy
  FUN_800399fc();

  puVar2 = PTR_DAT_8008d2ac;

  // get any flags that you already want
  // removed after loading finishes
  uVar1 = DAT_8008d104;

  switch((int)((uVar7 - 1) * 0x10000) >> 0x10) {
  case 0:
  case 3:
	// Unpause game
    *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac & 0xfffffffe;
    i
	// CheckeredFlag_IsFullyOffScreen
	Var3 = FUN_80043f28();
    if (iVar3 == 1)
	{
	  // checkered flag, begin transition on-screen
      FUN_80043fb0(1);
    }

	// if you are not showing a ghost during a race
    if (DAT_8008d958 == 0) {
      DAT_8008d0f8 = -5;
      return;
    }

	// If the ghost playing buffer is nullptr
    if (DAT_8008d754 == 0) {
      DAT_8008d0f8 = -5;
      return;
    }

	// At this point, we are certain there is a ghost
	// buffer so you must be in time trial mode

	// Make P2 the character that is saved in the
	// header of the ghost that you will see in the race
    DAT_80086e86 = *(undefined2 *)(DAT_8008d754 + 6);

	DAT_8008d0f8 = -5;
    return;
  case 1:

    // deactivate pause??
    FUN_80024c08(PTR_DAT_8008d2ac);

	// Unpause game
    *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac & 0xfffffffe;

	// unpause audio
    FUN_80034b48(0);

	// OtherFX_Play
    FUN_80028468(1,1);
    return;
  default:
    goto switchD_80039bcc_caseD_2;

  case 4:

	// Erase ghost of previous race from RAM
    FUN_80028410();

	// levelID of main menu
    iVar3 = 0x27;

	// Return to character selection
    DAT_8008d97c = 1;

	// when loading is done
	// add bit for "in menu"
    DAT_8008d100 = DAT_8008d100 | 0x2000;

	// Unpause game
    *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac & 0xfffffffe;
    break;
  case 5:

	// Erase ghost of previous race from RAM
	FUN_80028410();

	// level ID of main menu
	iVar3 = 0x27;

	// return to track selection
    DAT_8008d97c = 2;

	// when loading is done
	// add bit for "in menu"
    DAT_8008d100 = DAT_8008d100 | 0x2000;

	// Unpause game
    *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac & 0xfffffffe;
    break;
  case 9:

	// levelID of main menu
    iVar3 = 0x27;

	// return to battle setup
    DAT_8008d97c = 3;

	// when loading is done
	// add bit for "in menu"
    DAT_8008d100 = DAT_8008d100 | 0x2000;

	// Unpause game
    *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac & 0xfffffffe;
    break;

	// If you use "Exit To Map"
  case 0xc:

	// when loading is done
	// add this bit for In Adventure Arena
    DAT_8008d100 = DAT_8008d100 | 0x100000;

	// when loading is done
	// remove bits for Relic Race or Crystal Challenge
    DAT_8008d104 = DAT_8008d104 | 0xc000000;

	// when loading is done
	// remove bit for CTR Token Challenge
    DAT_8008d10c = DAT_8008d10c | 8;

	// Unpause game
	uVar7 = *(uint *)PTR_DAT_8008d2ac;  // get value
	uVar5 = uVar7 & 0xfffffffe;			// remove pause
    *(uint *)PTR_DAT_8008d2ac = uVar5;  // set value

	// If you are not in Adventure cup
    if ((uVar7 & 0x10000000) == 0) {

	  // 0x80000000
	  // If you're in Boss Mode
      if ((int)uVar5 < 0)
	  {
		// when loading is done remove bit for
		// Boss Race, relic, and crystal challenge
        DAT_8008d104 = uVar1 | 0x8c000000;

		// When loading is done
		// add bit to spawn driver near boss door
        DAT_8008d108 = DAT_8008d108 | 1;
      }

	  // set iVar3 to level you were in previously
      iVar3 = (int)*(short *)(puVar2 + 0x1eb4);
    }

	// If you're in Adventure Cup
    else
	{
	  // Level ID of Gemstone Valley
      iVar3 = 0x19;

	  // when loading is done remove bits for
	  // Adventure Cup, relic, and crystal challenge
      DAT_8008d104 = uVar1 | 0x1c000000;

	  // Level ID
      *(int *)(puVar2 + 0x1a10) = *(int *)(puVar2 + 0x1e58) + 100;
    }
  }

  // load level ID
  FUN_8003cfc0(iVar3);
switchD_80039bcc_caseD_2:
  return;
}


// Get_MenuBox_Pause
undefined * FUN_80039dcc(void)

{
  undefined *puVar1;
  uint uVar2;

  uVar2 = *(uint *)PTR_DAT_8008d2ac;

  // If you're not in Adventure Arena
  if ((uVar2 & 0x100000) == 0) {

    // If you're not in Adventure Mode
    if ((uVar2 & 0x80000) == 0) {

	  // if you are not in Battle
      if ((uVar2 & 0x20) == 0) {

		// If you are not in Arcade or VS cup
        if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x10) == 0)
		{
		  // Single Race Pause
          puVar1 = &DAT_80084510;
        }

		// if you are in a cup
        else
		{
		  // Cup Pause
          puVar1 = &DAT_800844b8;
        }
      }

	  // if you are in Battle
      else
	  {
		// Battle Pause
        puVar1 = &DAT_80084474;
      }
    }

	// if you're in Adventure Mode
	else
	{
	  // if you're in a race
      if ((uVar2 & 0x10000000) == 0)
	  {
		// adventure race pause
        puVar1 = &DAT_800843d4;
      }

	  // if you're in a cup
      else
	  {
		// adventure cup pause
        puVar1 = &DAT_80084418;
      }
    }
  }

  // if you're in Adventure Arena
  else
  {
	// Weapon_Mask_boolGoodGuy
    uVar2 = FUN_80064be4(*(undefined4 *)(PTR_DAT_8008d2ac + 0x24ec));

	// if you use uka

	// Set string to Uka Uka Hints
    DAT_8008436e = 0xc;

	// if you use aku
    if ((uVar2 & 0xffff) != 0)
	{
	  // Set string to Aku Aku Hints
      DAT_8008436e = 0xb;
    }

	// Adventure Arena Pause
    puVar1 = &DAT_80084388;
  }
  return puVar1;
}


// PauseGame_WhenPressingStart
void FUN_80039e98(void)

{
  int iVar1;
  uint uVar2;

  // CheckeredFlag_IsFullyOnScreen
  iVar1 = FUN_80043f1c();

  if (
		(
			(
				(
					(
						// if flag is not fully on screen
						(iVar1 == 0) &&

						// if you are not drawing loading screen (after fully off screen)
						((*(uint *)(PTR_DAT_8008d2ac + 0x256c) & 0x1000) == 0)
					) &&

					// if aku is not giving a hint
					(DAT_8008d874 == 0)
				) &&

				(
					(
						DAT_8008d908 == 0 &&
						(
							uVar2 = *(uint *)PTR_DAT_8008d2ac,

							// if not in time trial, and if not paused
							(uVar2 & 0x20000f) == 0
						)
					)
				)
			) &&

			(
				(
									// Level ID != 39
									// Not in Main Menu
					*(int *)(PTR_DAT_8008d2ac + 0x1a10) != 0x27 &&
					(
						(
							(uVar2 & 0x20000000) == 0 &&

							// If you're not in Demo Mode
							(PTR_DAT_8008d2ac[0x1d32] == '\0')
						)
					)
				)
			)
		) &&


		(
			(
							// Level ID
				1 < *(int *)(PTR_DAT_8008d2ac + 0x1a10) - 0x2aU &&
				(
					(
						// If game is not loading
						DAT_8008d0a4 == 0 &&

						// if in a state where you're seeing the boss key open an adv door,
						// or some other kind of cutscene where you can't move
						((*(uint *)(PTR_DAT_8008d2ac + 8) & 4) == 0)
					)
				)
			)
		)
	 )
  {
	// pause the game
    *(uint *)PTR_DAT_8008d2ac = uVar2 | 1;

	// set desired MenuBox to pause MenuBox
    iVar1 = FUN_80039dcc();

	// set row selected to the top row
    *(undefined2 *)(iVar1 + 0x1a) = 0;

	// make menu visible
    FUN_80046990();

	// pause audio
    FUN_80034b48(1);

	// OtherFX_Play to pause
    FUN_80028468(1,1);

	// Activate pause menu
    FUN_8002481c(PTR_DAT_8008d2ac);
  }
  return;
}


// EndOfRace_TimeTrial_Relic_CalculateReward
void FUN_80039fa8(int param_1)

{
  char *pcVar1;
  uint *puVar2;
  undefined *puVar3;
  undefined *puVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  uint uVar8;
  int iVar9;
  int iVar10;

  puVar3 = PTR_DAT_8008d2ac;

  // pointer to first Player thread, -> object
  iVar10 = *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x1b2c) + 0x30);

  // no new high score
  PTR_DAT_8008d2ac[0x1d49] = 0xff;

  puVar4 = PTR_DAT_8008d2ac;
  *(uint *)(puVar3 + 0x1d44) = *(uint *)(puVar3 + 0x1d44) & 0x7bffffff;
  puVar3 = PTR_DAT_8008d2ac;

  // subtract zero seconds from final time
  iVar9 = 0;

  // if the number of time crates you collected is equal to num crates in LEV
  if (((int)*(char *)(*(int *)(puVar4 + 0x24ec) + 0x32) == *(int *)(puVar4 + 0x1e2c)) &&
     (param_1 != 0))
  {
	// subtract 10 seconds from time
    iVar9 = 0x2580;
  }

  // loop counter
  iVar5 = 0;
  iVar7 = 0;

  // loop through 5 high scores
  do {
    iVar6 = iVar7 + 1;

    if (
			// player race time, is less than...
			*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x24ec) + 0x514) - iVar9 <

			// race time in slot[iVar5] of high scores
			(int)DAT_8008d738[(iVar5 >> 0x10) * 6 + 6]
		)
	{
      puVar2 = (uint *)(PTR_DAT_8008d2ac + 0x1d44);

	  // save high score index, as new high score
	  PTR_DAT_8008d2ac[0x1d49] = (char)iVar7;

      *(uint *)(puVar3 + 0x1d44) = *puVar2 | 0x88000000;
      break;
    }
    iVar5 = iVar6 * 0x10000;
    iVar7 = iVar6;
  } while (iVar6 * 0x10000 >> 0x10 < 5);

  puVar3 = PTR_DAT_8008d2ac;

  // number of laps
  pcVar1 = PTR_DAT_8008d2ac + 0x1d33;

  iVar9 = 0;

  // set best lap time
  *(undefined4 *)(PTR_DAT_8008d2ac + 0x1d3c) = *DAT_8008d738;

  // if numLaps > 0
  if ('\0' < *pcVar1) {
    iVar7 = 0;

	// loop through number of laps
    do
	{
	  // if number of laps is lower than best lap
      if (*(int *)(puVar3 + (iVar7 >> 0x10) * 4 + 0x1d14) < *(int *)(puVar3 + 0x1d3c))
	  {
		// set new lowest lap to this lap time
        *(int *)(puVar3 + 0x1d3c) = *(int *)(puVar3 + (iVar7 >> 0x10) * 4 + 0x1d14);

		// set lap ID (0,1,2) to flash, because it is new best lap
		*(int *)(puVar3 + 0x1d40) = iVar7 >> 0x10;

        *(uint *)(puVar3 + 0x1d44) = *(uint *)(puVar3 + 0x1d44) | 0x8c000000;
      }

	  // increase lap index
	  iVar9 = iVar9 + 1;

	  iVar7 = iVar9 * 0x10000;

    } while (iVar9 * 0x10000 >> 0x10 < (int)(char)puVar3[0x1d33]);
  }
  puVar3 = PTR_DAT_8008d2ac;

  // If you're not in Time Trial
  if ((*(uint *)PTR_DAT_8008d2ac & 0x20000) == 0) {
    return;
  }

  // quit function is this bit is not active
  // This bit becomes active as soon as you finish a race
  if ((*(uint *)(PTR_DAT_8008d2ac + 0x1d44) & 4) != 0) {
    return;
  }

  // This next line seems pointless

  // Activate bit, even though it had to be active, because we
  // wouldn't get to this line if it weren't active
  *(uint *)(PTR_DAT_8008d2ac + 0x1d44) = *(uint *)(PTR_DAT_8008d2ac + 0x1d44) | 4;

  // Level ID * 0x124
  iVar9 = *(int *)(puVar3 + 0x1a10) * 0x124;

  iVar7 = ((int)((uint)DAT_8008453c << 0x10) >> 0x15) * 4 + iVar9;

  // check timeTrialFlags, see if n.tropy has NOT been beaten
  if ((*(uint *)(&DAT_8008e814 + iVar7) >> (DAT_8008453c & 0x1f) & 1) == 0)
  {
	// if timeTrialFlags show N Tropy is not open
    if ((*(uint *)(&DAT_8008e814 + iVar9) & 1) == 0)
	{
	  // if time required to win event was less than the amount of time you took to finish,
	  // meaning if you lost the event, then you did not open N Tropy
      if (*(int *)(&DAT_80083a8c + *(int *)(puVar3 + 0x1a10) * 0x18) <= *(int *)(iVar10 + 0x514))
      goto LAB_8003a27c;

	  // write to timeTrialFlags,
	  // you just opened N Tropy
	  *(uint *)(&DAT_8008e814 + iVar9) =
	  *(uint *)(&DAT_8008e814 + iVar9) | 1;

	  // | 0x8000
	  uVar8 = *(uint *)(puVar3 + 0x1d44) | 0x8008000;
    }

	// if N Tropy is open
    else
	{
	  // if time required to win event was less than the amount of time you took to finish,
	  // meaning if you lost the event, then you did not beat N Tropy, nor open N Oxide
      if (*(int *)(puVar3 + 0x1d78) <= *(int *)(iVar10 + 0x514)) goto LAB_8003a27c;

	  // write to timeTrialFlags,
	  // you just beat N Tropy and opened N Oxide
      *(uint *)(&DAT_8008e814 + iVar7) =
      *(uint *)(&DAT_8008e814 + iVar7)
		| 1 << (DAT_8008453c & 0x1f);

	  // + 0x1d44) | 0x18000000
	  uVar8 = *(uint *)(puVar3 + 0x1d44) | DAT_80084548;
    }
  }

  // if N Tropy has been beaten,
  // and oxide is open
  else
  {
	// if time required to win event was less than the amount of time you took to finish,
	// meaning if you lost the event, then you did not beat N Oxide
    if (*(int *)(puVar3 + 0x1d78) <= *(int *)(iVar10 + 0x514)) goto LAB_8003a27c;

    iVar9 = ((int)((uint)DAT_80084540 << 0x10) >> 0x15) * 4 + iVar9;

	// write to timeTrialFlags,
	// you just beat N Oxide
	*(uint *)(&DAT_8008e814 + iVar9) =
    *(uint *)(&DAT_8008e814 + iVar9)
		| 1 << ((uint)DAT_80084540 & 0x1f);

	// + 0x1d44) | 0x08800000
    uVar8 = *(uint *)(puVar3 + 0x1d44) | DAT_80084544;
  }
  *(uint *)(puVar3 + 0x1d44) = uVar8;
LAB_8003a27c:

  // Check if Oxide was beaten on all tracks
  uVar8 = FUN_80026ae4(2);

  // If Oxide was beaten on all tracks
  if ((uVar8 & 0xffff) != 0)
  {
	// Unlock Scrapbook
    DAT_8008e6f0 = DAT_8008e6f0 | 0x10;
  }
  return;
}


// EndOfRace_TimeTrial_Relic_SaveHighScore
void FUN_8003a2b4(void)

{
  undefined2 uVar1;
  undefined *puVar2;
  uint uVar3;
  undefined4 *puVar4;
  int iVar5;
  uchar *puVar6;
  undefined4 *puVar7;
  int iVar8;

  // player structure
  iVar8 = *(int *)(PTR_DAT_8008d2ac + 0x24ec);

  // EndOfRace_TimeTrial_Relic_CalculateReward
  FUN_80039fa8(0);

  puVar2 = PTR_DAT_8008d2ac;
  uVar3 = *(uint *)(PTR_DAT_8008d2ac + 0x1d44);
  if ((uVar3 & 0x10000) == 0) {
    *(uint *)(PTR_DAT_8008d2ac + 0x1d44) = uVar3 | 0x10000;
    puVar7 = DAT_8008d738;

	// if there is a new best lap
    if ((uVar3 & 0x4000000) != 0)
	{
	  // save new best lap time to high score
      *DAT_8008d738 = *(undefined4 *)(puVar2 + 0x1d3c);

	  // Player / AI structure + 0x4a shows driver index (0-7)
      uVar1 = (&DAT_80086e84)[*(byte *)(iVar8 + 0x4a)];

	  // set first byte of high score name to nullptr (waste of time?)
	  *(undefined *)(puVar7 + 1) = 0;
      puVar4 = DAT_8008d738 + 1;

	  // prevNameEntered
      puVar6 = PTR_DAT_8008d2ac + 0x1d54;

	  // save characterID in high score
      *(undefined2 *)((int)puVar7 + 0x16) = uVar1;

	  // copy name
	  memmove((uchar *)puVar4,puVar6,0x11);
    }

	// index of new high score
    iVar5 = (int)(char)PTR_DAT_8008d2ac[0x1d49];

	// if there is a new high score
    if (-1 < iVar5)
	{
	  // pointer to saved time in high score
      puVar7 = DAT_8008d738 + iVar5 * 6 + 6;

	  // if this new high score, is not
	  // high score #5 on the list
      if (iVar5 < 4)
	  {
		// move all high scores, that come after this new high score,
		// down by one slot on the list of all times
        memmove((uchar *)(puVar7 + 6),(uchar *)puVar7,(4 - iVar5) * 0x18);
      }

	  // save race time in the high score
      *puVar7 = *(undefined4 *)(iVar8 + 0x514);

	  // Player / AI structure + 0x4a shows driver index (0-7)
      uVar1 = (&DAT_80086e84)[*(byte *)(iVar8 + 0x4a)];

	  // set first byte of high score name to nullptr (waste of time?)
      *(undefined *)(puVar7 + 1) = 0;

	  // prevNameEntered
      puVar6 = PTR_DAT_8008d2ac + 0x1d54;

	  // save characterID in high score
      *(undefined2 *)((int)puVar7 + 0x16) = uVar1;

	  // copy name
	  memmove((uchar *)(puVar7 + 1),puVar6,0x11);
    }
  }
  return;
}


// ToggleGameState_EndOfRace
void FUN_8003a3fc(void)

{
  byte *pbVar1;
  int *piVar2;
  int iVar3;
  undefined *puVar4;
  short sVar5;
  int iVar6;
  undefined4 *puVar7;
  int iVar8;
  uint uVar9;
  undefined *puVar10;
  int iVar11;
  int iVar12;
  undefined *puVar13;
  uint uVar14;
  int iVar15;
  uint uVar16;
  int iVar17;
  undefined4 local_38;
  undefined4 local_34;
  int local_30;

  // loop counter
  iVar17 = 0;

  // If you're not in End-Of-Race menu,
  // then enable End-Of-Race menu
  if ((*(uint *)PTR_DAT_8008d2ac & 0x200000) == 0)
  {
	// pointer to player structure (P1)
    local_30 = *(int *)(PTR_DAT_8008d2ac + 0x24ec);

	// for iVar17 = 0; iVar17 < 8; iVar17++
    do
	{
		// pointer to address of all 8 player structures,
		// if each structure is not nullptr
      if (*(int *)(PTR_DAT_8008d2ac + iVar17 * 4 + 0x24ec) != 0)
	  {
		// spawn player in position of next race, depending on
		// rank in current race (1st place, 2nd place, etc)
        (&DAT_8008d69c)[iVar17] =
             *(undefined *)(*(int *)(PTR_DAT_8008d2ac + iVar17 * 4 + 0x24ec) + 0x482);
      }

	  // increment loop counter
      iVar17 = iVar17 + 1;

    } while (iVar17 < 8);
    PTR_DAT_8008d2ac[0x1d49] = 0xff;

	// If you're drawing Weapon Roulette (randomizing)
    if ((*(uint *)PTR_DAT_8008d2ac & 0x800000) != 0)
	{
	  // OtherFX_Stop2
	  // stop weapon shuffle sound
      FUN_80028844(0x5d);

	  // disable randomizing effect in HUD
      *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac & 0xff7fffff;
    }

	uVar9 = *(uint *)PTR_DAT_8008d2ac;

	// Trophy, CTR Challenge, Crystal, Boss

	// If not in Adventure cup and not in Relic,
	// but you are in Adventure Mode
    if ((uVar9 & 0x14080000) == 0x80000) {

      // If player is in 1st place
      if (*(short *)(local_30 + 0x482) == 0)
	  {
		// If this is boss race
        if ((int)uVar9 < 0) {
          (&DAT_8008fbeb)[*(int *)(PTR_DAT_8008d2ac + 0x1eb8)] = 0;
        }

		// if this is not boss race
        else
		{
							// Level ID
          (&DAT_8008fbd4)[*(int *)(PTR_DAT_8008d2ac + 0x1a10)] = 0;
        }
      }

	  // if player is not in 1st place
	  else {

		// if this is boss race
        if ((int)uVar9 < 0) {
          iVar17 = *(int *)(PTR_DAT_8008d2ac + 0x1eb8) + 0x17;
        }

		// if this is not boss race
        else
		{
							// Level ID
          iVar17 = *(int *)(PTR_DAT_8008d2ac + 0x1a10);
        }

		// if number of times lost is less than 10
        if ((char)(&DAT_8008fbd4)[iVar17] < '\n')
		{
		  // increment number of times lost
          (&DAT_8008fbd4)[iVar17] = (&DAT_8008fbd4)[iVar17] + '\x01';
        }
      }
    }
    puVar13 = PTR_DAT_8008d2ac;

	// Enable End-Of-Race menu
    uVar9 = *(uint *)PTR_DAT_8008d2ac;
    *(uint *)PTR_DAT_8008d2ac = uVar9 | 0x200000;


    *(uint *)(puVar13 + 0x1d44) = uVar9 & 0x3e0020 | 0x200000;
    puVar10 = PTR_DAT_8008d2ac;

	// If you are not in Battle Mode
    if ((uVar9 & 0x20) == 0)
	{
	  // loop iteration counter
      iVar17 = 0;

	  // if not zero screens
      if (puVar13[0x1ca8] != '\0')
	  {
		// offset counter
        iVar12 = 0;

        puVar10 = puVar13;

		// for iVar17 = 0; iVar17 < numScreens; iVar17++
        do
		{
		  // if racer is in the top 3 positions of the race (1st, 2nd, 3rd)
          if ((int)*(short *)(*(int *)(puVar10 + 0x24ec) + 0x482) < 3)
		  {
			// all this, is just to increment one value by 1

			// The code here in Versus Standings looks
			// like the code use in Battle Standings

			// Get the rank that the player finished in VS (1st, 2nd, 3rd)
			// Then get the number of times this player has finished in this rank,
			// then increment that number

            *(int *)(puVar13 + (int)*(short *)(*(int *)(puVar10 + 0x24ec) + 0x482) * 4 + iVar12 +
                    0x1e80) =
            *(int *)(puVar13 + (int)*(short *)(*(int *)(puVar10 + 0x24ec) + 0x482) * 4 + iVar12 +
					0x1e80) + 1;
          }

		  // Each player has 12 bytes,
		  // one int for how many times they came 1st
		  // one int for how many times they came 2nd
		  // one int for how many times they came 3rd
          iVar12 = iVar12 + 0xc;

		  // increment iteration counter
          iVar17 = iVar17 + 1;

		  // pointer incrementation
          puVar10 = puVar10 + 4;
        } while (iVar17 < (int)(uint)(byte)puVar13[0x1ca8]);
      }
    }

	// if in battle mode
	else {
      if ((uVar9 & 0x4000) == 0) {
        if ((uVar9 & 0x8000) != 0) {
          local_38 = DAT_8008d2f4;
          local_34 = DAT_8008d2f8;
          uVar9 = 0;
          iVar17 = 0;
          do {
            iVar12 = 0;
            sVar5 = -400;

			// start with 3, then 2, 1, 0
            uVar14 = 3;

			// start with P4, and go backwards to P3, P2, P1
            puVar13 = PTR_DAT_8008d2ac + 0xc;

            do
			{
			  // pointer to each player structure, plus offset
              if (*(int *)(*(int *)(puVar13 + 0x24ec) + 0x4e4) != 0)
			  {
						// pointer to each player structure, plus offset
                if ((*(int *)(*(int *)(puVar13 + 0x24ec) + 0x4e4) == (int)sVar5) &&
                   (((int)(uVar9 & 0xff) >> (uVar14 & 0x1f) & 1U) == 0))
				{
                  *(undefined2 *)((int)&local_38 + ((iVar12 + 1) * 0x10000 >> 0xf)) = (short)uVar14;
                  uVar9 = uVar9 | 1 << (uVar14 & 0x1f);
                  iVar12 = iVar12 + 1;
                }

                else
				{
								// pointer to each player structure, plus offset
                  if (((int)sVar5 <= *(int *)(*(int *)(puVar13 + 0x24ec) + 0x4e4)) &&
                     (((int)(uVar9 & 0xff) >> (uVar14 & 0x1f) & 1U) == 0))
				  {
								// pointer to each player structure, plus offset
                    sVar5 = *(short *)(*(int *)(puVar13 + 0x24ec) + 0x4e4);
                    iVar12 = (int)(short)iVar12 + 1;
                    iVar11 = 0;
                    puVar7 = &local_38;
                    if (0 < iVar12) {
                      do {
                        if ((int)*(short *)puVar7 != 0xffffffff) {
                          uVar9 = uVar9 & ~(1 << ((int)*(short *)puVar7 & 0x1fU));
                        }
                        iVar11 = iVar11 + 1;
                        puVar7 = (undefined4 *)((int)puVar7 + 2);
                      } while (iVar11 < iVar12);
                    }
                    iVar12 = 0;

											// Battle Team that the player is on
                    uVar9 = uVar9 | 1 << ((uint)*(ushort *)(*(int *)(puVar13 + 0x24ec) + 0x4e8) &
                                         0x1f);

                    local_38 = local_38 & 0xffff0000 |

									// Battle Team that the player is on
                               (uint)*(ushort *)(*(int *)(puVar13 + 0x24ec) + 0x4e8);
                  }
                }
              }
              uVar14 = uVar14 - 1;
              puVar13 = puVar13 + -4;
            } while (-1 < (int)uVar14);

            sVar5 = (short)iVar12;
            if (((short)local_38 != -1) && (iVar12 = 0, 0 < (int)sVar5 + 1)) {
              puVar7 = &local_38;
              do {
                puVar13 = PTR_DAT_8008d2ac;

				*(int *)(PTR_DAT_8008d2ac + iVar17 * 4 + *(int *)(*(int *)(PTR_DAT_8008d2ac +

					// Battle Team the player is on
					(int)*(short *)puVar7 * 4 + 0x24ec) +0x4e8) *
						0xc + 0x1e80) =

                *(int *)(PTR_DAT_8008d2ac + iVar17 * 4 + *(int *)(*(int *)(PTR_DAT_8008d2ac +

					// Battle Team the player is on
					(int)*(short *)puVar7 * 4 + 0x24ec) + 0x4e8) *
						0xc + 0x1e80) + 1;

                if (
						(iVar17 == 0) &&

						// address of each player structure
						(*(int *)(puVar13 + (int)*(short *)puVar7 * 4 + 0x24ec) != 0)
					)
                {
				  // set next winner index in the array of winners, this ID will get confetti
                  *(uint *)(puVar13 + *(int *)(puVar13 + 0x2568) * 4 + 0x2558) =

														// address of each player structure
                       (uint)*(byte *)(*(int *)(puVar13 + (int)*(short *)puVar7 * 4 + 0x24ec) + 0x4a
                                      );

				  // Edit gGT offsets 0x17a, 0x17c, 0x17e
				  // = Camera110 offsets 0x12, 0x14, 0x16

				  // current fade = flash white
                  *(undefined2 *)
                   (puVar13 +
                   *(int *)(puVar13 + *(int *)(puVar13 + 0x2568) * 4 + 0x2558) * 0x110 + 0x17a) =
                       0x1fff;

				  // desired fade = neutral
                  *(undefined2 *)
                   (puVar13 +
                   *(int *)(puVar13 + *(int *)(puVar13 + 0x2568) * 4 + 0x2558) * 0x110 + 0x17c) =
                       0x1000;

				  // fade step is negative, to move downward
                  *(undefined2 *)
                   (puVar13 +
                   *(int *)(puVar13 + *(int *)(puVar13 + 0x2568) * 4 + 0x2558) * 0x110 + 0x17e) =
                       0xff78;

				  // turn driver into Robotcar
                  FUN_80017318(*(undefined4 *)(puVar13 + (int)*(short *)puVar7 * 4 + 0x24ec));

				  // increment number of winners,
				  // more people get confetti
                  *(int *)(PTR_DAT_8008d2ac + 0x2568) = *(int *)(PTR_DAT_8008d2ac + 0x2568) + 1;
                }
                puVar13 = PTR_DAT_8008d2ac;

				// amount of confetti particles
                *(undefined2 *)(PTR_DAT_8008d2ac + 0x1b04) = 0xfa;
                *(undefined2 *)(puVar13 + 0x1b06) = 0xfa;

                *(int *)(puVar13 + (int)*(short *)puVar7 * 4 + 0x1da8) = iVar17;

				// number of screens
                pbVar1 = puVar13 + 0x1ca8;

				// loop iteration counter
                uVar14 = 0;

				// if number of screens is not zero
                if (*pbVar1 != 0)
				{
					// address of each player structure
                  piVar2 = (int *)(puVar13 + (int)*(short *)puVar7 * 4 + 0x24ec);

				  // for uVar14 = 0; uVar14 < numScreens; uVar14++
				  do
				  {
					// If two players are on the same team
                    if (*(int *)(*(int *)(puVar13 + 0x24ec) + 0x4e8) == *(int *)(*piVar2 + 0x4e8))
					{
                      uVar9 = uVar9 | 1 << (uVar14 & 0x1f);
                    }

					// increment loop iteration counter
                    uVar14 = uVar14 + 1;

					// increment pointer
                    puVar13 = puVar13 + 4;

                  } while ((int)uVar14 < (int)(uint)*pbVar1);
                }
                iVar12 = iVar12 + 1;
                puVar7 = (undefined4 *)((int)puVar7 + 2);
              } while (iVar12 < (int)sVar5 + 1);
            }
            local_38 = CONCAT22(local_38._2_2_,0xffff);
            iVar17 = iVar17 + sVar5 + 1;
          } while (iVar17 < 4);
        }
      }
      else {
        uVar9 = 0;
        iVar17 = 0;
        local_38 = DAT_8008d2f4;
        local_34 = DAT_8008d2f8;
        do {
          sVar5 = -400;
          iVar12 = 0;
          uVar14 = 3;
          puVar13 = puVar10 + 0xc;
          do {
            if ((*(int *)(puVar13 + 0x1d90) == (int)sVar5) &&
               (((int)(uVar9 & 0xff) >> (uVar14 & 0x1f) & 1U) == 0)) {
              iVar12 = iVar12 + 1;
              *(undefined2 *)((int)&local_38 + (iVar12 * 0x10000 >> 0xf)) = (short)uVar14;
LAB_8003a71c:
              uVar9 = uVar9 | 1 << (uVar14 & 0x1f);
            }
            else {
              if (((int)sVar5 <= *(int *)(puVar13 + 0x1d90)) &&
                 (((int)(uVar9 & 0xff) >> (uVar14 & 0x1f) & 1U) == 0)) {
                sVar5 = *(short *)(puVar13 + 0x1d90);
                iVar12 = (int)(short)iVar12 + 1;
                iVar11 = 0;
                puVar7 = &local_38;
                if (0 < iVar12) {
                  do {
                    if ((int)*(short *)puVar7 != 0xffffffff) {
                      uVar9 = uVar9 & ~(1 << ((int)*(short *)puVar7 & 0x1fU));
                    }
                    iVar11 = iVar11 + 1;
                    puVar7 = (undefined4 *)((int)puVar7 + 2);
                  } while (iVar11 < iVar12);
                }
                iVar12 = 0;
                local_38 = local_38 & 0xffff0000 | uVar14 & 0xffff;
                goto LAB_8003a71c;
              }
            }
            uVar14 = uVar14 - 1;
            puVar13 = puVar13 + -4;
          } while (-1 < (int)uVar14);
          if ((short)local_38 != -1) {
            iVar11 = (int)(short)iVar12 + 1;
            iVar8 = 0;
            puVar7 = &local_38;
            if (0 < iVar11) {
              do {
                iVar8 = iVar8 + 1;
                *(int *)(puVar10 + (int)*(short *)puVar7 * 4 + 0x1da8) = iVar17;
                puVar7 = (undefined4 *)((int)puVar7 + 2);
              } while (iVar8 < iVar11);
            }
          }
          local_38 = CONCAT22(local_38._2_2_,0xffff);
          iVar17 = iVar17 + (short)iVar12 + 1;
        } while (iVar17 < 4);

		// iteration counter
        iVar12 = 0;

        iVar17 = 0;

		// for iVar12 = 0; iVar12 < 4; iVar12++
		do
		{
		  // If you are not in last place
          if (*(int *)(PTR_DAT_8008d2ac + iVar12 * 4 + 0x1da8) != 3)
		  {
			// Get Battle Team, then get rank of battle team (1st, 2nd, 3rd),
			// then get number of times this team has gotten this rank

			// Increment the number of times this team has finished in this rank

			// In "Battle Standings" You'll see "1st - xx" "2nd - xx", etc.
			// This is incrementing the "xx"

            *(int *)(PTR_DAT_8008d2ac +
                     *(int *)(PTR_DAT_8008d2ac + iVar12 * 4 + 0x1da8) * 4 + iVar17 + 0x1e80) =

			*(int *)(PTR_DAT_8008d2ac +
                     *(int *)(PTR_DAT_8008d2ac + iVar12 * 4 + 0x1da8) * 4 + iVar17 + 0x1e80) + 1;
          }

          puVar13 = PTR_DAT_8008d2ac;

		  // two lines combined get the address of each player structure
          puVar10 = PTR_DAT_8008d2ac + iVar12 * 4;
          iVar11 = *(int *)(puVar10 + 0x24ec);

          if (
				// if player structure is not nullptr
				(iVar11 != 0) &&

				// If this player is on a team that won the battle (0 for 1st place, 1 for 2nd, etc)
				(*(int *)(PTR_DAT_8008d2ac + *(int *)(iVar11 + 0x4e8) * 4 + 0x1da8) == 0)
			  )
		  {
			// set next winner index in the array of winners, this ID will get confetti
            *(uint *)(PTR_DAT_8008d2ac + *(int *)(PTR_DAT_8008d2ac + 0x2568) * 4 + 0x2558) =

				 // Player / AI structure + 0x4a shows driver index (0-7)
				 (uint)*(byte *)(iVar11 + 0x4a);

			// Edit Camera110 offsets 0x17a, 0x17c, 0x17e

            *(undefined2 *)
             (puVar13 + *(int *)(puVar13 + *(int *)(puVar13 + 0x2568) * 4 + 0x2558) * 0x110 + 0x17a)
                 = 0x1fff;
            *(undefined2 *)
             (puVar13 + *(int *)(puVar13 + *(int *)(puVar13 + 0x2568) * 4 + 0x2558) * 0x110 + 0x17c)
                 = 0x1000;
            *(undefined2 *)
             (puVar13 + *(int *)(puVar13 + *(int *)(puVar13 + 0x2568) * 4 + 0x2558) * 0x110 + 0x17e)
                 = 0xff78;

			// turn driver into Robotcar
            FUN_80017318(*(undefined4 *)(puVar10 + 0x24ec));

			// increment number of winners,
			// more people get confetti
            *(int *)(PTR_DAT_8008d2ac + 0x2568) = *(int *)(PTR_DAT_8008d2ac + 0x2568) + 1;
          }
          puVar13 = PTR_DAT_8008d2ac;

		  // increment loop counter
          iVar12 = iVar12 + 1;

		  // amount of confetti particles
          *(undefined2 *)(PTR_DAT_8008d2ac + 0x1b04) = 0xfa;
          *(undefined2 *)(puVar13 + 0x1b06) = 0xfa;

          iVar17 = iVar17 + 0xc;
        } while (iVar12 < 4);
      }
    }
    puVar13 = PTR_DAT_8008d2ac;
    uVar9 = 0;

	// loop counter
    iVar12 = 0;

    iVar17 = 0;
    puVar10 = PTR_DAT_8008d2ac;

	// for iVar12 = 0; iVar12 < 4; iVar12++
	do {
      iVar8 = 0;

	  // loop counter
      iVar15 = 0;

      iVar11 = iVar17;

	  // for iVar15 = 0; iVar15 < 3; iVar15++
      do {
        iVar3 = iVar11 + 0x1e80;
        iVar6 = 3 - iVar15;
        iVar11 = iVar11 + 4;

		// increment loop counter
        iVar15 = iVar15 + 1;

        iVar8 = iVar8 + *(int *)(puVar13 + iVar3) * iVar6;
      } while (iVar15 < 3);

      *(int *)(puVar10 + 0x1de0) = iVar8 * 0x10000 >> 0x10;
      puVar4 = PTR_DAT_8008d2ac;
      puVar10 = puVar10 + 4;

	  // increment loop counter
      iVar12 = iVar12 + 1;

      iVar17 = iVar17 + 0xc;
    } while (iVar12 < 4);

	// loop counter
    iVar17 = 0;

    puVar13 = PTR_DAT_8008d2ac;

	// for iVar17 = 0; iVar17 < 4; iVar17++
	do {
      sVar5 = 0;
      uVar14 = 0xffffffff;
      uVar16 = 3;
      puVar10 = puVar4 + 0xc;
      do {
        if ((((int)sVar5 <= *(int *)(puVar10 + 0x1de0)) &&
            (((int)(uVar9 & 0xff) >> (uVar16 & 0x1f) & 1U) == 0)) &&
           (((*(uint *)(puVar4 + 0x1dd8) & 1 << (uVar16 & 0x1f)) != 0 ||
            ((*(uint *)puVar4 & 0x20) == 0)))) {
          sVar5 = *(short *)(puVar10 + 0x1de0);
          if ((int)(short)uVar14 != 0xffffffff) {
            uVar9 = uVar9 & ~(1 << ((int)(short)uVar14 & 0x1fU));
          }
          uVar9 = uVar9 | 1 << (uVar16 & 0x1f);
          uVar14 = uVar16;
        }
        uVar16 = uVar16 - 1;
        puVar10 = puVar10 + -4;
      } while (-1 < (int)uVar16);
      *(int *)(puVar13 + 0x1dc8) = (int)(short)uVar14;

	  // increment loop counter
	  iVar17 = iVar17 + 1;

	  puVar13 = puVar13 + 4;
    } while (iVar17 < 4);

	// pointer to first Player thread
    iVar17 = *(int *)(PTR_DAT_8008d2ac + 0x1b2c);

	// end race clock for all human players

	// if thread is valid
    while (iVar17 != 0)
	{
	  // Driver_Finalize_RaceClock
      FUN_8005572c(*(undefined4 *)(iVar17 + 0x30));

	  // go to next thread
      iVar17 = *(int *)(iVar17 + 0x10);
    }

	// EndOfRace_AssignAllComments
    FUN_80054bfc();

	// OSK_RestoreName
    FUN_8004aa08(2);

	// if you are in Relic Race or Time Trial
    if ((*(uint *)PTR_DAT_8008d2ac & 0x4020000) != 0)
	{
	  // EndOfRace_TimeTrial_Relic_CalculateReward
      FUN_80039fa8(1);

	  // If you're not in a Relic Race
      if ((*(uint *)PTR_DAT_8008d2ac & 0x4000000) == 0)
	  {
        if (

			// if you are not showing a ghost during a race
			(DAT_8008d958 == 0) ||
			(
				(
					// if ghost is not too big
					DAT_8008d744 == 0 &&

					(*(int *)(local_30 + 0x514) < *(int *)(DAT_8008d754 + 0x10))
				)
			)
		   )
		{
          // GhostBuffer_EndRecording
		  FUN_80027e90();

          *(uint *)(PTR_DAT_8008d2ac + 0x1d44) = *(uint *)(PTR_DAT_8008d2ac + 0x1d44) | 1;
        }
      }

	  // If you are in Relic Race
      else
	  {
		// RR_EndEvent_UnlockAward
        FUN_8009f71c();
      }
    }
  }

  // Tawna_Init
  FUN_80041c84(PTR_DAT_8008d2ac);

  return;
}


// ToggleGameState_StartOfRace
void FUN_8003aee8(uint *param_1,int param_2)

{
  uint uVar1;

  // DotLights_AudioAndVideo wont execute
  // if (gGT & 0x20102000 == 0), but if it did execute,
  // traffic lights would instantly hit green in cutscene
  // and main menu, while starting from top-position (0xf00)
  // when spawning in the adventure arena

  // if you're not in cutscene and not in main menu
  if ((*(uint *)PTR_DAT_8008d2ac & 0x20002000) == 0)
  {
	// traffic light countdown
    param_1[0x743] = 0xf00;

	// fly-in camera animation
    uVar1 = *param_1 | 0x40;
  }

  // if you are:
  else
  {
	// disable traffic lights
    param_1[0x743] = 0;

	// no fly-in camera
    uVar1 = *param_1 & 0xffffffbf;
  }

  // save new game mode, removing end-of-race flag
  *param_1 = uVar1;
  *param_1 = *param_1 & 0xffdfffff;

  // this never happens in normal gameplay
  if (param_2 == 0) {

	// Music_Stop
	FUN_8002e4ec();

	// howl_StopAudio (stops menu sounds)
	// keep backup,
	// keep music (no music to stop),
	// stop all fx
    FUN_8002c8a8(0,0,1);
  }

  // Driver_TeleportAll
  FUN_80058898(param_1,2);
  return;
}


// VisMem_Clear
// param1 is PTR_DAT_8008d2ac
void FUN_8003af84(int param_1)

{
  int iVar1;
  int iVar2;

  // lev offset 0x190?
  iVar1 = *(int *)(*(int *)(param_1 + 0x160) + 400);

  // called VISMEM in prototypes
  *(int *)(param_1 + 0x1a38) = iVar1;

  if (
		(iVar1 != 0) &&
		(
			iVar1 = 0,

			// number of screens is not zero
			*(char *)(param_1 + 0x1ca8) != '\0')
		)
  {
	// for iVar1 = 0; iVar1 < numScreens; iVar1++
    do {
      iVar2 = iVar1 * 4;
      *(undefined4 *)(*(int *)(param_1 + 0x1a38) + iVar2 + 0x40) = 0;
      *(undefined4 *)(*(int *)(param_1 + 0x1a38) + iVar2 + 0x50) = 0;
      *(undefined4 *)(*(int *)(param_1 + 0x1a38) + iVar2 + 0x60) = 0;
      *(undefined4 *)(*(int *)(param_1 + 0x1a38) + iVar2 + 0x70) = 0;
      iVar1 = iVar1 + 1;
    } while (iVar1 < (int)(uint)*(byte *)(param_1 + 0x1ca8));
  }
  return;
}


// RainBufferInit
// param1 is PTR_DAT_8008d2ac
void FUN_8003b008(int param_1)

{
  byte bVar1;
  int iVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  int iVar5;
  int iVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 uVar9;

  iVar6 = 0;
  iVar5 = param_1;

  // if number of screens is not zero
  if (*(char *)(param_1 + 0x1ca8) != '\0') {

	// for ivar6 = 0; ivar6 < numScreens; ivar6++
    do
	{
	  // gGT->level1
      iVar2 = *(int *)(param_1 + 0x160);

	  // Rain Buffer
      puVar4 = (undefined4 *)(iVar5 + 0x1a40);

	  // copy rain buffer from level, to player's global rain buffer
      puVar3 = (undefined4 *)(iVar2 + 0x104);
      do {
        uVar7 = puVar3[1];
        uVar8 = puVar3[2];
        uVar9 = puVar3[3];
        *puVar4 = *puVar3;
        puVar4[1] = uVar7;
        puVar4[2] = uVar8;
        puVar4[3] = uVar9;
        puVar3 = puVar3 + 4;
        puVar4 = puVar4 + 4;
      } while (puVar3 != (undefined4 *)(iVar2 + 0x134));

	  // if there are zero screens, crash the game
      bVar1 = *(byte *)(param_1 + 0x1ca8);
      if (bVar1 == 0) {
        trap(0x1c00);
      }

	  // if there are -1 screens, crash the game
      if (((uint)bVar1 == 0xffffffff) && (*(int *)(iVar5 + 0x1a40) == -0x80000000)) {
        trap(0x1800);
      }

      *(int *)(iVar5 + 0x1a40) = *(int *)(iVar5 + 0x1a40) / (int)(uint)bVar1;

	  // if there are zero screens, crash the game
	  bVar1 = *(byte *)(param_1 + 0x1ca8);
      if (bVar1 == 0) {
        trap(0x1c00);
      }

	  // if there are -1 screens, crash the game
      if (((uint)bVar1 == 0xffffffff) && ((uint)*(ushort *)(iVar5 + 0x1a44) == 0x80000000)) {
        trap(0x1800);
      }

	  // next screen
	  iVar6 = iVar6 + 1;

      *(undefined2 *)(iVar5 + 0x1a44) =
           (short)((int)(uint)*(ushort *)(iVar5 + 0x1a44) / (int)(uint)bVar1);

	  // next player's rain buffer
	  iVar5 = iVar5 + 0x30;

    } while (iVar6 < (int)(uint)*(byte *)(param_1 + 0x1ca8));
  }
  return;
}

// SetPrimMemSize
void FUN_8003b0f0(uint *param_1)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;

  uVar3 = 0x5f;
  uVar1 = 0x78;
  uVar4 = 0x96;

  // 0x1a10, levID == adventure Character Selection
  if (param_1[0x684] == 0x28)
  {
	// +0x23 = gGT->0x8C, &gGT->DB[0].primMem
    FUN_800349c4(param_1 + 0x23,0x1b800);
    iVar2 = 0x1b800;
  }

  else
  {
	// If you are not in main menu
    if ((*param_1 & 0x2000) == 0)
	{
	  // (72a*4 = 1ca8), numPlayers
      switch(*(undefined *)(param_1 + 0x72a))
	  {
		// zero players, how?
      case 0:

		// +0x23 = gGT->0x8C, &gGT->DB[0].primMem
        FUN_800349c4(param_1 + 0x23,0x25800);
        iVar2 = 0x25800;
        goto LAB_8003b2b8;

		// 1 player
      case 1:

	    // If you're in Adventure Arena
        if ((*(uint *)PTR_DAT_8008d2ac & 0x100000) != 0)
		{
		  // +0x23 = gGT->0x8C, &gGT->DB[0].primMem
          FUN_800349c4(param_1 + 0x23,0x1c000);
          iVar2 = 0x1c000;
          goto LAB_8003b2b8;
        }

		// if level is some intro cutscene (30 - 39)
        if (*(int *)(PTR_DAT_8008d2ac + 0x1a10) - 0x1eU < 9)
		{
		  // +0x23 = gGT->0x8C, &gGT->DB[0].primMem
          FUN_800349c4(param_1 + 0x23,0x1e000);
          iVar2 = 0x1e000;
          goto LAB_8003b2b8;
        }

		// if LEV is a track 0-25,
		// so, not a warp room
        if ((int)param_1[0x684] < 0x19)
		{
		  // primMem[1p][gGT->levelID]
          uVar3 = (uint)(byte)&DAT_8008454c[param_1[0x684]];
        }
        iVar2 = uVar3 << 10;
        break;

		// 2 players
      case 2:
		// if LEV is a track 0-25,
		// so, not a warp room
        if ((int)param_1[0x684] < 0x19)
		{
		  // primMem[2p][gGT->levelID]
          uVar1 = (uint)(byte)(&DAT_80084568)[param_1[0x684]];
        }
        iVar2 = uVar1 << 10;
        break;

		// 3 or 4 players
      case 3:
      case 4:
		// if LEV is a track 0-25,
		// so, not a warp room
        if ((int)param_1[0x684] < 0x19)
		{
		  // primMem[4p][gGT->levelID]
          uVar4 = (uint)(byte)(&DAT_80084584)[param_1[0x684]];
        }
        iVar2 = uVar4 << 10;
        break;

      default:
        return;
      }

	  // +0x23 = gGT->0x8C, &gGT->DB[0].primMem
      FUN_800349c4(param_1 + 0x23,iVar2);
    }

	// If you are in main menu
	else
	{
	  // +0x23 = gGT->0x8C, &gGT->DB[0].primMem
      FUN_800349c4(param_1 + 0x23,0x17c00);
      iVar2 = 0x17c00;
    }
  }
LAB_8003b2b8:

  // +0x4C = gGT->0x8C+0xA4, &gGT->DB[1].primMem
  FUN_800349c4(param_1 + 0x4c,iVar2);
  return;
}


// ClearAllMemPools
void FUN_8003b2d4(int param_1)

{
  // erase everything in all pools
  FUN_80030fdc(param_1 + 0x18d0); // Thread Pool
  FUN_80030fdc(param_1 + 0x18f8); // Instance Pool
  FUN_80030fdc(param_1 + 0x1920); // Small Stack Pool
  FUN_80030fdc(param_1 + 0x1948); // Medium Stack Pool
  FUN_80030fdc(param_1 + 0x1970); // Large Stack Pool (drivers)
  FUN_80030fdc(param_1 + 0x1998); // Particle Pool
  FUN_80030fdc(param_1 + 0x19c0); // Oscillator Pool
  FUN_80030fdc(param_1 + 0x19e8); // Rain Pools
  return;
}

// SetOTMemSize
void FUN_8003b334(uint *param_1)

{
  uint uVar1;
  undefined4 uVar2;

  uVar1 = *param_1;

  // If not in main menu
  if ((uVar1 & 0x2000) == 0)
  {
	// If not in Adventure Arena
    if ((uVar1 & 0x100000) == 0) {

	  // If not in Battle
      if ((uVar1 & 0x20) == 0)
	  {
		// (72a*4 = 1ca8), numPlayers

		// if less than 3 players
        if (*(byte *)(param_1 + 0x72a) < 3)
		{
		  // +0x2a = gGT->0xA8 (&gGT->DB[0].otMem)
          FUN_80034a28(param_1 + 0x2a,0x2000);
          uVar2 = 0x2000;
        }

		// if 3 or 4 players
        else
		{
		  // +0x2a = gGT->0xA8 (&gGT->DB[0].otMem)
          FUN_80034a28(param_1 + 0x2a,0x3000);
          uVar2 = 0x3000;
        }
      }

	  // If in Battle
      else
	  {
		// +0x2a = gGT->0xA8 (&gGT->DB[0].otMem)
        FUN_80034a28(param_1 + 0x2a,0x8000);
        uVar2 = 0x8000;
      }
    }

	// If in Adventure Arena
    else
	{
	  // +0x2a = gGT->0xA8 (&gGT->DB[0].otMem)
      FUN_80034a28(param_1 + 0x2a,0x2c00);
      uVar2 = 0x2c00;
    }
  }

  // If in main menu
  else
  {
	// +0x2a = gGT->0xA8 (&gGT->DB[0].otMem)
    FUN_80034a28(param_1 + 0x2a,0x1800);
    uVar2 = 0x1800;
  }

  // +0x53 = gGT->0xA8+0xA4 (&gGT->DB[1].otMem)
  FUN_80034a28(param_1 + 0x53,uVar2);

  // s_ot_0__8008d2fc
  // "ot[0]"

  // MEMPACK_AllocMem
  // (72a*4 = 1ca8), numPlayers
  uVar1 = FUN_8003e874((uint)*(byte *)(param_1 + 0x72a) << 0xc | 0x18,s_ot_0__8008d2fc);

  // first index of "ot" pointer array
  param_1[0x632] = uVar1;

  // s_ot_1__8008d304
  // "ot[1]"

  // MEMPACK_AllocMem
  // (72a*4 = 1ca8), numPlayers
  uVar1 = FUN_8003e874((uint)*(byte *)(param_1 + 0x72a) << 0xc | 0x18,s_ot_1__8008d304);

  // second index of "ot" pointer array
  param_1[0x633] = uVar1;

  return;
}

// AllocateAllPools
void FUN_8003b43c(uint *param_1)
{
  // In theory, param_1 is PTR_DAT_8008d2ac

  undefined4 uVar1;
  int iVar2;
  uint uVar3;
  int *piVar4;
  undefined *puVar5;
  int iVar6;
  uint uVar7;
  undefined4 *puVar8;
  uint uVar9;

  // game mode
  uVar3 = *param_1;

  // This happens if you're in Adventure Arena
  uVar7 = 0x800;

  if (
		// If you're not in Adventure Arena
		((uVar3 & 0x100000) == 0) &&

		(
			// This value sets if you're not in adventure
			// arena, and not in the main menu
			uVar7 = 0x1000,

			// If you're in main menu
			(uVar3 & 0x2000) != 0
		)
	  )
  {
	// This is set if not in Adventure Arena,
	// and if you're in main menu
    uVar7 = 0x400;
  }

  // This happens if you're in Adventure Arena
  uVar9 = 0x800;

  // If you're not in Adventure Arena
  if ((uVar3 & 0x100000) == 0)
  {
	// If you're not in main menu
    if ((uVar3 & 0x2000) == 0) {
      uVar9 = 0x1000;
    }

	// If you're in main menu
    else {
      uVar9 = 0x400;

	  // if gGT->levelID == 40 (AdvGarage)
      if (param_1[0x684] == 0x28) {
        uVar9 = 0x800;
      }
    }
  }

  // add a bookmark
  FUN_8003e978();

  // param_1 + 0x634 =
  // PTR_DAT_8008d2ac + 0x18d0
  FUN_8003105c(param_1 + 0x634,uVar9 * 3 >> 7,0x48,"ThreadPool");

  // 8008d2ac + 0x18F8
  // instance size changes based on numPlayers
  FUN_8003105c(param_1 + 0x63e,uVar9 >> 5,
			  0x74 + (0x88 * (uint)(byte)PTR_DAT_8008d2ac[0x1ca8]),
			  "InstancePool");

  // 8008d2ac + 0x1920
  FUN_8003105c(param_1 + 0x648,uVar7 * 0x19 >> 10,0x48,"SmallStackPool");

  // 8008d2ac + 0x1948
  FUN_8003105c(param_1 + 0x652,uVar7 >> 7,0x88,"MediumStackPool");

  // if you're not in main menu
  if ((*param_1 & 0x2000) == 0)
  {
	// allocate 8 driver structs
    uVar3 = uVar7 >> 9;
  }

  // if you are in main menu
  else
  {
	// allocate 4 driver structs
    uVar3 = 4;
  }

  // 8008d2ac + 0x1970
  FUN_8003105c(param_1 + 0x65c,uVar3,0x670,"LargeStackPool");

  // 8008d2ac + 0x1998
  FUN_8003105c(param_1 + 0x666,uVar7 >> 5,0x7c,"ParticlePool");

  // 8008d2ac + 0x19c0
  FUN_8003105c(param_1 + 0x670,uVar7 >> 5,0x18,"OscillatorPool");

  // 8008d2ac + 0x19e8
  FUN_8003105c(param_1 + 0x67a,uVar7 >> 9,0x28,"RainPool");

  // MEMPACK_AllocMem
  uVar1 = FUN_8003e874(uVar9,"RENDER_BUCKET_INSTANCE");

  // render bucket instance
  *(undefined4 *)(PTR_DAT_8008d2ac + 0x1c94) = uVar1;

// ===========================================

  // 0x1920 (smallstack)
  // increment every pointer by 8 bytes,
  // to encapsulate "next" and "prev" in objects
  piVar4 = (int *)param_1[0x648];
  while (piVar4 != (int *)0x0) {
    *(int **)(piVar4 + 2) = piVar4 + 2;
    piVar4 = (int *)*piVar4;
  }
  
  // 0x1948 (medstack)
  // increment every pointer by 8 bytes,
  // to encapsulate "next" and "prev" in objects
  piVar4 = (int *)param_1[0x652];
  while (piVar4 != (int *)0x0) {
    *(int **)(piVar4 + 2) = piVar4 + 2;
    piVar4 = (int *)*piVar4;
  }
  
  // 0x1970 (largestack)
  // increment every pointer by 8 bytes,
  // to encapsulate "next" and "prev" in objects
  piVar4 = (int *)param_1[0x65c];
  puVar5 = PTR_DAT_8008d2ac;

  // for some reason, compiler optimization
  // manipulates gGT instead of the pointer,
  // but gGT gets reset at the end so whatever
  while (
			PTR_DAT_8008d2ac = puVar5,
			piVar4 != (int *)0x0
		)
  {
    *(int **)(piVar4 + 2) = piVar4 + 2;
    piVar4 = (int *)*piVar4;
    puVar5 = PTR_DAT_8008d2ac;
  }
  
  // loop count
  iVar6 = 0;

  // Number of screens != 0
  if (puVar5[0x1ca8] != '\0')
  {
	// global clip buffers
    puVar8 = &DAT_80084228;

	// ivar6 = 0; ivar6 < numScreens; iVar6++
    do {

	  // increment loop counter
      iVar6 = iVar6 + 1;

									// Level ID							// numScreens
      iVar2 = FUN_80034960(*(undefined4 *)(puVar5 + 0x1a10),(uint)(byte)puVar5[0x1ca8]);

	  // MEMPACK_AllocMem
      uVar1 = FUN_8003e874(iVar2 << 2,"Clip Buffer");

      puVar5 = PTR_DAT_8008d2ac;
      *puVar8 = uVar1;
      puVar8 = puVar8 + 1;
    } while (iVar6 < (int)(uint)(byte)puVar5[0x1ca8]);
  }
  return;
}


// AllocAllDrivers
void FUN_8003b6d0(uint *param_1)

{
  byte bVar1;
  uint *puVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;


  // 8 drivers
  iVar5 = 7;

  // 8009900C + 4*8
  puVar2 = param_1 + 7;

  // for iVar5 = 7; iVar5 > -1; iVar5--)
  do
  {
	// erase pointer to driver at 8009900C
    puVar2[0x93b] = 0;

	// decrement loop counter
    iVar5 = iVar5 + -1;

	// decrement pointer
    puVar2 = puVar2 + -1;

  } while (-1 < iVar5);

  // Set number of AIs to zero
  PTR_DAT_8008d2ac[0x1cab] = 0;

  // if game mode is not:
  // 	cutscene
  //	adventure arena
  //	main menu
  if ((*param_1 & 0x20102000) == 0)
  {
	// BOTS_Adv_AdjustDifficulty
    FUN_80012598();
  }

  // GhostBuffer_InitMemory
  FUN_80027838();

  // Check if 231 dll is loaded
  iVar5 = FUN_800348e8();

  // If it is loaded
  if (iVar5 != 0)
  {
	// RB_MinePool_Init
    FUN_800abfec();
  }

  // This is a strange way to count a loop

  // iVar5 = number of players - 1
  // (72a*4 = 1ca8), numPlayers
  iVar5 = (uint)*(byte *)(param_1 + 0x72a) - 1;

  // if that is zero or more, which it always will be,
  // knowing you can't have zero players in a game
  if (-1 < iVar5)
  {
    puVar2 = param_1 + iVar5;

	// spawn all players

	// iVar5 = numPlayers - 1; iVar5 > -1; iVar5--
	do {

	  // spawn a player, return Driver*
      uVar3 = FUN_80058ec0(iVar5);

	  // check that Driver is not nullptr
      if (uVar3 != 0)
	  {
		// put Driver pointer in 800990C array
        puVar2[0x93b] = uVar3;
      }

	  // strange iteration counter
      iVar5 = iVar5 + -1;

      puVar2 = puVar2 + -1;
    } while (-1 < iVar5);
  }
  if (
		(
			// not one of the following game modes ????
			((*param_1 & 0x2c122020) == 0) &&

			// number of screens is not 3
			(PTR_DAT_8008d2ac[0x1ca8] != '\x03')
		) &&
		(
			// assignment
			uVar3 = *(uint *)PTR_DAT_8008d2ac,

			// in Arcade or Adventure
			(uVar3 & 0x480000) != 0
		)
	)
  {
	// If you're in Boss Mode
	// 0x80000000
    if ((int)uVar3 < 0)
	{
	  // Make an AI for the boss

	  // Spawn AI for driver index 1,
	  // which is 2nd index of array
      FUN_80017164(1);
    }

	// If you're not in Boss Mode
    else {

      if (
			// If you are not in Adventure cup
			((uVar3 & 0x10000000) == 0) ||

			(
				// loop counter
				iVar5 = 1,

				// If you are in Adventure Cup, but not purple gem cup
				*(int *)(PTR_DAT_8008d2ac + 0x1e58) != 4
			)
		  )
	  {
		// (72a*4 = 1ca8), numPlayers
        bVar1 = *(byte *)(param_1 + 0x72a);

        uVar3 = (uint)bVar1;

		// If there is 1 human
        if (bVar1 == 1)
		{
		  // Number of drivers is 8
          uVar4 = 8;
        }

		// If this is not 1P mode
        else
		{
		  // Assume 4 drivers in 3P or 4P mode
          uVar4 = 4;

		  // If this is 2P mode
          if (bVar1 == 2)
		  {
			// There are 6 racers
            uVar4 = 6;
          }
        }

		// If the number of players <
		// desired number of drivers
        if (uVar3 < uVar4)
		{
          do
		  {
			// spawn an AI at this character index
            FUN_80017164(uVar3);

			// increment number loop counter
            uVar3 = uVar3 + 1;
          } while ((int)uVar3 < (int)uVar4);
        }
      }

	  // If you are in Purple Gem Cup
	  else
	  {
		// Spawn 4 AIs

		// for iVar5 = 1; iVar5 < 5; iVar5++
        do
		{
		  // Spawn an AI
          FUN_80017164(iVar5);

		  // increment loop counter
		  iVar5 = iVar5 + 1;

        } while (iVar5 < 5);
      }
    }
  }

  // If number of AIs is not zero
  if (PTR_DAT_8008d2ac[0x1cab] != '\0') {
    FUN_80028880(0x10,0x8080);
    FUN_80028880(0x11,0x8080);
  }

  // if this is main menu
  if ((*param_1 & 0x2000) != 0) {

	// uvar3 = number of screens
    uVar3 = (uint)(byte)PTR_DAT_8008d2ac[0x1ca8];

	// if number of screens is less than 4
    if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 4) {

	  param_1 = param_1 + uVar3;

	  // uVar3 = numScreens; uVar3 < 4; uVar3++
	  do {

		// spawn player, return Driver*
        uVar4 = FUN_80058ec0(uVar3);

		// make sure Driver isn't nullptr
        if (uVar4 != 0)
		{
		  // put Driver pointer in 800990C array
          param_1[0x93b] = uVar4;
        }

		// increment loop counter
        uVar3 = uVar3 + 1;

        param_1 = param_1 + 1;

      } while ((int)uVar3 < 4);
    }
  }

  // if you're in time trial, not main menu, not loading.
  // basically, if you're in time trial gameplay
  if ((*(uint *)PTR_DAT_8008d2ac & 0x20022000) == 0x20000)
  {
	// initialize all ghost instances,
	// assuming threads are already born
    FUN_80027b88();

	// initialize ghost recording system
    FUN_80027df4();
  }
  return;
}


// param1 is PTR_DAT_8008d2ac
// InitThreadBuckets
void FUN_8003b934(uint *param_1)

{
  byte bVar1;
  undefined *puVar2;
  undefined *puVar3;
  int iVar4;
  uint *puVar5;
  uint uVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;

  // enable collisions with all temporary walls
  // (adv hub doors, tiger temple teeth, etc)
  DAT_8008d728 = 0;

  // add a bookmark
  FUN_8003e978();

  puVar2 = PTR_DAT_8008d2ac;

  // loop counter
  iVar8 = 0;

  *(undefined4 *)(PTR_DAT_8008d2ac + 0x180) = 0x100;
  *(undefined4 *)(puVar2 + 0x274) = 0x100;

  // erase all threadBucket structs
  memset(param_1 + 0x6cb,0,0x168);

  // threadBuckets.player
  param_1[0x6cc] = 0x8008d30c; // PLAYER
  param_1[0x6cd] = 0x8008d314; // PLYR

  // threadBuckets.robot
  param_1[0x6d1] = 0x8008d31c; // ROBOT
  param_1[0x6d2] = 0x8008d324; // RBOT

  // threadBuckets.static
  param_1[0x6db] = 0x8008d32c; // STATIC
  param_1[0x6dc] = 0x8008d334; // STAT

  // threadBuckets.mine
  param_1[0x6e0] = 0x8008d33c; // MINE
  param_1[0x6e1] = 0x8008d33c; // MINE

  // threadBuckets.warppad
  param_1[0x6e5] = 0x8008d344; // WARPPAD
  param_1[0x6e6] = 0x8008d34c; // WRPD

  // threadBuckets.tracking
  param_1[0x6ea] = 0x80011434; // TRACKING
  param_1[0x6eb] = 0x8008d354; // TRKG

  // player threads can pause
  param_1[0x6ce] = 0;

  *(undefined *)(param_1 + 0x6cf) = 0x40;
  *(undefined *)((int)param_1 + 0x1b3d) = 0x40;
  *(undefined *)((int)param_1 + 0x1b3e) = 0x80;

  // robotcar threads can pause
  param_1[0x6d3] = 0;

  *(undefined *)(param_1 + 0x6d4) = 0x40;
  *(undefined *)((int)param_1 + 0x1b51) = 0x80;
  *(undefined *)((int)param_1 + 0x1b52) = 0x40;

  // static threads cant pause
  param_1[0x6dd] = 1;

  *(undefined *)(param_1 + 0x6de) = 0x40;
  *(undefined *)((int)param_1 + 0x1b79) = 0x80;
  *(undefined *)((int)param_1 + 0x1b7a) = 0x80;

  // mine threads can pause
  param_1[0x6e2] = 0;

  *(undefined *)(param_1 + 0x6e3) = 0x80;
  *(undefined *)((int)param_1 + 0x1b8d) = 0x80;
  *(undefined *)((int)param_1 + 0x1b8e) = 0x80;

  // warppad threads cant pause
  param_1[0x6e7] = 1;

  *(undefined *)(param_1 + 0x6e8) = 0x80;
  *(undefined *)((int)param_1 + 0x1ba1) = 0x40;
  *(undefined *)((int)param_1 + 0x1ba2) = 0x80;

  // tracking threads can pause
  param_1[0x6ec] = 0;

  *(undefined *)(param_1 + 0x6ed) = 0x80;

  // threadBuckets.burst
  param_1[0x6ef] = 0x8008d35c; // BURST
  param_1[0x6f0] = 0x8008d364; // BRST

  // threadBuckets.blowUp
  param_1[0x6f4] = 0x8008d36c; // BLOWUP
  param_1[0x6f5] = 0x8008d374; // BLWP

  // threadBuckets.turbo
  param_1[0x6f9] = 0x8008d37c; // TURBO
  param_1[0x6fa] = 0x8008d384; // TRBO

  // threadBuckets.spider
  param_1[0x6fe] = 0x8008d38c; // SPIDER
  param_1[0x6ff] = 0x8008d394; // SPDR

  // threadBuckets.follower
  param_1[0x703] = 0x80011440; // FOLLOWER
  param_1[0x704] = 0x8008d39c; // FLWR

  // threadBuckets.startText
  param_1[0x708] = 0x8001144c; // STARTTEXT

  *(undefined *)((int)param_1 + 0x1bb5) = 0x80;
  *(undefined *)((int)param_1 + 0x1bb6) = 0x80;

  // burst threads can pause
  param_1[0x6f1] = 0;

  *(undefined *)(param_1 + 0x6f2) = 0x80;
  *(undefined *)((int)param_1 + 0x1bc9) = 0x40;
  *(undefined *)((int)param_1 + 0x1bca) = 0x80;

  // blowup threads can pause
  param_1[0x6f6] = 0;

  *(undefined *)(param_1 + 0x6f7) = 0x80;
  *(undefined *)((int)param_1 + 0x1bdd) = 0x80;
  *(undefined *)((int)param_1 + 0x1bde) = 0;

  // turbo threads can pause
  param_1[0x6fb] = 0;

  *(undefined *)(param_1 + 0x6fc) = 0;
  *(undefined *)((int)param_1 + 0x1bf1) = 0;
  *(undefined *)((int)param_1 + 0x1bf2) = 0x80;

  // spider threads can pause
  param_1[0x700] = 0;

  *(undefined *)(param_1 + 0x701) = 0x80;
  *(undefined *)((int)param_1 + 0x1c05) = 0x40;
  *(undefined *)((int)param_1 + 0x1c06) = 0x80;

  // follower threads can pause
  param_1[0x705] = 0;

  *(undefined *)(param_1 + 0x706) = 0x40;
  *(undefined *)((int)param_1 + 0x1c19) = 0x40;
  *(undefined *)((int)param_1 + 0x1c1a) = 0x80;

  // threadBuckets.starttext
  param_1[0x709] = 0x8008d3a4; // STXT

  // threadBuckets.other
  param_1[0x70d] = 0x8008d3ac; // OTHER
  param_1[0x70e] = 0x8008d3b4; // OTHR

  // threadBuckets.akuAku
  param_1[0x712] = 0x8008d3bc; // AKUAKU
  param_1[0x713] = 0x8008d3c4; // AKUU

  // threadBuckets.camera
  param_1[0x717] = 0x8008d3cc; // CAMERA
  param_1[0x718] = 0x8008d3d4; // CAMR

  // threadBuckets.hud
  param_1[0x71c] = 0x8008d3dc; // HUD
  param_1[0x71d] = 0x8008d3e0; // THUD

  // threadBuckets.pause
  param_1[0x721] = 0x8008d3e8; // PAUSE

  // starttext threads can pause
  param_1[0x70a] = 0;

  *(undefined *)(param_1 + 0x70b) = 0x80;
  *(undefined *)((int)param_1 + 0x1c2d) = 0x80;
  *(undefined *)((int)param_1 + 0x1c2e) = 0x40;

  // "other" threads can pause
  param_1[0x70f] = 0;

  *(undefined *)(param_1 + 0x710) = 0x80;
  *(undefined *)((int)param_1 + 0x1c41) = 0x40;
  *(undefined *)((int)param_1 + 0x1c42) = 0x40;

  // aku threads can pause
  param_1[0x714] = 0;

  *(undefined *)(param_1 + 0x715) = 0x80;
  *(undefined *)((int)param_1 + 0x1c55) = 0x40;
  *(undefined *)((int)param_1 + 0x1c56) = 0x40;

  // camera threads cant pause
  param_1[0x719] = 1;

  *(undefined *)(param_1 + 0x71a) = 0x80;
  *(undefined *)((int)param_1 + 0x1c69) = 0x80;
  *(undefined *)((int)param_1 + 0x1c6a) = 0x40;

  // hud threads cant pause
  param_1[0x71e] = 1;

  *(undefined *)(param_1 + 0x71f) = 0x80;
  *(undefined *)((int)param_1 + 0x1c7d) = 0x80;
  *(undefined *)((int)param_1 + 0x1c7e) = 0x80;

  // PAUS
  param_1[0x722] = 0x8008d3f0;

  // pause threads can pause
  param_1[0x723] = 0;

  *(undefined *)(param_1 + 0x724) = 0;
  *(undefined *)((int)param_1 + 0x1c91) = 0x80;
  *(undefined *)((int)param_1 + 0x1c92) = 0;

  // reset particle linked lists
  param_1[0x727] = 0;
  param_1[0x728] = 0;

  // reset number of particles
  param_1[0x729] = 0;

  // deadc0ed, FUN_8006c684
  // RNG stuff
  param_1[0x94b] = 0x30215400;
  param_1[0x94c] = 0x493583fe;

  puVar5 = param_1;

  // for iVar8 = 0; iVar8 < 0xc; iVar8++
  do
  {
    puVar5[0x16c] = 0;
    *(undefined2 *)(puVar5 + 0x16a) = 1000;
    puVar5[0x1ad] = 0;
    puVar5[0x1ae] = 0;

	// increment loop counter
    iVar8 = iVar8 + 1;

    puVar5 = puVar5 + 0x4a;
  } while (iVar8 < 0xc);

  // erase everything in all pools
  FUN_8003b2d4(param_1);

  // 0x1d7c
  param_1[0x75f] =

	   // track length
	   // gGT -> level -> respawn points[0] -> dist_to_finish
       (uint)*(ushort *)(*(int *)(param_1[0x58] + 0x14c) + 6) *

	   // number of laps * 8
       (int)(char)PTR_DAT_8008d2ac[0x1d33] * 8;

  // AllocAllDrivers
  FUN_8003b6d0(param_1);

  // assume 1P fov
  uVar6 = 1;

  // if you are not in main menu
  if ((*param_1 & 0x2000) == 0)
  {
	// set FOV depending no numPlayers (72a*4 = 1ca8)
    uVar6 = (uint)*(byte *)(param_1 + 0x72a);
  }

  // Initialize four Camera110, 4 main screens
  FUN_800426f8(param_1 + 0x5a,0,uVar6);
  FUN_800426f8(param_1 + 0x9e,1,uVar6);
  FUN_800426f8(param_1 + 0xe2,2,uVar6);
  FUN_800426f8(param_1 + 0x126,3,uVar6);

  // pointer to Camera110_UI
  puVar5 = param_1 + 0x4e2;

  // Initialize Camera110
  FUN_800426f8(puVar5,0,1);

  // camera110_UI.offset6
  // rotX = 180 degrees
  *(undefined2 *)((int)param_1 + 0x138e) = 0x800;

  // Camera110_InitPsyqGeom
  FUN_80042910(puVar5);

  // Camera110_SetViewMatrix
  FUN_80042c04(puVar5);

  // loop counter
  iVar8 = 0;

  // If HUD is enabled
  if ((PTR_DAT_8008d2ac[0x1d31] & 2) != 0)
  {
	// HUD_INSTANCE_InitAll
    FUN_8004cec4();
  }

  // offset of 8008d2ac where P1's camera110 is
  iVar10 = 0x168;

  // offset of 8008d2ac where P1's camera is
  iVar9 = 0x1498;

  *(undefined4 *)(PTR_DAT_8008d2ac + 0x1cbc) = 2;
  puVar5 = param_1;

  // for iVar8 = 0; iVar8 < 8; iVar8++
  do
  {
	  // get pointer to player structure of each driver
    iVar4 = *(int *)(PTR_DAT_8008d2ac + iVar8 * 4 + 0x24ec);

	// if pointer is not nullptr
    if (iVar4 != 0)
	{
	  // get instance
      iVar7 = *(int *)(iVar4 + 0x1c);

	  // if loop iteration is less than number of screens,
	  // basically: if this driver is a human player
      if (iVar8 < (int)(uint)(byte)PTR_DAT_8008d2ac[0x1ca8])
	  {
		// param_1 + iVar9
		// pointer to cameraDC buffer

		// param_1 + iVar10
		// pointer to camera110 buffer

		// CAM_Init for all cameras
        FUN_80018818((int)param_1 + iVar9,iVar8,iVar4,(int)param_1 + iVar10);

        if (
				// If not in main menu (character selection, track selection, any part of it)
				((*(uint *)PTR_DAT_8008d2ac & 0x2000) == 0) ||
				(iVar8 < 1)
			)
		{
          // remove frozen camera flag
          uVar6 = puVar5[0x542] & 0xffff7fff;
        }
        else {
          
          // add frozen camera flag
          uVar6 = puVar5[0x542] | 0x8000;
        }
        
        // save flags
        puVar5[0x542] = uVar6;
      }

	  // if instance is valid
      if (iVar7 != 0)
	  {
		// set the scale (x, y, z)
        *(undefined2 *)(iVar7 + 0x1c) = 0xccc;
        *(undefined2 *)(iVar7 + 0x1e) = 0xccc;
        *(undefined2 *)(iVar7 + 0x20) = 0xccc;
      }
    }

	// += 0xDC (next cameraDC)
    puVar5 = puVar5 + 0x37;

	// increment offset to next camera110
    iVar10 = iVar10 + 0x110;

	// increment loop counter
    iVar8 = iVar8 + 1;

	// increment offset to next camera
    iVar9 = iVar9 + 0xdc;

  } while (iVar8 < 8);

  // If Level ID == 39
  // If you are drawing the main menu
  if (*(int *)(PTR_DAT_8008d2ac + 0x1a10) == 0x27)
  {
	// set demo countdown timer to 30 seconds
    *(undefined4 *)(PTR_DAT_8008d2ac + 0x1edc) = 900;
  }

  // INSTANCE_LevInitAll
  // copy InstDef to InstancePool
  FUN_80030ad4(*(undefined4 *)(param_1[0x58] + 0x10),*(undefined4 *)(param_1[0x58] + 0xc));

  // Debug_ToggleNormalSpawn == normal spawn
  if (PTR_DAT_8008d2ac[0x253f] != '\0')
  {
	// ToggleGameState_StartOfRace
    FUN_8003aee8(param_1,1);

    if (
			// if you're in Demo Mode
			(PTR_DAT_8008d2ac[0x1d32] != '\0') &&
			(
				// loop iteration counter
				iVar8 = 0,

				// if number of screens is not zero
				PTR_DAT_8008d2ac[0x1ca8] != '\0'
			)
		)
	{
	  // pointer counter (adds 4 each iteration)
      iVar9 = 0;

	  // for(int iVar8 = 0; iVar8 < numScreens; iVar8++)
      do
	  {
		// iterate loop counter
        iVar8 = iVar8 + 1;

		// turn driver into Robotcar
        FUN_80017318(*(undefined4 *)(PTR_DAT_8008d2ac + iVar9 + 0x24ec));

		// increment pointer
        iVar9 = iVar8 * 4;

						// number of screens
      } while (iVar8 < (int)(uint)(byte)PTR_DAT_8008d2ac[0x1ca8]);
    }
  }

  // execute all camera thread update functions
  FUN_800715e8(param_1[0x716]);

  // lev -> clearColor rgb
  DAT_8008cff4 = (uint)*(byte *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0xd8);
  DAT_8008cff8 = (uint)*(byte *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0xd9);
  DAT_8008cffc = (uint)*(byte *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0xda);

  // if number of screens is 1
  if (((PTR_DAT_8008d2ac[0x1ca8] == '\x01') &&
      (*(char *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x163) != '\0')) &&
     (*(char *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x167) != '\0'))
  {
	// set isbg of both DBs to false
    PTR_DAT_8008d2ac[0x30] = 0;
    PTR_DAT_8008d2ac[0xd4] = 0;
  }

  else
  {
	// set isbg of both DBs to true
    PTR_DAT_8008d2ac[0x30] = 1;
    PTR_DAT_8008d2ac[0xd4] = 1;
  }

  // gGT->db[0].drawenv.rgb
  PTR_DAT_8008d2ac[0x31] = *(undefined *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0xd8);
  PTR_DAT_8008d2ac[0x32] = *(undefined *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0xd9);
  PTR_DAT_8008d2ac[0x33] = *(undefined *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0xda);

  // gGT->db[1].drawenv.rgb
  PTR_DAT_8008d2ac[0xd5] = *(undefined *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0xd8);
  PTR_DAT_8008d2ac[0xd6] = *(undefined *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0xd9);
  PTR_DAT_8008d2ac[0xd7] = *(undefined *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0xda);

  if (
		// if LEV pointer is valid
		((int *)param_1[0x58] != (int *)0x0) &&

		// If LEV's meshInfo is valid
		(*(int *)param_1[0x58] != 0)
	 )
  {
	// INSTANCE_LevInstancesStart
    FUN_8003116c();
  }

  // VisMem_Clear
  FUN_8003af84(param_1);

  // RainBufferInit
  FUN_8003b008(param_1);

  // gGT->lev (0x58*4 = 0x160)
  uVar6 = param_1[0x58];

  iVar8 = 3;

  // 0x73b*4 = 0x1CEC
  // animates water, 1P mode
  FUN_8006d79c(

	// gGT->0x1cec
	param_1[0x73b],

	// lev->water_count
	*(undefined4 *)(uVar6 + 0x34),

	// lev->water_ptr
	*(undefined4 *)(uVar6 + 0x38),

	// lev->restart (maskgrab)
	*(undefined4 *)(uVar6 + 0x44),

	*(undefined4 *)(uVar6 + 0x28)
  );

  *(undefined2 *)(param_1 + 0x4e7) = 0x1000;
  *(undefined2 *)((int)param_1 + 0x139e) = 0x200;

  // (72a*4 = 1ca8), numPlayers
  bVar1 = *(byte *)(param_1 + 0x72a);

  if (bVar1 == 0) {
    trap(0x1c00);
  }
  if (((uint)bVar1 == 0xffffffff) && ((int)*(short *)(param_1[0x58] + 0x17c) == -0x80000000)) {
    trap(0x1800);
  }

  // number of stars per screen = number of stars in level, divided by number of players
  *(short *)(param_1 + 0x6c3) = (short)((int)*(short *)(param_1[0x58] + 0x17c) / (int)(uint)bVar1);

  // other star-related data
  *(undefined2 *)((int)param_1 + 0x1b0e) = *(undefined2 *)(param_1[0x58] + 0x17e);
  *(undefined2 *)(param_1 + 0x6c4) = *(undefined2 *)(param_1[0x58] + 0x180);
  puVar2 = PTR_DAT_8008d2ac;
  puVar3 = PTR_DAT_8008d2ac + 0xc;
  *(undefined2 *)((int)param_1 + 0x1b12) = *(undefined2 *)(param_1[0x58] + 0x182);

  // erase confetti data
  *(undefined4 *)(puVar2 + 0x1b00) = 0;
  *(undefined2 *)(puVar2 + 0x1b04) = 0;
  *(undefined2 *)(puVar2 + 0x1b06) = 0;

  // confetti VelY is negative, to move downward
  *(undefined4 *)(puVar2 + 0x1b08) = 0xfffffff6;

  // clear array of confetti winners
  do {
    *(undefined4 *)(puVar3 + 0x2558) = 0;
    puVar2 = PTR_DAT_8008d2ac;
    iVar8 = iVar8 + -1;
    puVar3 = puVar3 + -4;
  } while (-1 < iVar8);

  // If you are in a cutscene
  if ((*(uint *)PTR_DAT_8008d2ac & 0x20000000) != 0)
  {
	// CameraDC, freecam mode
    *(undefined2 *)(PTR_DAT_8008d2ac + 0x1532) = 3;

	// disable all HUD flags
    puVar2[0x1d31] = 0;
  }

  // BOTS_EmptyFunc
  FUN_80012560();

  if (
		// If you're in Adventure Arena
		((*(uint *)PTR_DAT_8008d2ac & 0x100000) != 0) &&

		// podium reward
		(*(short *)(PTR_DAT_8008d2ac + 0x2572) != 0)
	  )
  {
	// CS_Podium_FullScene_Init
    FUN_800b0300();
  }

  // If you are in a cutscene
  if ((*(uint *)PTR_DAT_8008d2ac & 0x20000000) != 0)
  {
	// CS_LevCamera_OnInit
    FUN_800b087c();
  }

  // RivalWeapons_Init
  FUN_80040850();

  return;
}


// Get Level ID from String
int FUN_8003c1d4(char *param_1)
{
  int iVar1;
  undefined *puVar2;
  int iVar3;

  // iteration counter
  iVar3 = 0;

  // array of pointers to strings
  // First pointer goes to "proto8" (dingo canyon)
  // Second pointer goes to "proto9" (dragon mines)
  // etc
  puVar2 = &DAT_80083a80;

  do
  {
	// get length of string
    iVar1 = strlen(*(char **)(puVar2 + 4));

	// compare pointer string to parameter
    iVar1 = strncmp(*(char **)(puVar2 + 4),param_1,iVar1);

	// if you found it
    if (iVar1 == 0)
	{
	  // return iteration, which is Level ID
      return iVar3;
    }

	// keep count of iterations
    iVar3 = iVar3 + 1;

	// go to next pointer
    puVar2 = puVar2 + 0x18;

	// loop 0x40 times (64)
	// there are only 64 levels
  } while (iVar3 < 0x41);

  // If you loop through all 64 and find
  // nothing, return zero as a result
  return 0;
}


// VRAM_ClearToBlack
void FUN_8003c248(void)

{
	// Clear the full VRAM (1024x512) to black

#if 0
	// Function is really [this]
	// but in-line makes the
	// disassembly more complex

	RECT r;
    setRECT(&r, 0, 0, 1024, 512);
    ClearImage2(&r, 0,0,0);
	DrawSync(0);
#endif

  DRAWENV DStack128;
  undefined4 local_20;
  undefined local_1c;
  undefined local_1b;
  undefined local_1a;
  undefined local_19;
  undefined2 local_18;
  undefined2 local_16;
  undefined2 local_14;
  undefined2 local_12;

  SetDefDrawEnv(&DStack128,0,0,0x400,0x200);
  DStack128.dfe = '\x01';
  PutDrawEnv(&DStack128);
  local_19 = 2;
  local_1c = 0;
  local_1b = 0;
  local_1a = 0;
  local_14 = 0x3ff;
  local_12 = 0x1ff;
  local_18 = 0;
  local_16 = 0;
  local_20 = 0x3ffffff;
  DrawOTag(&local_20);
  local_14 = 0x3ff;
  local_12 = 1;
  local_18 = 0;
  local_16 = 0x1ff;
  DrawOTag(&local_20);
  return;
}


// refresh screen during Intro
void FUN_8003c310(void)

{
  int iVar1;
  int iVar2;
  short *psVar3;
  int iVar4;
  RECT local_48;
  DR_MOVE local_40;
  short local_28;
  undefined2 local_26;
  short local_20;
  undefined2 local_1e;

  local_28 = 0;
  local_26 = 0x100;
  local_20 = 0;
  local_1e = 0x128;
  iVar4 = 0;
  do {
    iVar1 = 0;
    psVar3 = (short *)((int)&local_28 + ((iVar4 << 0x10) >> 0xf));
    do {
      local_48.y = 0x10c;
      local_48.w = 0x100;
      local_48.h = 0xd8;
      local_48.x = *psVar3 + 0x200;
      SetDrawMove(&local_40,&local_48,(int)*psVar3,
                  (int)*(short *)((int)&local_20 + ((iVar1 << 0x10) >> 0xf)));
      local_40.tag = local_40.tag | 0xffffff;
      DrawOTag(&local_40);
      DrawSync(0);
      iVar1 = iVar1 + 1;
      iVar2 = iVar4 + 1;
    } while (iVar1 * 0x10000 >> 0x10 < 2);
    iVar4 = iVar2;
  } while (iVar2 * 0x10000 >> 0x10 < 2);
  return;
}


// EndGame
void FUN_8003c41c(void)
{
  // set callback and save callback
  EnterCriticalSection();
  DrawSyncCallback(DAT_8008d3f8);
  ExitCriticalSection();

  StopCallback();

  // deinitialize memory card
  FUN_8003d95c();

  PadStopCom();
  ResetGraph(3);
  VSyncCallback(0);

  // stop RCnt
  FUN_8004b370();

  return;
}

// Launch Spyro 2 Demo
void FUN_8003c480(void)

{
  // CTR_ErrorScreen
  FUN_80021c94(0,0,0);

  // Music_Stop
  FUN_8002e4ec();

  // howl_StopAudio
  // clear backup, destroy music, destroy all fx
  FUN_8002c8a8(1,1,1);

  // Bank_DestroyAll
  FUN_800298e4();

  // Disable Audio
  FUN_8002ac94();

  VSync(0x1e);

  // end the game
  FUN_8003c41c();

  _96_remove();
  _96_init();

  // http://www.psxdev.net/forum/viewtopic.php?t=516
  // LoadExec("cdrom:\\MAIN.EXE;1", 0x801FFFF0, 0);
  LoadExec("cdrom:\\SPYRO2.EXE;1",(ulong)&DAT_801fff00,0);
  return;
}

// LoadVlcTable_Callback
void FUN_8003c508(void)

{
  // 8008D400, VLC is now loaded
  uGp00000494 = 1;
  
  return;
}

// LoadVlcTable
void FUN_8003c518(void)

{
  int iVar1;

  // VLC is not loaded
  DAT_8008d400 = 0;

  // DAT_8008d09c is the Pointer to "cd position of bigfile"
  iVar1 = *(int *)(DAT_8008d09c + 0xf0c) + 0x7ff;
  if (iVar1 < 0) {
    iVar1 = *(int *)(DAT_8008d09c + 0xf0c) + 0xffe;
  }

  //this one is labeled vlctable, loads some file that looks like array
  //google hints it's something for video decoding?

  // MEMPACK_AllocMem
  DAT_8008d3fc = FUN_8003e874((iVar1 >> 0xb) << 0xb,"VlcTable");

  // This table is passed as parameter to DecDCTvlc2

  // DAT_8008d09c is the Pointer to "cd position of bigfile"
  // '1' for readfile
  FUN_80032d30(DAT_8008d09c,1,0x1e0,DAT_8008d3fc,&FUN_8003c508);
  return;
}


// address 8003c58c
undefined4 main(void)

{
  ushort *puVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  undefined *puVar6;
  undefined *puVar7;
  int iVar8;
  uint uVar9;
  uint uVar10;
  uint *puVar11;
  undefined4 uVar12;
  undefined auStack40 [8];

  __main();
  do {

	// if game state is 5
    if (DAT_8008d0f4 == 5)
	{
	  // sep3
	  // printf("MAINSTATE_END\n");

	  // end the game
      FUN_8003c41c();

	  // quit
      return 0;
    }

	// LOAD_NextQueuedFile
	// execute loading queue
    FUN_80032dc0();

	// CDSYS_PauseAtEnd
    FUN_8001d06c();

	// determine game state
    switch(DAT_8008d0f4) {

	// Initialize Game (happens once)
    case 0:
      memset(PTR_DAT_8008d2ac,0,0x2584);

	  // Set Video Mode to NTSC
      SetVideoMode(0);

      ResetCallback();

	  // We have 2mb RAM total
      FUN_8003e740(0x200000);

	  // LOAD_InitCD
	  // also sets debug variables to "off"
      FUN_80031c58();

	  // CheckeredFlag_SetFullyOffScreen
	  // Without this, checkered flag will draw one
	  // frame after the copyright page draws, then
	  // go away once Naughty Dog Box scene is ready
      FUN_80044058();

      ResetGraph(0);
      SetGraphDebug(0);

	  // VRAM_ClearToBlack
      FUN_8003c248();

      SetDispMask(1);
      SetDefDrawEnv((DRAWENV *)(PTR_DAT_8008d2ac + 0x18),0,0,0x200,0xd8);
      SetDefDrawEnv((DRAWENV *)(PTR_DAT_8008d2ac + 0xbc),0,0x128,0x200,0xd8);
      SetDefDispEnv((DISPENV *)(PTR_DAT_8008d2ac + 0x74),0,0x128,0x200,0xd8);
      SetDefDispEnv((DISPENV *)(PTR_DAT_8008d2ac + 0x118),0,0,0x200,0xd8);

	  // structure to game modes, cheats, etc
      puVar6 = PTR_DAT_8008d2ac;

	  // db[0].drawEnv.isbg
	  PTR_DAT_8008d2ac[0x30] = 1;

	  // structure to game modes, cheats, etc
      puVar7 = PTR_DAT_8008d2ac;

	  // DispEnv 1 at 8008d2ac + 0x74
      *(undefined2 *)(puVar6 + 0x7c) = 0;
      *(undefined2 *)(puVar6 + 0x7e) = 0xc;
      *(undefined2 *)(puVar6 + 0x80) = 0x100;
      *(undefined2 *)(puVar6 + 0x82) = 0xd8;

	  // DispEnv 2 at 8008d2ac + 0x118
      *(undefined2 *)(puVar6 + 0x120) = 0;
      *(undefined2 *)(puVar6 + 0x122) = 0xc;
      *(undefined2 *)(puVar6 + 0x124) = 0x100;
      *(undefined2 *)(puVar6 + 0x126) = 0xd8;

	  // db[0].drawEnv
	  // r0, g0, b0
      puVar7[0x31] = 0;
      PTR_DAT_8008d2ac[0x32] = 0;
      PTR_DAT_8008d2ac[0x33] = 0;

	  // db[1].drawEnv
	  // isbg, r0, g0, b0
      PTR_DAT_8008d2ac[0xd4] = 1;
      PTR_DAT_8008d2ac[0xd5] = 0;
      PTR_DAT_8008d2ac[0xd6] = 0;
      PTR_DAT_8008d2ac[0xd7] = 0;

	  // structure to game modes, cheats, etc
      puVar6 = PTR_DAT_8008d2ac;

	  // default number of lives in battle,
	  // this is left over from prototypes, useless in retail
	  *(undefined4 *)(PTR_DAT_8008d2ac + 0x1d80) = 5;

	  // 30 second counter?
      *(undefined2 *)(puVar6 + 0x1d52) = 9000;

	  // set lap count to 3
      puVar6[0x1d33] = 3;

	  // structure to game modes, cheats, etc
      puVar7 = PTR_DAT_8008d2ac;

	  // weapons enabled in battle
	  *(uint *)(puVar6 + 0x1da0) = *(uint *)(puVar6 + 0x1da0) | 0x34de;

	  // set number of screens to 1
	  puVar7[0x1ca8] = 1;

	  // set number of players to 1
      PTR_DAT_8008d2ac[0x1ca9] = 1;

	  // structure to game modes, cheats, etc
      puVar6 = PTR_DAT_8008d2ac;

	  // player teams in battle
	  *(undefined4 *)(PTR_DAT_8008d2ac + 0x1da4) = 0x3020100;

	  // traffic light countdown timer, set to negative one second
      *(undefined4 *)(puVar6 + 0x1d0c) = 0xfffffc40;

	  // start rcnt
      FUN_8004b31c();

	  // set callback and save callback
	  EnterCriticalSection();
      DAT_8008d3f8 = DrawSyncCallback(&FUN_80034a80);
	  ExitCriticalSection();

	  // MEMCARD_InitCard
      FUN_8003d7d8();

	  VSync(0);

	  // initialize controller systems
      FUN_800251ac(PTR_DAT_8008d2b0);

      VSync(0);

	  // check number of controllers connected
	  FUN_800255b4(PTR_DAT_8008d2b0);

	  // Get CD Position fo BIGFILE
      DAT_8008d86c = FUN_80031c78("\\BIGFILE.BIG;1");

	  // Load Language
	  // takes 1 as hard-coded parameter for English
	  // PAL SCES02105 has this same function (different name), and calls it multiple times

	  // takes Pointer to "cd position of bigfile"
      FUN_80032b50(DAT_8008d86c,1);

	  // GAMEPROG_NewGame_OnBoot
      FUN_80026e48();

	  // overlayIndex_null_notUsed
      PTR_DAT_8008d2ac[0x2542] = 0;

	  // structure to game modes, cheats, etc
      puVar6 = PTR_DAT_8008d2ac;

	  // set level ID to naughty dog box (0x29 = 41)
	  *(undefined4 *)(PTR_DAT_8008d2ac + 0x1a10) = 0x29;

	  // set level name to "ndi"
      *(undefined4 *)(puVar6 + 0x1a14) = DAT_8008d16c;

	  // initialize geometry

	  // width / 2, and height / 2
      SetGeomOffset(0x100,0x78);

	  // "distance" to screen, alters FOV
      SetGeomScreen(0x140);

	  InitGeom();

	  // RenderBucket_InitDepthGTE
      FUN_8006ae74();

	  // BakeMathGTE
      FUN_80057884();

	  // structure to game modes, cheats, etc
      puVar6 = PTR_DAT_8008d2ac;

	  // overlayIndex_EndOfRace
      PTR_DAT_8008d2ac[0x2543] = 0xff;

	  // structure to game modes, cheats, etc
      puVar7 = PTR_DAT_8008d2ac;

	  // swapchainIndex
      *(undefined4 *)(puVar6 + 0xc) = 0;

	  // backBuffer
      *(undefined **)(puVar6 + 0x10) = puVar6 + 0x18;

	  // overlayIndex_LOD
      puVar7[0x2540] = 0xff;

	  // overlayIndex_Threads
      PTR_DAT_8008d2ac[0x2541] = 0xff;

	  PutDispEnv(PTR_DAT_8008d2ac + 0x118);
      PutDrawEnv(PTR_DAT_8008d2ac + 0xbc);
      DrawSync(0);

	  // Load Intro TIM for "SCEA Presents" page from VRAM file
	  // DAT_8008d86c is the Pointer to "cd position of bigfile"
	  // Add a bookmark before loading (param_3 is 0 in the call)
      FUN_80031fdc(DAT_8008d86c,0x1fd,0,auStack40,0xffffffff);

	  // refresh screen during Intro
	  FUN_8003c310();

	  // \SOUNDS\KART.HWL;1
	  // enable audio if not already enabled
      FUN_80029988(s__sounds_kart_hwl_1_80084214);

      VSyncCallback(FUN_80034aa4);

	  // Music_SetIntro
      FUN_8002dd24();

	  // CseqMusic_StopAll
      FUN_80029258();

	  // CseqMusic_Start
	  FUN_80028c78(0,0,0,0,0);

	  // Music_Start
      FUN_8002e524(0);

	  // CDSYS_XAPlay(CDSYS_XA_TYPE_EXTRA, 0x50);
	  // "Start your engines, for Sony Computer..."
      FUN_8001cdb4(1,0x50);

      // Loop until XA stops playing
      while (DAT_8008d708 != 0)
	  {
		// CDSYS_PauseAtEnd
        FUN_8001d06c();
      }

	  // DecalGlobal_Clear
      FUN_80022b9c(PTR_DAT_8008d2ac);

	  // This loads UI textures (ui_textures.vram)
	  // This includes traffic lights, font, and more
	  // In nopsx VRAM debug viewer:
	  // 	the area between 2 screen buffers and top right corner in vram
	  // DAT_8008d86c is the Pointer to "cd position of bigfile"
	  // Add a bookmark before loading (param_3 is 0 in the call)
      FUN_80031fdc(DAT_8008d86c,0x102,0,auStack40,0xffffffff);

	  // structure to game modes, cheats, etc
      puVar6 = PTR_DAT_8008d2ac;

	  // change game state (in switch statement) to 3
      DAT_8008d0f4 = 3;

	  // set loading state to begin
      DAT_8008d0f8 = 0;

      puVar1 = (ushort *)(PTR_DAT_8008d2ac + 0x2570);

	  // Turn on the "Loading..." flag
      *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac | 0x40000000;
      *(ushort *)(puVar6 + 0x2570) = *puVar1 & 0xfffe;
      break;

	// Happens on first frame that loading ends
    case 1:

	  // deactivate pause
      FUN_80024c08(PTR_DAT_8008d2ac);

	  // count number of times you lost race
      FUN_8003d068();

	  // Voiceline_ClearTimeStamp
      FUN_8002caa8();

	  // structure to game modes, cheats, etc
      puVar6 = PTR_DAT_8008d2ac;

	  // Disable End-Of-Race menu
      *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac & 0xffdfffff;

	  // Level ID == 39
	  // Main Menu Level ID
      if (*(int *)(puVar6 + 0x1a10) == 0x27)
	  {
LAB_8003ca68:

		// CheckeredFlag_IsFullyOffScreen
        iVar8 = FUN_80043f28();
        if (iVar8 != 0)
		{
		  // CheckeredFlag_SetFullyOnScreen
          FUN_8004402c();
        }
      }

	  // if not main menu
      else
	  {
		// CheckeredFlag_IsFullyOnScreen
        iVar8 = FUN_80043f1c();

		// if not
        if (iVar8 == 0) {

		  // If Level ID == 39
		  // If you are drawing main menu, set fully on screen
          if (*(int *)(PTR_DAT_8008d2ac + 0x1a10) == 0x27) goto LAB_8003ca68;
        }

		// if it is
        else
		{
		  // checkered flag, begin transition off-screen
          FUN_80043fb0(2);
        }
      }
	  
	  // EffectSfxRain_Reset
      FUN_8002451c(PTR_DAT_8008d2ac);

	  // GAMEPROG_GetPtrHighScoreTrack
      FUN_80026e80();

	  // initialize all threadBuckets
      FUN_8003b934(PTR_DAT_8008d2ac);

	  // get number of controllers connected
      FUN_800255b4(PTR_DAT_8008d2b0);

	  // set sound to unpaused
      DAT_8008d8a4 = 0;

	  // Init_EngineAudio_AllPlayers
      FUN_80058ba4();

	  // This is in OnlineCTR
	  // 9 = intro cutscene
	  // 10 = traffic lights
	  // 11 = racing

	  // Arcade-Style track starts with intro cutscene
      uVar12 = 9;

      if (
			// If Level ID is less than 18
			// One of the Arcade tracks
			(*(uint *)(PTR_DAT_8008d2ac + 0x1a10) < 0x12) ||
			(
				// Battle-Style track starts with traffic lights
				uVar12 = 10,

				// Level ID >= 18 and < 23
				// Battle tracks
				*(uint *)(PTR_DAT_8008d2ac + 0x1a10) - 0x12 < 7)
			)
	  {
		// Audio_SetState_Safe
        FUN_8002d4cc(uVar12);
      }

	  // change game state (in switch-statement) to 3
      DAT_8008d0f4 = 3;

      *(ushort *)(PTR_DAT_8008d2ac + 0x2570) = *(ushort *)(PTR_DAT_8008d2ac + 0x2570) & 0xfffe;
      break;

	// Reset stage, reset music
    case 2:

	  // Audio_SetState_Safe
	  // restarts music
      FUN_8002d4cc(1);

	  // MEMPACK_PopState
      FUN_8003e9d0();

	  // INSTANCE_LevInstancesStop
	  // ignore threads, because we PopState,
	  // so the threadpool will reset anyway
      FUN_80031268(**(undefined4 **)(PTR_DAT_8008d2ac + 0x160),0);

	  // change game state (in switch-statement) to 1
      DAT_8008d0f4 = 1;
      break;

	// Main Gameplay Update
	// Makes up all normal interaction with the game
    case 3:

	  // if loading is not finished
      if (DAT_8008d0f8 != -1)
	  {
		// CheckeredFlag_IsFullyOnScreen
        iVar8 = FUN_80043f1c();

        if (
			(
				// wait for flag to be fully on-screen
				// before starting to load the game
				(iVar8 == 1) ||

				// If Level ID is Naughty Dog Box
				(*(int *)(PTR_DAT_8008d2ac + 0x1a10) == 0x29)
			) || (DAT_8008d036 != 0)
		   )
        {
		  // Turn on the "Loading..." flag
          *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac | 0x40000000;
        }

	    // structure to game modes, cheats, etc
        puVar11 = (uint *)PTR_DAT_8008d2ac;

		// get loading stage
        iVar8 = DAT_8008d0f8;

		// elapsed milliseconds per frame, locked 32 here,
		// impacts speed of flag wave during "loading...",
		// but does not impact speed of flying text
        *(undefined4 *)(PTR_DAT_8008d2ac + 0x1d04) = 0x20;

		// if loading is finished, but still in
		// "loading mode", and if pools dont need
		// to be reset (maybe for credits?)
        if (iVar8 == -5)
		{
		  // CheckeredFlag_IsFullyOnScreen
          iVar8 = FUN_80043f1c();
          if (iVar8 == 1)
		  {
			// set game state to 2,
			// to initialize the world,
			// does not initialize pools
            DAT_8008d0f4 = 2;

			// nothing is being loaded anymore
            DAT_8008d0f8 = -1;

			// Turn off the "Loading..." flag
            *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac & 0xbfffffff;
            break;
          }
        }

		// if something is being loaded
        else
		{
		  // if not waiting for checkered flag to cover screen
          if (iVar8 != -4)
		  {
			// if loading VLC
            if (iVar8 == -6) 
			{
			  // if VLC is not loaded, quit.
			  // we know when it's done from a load callback
              if (DAT_8008d400 != 1) break;
            }
			
            else
			{
			  // DAT_8008d86c is the Pointer to "cd position of bigfile"
              DAT_8008d0f8 = FUN_80033610(puVar11,iVar8,DAT_8008d86c);
			  
			  // if did not just complete loading stage 9, skip logic to 
			  // load VLC, skip logic to end loading, skip logic if "if == -4",
			  // goto rendering. We can skip rendering by changing BNE on 
			  // 0x8003cca0 to "bne v0, v1, 8003cf3c"
              if (DAT_8008d0f8 != -2) goto LAB_8003ccf8;

			  // if stage 9 of loading was just finished

              if (
					// If Level ID is 39
					// If you're in main menu
					(*(int *)(PTR_DAT_8008d2ac + 0x1a10) == 0x27) ||

					(
						puVar11 = (uint *)PTR_DAT_8008d2ac,

						// If Level ID == 64
						// Scrapbook
						*(int *)(PTR_DAT_8008d2ac + 0x1a10) == 0x40
					)
				 )
              {
				// LoadVlcTable
                FUN_8003c518();

				// start loading VLC (scroll up to iVar8 == -6)
                DAT_8008d0f8 = -6;
				
				// go back to start of main() loop
				// "j LAB_8003cf3c"
                break;
              }
            }

			// loading is finished
            DAT_8008d0f8 = -1;

			// set game state to 1, to initialize world,
			// as well as initialize all pools
            DAT_8008d0f4 = 1;

			// remove "Loading..." flag from gGT
			*puVar11 = *puVar11 & 0xbfffffff;
			
			// go back to start of main() loop,
			// "j LAB_8003cf3c"
            break;
          }
		  
		  // if == -4, if waiting for checkered flag

		  // CheckeredFlag_IsFullyOnScreen
          iVar8 = FUN_80043f1c();

		  // Get address of GameTracker
          puVar6 = PTR_DAT_8008d2ac;

		  // when loading is done, remove this
		  // from gGT + 8
          uVar5 = DAT_8008d10c;

		  // when loading is done, add this
		  // from gGT + 8
          uVar4 = DAT_8008d108;

		  // when loading is done, remove this
		  // from gGT + 0
          uVar3 = DAT_8008d104;

		  // when loading is done, add this
		  // from gGT + 0
          uVar2 = DAT_8008d100;

		  // wait for flag to be fully on-screen
          if (iVar8 == 1)
		  {
			// reset the four variables
            DAT_8008d100 = 0;
            DAT_8008d104 = 0;
            DAT_8008d108 = 0;
            DAT_8008d10c = 0;

			// Get current gGT + 8
            uVar10 = *(uint *)(PTR_DAT_8008d2ac + 8);

            PTR_DAT_8008d2ac[0x1d31] = PTR_DAT_8008d2ac[0x1d31] & 0xf7;

			// get lev ID being loaded
			iVar8 = (int)DAT_8008d0fc;

			// Get current gGT + 0
            uVar9 = *(uint *)puVar6;

			// Make all desired changes
            *(uint *)(puVar6 + 8) = uVar10 | uVar4;
            *(uint *)puVar6 = uVar9 | uVar2;
            *(uint *)puVar6 = (uVar9 | uVar2) & ~uVar3;
            *(uint *)(puVar6 + 8) = (uVar10 | uVar4) & ~uVar5;

			// start loading (generic)
			FUN_8003cf7c(iVar8);
          }

		  // if not fully on screen
          else
		  {
			// CheckeredFlag_IsFullyOffScreen
            iVar8 = FUN_80043f28();
            if (iVar8 == 1)
			{
			  // checkered flag, begin transition on-screen
              FUN_80043fb0(1);
            }
          }
        }
      }
LAB_8003ccf8:
      puVar6 = PTR_DAT_8008d2ac;
      if (
			(
				// Check value of traffic lights
				(-0x3c0 < *(int *)(PTR_DAT_8008d2ac + 0x1d0c)) &&

				// if not drawing intro race cutscene and if not paused
				((*(uint *)PTR_DAT_8008d2ac & 0x4f) == 0)
			) &&

			(
				// amount of milliseconds on Traffic Lights - elapsed milliseconds per frame, ~32
				iVar8 = *(int *)(PTR_DAT_8008d2ac + 0x1d0c) - *(int *)(PTR_DAT_8008d2ac + 0x1d04),

				// decrease amount of time on Traffic Lights
				*(int *)(PTR_DAT_8008d2ac + 0x1d0c) = iVar8,

				// if countdown has gone down far enough
				// for traffic lights to go off-screen
				iVar8 < -0x3c0
			)
		 )
	  {
		// set a floor value, so countdown can't go farther negative
        *(undefined4 *)(puVar6 + 0x1d0c) = 0xfffffc40;
      }

	  // frame counter
      DAT_8008d970 = DAT_8008d970 + 1;

	  // Process all controller input
      FUN_800262d0(PTR_DAT_8008d2b0);

	  // Start new frame (ClearOTagR)
      FUN_80034bbc(PTR_DAT_8008d2ac,PTR_DAT_8008d2b0);

      if (
			// If you're in Demo Mode
			(PTR_DAT_8008d2ac[0x1d32] != '\0') &&

			// Turn off HUD
			(PTR_DAT_8008d2ac[0x1d31] = PTR_DAT_8008d2ac[0x1d31] & 0xfe,

			// main struct used for [0x1d32]
			puVar6 = PTR_DAT_8008d2ac,

			// if game is not loading
			DAT_8008d0f8 == -1)
		 )
	  {
		// All this code is for the 30-second timer within Demo Mode,
		// To see 30-second timer in Main Menu, go to FUN_00001604 in 230.c

		// 0x1edc is a countdown the timer
		// pressing (or holding) any button sets it to zero

		// Get the current value of the countdown timer
        iVar8 = *(int *)(PTR_DAT_8008d2ac + 0x1edc);

		// subtract one frame
        *(int *)(PTR_DAT_8008d2ac + 0x1edc) = iVar8 + -1;

		// check to see if time ran out
        if (iVar8 + -1 < 1)
		{
		  // leave demo mode
          puVar6[0x1d32] = 0;

		  // set number of players to 1
          PTR_DAT_8008d2ac[0x1ca9] = 1;

		  // go to main menu
          DAT_8008d97c = 0;
LAB_8003ce08:
			// load LEV of main menu
          FUN_8003cfc0(0x27);
        }

		// if time remains on the timer
        else {

		  // if any button is pressed by anyone
          if (*(int *)(PTR_DAT_8008d2b0 + 0x290) != 0)
		  {
			// leave demo mode
            puVar6[0x1d32] = 0;

            goto LAB_8003ce08;
          }
        }

		// if number of screens is 1
        if (PTR_DAT_8008d2ac[0x1ca8] == '\x01')
		{
		  // Draw text near top of screen
          uVar12 = 0x23;
        }

		// if this is multiplayer
        else
		{
		  // draw text halfway to top of screen
          uVar12 = 100;
        }

		// DAT_8008d878 + 0x8c0
		// DEMO MODE\rPRESS ANY BUTTON TO EXIT

		// DecalFont_DrawMultiLine
        FUN_80022b34(*(undefined4 *)(DAT_8008d878 + 0x8c0),0x100,uVar12,0x200,2,0xffff8000);
      }

	  // If you are not in a loading screen
      if ((*(uint *)PTR_DAT_8008d2ac & 0x40000000) == 0)
	  {
		// GameplayUpdateLoop
        FUN_80034d54(PTR_DAT_8008d2ac,PTR_DAT_8008d2b0);
      }

	  // If you are in demo mode
      if (PTR_DAT_8008d2ac[0x1d32] != '\0')
	  {
		// Turn off HUD
        PTR_DAT_8008d2ac[0x1d31] = PTR_DAT_8008d2ac[0x1d31] & 0xfe;
      }

	  // controller input structure
      puVar7 = PTR_DAT_8008d2b0;

	  // game state structure
      puVar6 = PTR_DAT_8008d2ac;

	  // reset vsync calls between drawsync
      *(undefined4 *)(PTR_DAT_8008d2ac + 0x1ce0) = 0;

	  // RenderFrame
      FUN_80035e70(puVar6,puVar7);

	  // if mask is talking in Adventure Hub
      if (DAT_8008d888 != 0)
	  {
		// AH_MaskHint_PerFrame
        FUN_800b4470();
      }
      break;

	// In theory, this is left over from the demos,
	// which would "timeout" and restart after sitting idle
    case 4:

	  // sep3
	  // printf("MAINSTATE_EXIT\n");

	  // erase all data past the
	  // last 3 bookmarks, if there
	  // that many exist

	  // MEMPACK_PopState x3
      FUN_8003e9d0();
      FUN_8003e9d0();
      FUN_8003e9d0();

	  // CTR_ErrorScreen
      FUN_80021c94(0,0,0);

	  // Music_Stop
      FUN_8002e4ec();

	  // howl_StopAudio
	  // clear backup, destroy music, destroy all fx
      FUN_8002c8a8(1,1,1);

	  // Bank_DestroyAll
      FUN_800298e4();

	  // Disable Audio
      FUN_8002ac94();

	  // GAMEPAD_SetMainMode,
	  // param1 is PtrGamepadSystem
      FUN_80025208(PTR_DAT_8008d2b0);

	  // Set vsync to 2 FPS
      VSync(0x1e);

	  // set game state to zero
      DAT_8008d0f4 = 0;

	  // Notice how there is no "break"
	  // That means the switch-statement repeats
	  // and the game goes back to state 0, to
	  // initialize all over again
    }
  } while( true );
}


// Level_StartLoading
void FUN_8003cf7c(short param_1)

{
  // howl_StopAudio
  // clear backup,
  // keep music,
  // destroy "most" fx, let menu fx play to end
  FUN_8002c8a8(1,0,0);

  // deactivate pause
  FUN_80024c08(PTR_DAT_8008d2ac);

  // start loading level
  FUN_80034874((int)param_1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// Level_RequestNewLEV
void FUN_8003cfc0(short param_1)

{
  int iVar1;

  // Turn off HUD
  PTR_DAT_8008d2ac[0x1d31] = PTR_DAT_8008d2ac[0x1d31] & 0xfe;

  // CheckeredFlag_IsFullyOffScreen
  iVar1 = FUN_80043f28();

  if (iVar1 == 1)
  {
	// checkered flag, begin transition on-screen
    FUN_80043fb0(1);
  }

  // CheckeredFlag_ResetTextAnim
  FUN_80044290();

  // loading stage = -4 (waiting for checkered flag)
  DAT_8008d0f8 = -4;

  // set LEV to load
  _DAT_8008d0fc = (int)param_1;

  return;
}

// ClearStandings_BattleVS
void FUN_8003d024(void)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;

  iVar4 = 0;
  iVar3 = 0;

  // loop for 4 players
  do {
    iVar2 = 0;
    iVar1 = iVar3;

	// loop for 3 positions (1st, 2nd, 3rd)
    do
	{
	  // gp->340 = 8008d2ac
	  // gGT->1e80 = standingsPoints
      *(undefined4 *)(iGp00000340 + iVar1 + 0x1e80) = 0;
      iVar2 = iVar2 + 1;
      iVar1 = iVar1 + 4;
    } while (iVar2 < 3);
    iVar4 = iVar4 + 1;
    iVar3 = iVar3 + 0xc;
  } while (iVar4 < 4);
  return;
}



void FUN_8003d068(void)

{
  char cVar1;
  undefined *puVar2;
  undefined *puVar3;
  int iVar4;
  int iVar5;
  undefined *puVar6;

  // loop counter
  uint uVar7;
  uVar7 = 0;

  // Turn off HUD
  PTR_DAT_8008d2ac[0x1d31] = PTR_DAT_8008d2ac[0x1d31] & 0xfe;

  puVar2 = PTR_DAT_8008d2ac;
  puVar6 = PTR_DAT_8008d2ac;

  // for iVar7 = 0; iVar7 < 4; iVar7++
  do
  {
	// if someone is on this battle team
    if ((*(uint *)(puVar2 + 0x1dd8) & 1 << (uVar7 & 0x1f)) == 0)
	{
	  // -500
	  // team points
      *(undefined4 *)(puVar6 + 0x1d90) = 0xfffffe0c;
    }

    else
	{
	  // erase team points
      *(undefined4 *)(puVar6 + 0x1d90) = 0;
    }
    puVar3 = PTR_DAT_8008d2ac;

	// increment loop counter
    uVar7 = uVar7 + 1;

    puVar6 = puVar6 + 4;

  } while ((int)uVar7 < 4);

  // TurboDisplayPos_Only1P
  DAT_8008d2a8 = 0;
  DAT_8008d2aa = 0;

  // no winners, nobody gets confetti
  *(undefined4 *)(PTR_DAT_8008d2ac + 0x2568) = 0;

  *(undefined4 *)(puVar3 + 0x1e28) = 0;	// numCrystalsInLEV
  *(undefined4 *)(puVar3 + 0x1e2c) = 0; // timeCratesInLEV
  *(undefined4 *)(puVar3 + 0x1d44) = 0;
  *(undefined4 *)(puVar3 + 0x1e20) = 0; // frozenTimeRemaining
  *(undefined4 *)(puVar3 + 0x1ec0) = 0; // zero missiles in play
  *(undefined4 *)(puVar3 + 0x1ec4) = 0; // zero players with 3 missiles


  uVar7 = *(uint *)PTR_DAT_8008d2ac;


  // If you're not in Adventure Mode
  if ((uVar7 & 0x80000) == 0) {
    return;
  }

  // if the lap you're on is not the 3rd lap,
  // then it means you just loaded track, and did not hit "Restart"
  if (*(char *)(*(int *)(puVar3 + 0x24ec) + 0x44) != '\x02') {
    return;
  }

  // If you're in Adventure Cup or Relic
  if ((uVar7 & 0x14000000) != 0) {
    return;
  }

  // if you're in boss mode
  if ((int)uVar7 < 0)
  {
	// bossID 0-5
    iVar4 = *(int *)(puVar3 + 0x1eb8);

	// pointer to somewhere random,
	// assembly is generated with pointers to
	// random places when accessing global variables,
	// there is no significance to this address
	iVar5 = iVar4 + -0x7ff70445; // 0x8008FBBB

	// get number of times lost boss race
    cVar1 = (&DAT_8008fbeb)[iVar4];

	// if you lost less than 10 times, increment counter
    if ((char)(&DAT_8008fbeb)[iVar4] < '\n') goto LAB_8003d178;
  }

  // Level ID
  iVar4 = *(int *)(PTR_DAT_8008d2ac + 0x1a10);

  // 0x8fba4 is where the adventure profile (currently loaded) begins
  iVar5 = (int)&DAT_8008fba4 + iVar4;

  // get number of times lost this race
  cVar1 = (&DAT_8008fbd4)[iVar4];

  // if you lost more than 10 times, quit
  if ('\t' < (char)(&DAT_8008fbd4)[iVar4]) {
    return;
  }

LAB_8003d178:

  // increment number of times lost this event
  *(char *)(iVar5 + 0x30) = cVar1 + '\x01';
  return;
}


// MATH_Sin(angle)
int FUN_8003d184(uint param_1)

{
  int iVar1;

  // approximate trigonometry
  iVar1 = *(int *)(&DAT_800845a0 + (param_1 & 0x3ff) * 4);

  // if (0 < angle < 90) or (180 < angle < 270)
  if ((param_1 & 0x400) == 0)
  {
	// shift bottom 2-byte to become top 2-byte
    iVar1 = iVar1 << 0x10;
  }

  // move top 2-byte to bottom 2-byte,
  // and make top 2-byte zero
  iVar1 = iVar1 >> 0x10;

  // if (angle > 180)
  if ((param_1 & 0x800) != 0)
  {
	// make negative
    iVar1 = -iVar1;
  }
  return iVar1;
}


// MATH_Cos(angle)
int FUN_8003d1c0(uint param_1)

{
  int iVar1;

  // if (0 < angle < 90) or (180 < angle < 270)
  if ((param_1 & 0x400) == 0)
  {
	// approximate trigonometry, then shift top bytes to bottom
    iVar1 = *(int *)(&DAT_800845a0 + (param_1 & 0x3ff) * 4) >> 0x10;

	// if (180 < angle < 270)
	if ((param_1 & 0x800) != 0)
	{
	  // convert negativeY into positiveX
      iVar1 = -iVar1;
    }
  }

  // if (90 < angle < 180) or (270 < angle < 360)
  else
  {
	// approximate trigonometry, use bottom bytes
    iVar1 = (int)(short)*(int *)(&DAT_800845a0 + (param_1 & 0x3ff) * 4);

	// if (90 < angle < 180)
	if ((param_1 & 0x800) == 0)
	{
	  // convert negativeX into positiveX
      iVar1 = -iVar1;
    }
  }
  return iVar1;
}


// prediction
// f(i,j) = f(i,0) * f(1,j)
// f(i,0) = approx square root
// f(1,j) = 2^(j/2)
int FUN_8003d214(uint param_1,int param_2)

{
  bool bVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  int iVar5;
  int iVar6;

  uVar2 = 0;
  iVar3 = (param_2 >> 1) + 0xf;
  iVar5 = 0;
  do {
    uVar2 = uVar2 << 2 | param_1 >> 0x1e;
    iVar6 = iVar5 * 2;
    uVar4 = iVar5 * 4 + 1;
    param_1 = param_1 << 2;
    if (uVar4 <= uVar2) {
      uVar2 = uVar2 - uVar4;
      iVar6 = iVar6 + 1;
    }
    bVar1 = iVar3 != 0;
    iVar3 = iVar3 + -1;
    iVar5 = iVar6;
  } while (bVar1);
  return iVar6;
}


// param_1 matrix output
// param_2 matrix input
// only used by flamejet and PapuPyramidPlant for hitbox collision,
// also used by missile, probably hitbox again
// MATH_HitboxMatrix
undefined8 FUN_8003d264(uint *param_1,uint *param_2)

{
  short sVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;

  // transpose matrix
  uVar5 = *param_2 & 0xffff | param_2[1] & 0xffff0000;
  uVar4 = param_2[3] & 0xffff | *param_2 & 0xffff0000;
  uVar2 = param_2[2] & 0xffff | param_2[3] & 0xffff0000;
  uVar3 = param_2[1] & 0xffff | param_2[2] & 0xffff0000;
  sVar1 = *(short *)(param_2 + 4);

  // store matrix into GTE
  gte_ldR11R12(uVar5);
  gte_ldR13R21(uVar4);
  gte_ldR22R23(uVar2);
  gte_ldR31R32(uVar3);
  gte_ldR33((int)sVar1);

  gte_ldVXY0(-param_2[5] & 0xffff | param_2[6] * -0x10000);
  gte_ldVZ0(-param_2[7]);
  gte_rtv0();

  *param_1 = uVar5;
  param_1[1] = uVar4;
  param_1[2] = uVar2;
  param_1[3] = uVar3;

  *(short *)(param_1 + 4) = sVar1;
  gte_stlvnl((VECTOR *)(param_1 + 5));

  return;
}


// MATH_VectorLength
void FUN_8003d328(undefined4 *param_1)

{
  undefined4 uVar1;

  gte_ldR11R12(*param_1);
  gte_ldR13R21((int)*(short *)(param_1 + 1));
  gte_ldVXY0(*param_1);
  gte_ldVZ0((int)*(short *)(param_1 + 1));
  gte_mvmva(0,0,0,3,0);

  uVar1 = gte_stMAC1();
  SquareRoot0(uVar1);

  return;
}


// MATH_VectorNormalize
int FUN_8003d378(short *param_1)

{
  int iVar1;

  // MATH_VectorLength
  iVar1 = FUN_8003d328();

  if (iVar1 != 0) {
    if (iVar1 == 0) {
      trap(0x1c00);
    }
    if ((iVar1 == -1) && ((int)*param_1 << 0xc == -0x80000000)) {
      trap(0x1800);
    }
    if (iVar1 == 0) {
      trap(0x1c00);
    }
    if ((iVar1 == -1) && ((int)param_1[1] << 0xc == -0x80000000)) {
      trap(0x1800);
    }
    if (iVar1 == 0) {
      trap(0x1c00);
    }
    if ((iVar1 == -1) && ((int)param_1[2] << 0xc == -0x80000000)) {
      trap(0x1800);
    }
    *param_1 = (short)(((int)*param_1 << 0xc) / iVar1);
    param_1[1] = (short)(((int)param_1[1] << 0xc) / iVar1);
    param_1[2] = (short)(((int)param_1[2] << 0xc) / iVar1);
  }
  return iVar1;
}

// MATH_MatrixMul
// Inspired by Spyro 2 USA demo, with 94426 variable names
void FUN_8003d460(int param_1,MATRIX *param_2,int param_3)

{
  // param_3 - input
  // param_1 - output
  FUN_8006c3b0(param_1, param_2, param_3);

  // FUN_8006c6f0
  // param_2 - matrix input
  // param_3+14 - vector input
  // param_1+14 - vector output
  ApplyMatrixLV(param_2,(VECTOR *)(param_3 + 0x14),(VECTOR *)(param_1 + 0x14));

  // Add Matrix2's position to Matrix1's position
  *(int *)(param_1 + 0x14) = *(int *)(param_1 + 0x14) + param_2->t[0];
  *(int *)(param_1 + 0x18) = *(int *)(param_1 + 0x18) + param_2->t[1];
  *(int *)(param_1 + 0x1c) = *(int *)(param_1 + 0x1c) + param_2->t[2];
  return;
}


// MEMCARD_SetIcon
void FUN_8003d4e4(short param_1)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 *puVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;

  // copy destination
  // overwrite psyq hand
  puVar2 = (undefined4 *)&DAT_800857a0;

  // pick a copy source
  if (param_1 == 0)
  {
	// ghost
    puVar1 = &DAT_800856a0;
  }

  else
  {
	// crash head
    puVar1 = &DAT_800855a0;
  }

  // last byte of copy (0x100)
  puVar3 = puVar1 + 0x40;

  // copy
  do {
    uVar4 = puVar1[1];
    uVar5 = puVar1[2];
    uVar6 = puVar1[3];
    *puVar2 = *puVar1;
    puVar2[1] = uVar4;
    puVar2[2] = uVar5;
    puVar2[3] = uVar6;
    puVar1 = puVar1 + 4;
    puVar2 = puVar2 + 4;
  } while (puVar1 != puVar3);
  return;
}


//calculates crc16 with polynomial p = x^16+x^12+x^5+x^0 (0x11021)
//this is a part of save game checksum calculation
//https://github.com/ShendoXT/memcardrex-plugins/blob/master/CTREdit/CTREdit/Additional/Crash Team Racing save.txt

// MEMCARD_CRC16
//param_1 - crc
//param_2 - data
uint FUN_8003d540(uint param_1,int param_2)

{
  uint uVar1;
  uint uVar2;

  //iterator i
  uVar1 = 7;

  //for (i = 7; i >= 0; i--)
  do {
    uVar2 = param_1 << 1;
    param_1 = uVar2 | param_2 >> (uVar1 & 0x1f) & 1U;

    if ((uVar2 & 0x10000) != 0) {
      param_1 = param_1 ^ 0x11021;
    }

    //i--
    uVar1 = uVar1 - 1;
  } while (-1 < (int)uVar1);

  return param_1;
}


// MEMCARD_ChecksumSave
// calculates memcard data stream checksum
// param_1 - pointer to data
// param_2 - data length (0x3e00, or 0x1680)
void FUN_8003d584(byte *param_1,int param_2)

{
  undefined2 uVar1;
  byte *pbVar2;
  undefined4 uVar3;
  int iVar4;

  //keep in mind checksum bytes are added in the end of stream

  //crc
  uVar3 = 0;
  //iterator i
  iVar4 = 0;
  //pointer to data
  pbVar2 = param_1;

  //if data length > 0
  if (0 < param_2 + -2) {
    //for each entry in data
    do {
      //i++
      iVar4 = iVar4 + 1;

      //crc = MEMCARD_CRC16
      uVar3 = FUN_8003d540(uVar3,(uint)*pbVar2);

	  //set next data entry
      pbVar2 = param_1 + iVar4;

	} while (iVar4 < param_2 + -2);
  }

  //save data crc to global
  DAT_8008d8d0 = uVar3;

  // finalize checksum
  // MEMCARD_CRC16 twice
  uVar3 = FUN_8003d540(uVar3,0);
  uVar1 = FUN_8003d540(uVar3,0);

  //write checksum to data (last 2 bytes)
  param_1[iVar4] = (byte)((ushort)uVar1 >> 8);
  param_1[iVar4 + 1] = (byte)uVar1;

  return;
}

// MEMCARD_ChecksumLoad
// assumed validates memcard data checksum,
// check full memcard, all 0x1680 bytes
uint FUN_8003d618(int param_1,int param_2)

{
  bool bVar1;
  undefined4 uVar2;
  int iVar3;
  uint uVar4;
  int iVar5;

  // previous crc
  uVar2 = DAT_8008d8d0;

  // CRC start byte
  iVar3 = DAT_8008d8b0;

  // if not the last frame of crc16
  if ((DAT_8008d8cc & 8) == 0)
  {
	// CRC end byte (start + 0x200)
    iVar5 = DAT_8008d8b0 + 0x200;
    bVar1 = false;
    if (iVar5 < param_2 + -2) goto LAB_8003d688;
  }

  // else
  // if last frame of crc16

  bVar1 = true;

  // CRC end byte (last two bytes of data)
  iVar5 = param_2 + -2;

LAB_8003d688:

  // from start to end
  while (iVar3 < iVar5)
  {
	// MEMCARD_CRC16
    uVar2 = FUN_8003d540(uVar2,(uint)*(byte *)(param_1 + iVar3));
    iVar3 = iVar3 + 1;
  }

  // save last byte, as the next checksum's start byte
  DAT_8008d8b0 = iVar3;

  // new crc
  DAT_8008d8d0 = uVar2;

  // if last frame of crc16
  if (bVar1)
  {
	// finalize checksum
	// MEMCARD_CRC16 twice
    uVar2 = FUN_8003d540(uVar2,(uint)*(byte *)(param_1 + iVar3));
	iVar3 = FUN_8003d540(uVar2,(uint)*(byte *)(param_1 + iVar3 + 1));

	// return if it worked or not
	uVar4 = (uint)(iVar3 != 0);
  }

  // if not last frame of crc16
  else
  {
	// return 7, which means repeat step
    uVar4 = 7;
  }
  return uVar4;
}


// MEMCARD_StringInit
// param1 - slotIndex
uint * FUN_8003d6e8(uint param_1,uint *param_2)

{
  // if no paramter given
  if (param_2 == (uint *)0x0)
  {
	// "bu00:\0"
    param_2 = &DAT_8008d414;
  }

  // set "buXX"
  // where XX depends on param_1
  *param_2 = (((int)param_1 >> 4 & 1U) + 0x30) * 0x10000 |
             ((param_1 & 3) + 0x30) * 0x1000000 | 0x7562;

  // set bytes [4,5] with a short,
  // which sets ':' and '\0'
  *(undefined2 *)(param_2 + 1) = 0x3a;

  return param_2;
}


// MEMCARD_StringSet
// param2 slotIndex
void FUN_8003d730(char *param_1,undefined4 param_2,char *param_3)

{
  char cVar1;
  int iVar2;
  int iVar3;

  // MEMCARD_StringInit
  FUN_8003d6e8(param_2,param_1);

  // index
  iVar3 = 0;

  // destination string
  if (*param_1 != '\0') {
    iVar2 = 1;
    do
	{
	  // loop counter
      iVar3 = iVar2;
      iVar2 = iVar3 + 1;

	  // loop to end of string
    } while (param_1[iVar3] != '\0');
  }

  // source string
  cVar1 = *param_3;

  // copy string from param_3 to param_1
  while ((cVar1 != '\0' && (iVar3 < 0x3f))) {
    cVar1 = *param_3;
    param_3 = param_3 + 1;
    param_1[iVar3] = cVar1;
    cVar1 = *param_3;
    iVar3 = iVar3 + 1;
  }
  param_1[iVar3] = '\0';
  return;
}


//8003d7d8 - initializes memcard stuff - MEMCARD_Init
//- creates 8 events (4 per card?)
//- calls InitCARD and StartCARD
void FUN_8003d7d8(void)

{
  // This section was copy/pasted by Naughty Dog,
  // psx\sample\memcard\CARD\CARD.C lines 84 to 101

  // -------------------------------------------
  EnterCriticalSection();
  DAT_8008d8d4 = OpenEvent(SwCARD,EvSpIOE,		EvMdNOINTR,	NULL);
  DAT_8008d8c4 = OpenEvent(SwCARD,EvSpERROR,	EvMdNOINTR,	NULL);
  DAT_8008d8e0 = OpenEvent(SwCARD,EvSpTIMOUT,	EvMdNOINTR,	NULL);
  DAT_8008d8c0 = OpenEvent(SwCARD,EvSpNEW,		EvMdNOINTR,	NULL);
  DAT_8008d8c8 = OpenEvent(HwCARD,EvSpIOE,		EvMdNOINTR,	NULL);
  DAT_8008d8b4 = OpenEvent(HwCARD,EvSpERROR,	EvMdNOINTR,	NULL);
  DAT_8008d8dc = OpenEvent(HwCARD,EvSpTIMOUT,	EvMdNOINTR,	NULL);
  DAT_8008d8bc = OpenEvent(HwCARD,EvSpNEW,		EvMdNOINTR,	NULL);
  EnableEvent(DAT_8008d8d4);
  EnableEvent(DAT_8008d8c4);
  EnableEvent(DAT_8008d8e0);
  EnableEvent(DAT_8008d8c0);
  EnableEvent(DAT_8008d8c8);
  EnableEvent(DAT_8008d8b4);
  EnableEvent(DAT_8008d8dc);
  EnableEvent(DAT_8008d8bc);
  ExitCriticalSection();
  // -------------------------------------------

  InitCARD(0);
  StartCARD();
  _bu_init();

  // This tells us a memory card exists,
  // If it is set to 0 with Cheat Engine,
  // the game will think the card is unformatted
  DAT_8008d8cc = 1;
  return;
}


//8003d95c - closes memcard stuff - MEMCARD_Close
void FUN_8003d95c(void)

{
  // This function was copy/pasted by Naughty Dog,
  // psx\sample\memcard\CARD\CARD.C lines 355 to 365

  StopCARD();
  EnterCriticalSection();
  CloseEvent(DAT_8008d8d4);
  CloseEvent(DAT_8008d8c4);
  CloseEvent(DAT_8008d8e0);
  CloseEvent(DAT_8008d8c0);
  CloseEvent(DAT_8008d8c8);
  CloseEvent(DAT_8008d8b4);
  CloseEvent(DAT_8008d8dc);
  CloseEvent(DAT_8008d8bc);
  ExitCriticalSection();

  return;
}


//8003d9ec - tests for 1st slot events - MEMCARD_GetNextSlot1Event
//- basically gets index of first triggered event or returns 7, which is no event i guess. 7 is 3 bits.
undefined4 FUN_8003d9ec(void)

{
  long lVar1;
  undefined4 uVar2;

  lVar1 = TestEvent(DAT_8008d8d4);
  uVar2 = 0;
  if (lVar1 != 1) {
    lVar1 = TestEvent(DAT_8008d8c4);
    uVar2 = 1;
    if (lVar1 != 1) {
      lVar1 = TestEvent(DAT_8008d8e0);
      if (lVar1 == 1) {
        uVar2 = 2;
      }
      else {
        lVar1 = TestEvent(DAT_8008d8c0);
        uVar2 = 3;
        if (lVar1 != 1) {
          uVar2 = 7;
        }
      }
    }
  }
  return uVar2;
}


//8003da68 - tests for 2nd slot events - MEMCARD_GetNextSlot2Event
//- same as above but for other 4 events
undefined4 FUN_8003da68(void)

{
  long lVar1;
  undefined4 uVar2;

  lVar1 = TestEvent(DAT_8008d8c8);
  uVar2 = 0;
  if (lVar1 != 1) {
    lVar1 = TestEvent(DAT_8008d8b4);
    uVar2 = 1;
    if (lVar1 != 1) {
      lVar1 = TestEvent(DAT_8008d8dc);
      if (lVar1 == 1) {
        uVar2 = 2;
      }
      else {
        lVar1 = TestEvent(DAT_8008d8bc);
        uVar2 = 3;
        if (lVar1 != 1) {
          uVar2 = 7;
        }
      }
    }
  }
  return uVar2;
}


//8003dae4 - waits for event on slot1 to happen and returns index - MEMCARD_WaitForSlot1Event
//- loops while there is not a single true for mc1 events
//- only called once, wonder how that doesn't halt the exection. or maybe it does, are there hangs when save/load happens?
undefined4 FUN_8003dae4(void)

{
  long lVar1;

  do {
    lVar1 = TestEvent(DAT_8008d8c8);
    if (lVar1 == 1) {
      return 0;
    }
    lVar1 = TestEvent(DAT_8008d8b4);
    if (lVar1 == 1) {
      return 1;
    }
    lVar1 = TestEvent(DAT_8008d8dc);
    if (lVar1 == 1) {
      return 2;
    }
    lVar1 = TestEvent(DAT_8008d8bc);
  } while (lVar1 != 1);
  return 3;
}


//8003db54 - tests all events until no events left for both cards - MEMCARD_SkipEvents
//maybe it's a kind of clearing function?
undefined4 FUN_8003db54(void)

{
  int iVar1;

  do
  {
	// MEMCARD_GetNextSlot1Event
    iVar1 = FUN_8003d9ec();
  } while (iVar1 != 7);

  do
  {
	// MEMCARD_GetNextSlot2Event
    iVar1 = FUN_8003da68();
  } while (iVar1 != 7);

  return 7;
}


// MEMCARD_NewTask
// param1 slotIndex
// param2 name
// param3 pointer to memcard
// param4 memcard size
undefined4 FUN_8003db98(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)

{
  // card slot
  DAT_8008d8b8 = param_1;

  // MEMCARD_StringSet
  FUN_8003d730(&DAT_800990a4,param_1,param_2);

  // pointer to memcard 800992e4
  DAT_8008d408 = param_3;

  // reset to 8 attempts before quitting
  DAT_8008d410 = 8;

  // memcard size (0x1680)
  DAT_8008d8a8 = param_4;

  return 0;
}


// close memcard file
void FUN_8003dbf8(void)
{
  // if file is open
  if (DAT_8008d40c != -1)
  {
	// close the file
    close(DAT_8008d40c);

	// no file is open
    DAT_8008d40c = -1;
  }
  DAT_8008d404 = 0;
  return;
}


// Read from memory card
// parameters are start and end offsets
undefined4 FUN_8003dc30(long param_1,long param_2)

{
  long lVar1;

  // seek to start offset
  lVar1 = lseek(DAT_8008d40c,param_1,0);

  // read to memcard buffer in RAM, param_2 size
  if ((lVar1 != -1) && (lVar1 = read(DAT_8008d40c,DAT_8008d408,param_2), lVar1 != -1)) {
    return 7;
  }

  // close memcard file
  FUN_8003dbf8();

  return 1;
}


// Write to memory card
// start offset, pointer to data, end offset
undefined4 FUN_8003dc9c(long param_1,void *param_2,long param_3)

{
  long lVar1;

  // seek to start offset
  lVar1 = lseek(DAT_8008d40c,param_1,0);

  // write to memcard buffer in RAM, param_3 size
  if ((lVar1 != -1) && (lVar1 = write(DAT_8008d40c,param_2,param_3), lVar1 != -1)) {
    return 7;
  }

  // close memcard file
  FUN_8003dbf8();

  return 1;
}


// MEMCARD_GetFreeBytes
// param1 slotIndex
void FUN_8003dd10(undefined4 param_1)

{
  DIRENTRY *pDVar1;
  DIRENTRY *pDVar2;
  int iVar3;
  DIRENTRY DStack56;

  // MEMCARD_StringSet
  FUN_8003d730(&DAT_800990a4,param_1,&DAT_8008d41c);

  // bytes used on memory card
  iVar3 = 0;

  // 800990a4
  // string for directory and file of save that is in use
  pDVar1 = firstfile(&DAT_800990a4,&DStack56);

  pDVar2 = &DStack56;
  while (pDVar1 == pDVar2)
  {
	// add to number of bytes used
    iVar3 = iVar3 + (DStack56.size + 0x1fffU & 0xffffe000);

	pDVar2 = nextfile(&DStack56);
  }

  // bytes left on memcard = 128kb - used size
  DAT_8008d8ac = 0x1e000 - iVar3;

  return;
}



int FUN_8003ddac(void)

{
  long lVar1;
  undefined4 uVar2;
  int iVar3;
  int iVar4;
  undefined *puVar5;

  switch(DAT_8008d404) {

  case 1:

	// MEMCARD_GetNextSlot1Event
	iVar3 = FUN_8003d9ec();

    if (iVar3 == 0)
	{
	  // If this is the first frame of the main game loop,
	  // after all initialization is done
      if ((DAT_8008d8cc & 1) != 0)
	  {
		// allow the "switch" statement to go to stage 2
        DAT_8008d404 = 2;

		// do something wtih both memcards if they're present
        FUN_8003db54();

		// ??
		// spam read until it works?
        do {
          lVar1 = _card_load(DAT_8008d8b8);
        } while (lVar1 != 1);

        return 7;
      }
      if ((DAT_8008d8cc & 2) == 0)
	  {
		// zero free bytes on memcard
        DAT_8008d8ac = 0;

		iVar3 = 5;
      }
    }

    else {
      if (iVar3 != 3) {
        if (iVar3 != 7) {
          DAT_8008d404 = 0;

		  // zero free bytes on memcard
          DAT_8008d8ac = 0;

          return iVar3;
        }
        return 7;
      }
      FUN_8003db54();
      do {
        lVar1 = _card_clear(DAT_8008d8b8);
      } while (lVar1 != 1);
      iVar3 = FUN_8003dae4();
      if (iVar3 == 0) {
        DAT_8008d404 = 2;
        FUN_8003db54();
        do {
          lVar1 = _card_load(DAT_8008d8b8);
        } while (lVar1 != 1);
        return 7;
      }
    }

    goto LAB_8003df38;

  case 2:

	// MEMCARD_GetNextSlot1Event
	iVar3 = FUN_8003d9ec();

    if (iVar3 == 0) {
      DAT_8008d404 = 0;
      DAT_8008d8cc = DAT_8008d8cc & 0xfffffffe | 2;

	  // MEMCARD_GetFreeBytes
      FUN_8003dd10(DAT_8008d8b8);

      return 3;
    }
    if (iVar3 == 3) {
      DAT_8008d404 = 0;
      DAT_8008d8cc = DAT_8008d8cc & 0xfffffffc;
      return 5;
    }
    if (iVar3 == 7) {
      return 7;
    }
LAB_8003df38:
    DAT_8008d404 = 0;
    break;

  case 3:

	// MEMCARD_GetNextSlot1Event
    iVar3 = FUN_8003d9ec();

    if (iVar3 == 0)
	{
	  // allow "switch" statement to go to stage 4
      DAT_8008d404 = 4;

	  DAT_8008d8d8 = (((uint)(byte)DAT_8008d408[2] & 0xf) + 1) * 0x80;

	  // Read memory card
      uVar2 = FUN_8003dc30(DAT_8008d8d8,DAT_8008d8a8);

	  if ((DAT_8008d8d8 + DAT_8008d8a8 + 0x1fff >> 0xd < (int)(uint)(byte)DAT_8008d408[3]) &&
         (1 < DAT_8008d8d8 + DAT_8008d8a8 * 2 + 0x1fff >> 0xd)) {
        DAT_8008d8cc = DAT_8008d8cc & 0xfffffffb;
        return uVar2;
      }
      DAT_8008d8cc = DAT_8008d8cc | 4;
      return uVar2;
    }

    if (iVar3 == 7) {
      return 7;
    }

    if (0 < DAT_8008d410) {
      iVar4 = 0;
      iVar3 = 0x80;

	  // reduce remaining attempts
      DAT_8008d410 = DAT_8008d410 + -1;

	  // go to read card
      goto LAB_8003e010;
    }

	// go to close file
    goto LAB_8003e1fc;

  case 4:
  case 6:

    // MEMCARD_GetNextSlot1Event
    iVar3 = FUN_8003d9ec();

    if (iVar3 == 0) {
      DAT_8008d8b0 = 0;
      DAT_8008d8d0 = 0;
      DAT_8008d404 = DAT_8008d404 + 1;
      if ((DAT_8008d8cc & 8) == 0) {
        DAT_8008d8b0 = 0;
        DAT_8008d8d0 = 0;
        return 7;
      }
      goto switchD_8003dde0_caseD_5;
    }

    if (iVar3 == 7) {
      return 7;
    }

	if (0 < DAT_8008d410) {
      iVar4 = DAT_8008d8d8 + (DAT_8008d404 + -4) * DAT_8008d8a8;
      iVar3 = DAT_8008d8a8;

	  // reduce remaining attempts
      DAT_8008d410 = DAT_8008d410 + -1;

	  // go to read card
      goto LAB_8003e010;
    }

	// go to close file
    goto LAB_8003e1fc;

  case 5:
  case 7:
switchD_8003dde0_caseD_5:

	// MEMCARD_ChecksumLoad
	// pointer to memory card, and size
    iVar3 = FUN_8003d618(DAT_8008d408,DAT_8008d8a8);

    if (iVar3 != 0)
	{
	  // if checksumLoad returned 7, then the checksum
	  // is not finished processing, it will continue next frame
      if (iVar3 == 7) {
        return 7;
      }

	  // at this point, assume checksum succeeded (return 1)

      if (((DAT_8008d8cc & 4) == 0) && (iVar4 = DAT_8008d404 + -3, DAT_8008d404 < 7))
	  {
		// Make "switch" statement go to "next" stage
        DAT_8008d404 = DAT_8008d404 + 1;

        iVar4 = DAT_8008d8d8 + iVar4 * DAT_8008d8a8;
        iVar3 = DAT_8008d8a8;
LAB_8003e010:

		// Read memory card
        uVar2 = FUN_8003dc30(iVar4,iVar3);

        return uVar2;
      }
    }
LAB_8003e1fc:
	// close memcard file
    FUN_8003dbf8();
    break;
  default:
    iVar3 = 1;
    break;
  case 9:
  case 10:
  case 0xb:

	// MEMCARD_GetNextSlot1Event
    iVar3 = FUN_8003d9ec();

    if (iVar3 == 0)
	{
      if ((DAT_8008d404 != 9) && ((10 < DAT_8008d404 || ((DAT_8008d8cc & 4) != 0))))
	  {
		// close memcard file
        FUN_8003dbf8();

		// MEMCARD_GetFreeBytes
        FUN_8003dd10(DAT_8008d8b8);

        return 0;
      }
      iVar3 = DAT_8008d404 + -9;
      DAT_8008d404 = DAT_8008d404 + 1;
LAB_8003e1e4:
      iVar4 = DAT_8008d8d8 + iVar3 * DAT_8008d8a8;

	  // pointer to memory card bytes
      puVar5 = DAT_8008d408;

	  // size, 0x1680 bytes
      iVar3 = DAT_8008d8a8;
    }

	else
	{
      if (iVar3 == 7) {
        return 7;
      }

	  // reduce remaining number of attempts
	  iVar4 = DAT_8008d410 + -1;

	  // if out of attempts, go to close file
      if (DAT_8008d410 < 1) goto LAB_8003e1fc;

      iVar3 = DAT_8008d404 + -10;
      DAT_8008d410 = iVar4;
      if (DAT_8008d404 != 9) goto LAB_8003e1e4;
      iVar4 = 0;

	  // pointer to memory card icon
	  // psyq hand
	  puVar5 = &DAT_800857a0;

	  // 256 bytes, 0x100
      iVar3 = DAT_8008d8d8;
    }

	// write to memory card
    iVar3 = FUN_8003dc9c(iVar4,puVar5,iVar3);
    break;
  case 0xd:
    DAT_8008d404 = 0;
    iVar3 = 1;
    break;
  case 0xe:
    DAT_8008d404 = 0;
    iVar3 = 0;
  }
  return iVar3;
}


// MEMCARD_GetInfo
undefined4 FUN_8003e238(long param_1)

{
  undefined4 uVar1;
  long lVar2;

  if (DAT_8008d404 == 0) {
    FUN_8003db54();
    DAT_8008d404 = 1;
    DAT_8008d8b8 = param_1;

	// loop until check is "submitted",
	// result is not "returned", result
	// is found in SwCARD descriptor/event (see libref)
	do
	{
	  // check if card is connected
      lVar2 = _card_info(param_1);

	} while (lVar2 != 1);

	DAT_8008d410 = 8;
    uVar1 = 7;
  }
  else {
    uVar1 = 1;
  }
  return uVar1;
}


// MEMCARD_Load
// ghidra couldn't detect parameters,
// because they were passed directly from this func to another
undefined4 FUN_8003e29c(param1, param2, param3, param4, param5)

{
  int iVar1;
  undefined4 uVar2;
  uint param_5;

  if (
		(DAT_8008d404 == 0) &&

		(
			// MEMCARD_NewTask
			iVar1 = FUN_8003db98(param1, param2, param3, param4, param5),

			// this will always be true
			iVar1 == 0
		)
	  )
  {
	// 800990a4
	// string for directory and file of save that is in use

	// 0x8001, in sys/fcntl.h
	// 0x8000 = FASYNC, for asynchronous I/O
	// 0x0001 = FREAD, for reading

    DAT_8008d40c = open(&DAT_800990a4,0x8001);

	// if open failed
    if (DAT_8008d40c == -1)
	{
	  // close memcard file
      FUN_8003dbf8();
      uVar2 = 6;
    }
    else {
      if ((param_5 & 2) == 0)
	  {
		// dont process crc16 to the end of memory,
		// just the next 0x200 bytes (async)
        DAT_8008d8cc = DAT_8008d8cc & 0xfffffff7;
      }
      else
	  {
		// process crc16 to the end of memory
        DAT_8008d8cc = DAT_8008d8cc | 8;
      }
      DAT_8008d404 = 3;

	  // Read memory card
      uVar2 = FUN_8003dc30(0,0x80);
    }
  }
  else {
    uVar2 = 1;
  }
  return uVar2;
}


// MEMCARD_Save
undefined4 FUN_8003e344(undefined4 param_1,undefined4 param_2,
						char *param_3,undefined4 param_4,int param_5,
						uint param_6)

{
  char cVar1;
  int iVar2;
  undefined4 uVar3;
  int iVar4;

  if (DAT_8008d404 == 0)
  {
    DAT_8008d8d8 = 0x100;

	// MEMCARD_NewTask
	iVar2 = FUN_8003db98(param_1,param_2,param_4,param_5);

	// this will always be true
	if (iVar2 == 0)
	{
      if (((param_6 & 1) == 0) && (1 < DAT_8008d8d8 + param_5 * 2 + 0x1fff >> 0xd)) {
        DAT_800857a3 = (byte)(DAT_8008d8d8 + param_5 + 0x1fff >> 0xd);
        DAT_8008d8cc = DAT_8008d8cc | 4;
      }
      else {
        DAT_8008d8cc = DAT_8008d8cc & 0xfffffffb;
        DAT_800857a3 = (byte)(DAT_8008d8d8 + param_5 * 2 + 0x1fff >> 0xd);
      }
      iVar2 = 0;
      do {
        iVar4 = iVar2 + 2;
        (&DAT_800857a4)[iVar2] = 0x81;
        (&DAT_800857a5)[iVar2] = 0x40;
        iVar2 = iVar4;
      } while (iVar4 < 0x40);
      cVar1 = *param_3;
      iVar2 = 0;
      while ((cVar1 != '\0' && (iVar2 < 0x40))) {
        cVar1 = *param_3;
        param_3 = param_3 + 1;
        (&DAT_800857a4)[iVar2] = cVar1;
        cVar1 = *param_3;
        iVar2 = iVar2 + 1;
      }

	  // MEMCARD_ChecksumSave
	  // ptrData, size of data
	  // (8009aa50 and 8009aa54)
      FUN_8003d584(param_4,param_5);

	  // 800990a4
	  // string for directory and file of save that is in use

	  // In sys/fcntl.h
	  // 0x200 is FCREAT, create if it does not exist,
	  // DAT_800857a3 handles read or write

      DAT_8008d40c = open(&DAT_800990a4,(uint)DAT_800857a3 << 0x10 | 0x200);

	  if (DAT_8008d40c != -1) {
        close(DAT_8008d40c);
        DAT_8008d40c = -1;
      }

	  // 800990a4
	  // string for directory and file of save that is in use

	  // 0x8002, in sys/fcntl.h
	  // 0x8000 = FASYNC, for asynchronous I/O
	  // 0x0001 = FWRITE, for writing

      DAT_8008d40c = open(&DAT_800990a4,0x8002);

      if (DAT_8008d40c != -1) {
        DAT_8008d404 = 9;

		// write to memory card, given pointer to icon
		// and the size of the icon, psyq hand
        uVar3 = FUN_8003dc9c(0,&DAT_800857a0,DAT_8008d8d8);

        return uVar3;
      }

	  // close memcard file
      FUN_8003dbf8(0);
      return 4;
    }
  }
  return 1;
}


// MEMCARD_Format
// param1 slotIndex
undefined4 FUN_8003e51c(long param_1)

{
  char *pcVar1;
  long lVar2;
  undefined4 uVar3;

  if (DAT_8008d404 == 0)
  {
	// MEMCARD_StringInit
    pcVar1 = (char *)FUN_8003d6e8(param_1,0);

	lVar2 = format(pcVar1);
    uVar3 = 1;
    if (lVar2 == 1) {
      DAT_8008d404 = 2;

	  // slotIndex
      DAT_8008d8b8 = param_1;

      FUN_8003db54();

      do {
        lVar2 = _card_load(DAT_8008d8b8);
      } while (lVar2 != 1);

	  DAT_8008d410 = 8;
      uVar3 = 7;
    }
  }
  else {
    uVar3 = 1;
  }
  return uVar3;
}


// param1 slotIndex
// param2 saveName
undefined4 FUN_8003e59c(undefined4 param_1,undefined4 param_2)

{
  undefined4 uVar1;
  char acStack72 [64];

  // MEMCARD_StringSet
  FUN_8003d730(acStack72,param_1,param_2);

  // 0x8002, in sys/fcntl.h
  // 0x8000 = FASYNC, for asynchronous I/O
  // 0x0001 = FWRITE, for writing
  DAT_8008d40c = open(acStack72,0x8002);

  if (DAT_8008d40c == -1) {
    uVar1 = 6;
  }
  else {
    close(DAT_8008d40c);
    DAT_8008d40c = -1;
    uVar1 = 0;
  }
  return uVar1;
}


// MEMCARD_FindFirstGhost
undefined * FUN_8003e600(undefined4 param_1,undefined4 param_2)

{
  DIRENTRY *pDVar1;
  DIRENTRY DStack48;

  // param2 = BASCUS-94426G*

  if (DAT_8008d404 == 0)
  {
    // MEMCARD_StringSet
    FUN_8003d730(&DAT_800990a4,param_1,param_2);

    // 800990a4
    // string for directory and file of save that is in use
	pDVar1 = firstfile(&DAT_800990a4,&DStack48);

	if (pDVar1 == &DStack48) {
      DAT_8008d404 = 0xf;
      strcpy();
      return &DAT_800990c4;
    }
  }
  return (undefined *)0;
}


// MEMCARD_FindNextGhost
undefined * FUN_8003e678(void)

{
  DIRENTRY *pDVar1;
  DIRENTRY DStack48;

  if (DAT_8008d404 == 0xf) {
    pDVar1 = nextfile(&DStack48);
    if (pDVar1 == &DStack48) {
      strcpy();
      return &DAT_800990c4;
    }
    DAT_8008d404 = 0;
  }
  return (undefined *)0;
}


// MEMCARD_EraseFile (unused)
// param1 slotIndex
undefined4 FUN_8003e6d4(undefined4 param_1,undefined4 param_2)

{
  undefined4 uVar1;
  long lVar2;
  char acStack72 [64];

  if (DAT_8008d404 == 0)
  {
	// MEMCARD_StringSet
    FUN_8003d730(acStack72,param_1,param_2);

	DAT_8008d404 = 0xe;
    lVar2 = erase(acStack72);
    if (lVar2 != 1) {
      DAT_8008d404 = 0xd;
    }

	// MEMCARD_GetFreeBytes
	FUN_8003dd10(param_1);

    uVar1 = 7;
  }
  else {
    uVar1 = 1;
  }
  return uVar1;
}



// WARNING: Removing unreachable block (ram,0x8003e774)
// WARNING: Removing unreachable block (ram,0x8003e77c)
// WARNING: Removing unreachable block (ram,0x8003e790)
// WARNING: Removing unreachable block (ram,0x8003e7a8)

// In Aug 5 prototype, this is
// called MEMPACK_Init,
// param1 is the amount to allocate
void FUN_8003e740(int param_1)

{
  undefined *puVar1;

  // structure of memory allocation system
  puVar1 = PTR_DAT_8008d420;

  // start of memory allocation system
  // 800ba9f0 = (ovr3)0x800ba9f0 + (231)0xEB58 + (align-up)0x4A8,
  // 800ba9f0 = 0x800ab9f0 + 0xF000 (only 0x4A8 can be overwritten)
  *(undefined4 *)(PTR_DAT_8008d420 + 4) = 0x800ba9f0;

  // Set pointer to end of CTR Memory allocation
  // It adds so much so that it becomes 801FF800
  // with the '80' prefix
  *(int *)(puVar1 + 0xc) = param_1 + 0x7ffff800;
  *(int *)(puVar1 + 8) = param_1 + 0x7ffff800;

  // size of mempack
  // (0x801FF800 - 0x800ba9f0) = (0x200000 - 0xbb1f0)
  *(int *)puVar1 = param_1 + -0xbb1f0;

  // set number of bookmarks to zero
  *(undefined4 *)(puVar1 + 0x1c) = 0;

  // Set total size of PS1 Memory
  // The game never actually uses this variable
  *(undefined4 *)(puVar1 + 0x10) = 0x80200000;

  // set end of allocation to the start of allocation
  *(undefined4 *)(puVar1 + 0x14) = *(undefined4 *)(puVar1 + 4);
  return;
}


// MEMPACK_SwapPacks
void FUN_8003e80c(int param_1)
{
  // change pointer of active allocation system,
  // this is pointer incrementation, so param1*0x18
  // is actually param1*0x60 bytes, you can tell by
  // looking at the value 8008d420 as it changes
  PTR_DAT_8008d420 = (undefined *)(&DAT_800990e4 + param_1 * 0x18);
  return;
}

// build a new pack with a new start and end
void FUN_8003e830(int param_1,int param_2)
{
  undefined *puVar1;

  // structure of memory allocation system
  puVar1 = PTR_DAT_8008d420;

  // set start of memory
  *(int *)(PTR_DAT_8008d420 + 4) = param_1;

  // Set lastFreeByte to end of this pack
  *(int *)(puVar1 + 8) = param_1 + param_2;

  // size of pack
  *(int *)puVar1 = param_2;

  // set number of bookmarks to zero
  *(undefined4 *)(puVar1 + 0x1c) = 0;

  // set size of psx memory to size of current CTR memory
  *(int *)(puVar1 + 0x10) = param_1 + param_2;

  // set last byte of allocation to the start of allocation
  *(undefined4 *)(puVar1 + 0x14) = *(undefined4 *)(puVar1 + 4);
  return;
}


// Get amount of free memory
int FUN_8003e85c(void)

{
  // Pointer to end of CTR Memory (0x1FF800) - pointer to end of used memory
  return *(int *)(PTR_DAT_8008d420 + 8) - *(int *)(PTR_DAT_8008d420 + 0x14);
}


// In Aug 5 prototype, this is
// called MEMPACK_AllocMem,
// param1 is amount to allocate
int FUN_8003e874(int param_1)

{
  // pointer to memory managment structure
  undefined *puVar1;

  // pointer that will be returned
  int iVar2;

  // aligned size of memory allocated
  uint uVar3;

  // pointer to memory managment structure
  puVar1 = PTR_DAT_8008d420;

  // if the last byte address of allocated RAM
  // minus the address of RAM being used, is less
  // than the amount of memory you want to allocate

  // PTR_DAT_8008d420 + 8 will be 801FF800 by default
  // PTR_DAT_8008d420 + 0x14 will be a pointer to the last byte in use

  // basically, if there is no room to allocate param_1 amount of bytes
  if (*(int *)(PTR_DAT_8008d420 + 8) - *(int *)(PTR_DAT_8008d420 + 0x14) < param_1) {

	// CTR_ErrorScreen
	FUN_80021c94(0xff,0,0);

	// freeze the game
    do
	{
      trap(0x400);
    } while( true );
  }

  // First free byte
  iVar2 = *(int *)(PTR_DAT_8008d420 + 0x14);

  // Align allocation size
  uVar3 = param_1 + 3U & 0xfffffffc;

  // set the size of memory allocated
  *(uint *)(PTR_DAT_8008d420 + 0x18) = uVar3;

  // Increase address where allocated memory ends,
  // so that used memory can't be overwritten
  *(uint *)(puVar1 + 0x14) = iVar2 + uVar3;

  // Return pointer to where memory is free
  return iVar2;
}

// In Aug 5 prototype, this is
// called MEMPACK_AllocHighMem,
// param1 is amount to allocate,
int FUN_8003e8e8(int param_1)
{
  // This is only called once for "Patch Memory Table",
  // and it is given the amount of free remaining memory

  int iVar1;
  undefined *puVar2;
  uint uVar3;

  // pointer to memory managment structure
  puVar2 = PTR_DAT_8008d420;

  // basically, if there is no room to allocate param_1 amount of bytes
  if (*(int *)(PTR_DAT_8008d420 + 8) - *(int *)(PTR_DAT_8008d420 + 0x14) < param_1)
  {
	// Freeze the game
    do
	{
      trap(0x400);
    } while( true );
  }

  // lastFreeByte
  iVar1 = *(int *)(PTR_DAT_8008d420 + 8);

  // Align allocation size
  uVar3 = param_1 + 3U & 0xfffffffc;

  // set the size of memory allocated
  *(uint *)(PTR_DAT_8008d420 + 0x18) = uVar3;

  // decrease the last free byte
  *(uint *)(puVar2 + 8) = iVar1 - uVar3;

  // return pointer to memory
  return (iVar1 - uVar3);
}

// MEMPACK_ClearHighMem
void FUN_8003e938(void)

{
  // lastFreeByte = endOfAllocator
  *(undefined4 *)(PTR_DAT_8008d420 + 8) = *(undefined4 *)(PTR_DAT_8008d420 + 0xc);
  return;
}

// In Aug 5 prototype, this is
// called MEMPACK_ReallocMem,
// param1 is the amount to allocate
void FUN_8003e94c(int param_1)

{
  // pointer to memory managment structure
  int iVar1;

  // pointer that will be returned
  undefined *puVar2;

  // aligned size of memory allocated
  uint uVar3;

  // amount of memory to erase
  int iVar4;

  // pointer to memory managment structure
  puVar2 = PTR_DAT_8008d420;

  // firstFreeByte
  iVar1 = *(int *)(PTR_DAT_8008d420 + 0x14);

  // Get size of previous allocation
  iVar4 = *(int *)(PTR_DAT_8008d420 + 0x18);

  // Align allocation size
  uVar3 = param_1 + 3U & 0xfffffffc;

  // set the size of memory allocated
  *(uint *)(PTR_DAT_8008d420 + 0x18) = uVar3;

  // Change address where allocation ends
  // Decrease by the amount of bytes erased
  // Increase by the amount of bytes allocated
  *(uint *)(puVar2 + 0x14) = (iVar1 - iVar4) + uVar3;

  // return pointer
  return (iVar1 - iVar4);
}


// In Aug 5 prototype, this is
// called MEMPACK_PushState,
// add a bookmark
void FUN_8003e978(void)

{
  undefined *puVar1;
  int iVar2;

  // pointer to memory allocation system
  puVar1 = PTR_DAT_8008d420;

  // get current number of bookmarks
  iVar2 = *(int *)(PTR_DAT_8008d420 + 0x1c);

  // if you have less than 16 bookmarks
  if (iVar2 < 0x10)
  {
	// set member of bookmark array
    *(undefined4 *)(PTR_DAT_8008d420 + iVar2 * 4 + 0x20) =

		// firstFreeByte
		*(undefined4 *)(PTR_DAT_8008d420 + 0x14);

	// increment number of bookmarks
	*(int *)(puVar1 + 0x1c) = iVar2 + 1;
  }

  return;
}


// MEMPACK_ClearLowMem
void FUN_8003e9b8(void)
{
  undefined4 *puVar1;
  undefined *puVar2;

  // pointer to memory allocation structure
  puVar2 = PTR_DAT_8008d420;

  // get first byte of memory allocation
  puVar1 = (undefined4 *)(PTR_DAT_8008d420 + 4);

  // set number of bookmarks to zero
  *(undefined4 *)(PTR_DAT_8008d420 + 0x1c) = 0;

  // set firstFreeByte to mempack start
  *(undefined4 *)(puVar2 + 0x14) = *puVar1;
  return;
}

// In Aug 5 prototype, this is
// called MEMPACK_PopState,
// erase all memory after the last bookmark
void FUN_8003e9d0(void)
{
  undefined *puVar1;
  int iVar2;

  // get pointer to memory allocation system
  puVar1 = PTR_DAT_8008d420;

  // check how many bookmarks we have
  iVar2 = *(int *)(PTR_DAT_8008d420 + 0x1c) + -1;

  // if there are any bookmarks
  if (0 < *(int *)(PTR_DAT_8008d420 + 0x1c))
  {
	// decrease bookmark by one
    *(int *)(PTR_DAT_8008d420 + 0x1c) = iVar2;

	// erase all memory after the bookmark we are going back to
    *(undefined4 *)(puVar1 + 0x14) = *(undefined4 *)(puVar1 + iVar2 * 4 + 0x20);
  }
  return;
}

// In Aug 5 prototype, this is
// called MEMPACK_PopToState,
// erase all memory after this bookmark
// param1 is the bookmark ID
void FUN_8003ea08(int param_1)

{
  undefined *puVar1;

  // get structure to memory managment system
  puVar1 = PTR_DAT_8008d420;

  // set current bookmark
  *(int *)(PTR_DAT_8008d420 + 0x1c) = param_1;

  // change last byte of currently-used memory
  *(undefined4 *)(puVar1 + 0x14) = *(undefined4 *)(puVar1 + param_1 * 4 + 0x20);
  return;
}


// RNG_Scramble
void FUN_8003ea28(void)

{
  // random algorithm for seemingly-random numbers
  DAT_8008d424 = DAT_8008d424 * 0x6255 + 0x3619 & 0xffff;
  return;
}


// RNG_Particles
// gets number between zero and param_1
int FUN_8003ea6c(int param_1)

{
  uint uVar1;

  uVar1 = FUN_8006c684(PTR_DAT_8008d2ac + 0x252c);
  return (int)((uVar1 & 0xffff) * param_1) >> 0x10;
}


// RNG_GetValue
uint FUN_8003eaac(int param_1)

{
  return param_1 * 0x6255 + 0x3619U & 0xffff;
}


// Particle_FuncPtr_PotionShatter
void FUN_8003eae0(int param_1)

{
  short sVar2;
  int iVar1;

  if (*(short *)(param_1 + 0x30) < 0x578) {
    if (*(short *)(param_1 + 0x28) != 0) goto LAB_8003ebc8;

	// Get random number
    iVar1 = FUN_8003ea28();

	*(short *)(param_1 + 0x28) = (short)iVar1 + (short)(iVar1 / 800) * -800 + -400;

	// Get random number
    iVar1 = FUN_8003ea28();

	*(short *)(param_1 + 0x38) = (short)iVar1 + (short)(iVar1 / 800) * -800 + -400;

	// Get random number
    iVar1 = FUN_8003ea28();

    sVar2 = (short)((uint)iVar1 >> 8);
    if (iVar1 < 0) {
      sVar2 = (short)((uint)(iVar1 + 0xff) >> 8);
    }
    *(short *)(param_1 + 0x50) = (short)iVar1 + sVar2 * -0x100 + 0x100;
  }
  if (*(short *)(param_1 + 0x28) == 0) {
    return;
  }
LAB_8003ebc8:
  if (*(int *)(param_1 + 0x20) == 0x45) {
    if (0 < *(int *)(param_1 + 100)) {
      *(int *)(param_1 + 100) = *(int *)(param_1 + 100) + -0x1200;
    }
  }
  else {
    if (0 < *(int *)(param_1 + 0x5c)) {
      *(int *)(param_1 + 0x5c) = *(int *)(param_1 + 0x5c) + -0x1200;
    }
  }
  return;
}


// Particle_FuncPtr_SpitTire
void FUN_8003ec18(int param_1)

{
  int iVar1;
  int iVar2;

  if (*(int *)(param_1 + 0x2c) >> 8 < *(int *)(*(int *)(param_1 + 0x20) + 0x48) + 0x10)
  {
	// Get random number
    iVar1 = FUN_8003ea28();

    *(short *)(param_1 + 0x28) = (short)iVar1 + (short)(iVar1 / 0x1640) * -0x1640 + -0xb20;

	// Get random number
	iVar1 = FUN_8003ea28();

	iVar2 = *(int *)(param_1 + 0x4c);

	*(short *)(param_1 + 0x38) = (short)iVar1 + (short)(iVar1 / 0x1640) * -0x1640 + -0xb20;
    if (iVar2 == 0x1000)
	{
	  // Get random number
      iVar1 = FUN_8003ea28();

      *(short *)(param_1 + 0x30) = (short)iVar1 + (short)(iVar1 / 0x12c0) * -0x12c0 + 0x1900;
      iVar1 = *(int *)(*(int *)(param_1 + 0x20) + 0x48);
      *(undefined4 *)(param_1 + 0x4c) = 0xfff;
    }
    else {
      if (iVar2 == 0xfff) {
        iVar1 = FUN_8003ea28();
        *(short *)(param_1 + 0x30) = (short)iVar1 + (short)(iVar1 / 800) * -800 + 8000;
        iVar1 = *(int *)(*(int *)(param_1 + 0x20) + 0x48);
        *(undefined4 *)(param_1 + 0x4c) = 0xffe;
      }
      else {
        if (iVar2 != 0xffe) {
          return;
        }

		// Get random number
        iVar1 = FUN_8003ea28();

		*(short *)(param_1 + 0x30) = (short)iVar1 + (short)(iVar1 / 800) * -800 + 6000;
        iVar1 = *(int *)(*(int *)(param_1 + 0x20) + 0x48);
        *(undefined2 *)(param_1 + 0x50) = 0xf801;
      }
    }
    *(int *)(param_1 + 0x2c) = (iVar1 + 0x10) * 0x100;
  }
  return;
}


// Particle_FuncPtr_ExhaustUnderwater
void FUN_8003ee20(int param_1)

{
  int iVar1;
  uint uVar2;

  if ((3 < (*(int *)(param_1 + 0x2c) >> 8) + *(int *)(*(int *)(param_1 + 0x20) + 0x48)) &&
     (*(short *)(param_1 + 0x10) < 0x1b))
  {
	// bubblepop
    iVar1 = *(int *)(PTR_DAT_8008d2ac + 0x2134);

	// save iconGroup
    *(int *)(param_1 + 0xc) = iVar1;

    if (iVar1 != 0)
	{
	  // save icons
	  // param1->8 = iconGroup->icons
      *(undefined4 *)(param_1 + 8) = *(undefined4 *)(iVar1 + 0x14);
    }

	// Get random number
    uVar2 = FUN_8003ea28();

    *(uint *)(param_1 + 0x44) = uVar2 & 0xfff;
    *(undefined2 *)(param_1 + 0x10) = 0;
  }
  return;
}


// Particle_OnDestroy
void FUN_8003eeb0(int param_1)

{
  int *piVar1;

  piVar1 = *(int **)(param_1 + 4);

  while (piVar1 != (int *)0x0)
  {
    piVar1 = (int *)*piVar1;

	// LIST_AddFront
	// free list of Oscillator Pool
    FUN_80031744(PTR_DAT_8008d2ac + 0x19c0);
  }
  return;
}


// Particle_UpdateList
void FUN_8003eefc(int **param_1,int **param_2)

{
  ushort uVar1;
  ushort uVar2;
  short sVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  int *piVar7;
  int **ppiVar8;
  int **ppiVar9;
  int *piVar10;
  int **ppiVar11;
  int **ppiVar12;

  if (param_2 != (int **)0x0) {
    do
	{
	  // get frames remaining in particle life,
	  // offset 0x10
      sVar3 = *(short *)(param_2 + 4);

	  // particle->next
	  ppiVar12 = (int **)*param_2;

	  // reduce life by one frame
      *(short *)(param_2 + 4) = sVar3 + -1;

	  // if particle is dead
      if ((short)(sVar3 + -1) == -1) {
LAB_8003f2dc:

		// Particle_OnDestroy
        FUN_8003eeb0(param_2);

		// LIST_AddFront
		// free list of particle pool
        FUN_80031744(PTR_DAT_8008d2ac + 0x1998,param_2);

		// decrease number of particles
        *(int *)(PTR_DAT_8008d2ac + 0x1ca4) = *(int *)(PTR_DAT_8008d2ac + 0x1ca4) + -1;

		// particle = particle->next
        *(int ***)param_1 = ppiVar12;
      }

	  // if particle is not dead
      else
	  {
		// particle offset 0x12 (flags)
        uVar1 = *(ushort *)((int)param_2 + 0x12);

        if ((uVar1 & 8) != 0) goto LAB_8003f2dc;

		if ((uVar1 & 0x1000) != 0)
		{
          param_2[0xf] = param_2[9];
          param_2[0x15] = param_2[0xb];
          param_2[0x11] = param_2[0xd];
          if ((uVar1 & 0x4000) == 0) {
            param_2[0x1d] = param_2[0x1e];
          }
        }

		// particle offset 0x14
        piVar10 = param_2[5];

		// offset 4 (unknown pointer)
        ppiVar8 = (int **)param_2[1];

		// particle offset 0x24
        ppiVar11 = param_2 + 9;

        if (piVar10 != (int *)0x0)
		{
		  // particle offset 0x28
          ppiVar9 = param_2 + 10;

		  // loop through each axis of animation (x, y, z)
          do 
		  {
			// if axis is disabled, check next
            if (((uint)piVar10 & 1) == 0) goto LAB_8003f1f4;
			
			// pos = pos + vel
            *ppiVar11 = (int *)((int)*ppiVar11 + (int)*(short *)ppiVar9);
			
			// vel = vel + accel
            sVar3 = *(short *)ppiVar9 + *(short *)((int)ppiVar9 + 2);
            *(short *)ppiVar9 = sVar3;
			
			// if axis is disabled, check next
            if ((((int)piVar10 >> 0x10 & 1U) == 0) || (ppiVar8 == (int **)0x0)) goto LAB_8003f1f4;
			
            if ((*(ushort *)(ppiVar8 + 2) & 8) == 0) {
              if ((*(ushort *)(ppiVar8 + 2) & 0x10) == 0) {
                *ppiVar11 = (int *)((int)*ppiVar11 - (int)*(short *)((int)ppiVar8 + 10));
              }
              else {
                *(short *)ppiVar9 = sVar3 - *(short *)((int)ppiVar8 + 10);
              }
            }

			// confetti frame timer
			iVar4 = *(int *)(PTR_DAT_8008d2ac + 0x1cf0);

            switch((uint)*(ushort *)(ppiVar8 + 2) & 7) {
            case 0:

			  // Sine(angle)
              iVar4 = FUN_8003d184((int)((uint)*(ushort *)(ppiVar8 + 3) *
                                        (iVar4 + *(short *)((int)ppiVar8 + 0xe))) >> 5);
              goto switchD_8003f074_caseD_7;
            case 1:

			  // Sine(angle)
			  iVar4 = FUN_8003d184((int)((uint)*(ushort *)(ppiVar8 + 3) *
                                        (iVar4 + *(short *)((int)ppiVar8 + 0xe))) >> 6);
              if (iVar4 < 0) {
                iVar4 = -iVar4;
              }
              uVar6 = iVar4 << 1;
              break;
            case 2:
              uVar6 = (int)((uint)*(ushort *)(ppiVar8 + 3) *
                           (iVar4 + *(short *)((int)ppiVar8 + 0xe))) >> 4 & 0x1fff;
              break;
            case 3:
              uVar6 = (int)((uint)*(ushort *)(ppiVar8 + 3) *
                           (iVar4 + *(short *)((int)ppiVar8 + 0xe))) >> 3 & 0x3fff;
              if (0x2000 < uVar6) {
                uVar6 = 0x4000 - uVar6;
              }
              break;
            case 4:
              iVar5 = iVar4 + *(short *)((int)ppiVar8 + 0xe);
              iVar4 = -0x1000;
              if (((int)((uint)*(ushort *)(ppiVar8 + 3) * iVar5) >> 6 & 0x400U) != 0) {
                iVar4 = 0x1000;
              }
              goto switchD_8003f074_caseD_7;
            case 5:
			  // Get random number
              iVar4 = FUN_8003ea28();
              uVar6 = iVar4 >> 3;
              break;
            case 6:
			  // get random number (alternative way)
              iVar4 = FUN_8003eaac((int)*(short *)((int)ppiVar8 + 10));
              uVar6 = iVar4 >> 3;
              break;
            default:
              goto switchD_8003f074_caseD_7;
            }
            iVar4 = uVar6 - 0x1000;
switchD_8003f074_caseD_7:
            iVar4 = (int)((iVar4 + *(short *)((int)ppiVar8 + 0x12)) * (uint)*(ushort *)(ppiVar8 + 4)
                         ) >> 0xc;
            if ((int)*(short *)((int)ppiVar8 + 0x16) < iVar4) {
              iVar4 = (int)*(short *)((int)ppiVar8 + 0x16);
            }
            if (iVar4 < (int)*(short *)(ppiVar8 + 5)) {
              iVar4 = (int)*(short *)(ppiVar8 + 5);
            }
            if ((*(ushort *)(ppiVar8 + 2) & 0x10) == 0) {
              *ppiVar11 = (int *)((int)*ppiVar11 + iVar4);
            }
            else {
              *(short *)ppiVar9 = *(short *)ppiVar9 + (short)iVar4;
            }
            *(short *)((int)ppiVar8 + 10) = (short)iVar4;
            ppiVar8 = (int **)*ppiVar8;
			
			// next axis to animate
LAB_8003f1f4:
            ppiVar9 = ppiVar9 + 2;
            piVar10 = (int *)((int)((uint)piVar10 & 0xfffeffff) >> 1);
            ppiVar11 = ppiVar11 + 2;
			
          } while (piVar10 != (int *)0x0);
        }
		
		// if particle has function pointer (offset 0x1C)
        if (param_2[7] != (int *)0x0) 
		{
		  // execute function for this particle
          (*(code *)param_2[7])(param_2);
        }
		
        uVar2 = *(ushort *)(param_2 + 5);
        if (((uVar1 & 1) != 0) &&
           ((((uVar2 & 0x20) != 0 && ((int)param_2[0x13] < 1)) ||
            (((uVar2 & 0x40) != 0 && ((int)param_2[0x15] < 1)))))) goto LAB_8003f2dc;
        if ((uVar1 & 2) != 0) {
          piVar10 = (int *)0x0;
          if (((uVar2 & 0x80) != 0) && (0 < (int)param_2[0x17])) {
            piVar10 = param_2[0x17];
          }
          if (((uVar2 & 0x100) != 0) && (0 < (int)param_2[0x19])) {
            piVar10 = (int *)((uint)piVar10 | (uint)param_2[0x19]);
          }
          if (((uVar2 & 0x200) != 0) && (0 < (int)param_2[0x1b])) {
            piVar10 = (int *)((uint)piVar10 | (uint)param_2[0x1b]);
          }
          if ((int)piVar10 < 0x800) goto LAB_8003f2dc;
        }
        param_1 = param_2;
        if (((*(ushort *)(param_2 + 5) & 0x400) != 0) &&
           (piVar10 = param_2[3], piVar10 != (int *)0x0)) {
          piVar7 = param_2[0x1d];
          if ((int)piVar7 < 0)
		  {
            if ((*(ushort *)((int)param_2 + 0x12) & 0x100) == 0) {
              if ((*(ushort *)((int)param_2 + 0x12) & 0x200) == 0) {
                piVar7 = (int *)0x0;
              }
              else {
LAB_8003f3c4:
                piVar7 = (int *)((int)piVar7 + (int)*(short *)(param_2 + 0x1e) * -2);
                *(short *)((int)param_2 + 0x7a) = -*(short *)((int)param_2 + 0x7a);
                *(short *)(param_2 + 0x1e) = -*(short *)(param_2 + 0x1e);
              }
            }
            else {
              piVar7 = piVar7 + (int)*(short *)((int)piVar10 + 0x12) * 0x40;
            }
          }
          else {
            iVar4 = (int)*(short *)((int)piVar10 + 0x12) * 0x100;
            if ((int)piVar7 < iVar4) goto LAB_8003f3f8;
            if ((*(ushort *)((int)param_2 + 0x12) & 0x100) == 0) {
              if ((*(ushort *)((int)param_2 + 0x12) & 0x200) != 0) goto LAB_8003f3c4;
              piVar7 = (int *)(iVar4 + -1);
            }
            else {
              piVar7 = piVar7 + (int)*(short *)((int)piVar10 + 0x12) * 0x3fffffc0;
            }
          }
          param_2[0x1d] = piVar7;
        }
      }
LAB_8003f3f8:
      param_2 = ppiVar12;
    } while (ppiVar12 != (int **)0x0);
  }
  return;
}


// Particle_UpdateAllParticles
void FUN_8003f434(void)

{
  // if PauseAllThreads is diabled
  if ((*(uint *)PTR_DAT_8008d2ac & 0x10) == 0)
  {
	// world-space particles (exhaust on cars)
    FUN_8003eefc(PTR_DAT_8008d2ac + 0x1c9c,*(undefined4 *)(PTR_DAT_8008d2ac + 0x1c9c));

	// Draw "heat" particles that warp the screen
	// (above fire in tiger temple flamejet and player missiles)
	FUN_8003eefc(PTR_DAT_8008d2ac + 0x1ca0,*(undefined4 *)(PTR_DAT_8008d2ac + 0x1ca0));
  }
  return;
}


// Particle_BitwiseClampByte
// only called from Particle_SetColors
int FUN_8003f48c(int *param_1)

{
  int iVar1;

  iVar1 = *param_1;

  // min value
  if (iVar1 < 0) {
    iVar1 = 0;
    *param_1 = 0;
  }

  else
  {
	// max value
    if (0xff00 < iVar1) {
      iVar1 = 0xff00;
      *param_1 = 0xff00;
    }
  }

  // shift down a byte
  return iVar1 >> 8;
}


// Particle_SetColors
// called from RenderList and CreateInstance
uint FUN_8003f4c4(uint param_1,uint param_2,int param_3)

{
  uint uVar1;
  uint uVar2;

  if ((param_1 & 0x80) == 0)
  {
	// draw white
    uVar2 = 0x1000000;

    if ((param_2 & 0x80) != 0)
	{
	  // draw white, with alpha clipping
      uVar2 = 0x3000000;
    }
  }
  else
  {
	// Particle_BitwiseClampByte
    uVar1 = FUN_8003f48c(param_3 + 0x5c);

	// red
    uVar2 = uVar1;

	if ((param_1 & 0x100) != 0)
	{
	  // Particle_BitwiseClampByte
      uVar2 = FUN_8003f48c(param_3 + 0x64); // 0x64 = 100
    }

	// green
	uVar2 = uVar1 | uVar2 << 8;

    if ((param_1 & 0x200) != 0)
	{
	  // Particle_BitwiseClampByte
      uVar1 = FUN_8003f48c(param_3 + 0x6c);
    }

	// blue
	uVar2 = uVar2 | uVar1 << 0x10;

	if ((param_2 & 0x80) != 0)
	{
	  // enable alpha clipping
      uVar2 = uVar2 | 0x2000000;
    }
  }

  // returns 0xXXBBGGRR
  // BB for blue, GG for green, RR for red, XX for flags
  return uVar2;
}


// Particle_RenderList
void FUN_8003f590(int param_1,int *param_2)

{
  char cVar1;
  ushort uVar2;
  ushort uVar3;
  short sVar4;
  uint uVar5;
  int iVar6;
  uint *puVar7;
  int iVar8;
  int iVar9;
  uint uVar10;
  int iVar11;
  uint uVar12;
  uint uVar13;
  uint *puVar14;
  int iVar15;
  uint uVar16;
  uint uVar17;
  int iVar18;
  uint uVar19;
  undefined4 uVar20;
  uint uVar21;
  undefined4 uVar22;
  undefined4 uVar23;
  uint *puVar24;
  uint *puVar25;
  uint uVar26;

  // Camera110_InitPsyqGeom
  FUN_80042910();

  // camera110 -> 0x28 (matrix)
  DAT_1f800000 = *(undefined4 *)(param_1 + 0x28);
  DAT_1f800004 = *(undefined4 *)(param_1 + 0x2c);
  DAT_1f800008 = *(undefined4 *)(param_1 + 0x30);
  DAT_1f80000c = *(undefined4 *)(param_1 + 0x34);
  DAT_1f800010 = DAT_1f800010 & 0xffff0000 | (uint)*(ushort *)(param_1 + 0x38);
  setCopControlWord(2,0x4000,DAT_1f800000);
  setCopControlWord(2,0x4800,DAT_1f800004);
  setCopControlWord(2,0x5000,DAT_1f800008);
  setCopControlWord(2,0x5800,DAT_1f80000c);
  setCopControlWord(2,0x6000,DAT_1f800010);
  
  // camera110 ptrOT
  DAT_1f800020 = *(int *)(param_1 + 0xf4);
  
  // camera110 cameraID
  cVar1 = *(char *)(param_1 + 0x108);
  
  // another matrix
  DAT_1f800024 = *(int *)(param_1 + 0x7c) << 2;
  DAT_1f800028 = *(int *)(param_1 + 0x80) << 2;
  DAT_1f80002c = *(int *)(param_1 + 0x84) << 2;

  // backBuffer->primMem.curr
  puVar7 = *(uint **)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80);

  if (
		// get the number of bytes needed to draw particles
		puVar7 + *(int *)(PTR_DAT_8008d2ac + 0x1ca4) * 10 <

	    // end of PrimMem, minus 0x100,
		// make sure to leave enough memory behind for [something else, idk]
		*(uint **)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x84)
	 )
  {
    if (param_2 != (int *)0x0)
	{
      puVar25 = puVar7 + 8;
      puVar24 = puVar7;
      do {
        puVar7 = puVar24;
        if ((((int)*(char *)((int)param_2 + 0x19) == -1) ||
            ((int)*(char *)((int)param_2 + 0x19) == (int)cVar1)) && (iVar8 = param_2[3], iVar8 != 0)
           ) {
          uVar2 = *(ushort *)(param_2 + 5);
          if ((uVar2 & 0x400) == 0) {
            iVar8 = param_2[2];
          }
          else {
            iVar18 = param_2[0x1d] >> 8;
            if (iVar18 < 0) {
              iVar18 = 0;
            }
            if ((int)*(short *)(iVar8 + 0x12) <= iVar18) {
              iVar18 = (int)*(short *)(iVar8 + 0x12) + -1;
            }
            if (iVar18 < 0)
			{
				// skip this particle,
				// go to next particle
				goto LAB_800402b0;
			}

            iVar8 = *(int *)(iVar8 + iVar18 * 4 + 0x14);
            param_2[2] = iVar8;
          }
          iVar18 = 0;

		  if (iVar8 != 0) {
            uVar3 = *(ushort *)((int)param_2 + 0x12);
            uVar26 = (uint)uVar3;
            iVar11 = param_2[9] >> 6;
            iVar9 = param_2[0xd] >> 6;
            iVar15 = param_2[0xb] >> 6;
            
			if (
				((uVar3 & 0x800) != 0) && 
				
				// instance that particle is attached to?
				(iVar6 = param_2[8], iVar6 != 0)
			  )
			{
			  // InstDrawPerPlayer = &Instance->InstDrawPerPlayer[cVar1]
              iVar18 = iVar6 + (int)cVar1 * 0x88 + 0x74;

			  // 0xB8 (flags per player)
              if ((*(uint *)(iVar18 + 0x44) & 0x40) == 0)
			  {
				  // skip this particle,
				  // go to next particle
				  goto LAB_800402b0;
			  }

			  iVar11 = iVar11 + *(int *)(iVar6 + 0x44) * 4;
              if ((uVar3 & 0x8000) == 0) {
                iVar15 = iVar15 + *(int *)(iVar6 + 0x48) * 4;
              }
              iVar9 = iVar9 + *(int *)(iVar6 + 0x4c) * 4;
			  
			  // 0xB8 (flags per player)
              if ((*(uint *)(iVar18 + 0x44) & 0x100) != 0) {
                iVar18 = 0;
              }
            }
            uVar12 = iVar11 - DAT_1f800024;
            iVar15 = iVar15 - DAT_1f800028;
            uVar5 = uVar12;
            if ((int)uVar12 < 0) {
              uVar5 = -uVar12;
            }
            iVar9 = iVar9 - DAT_1f80002c;
            if ((int)uVar5 < 0x7531) {
              iVar11 = iVar15;
              if (iVar15 < 0) {
                iVar11 = -iVar15;
              }
              if (iVar11 < 0x7531) {
                iVar11 = iVar9;
                if (iVar9 < 0) {
                  iVar11 = -iVar9;
                }
                if (iVar11 < 0x7531) {
                  setCopReg(2,0,uVar12 & 0xffff | iVar15 * 0x10000);
                  setCopReg(2,0x800,iVar9);

				  // llv0     cop2 $04A6012  v0 * light matrix
                  copFunction(2,0x4a6012);

				  uVar20 = getCopReg(2,0xc800);
                  uVar22 = getCopReg(2,0xd000);
                  uVar23 = getCopReg(2,0xd800);
                  setCopControlWord(2,0x2800,uVar20);
                  setCopControlWord(2,0x3000,uVar22);
                  setCopControlWord(2,0x3800,uVar23);
                  iVar9 = getCopReg(2,0xd800);
                  if ((-1 < iVar9) && (iVar9 <= (int)*(short *)((int)param_2 + 0x1a) << 2))
				  {
					// Particle_SetColors
                    uVar5 = FUN_8003f4c4((uint)uVar2,uVar26,param_2);

                    if ((uVar3 & 0x1000) == 0) {
                      uVar12 = 0x2000;
                      iVar9 = 0;
                      uVar13 = 0x1000;
                      uVar19 = 0;
                      uVar21 = 0x1000;
                      if ((uVar2 & 8) == 0) {
                        if ((uVar2 & 0x10) == 0) {
                          if ((uVar2 & 0x20) != 0) {
                            uVar12 = param_2[0x13] << 1;
                            uVar13 = (int)uVar12 >> 1;
                          }
                          if ((uVar2 & 0x40) != 0) {
                            uVar13 = param_2[0x15];
                          }
                        }
                        else {
                          uVar12 = param_2[0x11];

						  // approximate trigonometry
						  sVar4 = (short)*(int *)(&DAT_800845a0 + (uVar12 & 0x3ff) * 4);
                          uVar13 = *(int *)(&DAT_800845a0 + (uVar12 & 0x3ff) * 4) >> 0x10;

						  if ((uVar12 & 0x400) == 0) {
                            uVar10 = SEXT24(sVar4);
                            if ((uVar12 & 0x800) != 0) {
                              uVar17 = -uVar13;
                              goto LAB_8003ff30;
                            }
                          }
                          else {
                            uVar17 = SEXT24(sVar4);
                            uVar10 = uVar13;
                            if ((uVar12 & 0x800) == 0) {
                              uVar13 = -uVar17;
                            }
                            else {
LAB_8003ff30:
                              uVar10 = -uVar10;
                              uVar13 = uVar17;
                            }
                          }
                          if ((uVar2 & 0x20) == 0) {
                            if ((uVar2 & 0x40) != 0) {
                              iVar11 = param_2[0x15];
                              iVar9 = -uVar10 * iVar11;
                              uVar12 = (uVar13 & 0x7fff) << 1 | uVar10 << 0x11;
                              goto LAB_8004000c;
                            }
                            uVar12 = (uVar13 & 0x7fff) << 1 | uVar10 << 0x11;
                            iVar9 = uVar10 * -0x10000;
                            uVar13 = uVar13 & 0xffff;
                          }
                          else {
                            iVar15 = param_2[0x13];
                            if ((uVar2 & 0x40) == 0) {
                              uVar12 = (int)(uVar13 * iVar15) >> 0xc;
                              uVar13 = uVar12 & 0xffff;
                              iVar9 = (int)(uVar10 * iVar15) >> 0xc;
                              uVar12 = (uVar12 & 0x7fff) << 1 | iVar9 << 0x11;
                              iVar9 = iVar9 * -0x10000;
                            }
                            else {
                              iVar11 = param_2[0x15];
                              iVar9 = -uVar10 * iVar11;
                              uVar12 = (int)(uVar13 * iVar15) >> 0xb & 0xffffU |
                                       ((int)(uVar10 * iVar15) >> 0xb) << 0x10;
LAB_8004000c:
                              iVar9 = (iVar9 >> 0xc) << 0x10;
                              uVar13 = (int)(uVar13 * iVar11) >> 0xc & 0xffff;
                            }
                          }
                        }
                        goto LAB_80040074;
                      }
                      if ((uVar2 & 0x10) == 0) {
                        uVar21 = param_2[0xf];

						// approximate trigonometry
						sVar4 = (short)*(int *)(&DAT_800845a0 + (uVar21 & 0x3ff) * 4);
                        uVar13 = *(int *)(&DAT_800845a0 + (uVar21 & 0x3ff) * 4) >> 0x10;

						if ((uVar21 & 0x400) == 0) {
                          uVar10 = SEXT24(sVar4);
                          if ((uVar21 & 0x800) != 0) {
                            uVar19 = -uVar13;
                            goto LAB_8003fdec;
                          }
                        }
                        else {
                          uVar19 = SEXT24(sVar4);
                          uVar10 = uVar13;
                          if ((uVar21 & 0x800) == 0) {
                            uVar13 = -uVar19;
                          }
                          else {
LAB_8003fdec:
                            uVar10 = -uVar10;
                            uVar13 = uVar19;
                          }
                        }
                        if ((uVar2 & 0x20) == 0) {
                          uVar21 = uVar13 & 0xffff;
                          if ((uVar2 & 0x40) != 0) {
                            iVar11 = param_2[0x15];
                            goto LAB_8003fe90;
                          }
                          uVar13 = uVar21 | uVar10 << 0x10;
                          uVar19 = uVar10 * -0x10000;
                        }
                        else {
                          iVar15 = param_2[0x13];
                          if ((uVar2 & 0x40) != 0) {
                            iVar11 = param_2[0x15];
                            uVar12 = iVar15 << 1 & 0xffff;
LAB_8003fe90:
                            uVar19 = uVar10 * -0x10000;
                            uVar21 = uVar13 & 0xffff;
                            uVar13 = (int)(uVar13 * iVar11) >> 0xc & 0xffff;
                            iVar11 = (int)(uVar10 * iVar11) >> 0xc;
                            goto LAB_8003feac;
                          }
                          uVar12 = iVar15 << 1 & 0xffff;
                          iVar11 = (int)(uVar10 * iVar15) >> 0xc;
                          uVar21 = (int)(uVar13 * iVar15) >> 0xc & 0xffff;
                          uVar13 = uVar21 | iVar11 << 0x10;
                          uVar19 = iVar11 * -0x10000;
                        }
                      }
                      else {
                        uVar12 = param_2[0xf];

						// approximate trigonometry
						sVar4 = (short)*(int *)(&DAT_800845a0 + (uVar12 & 0x3ff) * 4);
                        uVar13 = *(int *)(&DAT_800845a0 + (uVar12 & 0x3ff) * 4) >> 0x10;

						if ((uVar12 & 0x400) == 0) {
                          uVar10 = SEXT24(sVar4);
                          if ((uVar12 & 0x800) != 0) {
                            uVar21 = -uVar13;
                            goto LAB_8003fac0;
                          }
                        }
                        else {
                          uVar21 = SEXT24(sVar4);
                          uVar10 = uVar13;
                          if ((uVar12 & 0x800) == 0) {
                            uVar13 = -uVar21;
                          }
                          else {
LAB_8003fac0:
                            uVar10 = -uVar10;
                            uVar13 = uVar21;
                          }
                        }
                        uVar12 = param_2[0x11];

						// approximate trigonometry
                        sVar4 = (short)*(int *)(&DAT_800845a0 + (uVar12 & 0x3ff) * 4);
                        uVar17 = *(int *)(&DAT_800845a0 + (uVar12 & 0x3ff) * 4) >> 0x10;

						if ((uVar12 & 0x400) == 0) {
                          uVar16 = SEXT24(sVar4);
                          if ((uVar12 & 0x800) != 0) {
                            uVar21 = -uVar17;
                            goto LAB_8003fb18;
                          }
                        }
                        else {
                          uVar21 = SEXT24(sVar4);
                          uVar16 = uVar17;
                          if ((uVar12 & 0x800) == 0) {
                            uVar17 = -uVar21;
                          }
                          else {
LAB_8003fb18:
                            uVar16 = -uVar16;
                            uVar17 = uVar21;
                          }
                        }
                        if ((uVar2 & 0x20) == 0) {
                          if ((uVar2 & 0x40) == 0) {
                            iVar9 = uVar13 * -uVar16;
                            iVar11 = uVar17 * uVar13;
                            iVar15 = uVar10 * uVar16;
                            iVar6 = -uVar10 * uVar17;
                            goto LAB_8003fd5c;
                          }
                          iVar11 = param_2[0x15];
                          uVar21 = uVar13 & 0xffff;
                          uVar12 = (uVar17 & 0x7fff) << 1 | uVar16 << 0x11;
                          uVar19 = (int)(uVar10 * uVar16) >> 0xc & 0xffffU |
                                   ((int)(-uVar10 * uVar17) >> 0xc) << 0x10;
                          iVar9 = (((int)(uVar13 * -uVar16) >> 0xc) * iVar11 >> 0xc) << 0x10;
                          uVar13 = ((int)(uVar17 * uVar13) >> 0xc) * iVar11 >> 0xc & 0xffff;
                          iVar11 = (int)(uVar10 * iVar11) >> 0xc;
                        }
                        else {
                          iVar15 = param_2[0x13];
                          if ((uVar2 & 0x40) == 0) {
                            uVar13 = (int)(uVar13 * iVar15) >> 0xc;
                            uVar16 = (int)(uVar16 * iVar15) >> 0xc;
                            iVar9 = uVar13 * -uVar16;
                            uVar17 = (int)(uVar17 * iVar15) >> 0xc;
                            iVar11 = uVar17 * uVar13;
                            uVar10 = (int)(uVar10 * iVar15) >> 0xc;
                            iVar15 = uVar10 * uVar16;
                            iVar6 = -uVar10 * uVar17;
LAB_8003fd5c:
                            uVar21 = uVar13 & 0xffff;
                            uVar12 = (uVar17 & 0x7fff) << 1 | uVar16 << 0x11;
                            iVar9 = (iVar9 >> 0xc) << 0x10;
                            uVar13 = iVar11 >> 0xc & 0xffffU | uVar10 << 0x10;
                            uVar19 = iVar15 >> 0xc & 0xffffU | (iVar6 >> 0xc) << 0x10;
                            goto LAB_80040074;
                          }
                          iVar11 = param_2[0x15];
                          uVar21 = uVar13 & 0xffff;
                          uVar12 = (int)(uVar17 * iVar15) >> 0xb & 0xffffU |
                                   ((int)(uVar16 * iVar15) >> 0xb) << 0x10;
                          uVar19 = (int)(uVar10 * uVar16) >> 0xc & 0xffffU |
                                   ((int)(-uVar10 * uVar17) >> 0xc) << 0x10;
                          iVar9 = (((int)(uVar13 * -uVar16) >> 0xc) * iVar11 >> 0xc) << 0x10;
                          uVar13 = ((int)(uVar17 * uVar13) >> 0xc) * iVar11 >> 0xc & 0xffff;
                          iVar11 = (int)(uVar10 * iVar11) >> 0xc;
                        }
LAB_8003feac:
                        uVar13 = uVar13 | iVar11 << 0x10;
                      }
LAB_80040074:
                      setCopControlWord(2,0,uVar12);
                      setCopControlWord(2,0x800,iVar9);
                      setCopControlWord(2,0x1000,uVar13);
                      setCopControlWord(2,0x1800,uVar19);
                      setCopControlWord(2,0x2000,uVar21);
                      puVar25[-7] = uVar5 | 0x2c000000;
                      puVar25[-5] = *(uint *)(iVar8 + 0x14);
                      puVar25[-3] = *(uint *)(iVar8 + 0x18) & 0xff9fffff | (uVar26 & 0x60) << 0x10;
                      *(undefined2 *)(puVar25 + -1) = *(undefined2 *)(iVar8 + 0x1c);
                      *(undefined2 *)(puVar25 + 1) = *(undefined2 *)(iVar8 + 0x1e);
                      iVar9 = ((uint)*(byte *)(iVar8 + 0x18) - (uint)*(byte *)(iVar8 + 0x14)) + 1;
                      uVar26 = iVar9 * 2;
                      iVar8 = ((uint)*(byte *)(iVar8 + 0x1d) - (uint)*(byte *)(iVar8 + 0x15)) + 1;
                      iVar11 = iVar8 * 2;
                      if ((uVar3 & 0x400) != 0) {
                        uVar26 = iVar9 * 0x10;
                        iVar11 = iVar8 * 0x10;
                      }
                      uVar5 = -uVar26 & 0xffff | iVar11 * -0x10000;
                      setCopReg(2,0x800,0);

					  // loop counter
                      iVar8 = 0;

					  // for iVar8 = 0; iVar8 < 4; iVar8++
					  // get four xy positions of quad
                      do
					  {
                        setCopReg(2,0,uVar5);

						// RTPS - Perspective Transformation (single)
                        copFunction(2,0x180001);

						if (iVar8 == 1) {
                          uVar5 = -uVar26 & 0xffff | iVar11 << 0x10;
                          
						  // screenspace pos xy
						  uVar12 = getCopReg(2,0xe);
						  
						  // offset 0x10
                          puVar24[4] = uVar12;
                        }
                        else {
                          if (iVar8 < 2) {
                            if (iVar8 == 0) {
                              uVar5 = uVar26 & 0xffff | iVar11 * -0x10000;
							  
							  // screenspace pos xy
                              uVar12 = getCopReg(2,0xe);
							  
								// offset 0x8
                              puVar24[2] = uVar12;
                              
							  DAT_1f800030 = getCopReg(2,0x13);
                            }
                          }
                          else {
                            if (iVar8 == 2) {
                              uVar5 = uVar26 & 0xffff | iVar11 << 0x10;
							  
							  // screenspace pos xy
                              uVar12 = getCopReg(2,0xe);
							  
							  // offset 0x18
                              puVar24[6] = uVar12;
                            }
                            else {
                              if (iVar8 == 3) 
							  {
								// screenspace pos xy
                                uVar12 = getCopReg(2,0xe);
								
								// offset 0x0
                                *puVar25 = uVar12;
                              }
                            }
                          }
                        }

						// increment loop counter
                        iVar8 = iVar8 + 1;
                      } while (iVar8 < 4);
                    }
                    else {
                      setCopControlWord(2,0,DAT_1f800000);
                      setCopControlWord(2,0x800,DAT_1f800004);
                      setCopControlWord(2,0x1000,DAT_1f800008);
                      setCopControlWord(2,0x1800,DAT_1f80000c);
                      setCopControlWord(2,0x2000,DAT_1f800010);
                      setCopReg(2,0,0);
                      setCopReg(2,0x800,0);
                      if ((uVar2 & 0x20) == 0) {
                        setCopReg(2,0x1000,param_2[0xf] - param_2[9] >> 6 & 0xffffU |
                                           (param_2[0x15] - param_2[0xb] >> 6) << 0x10);
                        setCopReg(2,0x1800,param_2[0x11] - param_2[0xd] >> 6);
                      }
                      else {
                        iVar8 = param_2[0x13];
                        setCopReg(2,0x1000,(uint)((param_2[0xf] - param_2[9] >> 6) * iVar8) >> 0x10
                                           | ((param_2[0x15] - param_2[0xb] >> 6) * iVar8 >> 0x10)
                                             << 0x10);
                        setCopReg(2,0x1800,(param_2[0x11] - param_2[0xd] >> 6) * iVar8 >> 0x10);
                      }

					  // RTPT - Perspective Transformation (triple)
                      copFunction(2,0x280030);

					  uVar5 = uVar5 | 0x50000000;
                      if ((uVar3 & 0x2000) == 0) {
                        uVar12 = param_2[0x1d];
                        puVar24[3] = uVar5;
                        puVar24[5] = uVar12;
                      }
                      else {
                        uVar12 = param_2[0x1d];
                        puVar24[5] = uVar5;
                        puVar24[3] = uVar12;
                      }
                      param_2[0x1e] = uVar5;
                      puVar24[1] = uVar26 & 0x60 | 0xe1000a00;
                      puVar24[2] = 0;
                      uVar26 = getCopReg(2,0xc);
                      puVar24[4] = uVar26;
                      uVar26 = getCopReg(2,0xd);
                      puVar24[6] = uVar26;
                      DAT_1f800030 = getCopReg(2,0x11);
                    }
                    if (iVar18 == 0) {
                      uVar5 = (DAT_1f800030 >> 8) + (int)*(char *)(param_2 + 6);
                      uVar26 = uVar5;
                      if ((int)uVar5 < 0) {
                        uVar26 = 0;
                      }
                      iVar8 = DAT_1f800020;
                      if (0x3ff < (int)uVar5) {
                        uVar26 = 0x3ff;
                      }
                    }
                    else {
                      uVar26 = DAT_1f800030 >> 5;
                      if (DAT_1f800030 >> 5 < (int)(uint)*(ushort *)(iVar18 + 0x68)) {
                        uVar26 = (uint)*(ushort *)(iVar18 + 0x68);
                      }
                      if ((int)(uint)*(ushort *)(iVar18 + 0x6a) < (int)uVar26) {
                        uVar26 = (uint)*(ushort *)(iVar18 + 0x6a);
                      }
                      iVar8 = *(int *)(iVar18 + 0x70);
                    }
                    puVar14 = (uint *)(iVar8 + uVar26 * 4);
                    if ((uVar3 & 0x1000) == 0) {
                      puVar25 = puVar25 + 10;
                      *puVar24 = *puVar14 | 0x9000000;
                      puVar7 = puVar24 + 10;
                    }
                    else {
                      puVar25 = puVar25 + 7;
                      *puVar24 = *puVar14 | 0x6000000;
                      puVar7 = puVar24 + 7;
                    }
                    *puVar14 = (uint)puVar24 & 0xffffff;
                  }
                }
              }
            }
          }
        }
LAB_800402b0:

		// linked list, get next node
        param_2 = (int *)*param_2;

        puVar24 = puVar7;

	  // until you hit nullptr
	  } while (param_2 != (int *)0x0);
    }

	// backBuffer->primMem.curr
    *(uint **)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80) = puVar7;
  }
  return;
}


// Particle_CreateInstance
// param2 - IconGroup
undefined4 * FUN_80040308(undefined4 param_1,int param_2,ushort *param_3)

{
  ushort uVar1;
  undefined4 *puVar2;
  undefined *puVar3;
  short sVar4;
  undefined4 *puVar5;
  undefined4 *puVar6;
  int iVar7;
  uint uVar8;
  undefined4 uVar9;
  undefined4 *puVar10;
  undefined4 uVar11;
  undefined4 uVar12;
  ushort uVar13;
  int iVar14;
  ushort *puVar15;
  uint uVar16;
  uint uVar17;
  undefined4 local_60 [12];
  int local_30;
  undefined4 *local_2c;

  // ordinary particle
  local_30 = 0;

  // LIST_RemoveFront
  // first free item in Particle Pool
  puVar5 = (undefined4 *)FUN_8003186c(PTR_DAT_8008d2ac + 0x1998);

  uVar17 = 0;

  // if particle allocated correctly
  if (puVar5 != (undefined4 *)0x0)
  {
	// increment number of particles
    *(int *)(PTR_DAT_8008d2ac + 0x1ca4) = *(int *)(PTR_DAT_8008d2ac + 0x1ca4) + 1;

	// ptrIconGroup (sprite animation?)
	puVar5[3] = param_2;

	// if group is invalid
    if (
			(
				// if nullptr
				(param_2 == 0) ||

				// if there are no icons in group
				(*(short *)(param_2 + 0x12) == 0)
			) ||

			// if there are still no icons in group
			(*(short *)(param_2 + 0x12) < 1)
		)
	{
	  // erase ptrIconGroup and ptrIcons
      puVar5[3] = 0;
      puVar5[2] = 0;
    }

	// if group is valid
    else
	{
	  // keep ptr to icon array
      puVar5[2] = *(undefined4 *)(param_2 + 0x14);
    }

	// safe-check nullptr
    if (param_3 != (ushort *)0x0)
	{
      // emitterChunk offset 0x0 (flags)
	  uVar1 = *param_3;

	  // always != 0, except last chunk
      if (uVar1 != 0)
	  {
        local_2c = local_60;

		// emitterChunk offset 0x12
        puVar15 = param_3 + 9;

        do
		{
		  // emitterChunk offset 0x12-0x10 (0x2),
		  // used as an offset for writing particle
          uVar16 = (uint)*(byte *)(puVar15 + -8);

		  // if invalid, assume color/funcPtr initializer
          if (*(byte *)(puVar15 + -8) == 0xc)
		  {
			// if not an AxisInit or (other?),
			// then assume this is a FuncInit
            if ((uVar1 & 0xc0) == 0)
			{
			  // emitterChunk offset 0x12-0xE (0x4)
			  // function pointer to animate particle (can be nullptr)
              puVar5[7] = *(undefined4 *)(puVar15 + -7);

			  // emitterChunk offset 0x12-0xA (0x8)
			  // flags, passed to SetColors
              *(ushort *)((int)puVar5 + 0x12) = puVar15[-5];

			  // emitterChunk offset 0x12-0x8 (0xA)
			  // number of frames in particle life
              *(ushort *)(puVar5 + 4) = puVar15[-4];

              uVar17 = uVar17 | 0x1000;

			  // emitterChunk offset 0x12-0x6 (0xC)
			  // ordinary particle, or heatWarp particle
			  local_30 = *(int *)(puVar15 + -3);
            }
          }

		  // if not color/funcPtr initializer
          else {
            if ((uVar1 & 0x80) == 0)
			{
			  // if this is not a memcpy Init
              if ((uVar1 & 0x40) == 0)
			  {
				// assume AxisInit emitter
				  
				  
				// === pos init ===
				
				
				// value
                iVar14 = 0;
				
				// if base value exists
                if ((uVar1 & 1) != 0)
				{
				  // emitterChunk offset 0x12-0xE (0x4)
                  iVar14 = *(int *)(puVar15 + -7);
                }

				if ((uVar1 & 8) != 0)
				{
				  // RNG
				  // emitterChunk offset 0x12-0x6 (0xC)
                  iVar7 = FUN_8003ea6c(*(undefined4 *)(puVar15 + -3));
                  iVar14 = iVar14 + iVar7;
                }
				
				
				// particle + offset * 2
				// determines which axis is initialized
                puVar6 = puVar5 + uVar16 * 2;
				
				
				// 0x24 - position
                puVar6[9] = iVar14;
				
				
				// === vel init ===
				
				
				// velocity
                uVar13 = 0;

				// if base vel exists
				if ((uVar1 & 2) != 0)
				{
				  // emitterChunk offset 0x12-0xA (0x8)
                  uVar13 = puVar15[-5];
                }

				if ((uVar1 & 0x10) != 0)
				{
				  // RNG
				  // emitterChunk offset 0x12-0x2 (0x10)
                  sVar4 = FUN_8003ea6c((int)(short)puVar15[-1]);
                  uVar13 = uVar13 + sVar4;
                }

				// 0x28 - velocity
                *(ushort *)(puVar6 + 10) = uVar13;
				
				
				// === accel init ===
				
				
				// acceleration
                uVar13 = 0;

				// if base accel exists
				if ((uVar1 & 4) != 0)
				{
				  // emitterChunk offset 0x12-0x8 (0xA)
                  uVar13 = puVar15[-4];
                }

                if ((uVar1 & 0x20) != 0)
				{
				  // RNG
				  // emitterChunk offset 0x12
                  sVar4 = FUN_8003ea6c((int)(short)*puVar15);
                  uVar13 = uVar13 + sVar4;
                }

				// 0x2A - acceleration
                *(ushort *)((int)puVar6 + 0x2a) = uVar13;
				
                uVar17 = uVar17 | 1 << (uVar16 & 0x1f);
              }

			  // & 0x40 == 1
              else
			  {
                if ((uVar17 & 1 << (uVar16 + 0x10 & 0x1f)) == 0)
				{
				  // LIST_RemoveFront
				  // first free member in Oscillator Pool
                  iVar14 = FUN_8003186c(PTR_DAT_8008d2ac + 0x19c0);

                  if (iVar14 == 0) goto LAB_800406f8;
                  local_2c[uVar16] = iVar14;
                }
                else {
                  iVar14 = local_2c[uVar16];
                }

				// lazy memcpy
				// src: emitterChunk offset 0x12+0x2 (0x14)
				// dst: iVar14 + 8
				// size: 0x10
                uVar11 = *(undefined4 *)(puVar15 + 3);
                uVar12 = *(undefined4 *)(puVar15 + 5);
                uVar9 = *(undefined4 *)(puVar15 + 7);
                *(undefined4 *)(iVar14 + 8) = *(undefined4 *)(puVar15 + 1);
                *(undefined4 *)(iVar14 + 0xc) = uVar11;
                *(undefined4 *)(iVar14 + 0x10) = uVar12;
                *(undefined4 *)(iVar14 + 0x14) = uVar9;

				// emitterChunk offset 0x12+0x2 (0x14)
				if ((puVar15[1] & 0x20) != 0)
				{
				  // related to confetti frame timer

                  *(short *)(iVar14 + 0xe) =
                       *(short *)(iVar14 + 0xe) - *(short *)(PTR_DAT_8008d2ac + 0x1cf0);
                }

				// emitterChunk offset 0x12+0x2 (0x14)
                if ((puVar15[1] & 7) == 6)
				{
                  *(undefined2 *)(iVar14 + 10) = *(undefined2 *)(iVar14 + 0xe);
                }

				uVar17 = uVar17 | 1 << (uVar16 + 0x10 & 0x1f);
                uVar8 = 1 << (uVar16 & 0x1f);
                if ((uVar17 & uVar8) == 0) {
                  uVar17 = uVar17 | uVar8;
                  puVar6 = puVar5 + uVar16 * 2;
                  puVar6[9] = 0;
                  *(undefined2 *)(puVar6 + 10) = 0;
                  *(undefined2 *)((int)puVar6 + 0x2a) = 0;
                }
              }
            }

			// & 0x80 == 1
			else {
              if ((uVar17 & 1 << (uVar16 + 0x10 & 0x1f)) != 0) {
                iVar14 = local_2c[uVar16];

				// emitterChunk offset 0x12+0x6 (0x18)
                if (puVar15[3] != 0)
				{
				  // RNG
				  // emitterChunk offset 0x12+0x6 (0x18)
                  sVar4 = FUN_8003ea6c((uint)puVar15[3]);
                  *(short *)(iVar14 + 0xc) = *(short *)(iVar14 + 0xc) + sVar4;
                }

				// emitterChunk offset 0x12+0x8 (0x1A)
                if ((int)(short)puVar15[4] != 0)
				{
				  // RNG
				  // emitterChunk offset 0x12+0x8 (0x1A)
                  sVar4 = FUN_8003ea6c((int)(short)puVar15[4]);
                  *(short *)(iVar14 + 0xe) = *(short *)(iVar14 + 0xe) + sVar4;
                }

				// emitterChunk offset 0x12+0xA (0x1C)
				if (puVar15[5] != 0)
				{
				  // RNG
				  // emitterChunk offset 0x12+0xA (0x1C)
                  sVar4 = FUN_8003ea6c((uint)puVar15[5]);
                  *(short *)(iVar14 + 0x10) = *(short *)(iVar14 + 0x10) + sVar4;
                }

				// emitterChunk offset 0x12+0xC (0x1E)
                if ((int)(short)puVar15[6] != 0)
				{
				  // RNG
				  // emitterChunk offset 0x12+0xC (0x1E)
                  sVar4 = FUN_8003ea6c((int)(short)puVar15[6]);
                  *(short *)(iVar14 + 0x12) = *(short *)(iVar14 + 0x12) + sVar4;
                }

				// emitterChunk offset 0x12+0xE (0x20)
                if ((int)(short)puVar15[7] != 0)
				{
				  // RNG
				  // emitterChunk offset 0x12+0xE (0x20)
                  sVar4 = FUN_8003ea6c((int)(short)puVar15[7]);
                  *(short *)(iVar14 + 0x14) = *(short *)(iVar14 + 0x14) + sVar4;
                }

				// emitterChunk offset 0x12+0x10 (0x22)
				if ((int)(short)puVar15[8] != 0)
				{
				  // RNG
				  // emitterChunk offset 0x12+0x10 (0x22)
                  sVar4 = FUN_8003ea6c((int)(short)puVar15[8]);
                  *(short *)(iVar14 + 0x16) = *(short *)(iVar14 + 0x16) + sVar4;
                }
              }
            }
          }
LAB_800406f8:

		  // every particle emitter metadata
		  // is divided into 0x24-byte chunks

		  // next particle emitter chunk
          param_3 = param_3 + 0x12;

		  // get flag of next type,
		  // while (!= 0) checks validity
		  uVar1 = *param_3;

		  // next particle emitter chunk
          puVar15 = puVar15 + 0x12;
        } while (uVar1 != 0);
      }
    }

	// shift flags down (top 2 bytes)
	uVar16 = (int)uVar17 >> 0x10;

	puVar6 = local_60;

	// particle offset 0x4
    puVar2 = puVar5 + 1;

	// check all bits
    while (uVar16 != 0)
	{
	  // backup particle offset 0x4 (why?)
      puVar10 = puVar2;

	  // if bit is on
      if ((uVar16 & 1) != 0)
	  {
		// new value of particle offset 0x4
        puVar10 = (undefined4 *)*puVar6;

		// set particle offset 0x4
        *(undefined4 **)puVar2 = puVar10;
      }

	  // next bit
      uVar16 = (int)uVar16 >> 1;

	  // count bit index
      puVar6 = puVar6 + 1;

	  // set new value, or restore old value (why?)
      puVar2 = puVar10;
    }

	// particle -> 0x4 -> 0x0 = 0
    *puVar2 = 0;

	// if flag was not set in the previous loop
    if ((uVar17 & 0x1000) == 0)
	{
	  // sep 3
	  // printf("particle initializer w/o PARTICLEFIELD_SPECIAL\n");

	  // clear function
      puVar5[7] = 0;

	  // no flags passed to SetColor
      *(undefined2 *)((int)puVar5 + 0x12) = 0;

	  // zero life in this particle
      *(undefined2 *)(puVar5 + 4) = 0;

	  // erase pointers
      puVar5[2] = 0;
      puVar5[3] = 0;
    }
    puVar5[5] = uVar17 & 0xffffefff;
    puVar3 = PTR_DAT_8008d2ac;

	// ordinary particle
    if (local_30 == 0)
	{
	  // linked list, first member of struct is the pointer to next
      *puVar5 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1c9c);
      *(undefined4 **)(puVar3 + 0x1c9c) = puVar5;
    }

	// heatwarp particle
	else
	{
	  // linked list, first member of struct is the pointer to next
      *puVar5 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1ca0);
      *(undefined4 **)(puVar3 + 0x1ca0) = puVar5;
    }

	// particle offset 0x12, flags for alpha in SetColor
    uVar1 = *(ushort *)((int)puVar5 + 0x12);

    *(undefined2 *)((int)puVar5 + 0x1a) = 0x400;
    *(undefined *)((int)puVar5 + 0x19) = 0xff;

	// offset 0x18
    *(undefined *)(puVar5 + 6) = 0;

    if ((uVar1 & 0x1000) != 0) {
      if ((uVar1 & 0x4000) == 0)
	  {
		// Particle_SetColors
        uVar17 = FUN_8003f4c4(uVar17,(uint)*(ushort *)((int)puVar5 + 0x12),puVar5);

        puVar5[0x1d] = uVar17 | 0x50000000;
        puVar5[0x1e] = uVar17 | 0x50000000;
      }
      else
	  {
		// ???
        uVar9 = 0x50000000;

		if ((uVar1 & 0x80) != 0)
		{
		  // ??? + Alpha clipping
          uVar9 = 0x52000000;
        }
        puVar5[0x1d] = uVar9;
      }
    }
  }
  return puVar5;
}


// RivalWeapons_Init
void FUN_80040850(void)

{
  int iVar1;

  // get hubID of level
  iVar1 = (uint)*(ushort *)(&DAT_80083a80 + *(int *)(PTR_DAT_8008d2ac + 0x1a10) * 0x18) << 0x10;

  // If Level ID == 13
  // If Level ID is Oxide Station
  if (*(int *)(PTR_DAT_8008d2ac + 0x1a10) == 0xd) {
    iVar1 = 0;
  }

  if (-1 < iVar1 >> 0x10)
  {
	// set pointer to boss weapon meta
    DAT_8008d8e8 = (&PTR_DAT_800859d0)[iVar1 >> 0x10];
  }

  return;
}


// RivalWeapons_PerFrame
void FUN_800408b8(void)
{
  // handles which weapons bosses use

  undefined uVar1;
  short sVar2;
  ushort uVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  byte bVar8;
  undefined uVar9;
  undefined4 uVar10;
  short sVar11;
  byte *pbVar12;
  int iVar13;
  int iVar14;

  // pointer to boss meta
  pbVar12 = DAT_8008d8e8;

  // If number of AIs is zero,			or		time on clock is less than 4b00
  if ((PTR_DAT_8008d2ac[0x1cab] == '\0') || (*(int *)(PTR_DAT_8008d2ac + 0x1d10) < 0x4b00)) {
    if (-1 < *(int *)PTR_DAT_8008d2ac) {
      return;
    }

	// quit if event started less than 4800ms ago (4.8s)
    if (*(int *)(PTR_DAT_8008d2ac + 0x1d10) < 0x12c0) {
      return;
    }
  }

  // if this is NOT an unfinished boss race
  if ((*(uint *)PTR_DAT_8008d2ac & 0x80200000) != 0x80000000)
  {
	// This whole block handles Arcade/Adv weapons
	// RNG for firing the weapons
	// RNG for choosing wumpa (change tnt/nitro)
	// RNG for which weaopn shoots (oxide)
	// etc

    iVar13 = 0;

	// if number of screens is 0
    if (PTR_DAT_8008d2ac[0x1ca8] == '\0') {
      return;
    }

	// if number of screens is not zero

	// for(int iVar13 = 0; iVar13 < numScreens; iVar13++)
    do
	{
	  // get the player structure of each human player
      iVar14 = *(int *)(PTR_DAT_8008d2ac + iVar13 * 4 + 0x24ec);

	  // if racer is not in first place
      if ((int)*(short *)(iVar14 + 0x482) != 0)
	  {
		// driver in front of the player
        iVar4 = *(int *)(PTR_DAT_8008d2ac + ((int)*(short *)(iVar14 + 0x482) + -1) * 4 + 0x250c);

		if (
				(
					(
						(
							// If this is an AI and not a human
							(*(uint *)(iVar4 + 0x2c8) & 0x100000) != 0
						) &&

						(
							// if AI is not blasted or spinning out
							(*(uint *)(iVar4 + 0x5b0) & 2) == 0
						)
					) &&
					(
						//if racer hasn't finished the race
						(*(uint *)(iVar4 + 0x2c8) & 0x2000000) == 0
					)
				) &&
				(
					(
						(
							// If there is no AI weapon cooldown
							*(short *)(iVar4 + 0x624) == 0 &&

							// If you dont have a tnt on your head
							(*(int *)(iVar4 + 0x18) == 0)
						) &&
						(
							(
								// if there is no clock weapon in effect
								*(short *)(iVar4 + 0xc) == 0 &&
								(
									// driver1x - driver2x
									iVar6 = *(int *)(*(int *)(iVar14 + 0x1c) + 0x44) -
											*(int *)(*(int *)(iVar4 + 0x1c) + 0x44),

									// driver1z - driver2z
									iVar7 = *(int *)(*(int *)(iVar14 + 0x1c) + 0x4c) -
											*(int *)(*(int *)(iVar4 + 0x1c) + 0x4c),

									// check if distance between drivers is small
									(iVar6 * iVar6 + iVar7 * iVar7) - 0x90001U < 0x13affff
								)
							)

						)
					)
				)
			)
		{
		  // Get random number
          iVar6 = FUN_8003ea28();

		  // Get remainder when divided by 200
          iVar6 = iVar6 % 200;

		  // If RNG is 0, (1/200 chance)
		  if (iVar6 == 0)
		  {
            if (
					(*(char *)(iVar4 + 0x44) != '\0') &&

					(
						// Get random number
						iVar6 = FUN_8003ea28(),

						// 50% chance this will happen
						iVar6 % 100 < 0x32
					)
				)
			{
			  // Set number of wumpa to 10
              *(undefined *)(iVar4 + 0x30) = 10;
            }

			// if time on the clock is an even number
            if ((*(uint *)(PTR_DAT_8008d2ac + 0x1d10) & 1) == 0)
			{
			  // Set weapon to potion
              *(undefined *)(iVar4 + 0x36) = 4;

			  // If this is human and not AI
              if ((*(uint *)(iVar14 + 0x2c8) & 0x100000) == 0)
			  {
				// Make driver talk
                FUN_8002cbe8(0xf,(int)(short)(&DAT_80086e84)[*(byte *)(iVar4 + 0x4a)],
                             (int)(short)(&DAT_80086e84)[*(byte *)(iVar14 + 0x4a)]);
              }

			  // potion
              uVar10 = 4;
            }

			// if time on the clock is an odd number
            else
			{
			  // Set weapon to tnt/nitro
              *(undefined *)(iVar4 + 0x36) = 3;

			  // If this is human and not AI
              if ((*(uint *)(iVar14 + 0x2c8) & 0x100000) == 0)
			  {
				// Make driver talk
                FUN_8002cbe8(0xf,(int)(short)(&DAT_80086e84)[*(byte *)(iVar4 + 0x4a)],
                             (int)(short)(&DAT_80086e84)[*(byte *)(iVar14 + 0x4a)]);
              }

			  // tnt/nitro
              uVar10 = 3;
            }

			// Weapon_Shoot_Now (Arcade/Adv)
            FUN_8006540c(iVar4,uVar10,0);

			// set wumpa to zero
            *(undefined *)(iVar4 + 0x30) = 0;

LAB_800412a4:

			// Get random number
            uVar3 = FUN_8003ea28();

			// weapon cooldown
            *(short *)(iVar4 + 0x624) = (uVar3 & 0xff) + 0xf0;
          }
          else
		  {
			// If RNG is 1, (1/200 chance)
            if (iVar6 == 1)
			{
			  // Set weapon to bomb
              *(undefined *)(iVar4 + 0x36) = (char)iVar6;

			  // If this is human and not AI
              if ((*(uint *)(iVar14 + 0x2c8) & 0x100000) == 0)
			  {
				// Player / AI structure + 0x4a shows driver index (0-7)

				// Get character ID of two player/AI structures: iVar4 and iVar14

                sVar11 = (&DAT_80086e84)[*(byte *)(iVar4 + 0x4a)];
                sVar2 = (&DAT_80086e84)[*(byte *)(iVar14 + 0x4a)];
                uVar10 = 10;
LAB_8004128c:
				// Make driver talk
                FUN_8002cbe8(uVar10,(int)sVar11,(int)sVar2);
              }
LAB_80041298:
			  // Weapon_Shoot_Now (Arcade/Adv), Missile
              FUN_8006540c(iVar4,2,0);
              goto LAB_800412a4;
            }

			// If RNG is 2, (1/200 chance)
            if (iVar6 == 2)
			{
			  // Set weapon to 2
              *(undefined *)(iVar4 + 0x36) = (char)iVar6;

              // if this is human and not AI
              if ((*(uint *)(iVar14 + 0x2c8) & 0x100000) == 0)
			  {

				// Player / AI structure + 0x4a shows driver index (0-7)

				// Get character ID of two player/AI structures: iVar4 and iVar14

                sVar11 = (&DAT_80086e84)[*(byte *)(iVar4 + 0x4a)];
                sVar2 = (&DAT_80086e84)[*(byte *)(iVar14 + 0x4a)];
                uVar10 = 0xb;
                goto LAB_8004128c;
              }
              goto LAB_80041298;
            }
          }

		  // You have no weapon
          *(undefined *)(iVar4 + 0x36) = 0xf;
        }
      }

	  // If racer is in the top 3 places of the race (1st, 2nd, 3rd)
      if ((int)*(short *)(iVar14 + 0x482) < 3)
	  {
		// driver in the position behind player
        iVar4 = *(int *)(PTR_DAT_8008d2ac + ((int)*(short *)(iVar14 + 0x482) + 1) * 4 + 0x250c);

        if (
				(
					(
						(
							// If this is an AI, and not human
							((*(uint *)(iVar4 + 0x2c8) & 0x100000) != 0) &&

							// if AI is not blasted or spinning out
							((*(uint *)(iVar4 + 0x5b0) & 2) == 0)
						) &&

						//if racer hasn't finished the race
						((*(uint *)(iVar4 + 0x2c8) & 0x2000000) == 0)
					) &&
					(
						(
							(
								// If there is no AI weapon cooldown
								*(short *)(iVar4 + 0x624) == 0 &&

								// If there is no TNT on your head
								(*(int *)(iVar4 + 0x18) == 0)
							) &&
							(
								(
									// If there is no clock weapon in effect
									*(short *)(iVar4 + 0xc) == 0 &&
									(
										(
											// this driver's lap count less than number of laps in race,
											// (this is false if you finish race)
											(int)(uint)*(byte *)(iVar14 + 0x44) < (int)(char)PTR_DAT_8008d2ac[0x1d33] ||

											// distToFinish more than 16000
											(16000 < *(int *)(iVar14 + 0x488))
										)
									)
								)
							)
						)
					) &&
					(
						// driver1x - driver2x
						iVar6 = *(int *)(*(int *)(iVar14 + 0x1c) + 0x44) -
								*(int *)(*(int *)(iVar4 + 0x1c) + 0x44),

						// driver1z - driver2z
						iVar7 = *(int *)(*(int *)(iVar14 + 0x1c) + 0x4c) -
								*(int *)(*(int *)(iVar4 + 0x1c) + 0x4c),

						// check if distance between drivers is small
						(iVar6 * iVar6 + iVar7 * iVar7) - 0x90001U < 0x13affff
					)
				)
			)
		{
		  // Get random number
          iVar6 = FUN_8003ea28();

		  if (
				(
					// 2 in 800 chance (1 in 400)
					(iVar6 % 800 < 2) &&
					(
						// override weapon to missile
						uVar9 = 2,

						// if driver's lap is not last lap
						(uint)*(byte *)(iVar4 + 0x44) != (int)(char)PTR_DAT_8008d2ac[0x1d33] - 1U
					)
				) ||
				(
					// override weapon to bomb
					uVar9 = 1,

					// 4 in 800 chance (1 in 200)
					iVar6 % 800 < 4
				)
			 )
		  {
			// set weapon
            *(undefined *)(iVar4 + 0x36) = uVar9;

			// If this is an AI and not human
            if ((*(uint *)(iVar14 + 0x2c8) & 0x100000) == 0)
			{
			  // Make driver talk
              FUN_8002cbe8(0xb,(int)(short)(&DAT_80086e84)[*(byte *)(iVar4 + 0x4a)],
                           (int)(short)(&DAT_80086e84)[*(byte *)(iVar14 + 0x4a)]);
            }

			// Weapon_Shoot_Now (Arcade/Adv) Missile
            FUN_8006540c(iVar4,2,0);

			// Get random number
            uVar3 = FUN_8003ea28();

			// cooldown before next weapon
            *(short *)(iVar4 + 0x624) = (uVar3 & 0xff) + 0xf0;
          }

		  // You have no weapon
          *(undefined *)(iVar4 + 0x36) = 0xf;
        }
      }

      // increment loop counter
      iVar13 = iVar13 + 1;

	  // for(int iVar13 = 0; iVar13 < numScreens; iVar13++)
      if ((int)(uint)(byte)PTR_DAT_8008d2ac[0x1ca8] <= iVar13)
	  {
		// when the loop is finished, quit the function
        return;
      }
    } while( true );
  }

  // =============================

  // Everything beyond this line is for Boss weapons

  // =============================

  // pointer to player structure (P2 or boss)
  iVar13 = *(int *)(PTR_DAT_8008d2ac + 0x24f0);

  // pointer to player structure (P1)
  iVar14 = *(int *)(PTR_DAT_8008d2ac + 0x24ec);

  if (
		(
			((*(uint *)(iVar13 + 0x5b0) & 2) != 0) ||

			//if racer finished this race
			((*(uint *)(iVar13 + 0x2c8) & 0x2000000) != 0)
		) ||
		(
			(
				// if boss has tnt on their head
				*(int *)(iVar13 + 0x18) != 0 ||
				(
					(
						// victim of clock weapon
						*(short *)(iVar13 + 0xc) != 0 ||

						// if boss has not reached high speed
						(*(int *)(iVar13 + 0x5d4) < 0x1f41)
					)
				)
			)
		)
	)
  {
	// some kind of RNG with 0xdeadc0ed
    uVar3 = FUN_8006c684(&DAT_8008d668);

	// new cooldown
    DAT_8008d8e4 =

		// random [0 to 16] +
		(uVar3 & 0x10) +

		// min cooldown for boss
		*(short *)(pbVar12 + 4) + 0xc +

			// number of times you lost the event
			(short)(char)(&DAT_8008fbeb)[*(int *)(PTR_DAT_8008d2ac + 0x1eb8)] * 4;

    return;
  }

  if (DAT_8008d8e8[9] == 0) {
    if ((int)((uint)*(ushort *)
                     ((uint)*DAT_8008d8e8 * 0xc +
                      *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c) + 6) << 3) <
		// distToFinish
        *(int *)(iVar13 + 0x488))
	{
      uVar3 = 0xffff;
      if (((DAT_8008d8e8[2] == 0x66) || (DAT_8008d8e8[2] == 100)) && (DAT_8008d42c == 5)) {
        uVar3 = (ushort)DAT_8008d8e8[1];
      }
      pbVar12 = PTR_DAT_800859d0;

	  // if levelID is not oxide station
      if (*(int *)(PTR_DAT_8008d2ac + 0x1a10) != 0xd)
	  {
		// set boss weapon meta to the one type it can be on this hub
        pbVar12 = (&PTR_DAT_800859d0)
                  [*(short *)(&DAT_80083a80 + *(int *)(PTR_DAT_8008d2ac + 0x1a10) * 0x18)];
      }
      if (uVar3 != 0xffff) {
        pbVar12[1] = (byte)uVar3;
      }
    }
  }
  else
  {
	// distToFinish less than...
    if (*(int *)(iVar13 + 0x488) <
        (int)((uint)*(ushort *)
                     ((uint)DAT_8008d8e8[8] * 0xc +
                      *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c) + 6) << 3)) {
      bVar8 = 0xff;
      if (((DAT_8008d8e8[2] == 0x66) || (iVar4 = -0x10000, DAT_8008d8e8[2] == 100)) &&
         (iVar4 = -0x10000, DAT_8008d42c == 5)) {
        bVar8 = DAT_8008d8e8[1];
        iVar4 = (uint)bVar8 << 0x10;
      }
      pbVar12 = DAT_8008d8e8 + 8;
      if (iVar4 >> 0x10 != -1) {
        DAT_8008d8e8[9] = bVar8;
      }
    }
  }

  // set new boss meta
  DAT_8008d8e8 = pbVar12;

  if (pbVar12[3] == 0) {
    if (DAT_8008d428 == 0x1e) {
      if ((*(uint *)(iVar13 + 0x5b0) & 0x80) == 0) {
        if (DAT_8008d42a == 0) {
          sVar11 = *(short *)(iVar13 + 0x5b8);
          if (sVar11 == 2) goto LAB_80040ba0;
          if (sVar11 == 1) {
            *(undefined *)(iVar13 + 0x627) = 0;
            DAT_8008d428 = 0;
            DAT_8008d42a = sVar11;
            *(uint *)(iVar13 + 0x5b0) = *(uint *)(iVar13 + 0x5b0) | 0x40;
          }
        }
        else {
          if (*(short *)(iVar13 + 0x5b8) == 0) {
LAB_80040ba0:
            uVar5 = *(uint *)(iVar13 + 0x5b0);
            *(undefined *)(iVar13 + 0x627) = 1;
          }
          else {
            if (*(short *)(iVar13 + 0x5b8) != 1) goto LAB_80040bf8;
            uVar5 = *(uint *)(iVar13 + 0x5b0);
            *(undefined *)(iVar13 + 0x627) = 2;
            DAT_8008d42a = 0;
          }
          DAT_8008d428 = 0;
          *(uint *)(iVar13 + 0x5b0) = uVar5 | 0x40;
        }
      }
    }
    else {
      if ((*(uint *)(iVar13 + 0x5b0) & 0x40) == 0) {
        DAT_8008d428 = DAT_8008d428 + 1;
      }
    }
  }
LAB_80040bf8:

  // cooldown, cant shoot weapons till finished
  if (0 < DAT_8008d8e4) {
    DAT_8008d8e4 = DAT_8008d8e4 + -1;
    return;
  }

  // some kind of RNG with 0xdeadc0ed
  uVar3 = FUN_8006c684(&DAT_8008d668);

  // new cooldown
  DAT_8008d8e4 =

	// random [0 to 16] +
	(uVar3 & 0x10) +

	// min cooldown for boss
	*(short *)(pbVar12 + 4) + 0xc +

		// number of times you lost the event
		(short)(char)(&DAT_8008fbeb)[*(int *)(PTR_DAT_8008d2ac + 0x1eb8)] * 4;

  bVar8 = pbVar12[2];
  uVar5 = (uint)bVar8;
  if (bVar8 == 100) {
    uVar5 = 3;
  }
  else {
    if (bVar8 == 0x65) {
      uVar5 = 1;
    }
    else {
      if (bVar8 == 0x66) {
        uVar5 = 4;
      }
      else {
        if (bVar8 == 0xf) {
          uVar5 = 0xffffffff;
        }
      }
    }
  }
  uVar3 = *(ushort *)(pbVar12 + 6);
  if ((uVar3 & 2) == 0) {
LAB_80040d9c:
    DAT_8008d42c = 0;
    sVar11 = DAT_8008d42c;
  }
  else {
    sVar11 = DAT_8008d42c + 1;
    if (DAT_8008d42c < 5) goto LAB_80040da0;
    bVar8 = pbVar12[2];
    if (bVar8 == 100) {
      uVar5 = 3;
      if (pbVar12[1] != 3) {
        pbVar12[1] = 3;
        DAT_8008d42c = 5;
        *(ushort *)(pbVar12 + 6) = uVar3 | 1;
        sVar11 = DAT_8008d42c;
        goto LAB_80040da0;
      }
    }
    else {
      if (bVar8 == 0x65) {
        uVar5 = 1;
        if ((uVar3 & 1) == 0) {
          *(ushort *)(pbVar12 + 6) = uVar3 | 1;
          DAT_8008d42c = 5;
          uVar5 = 3;
          sVar11 = DAT_8008d42c;
          goto LAB_80040da0;
        }
        *(ushort *)(pbVar12 + 6) = uVar3 & 0xfffe;
        goto LAB_80040d9c;
      }
      sVar11 = DAT_8008d42c;
      if (bVar8 != 0x66) goto LAB_80040da0;
      uVar5 = 4;
      if (pbVar12[1] != 3) {
        pbVar12[1] = 3;
        DAT_8008d42c = 5;
        *(ushort *)(pbVar12 + 6) = *(ushort *)(pbVar12 + 6) | 1;
        sVar11 = DAT_8008d42c;
        goto LAB_80040da0;
      }
    }
    pbVar12[1] = 2;
    DAT_8008d42c = 0;
    *(ushort *)(pbVar12 + 6) = *(ushort *)(pbVar12 + 6) & 0xfffe;
    sVar11 = DAT_8008d42c;
  }
LAB_80040da0:
  DAT_8008d42c = sVar11;
  bVar8 = pbVar12[1];
  uVar3 = (ushort)(bVar8 == 2);
  uVar9 = 0;
  if (-1 < (int)(uVar5 << 0x10)) {
    uVar1 = *(undefined *)(iVar13 + 0x30);
    if ((*(ushort *)(pbVar12 + 6) & 1) != 0) {
      uVar9 = 10;
    }
    *(undefined *)(iVar13 + 0x30) = uVar9;
    *(undefined *)(iVar13 + 0x36) = (char)uVar5;
    if ((uVar5 - 3 & 0xffff) < 2)
	{
	  // Player / AI structure + 0x4a shows driver index (0-7)

	  // get the character ID of P1 and P2 (or boss)
      sVar11 = (&DAT_80086e84)[*(byte *)(iVar13 + 0x4a)];
      sVar2 = (&DAT_80086e84)[*(byte *)(iVar14 + 0x4a)];

      uVar10 = 0xf;
    }
    else
	{
	  // Player / AI structure + 0x4a shows driver index (0-7)

      uVar10 = 10;

	  // get the character ID of P1 and P2 (or boss)
      sVar11 = (&DAT_80086e84)[*(byte *)(iVar13 + 0x4a)];
      sVar2 = (&DAT_80086e84)[*(byte *)(iVar14 + 0x4a)];

      uVar3 = (ushort)(bVar8 == 2) | 2;
    }

	// Make driver talk
    FUN_8002cbe8(uVar10,(int)sVar11,(int)sVar2);

	// If weapon is bomb
	if (*(char *)(iVar13 + 0x36) == '\x01')
	{
	  // Pinstripe or Oxide

	  // Weapon_Shoot_Now (boss)
      FUN_8006540c(iVar13,2,(int)(short)uVar3);
    }

	else
	{
      sVar11 = (short)uVar5;
      if (

			(
				// Papu or Oxide

				// If your weapon is potion
				(*(char *)(iVar13 + 0x36) == '\x04') &&

				(uVar3 == 1)
			) &&

			// If you are on oxide station
			(*(int *)(PTR_DAT_8008d2ac + 0x1a10) == 0xd)
		 )
	  {
		// Weapon_Shoot_Now (boss)
		// Fire two potions (see oxide boss challenge)
        FUN_8006540c(iVar13,(int)sVar11,1);
        FUN_8006540c(iVar13,(int)sVar11,1);
      }
      else
	  {
		// Weapon_Shoot_Now (boss)
        FUN_8006540c(iVar13,(int)sVar11,(int)(short)uVar3);

		if (
				// Roo, Joe, Oxide

				(
					// If your weapon is TNT or Nitro
					(*(char *)(iVar13 + 0x36) == '\x03') &&

					(pbVar12[1] == 3)
				) &&

				(DAT_8008d42c != 5)
			)
		{
          DAT_8008d42c = 5;
        }
      }
    }

	// You have no weapon
    *(undefined *)(iVar13 + 0x36) = 0xf;

	// Set number of wumpa fruit
    *(undefined *)(iVar13 + 0x30) = uVar1;
  }
  return;
}


// StartLine_PerFrame
void FUN_800414f4(void)
{
  byte bVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  undefined *puVar5;
  int iVar6;
  undefined *puVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  undefined *puVar12;
  int iVar13;

  //puVar7 = 0x96B20
  puVar7 = PTR_DAT_8008d2ac;
  iVar11 = 0;
  iVar13 = 0;

  // loop counter
  iVar9 = 0;

  //puVar5 = 0x96B20
  puVar5 = PTR_DAT_8008d2ac;

  // get the highest-ranked player,
  // store that in puVar5 (pointer)

  // for (iVar9 = 0; iVar9 < 8; iVar9++)
  do
  {
    //iVar2 = (iVar9 + 1)th's place racer struct pointer
    iVar2 = *(int *)(puVar5 + 0x250c);

	// If this driver pointer is not nullptr
	// If this is a human and not AI
    if ((iVar2 != 0) && ((*(uint *)(iVar2 + 0x2c8) & 0x100000) == 0))	{
			break;
		}

    // increment loop counter
    iVar9 = iVar9 + 1;

    //move on to next racer
    puVar5 = puVar5 + 4;

	// clear pointer
    iVar2 = 0;

  } while (iVar9 < 8);

  // counter for loop iteration
  iVar10 = 0;

  // variable is used for multple things,
  // at beginning and end of the loop
  // it is 4 * iVar10
  iVar9 = 0;

  do
  {
    //iVar6 = driver struct
    iVar6 = *(int *)(puVar7 + iVar9 + 0x24ec);

    //set 1st place racer to no one
    *(undefined4 *)(puVar7 + iVar9 + 0x250c) = 0;

	//if driver exists
    if (iVar6 != 0)
	{
      // iVar8 = distance to finish
      iVar8 = *(int *)(iVar6 + 0x488);

      // Driver_UpdateLapProgress (driver)
      FUN_8005ca24(iVar6);

      // iVar9 = distance driven backwards + (distToFinish_curr - distToFinish_prev)
      iVar9 = *(int *)(iVar6 + 0x490) + (*(int *)(iVar6 + 0x488) - iVar8);

      // update distance driven backwards
      *(int *)(iVar6 + 0x490) = iVar9;

      // If racer's distance driven backwards is negative
      // (means racer is driving forwards)
      if (iVar9 < 0)
	  {
		// Set racer's distance driven backwards to zero, so it's not negative
        *(undefined4 *)(iVar6 + 0x490) = 0;
      }

      // if racer has distance driven backwards
      else
      {
        // If racer's distance driven backwards > 1000 units
        if (1000 < iVar9)
        {
		      // This prevents racer from going having negative laps
		      // Set maximum drive backwards value to 1000
          *(undefined4 *)(iVar6 + 0x490) = 1000;
        }
      }

	  // 0x4b0 = 1200

	  // if player just finished lap
      if (
	       // if distance to finish was low last frame
			(iVar8 < 0x4b0) &&

			// now suddenly high
			(32000 < *(int *)(iVar6 + 0x488))
		 )
      {
		// Set racer's distance driven backwards to zero
        *(undefined4 *)(iVar6 + 0x490) = 0;

        //if racer was driving behind the finish lap
        if ((*(uint *)(iVar6 + 0x2c8) & 0x1000000) != 0)
		    {
          //turn off 25th flag of actions flag set (means player crossed the start line backwards)
          //racer is not driving backwards through the start line anymore
          *(uint *)(iVar6 + 0x2c8) = *(uint *)(iVar6 + 0x2c8) & 0xfeffffff;
          //skip next 46 lines of code
          goto LAB_800418b4;
        }

        // update checkpoint with distToFinish
        *(undefined4 *)(iVar6 + 0x48c) = *(undefined4 *)(iVar6 + 0x488);

		// puVar7 is 8008d2ac
		// if numLaps < lapIndex+1
		// If this is final lap
        if ((int)(char)puVar7[0x1d33] < (int)((uint)*(byte *)(iVar6 + 0x44) + 1)) {
LAB_80041720:
          // uVar3 = lap counter
          uVar3 = (uint)*(byte *)(iVar6 + 0x44);
        }

		// if this is not final lap
        else
		{
          if (
				// Compare !=
				// puVar7 is 8008d2ac
				// If you're in Arcade, or
				// If you're in Adventure, or
				// If you're in Time Trial
				((*(uint *)puVar7 & 0x4a0000) != 0) &&

				// AND

				// driver -> instance -> thread -> modelIndex == "player" of any kind
				(*(short *)(*(int *)(*(int *)(iVar6 + 0x1c) + 0x6c) + 0x44) == 0x18)
			)
		  {
			// Save Lap Time
            FUN_8004c55c(
							// Lap Counter
							(uint)*(byte *)(iVar6 + 0x44),

							// puVar7 is 8008d2ac

							// time on clock - lap time
							*(int *)(puVar7 + 0x1d10) - *(int *)(iVar6 + 0x40),

							// Player / AI structure + 0x4a shows driver index (0-7)
							(uint)*(byte *)(iVar6 + 0x4a)
						);

			// Keep track of each lap time for time trial or relic race

											// lap counter
            *(int *)(puVar7 + (uint)*(byte *)(iVar6 + 0x44) * 4 + 0x1d14) =

				// time on clock - lap time
                 *(int *)(puVar7 + 0x1d10) - *(int *)(iVar6 + 0x40);
          }

											// time on the clock
          *(undefined4 *)(iVar6 + 0x40) = *(undefined4 *)(puVar7 + 0x1d10);

		  // lap counter = lap counter + 1
          *(char *)(iVar6 + 0x44) = *(char *)(iVar6 + 0x44) + '\x01';

		  // if player is highest ranked player
          if (iVar6 == iVar2)
		  {
			// OtherFX_Play for finishing lap
            FUN_80028468(0x66,1);

			// Voiceline_ClearTimeStamp
            FUN_8002caa8();
          }

          // uVar3 = lap counter
          uVar3 = (uint)*(byte *)(iVar6 + 0x44);

		  // if driver lap == last lap of race
		  if (uVar3 == (int)(char)PTR_DAT_8008d2ac[0x1d33] - 1U)
		  {
            // if this is human and not AI
            if ((*(uint *)(iVar6 + 0x2c8) & 0x100000) == 0)
			{
			  // set "Final Lap" timer to 0x5a (90)
			  // frames, so the animation lasts 3 seconds
              (&DAT_8008d2a0)[iVar10] = 0x5a;
            }
            goto LAB_80041720;
          }
        }

		// if driver lap is not equal to numLaps
		//		this is true any time finish line is crossed,
		//		except for crossing finish at end of final lap
        if (uVar3 != (int)(char)puVar7[0x1d33]) goto LAB_800418b4;

        //if racer hadn't finished the race
        if ((*(uint *)(iVar6 + 0x2c8) & 0x2000000) == 0)
        {
          //turn on 26th bit of Actions Flag set (means racer finished the race)
          *(uint *)(iVar6 + 0x2c8) = *(uint *)(iVar6 + 0x2c8) | 0x2000000;

		  // This block of code only executes once

		  // puVar7 is 8008d2ac
          if ((*(uint *)puVar7 & 0x200000) == 0)
		  {
            *(short *)(iVar6 + 0x482) = DAT_8008d2aa;
            DAT_8008d2aa = DAT_8008d2aa + 1;
          }

		  // you have no weapon
          *(undefined *)(iVar6 + 0x36) = 0xf;

		  // If this is human and not AI
          if ((*(uint *)(iVar6 + 0x2c8) & 0x100000) == 0)
		  {
			// If this racer is in first place
            if (*(short *)(iVar6 + 0x482) == 0)
			{
			  // amount of confetti particles
              *(undefined2 *)(puVar7 + 0x1b04) = 0xfa;
              *(undefined2 *)(puVar7 + 0x1b06) = 0xfa;

			  // Player / AI structure + 0x4a shows driver index (0-7)
              bVar1 = *(byte *)(iVar6 + 0x4a);

			  // add driver ID to array of confetti winners
              *(uint *)(puVar7 + 0x2558) = (uint)bVar1;

			  // one person won,
			  // one person gets confetti
              *(undefined4 *)(puVar7 + 0x2568) = 1;

			  // edit window variables for confetti
			  *(undefined2 *)(puVar7 + (uint)bVar1 * 0x110 + 0x17a) = 0x1fff;
              *(undefined2 *)(puVar7 + *(int *)(puVar7 + 0x2558) * 0x110 + 0x17c) = 0x1000;
              *(undefined2 *)(puVar7 + *(int *)(puVar7 + 0x2558) * 0x110 + 0x17e) = 0xff78;
            }
            if (*(short *)(iVar6 + 0x3c) != 0) {
              *(undefined2 *)(iVar6 + 0x3c) = 0;
              *(undefined *)(iVar6 + 0x36) = 0xf;
            }

			// turn driver into robotcar
            FUN_80017318(iVar6);
          }
          goto LAB_800418b4;
        }
      }

      // if player did not just finish a lap (correctly)
      else
	  {
		// if player crossed finish line backwards
        if (
				// if distToFinish_curr is low
				(*(int *)(iVar6 + 0x488) < 0x4b0) &&

				// if distToFinish_prev is high
				(32000 < iVar8)
			)
		{
		  // automatic backwards penalty
          *(undefined4 *)(iVar6 + 0x490) = 600;

          //turn on 25th bit of Actions Flag set (means racer crossed start line backwards)
          *(uint *)(iVar6 + 0x2c8) = *(uint *)(iVar6 + 0x2c8) | 0x1000000;
        }

        // if player did not JUST cross finish backwards
        else {

          // if player did not EVER cross finish backwards
          if (((*(uint *)(iVar6 + 0x2c8) & 0x1000000) == 0) &&

			// if distance driven this frame is less than...
			((uint)(*(int *)(iVar6 + 0x48c) - *(int *)(iVar6 + 0x488)) <=

										//puVar7 is 8008d2ac (0x96B20)
            (uint)(*(ushort *)(*(int *)(*(int *)(puVar7 + 0x160) + 0x14c) + 6) >> 2) << 3))
		  {
			// save distance for next frame
            *(int *)(iVar6 + 0x48c) = *(int *)(iVar6 + 0x488);
          }
        }
LAB_800418b4:
        //if racer hasn't finished the race
        if ((*(uint *)(iVar6 + 0x2c8) & 0x2000000) == 0)
        {
          //set racer's place in race to -1
          *(undefined2 *)(iVar6 + 0x482) = 0xffff;

          //skip next 5 lines of code
          goto LAB_80041910;
        }
      }

	  // driver -> instance -> thread -> modelIndex == "player" of any kind
      if (*(short *)(*(int *)(*(int *)(iVar6 + 0x1c) + 0x6c) + 0x44) == 0x18)
	  {
        iVar13 = iVar13 + 1;
      }

	  // increase your rank in the race, someone passed you
      iVar9 = (int)*(short *)(iVar6 + 0x482) + 1;

	  if (iVar11 < iVar9)
	  {
        iVar11 = iVar9;
      }
    }
LAB_80041910:

	// increment loop iteration counter
    iVar10 = iVar10 + 1;

	// pointer incrementation
    iVar9 = iVar10 * 4;

	// if you're done looping from 0 - 7
	// for all 8 drivers on the track

    if (7 < iVar10) {

	  while (iVar11 < 8)
	  {
		// set "min" distance to max
        iVar6 = 0x3fffffff;

		// index of driver closest to finish line
        iVar2 = -1;

        iVar9 = -10;

		// loop counter
        iVar10 = 0;

		// puVar7 is 8008d2ac
        puVar5 = puVar7;

		// for iVar10 = 0; iVar10 < 8; iVar10++
        do
		{
		  // get current driver
          iVar8 = *(int *)(puVar5 + 0x24ec);

          if (
				(
					// Compare !=
					(iVar8 != 0) &&

					// AND

					// Compare ==
					(*(short *)(iVar8 + 0x482) == -1)
				) &&

				// AND

				(
					(
						// Assignment
						iVar4 = (uint)*(byte *)(iVar8 + 0x44) - ((uint)*(byte *)(iVar8 + 0x2cb) & 1),

						// Compare <
						iVar9 < iVar4 ||

						// OR

						(
							(
								// Compare ==
								iVar4 == iVar9 &&

								// AND

								// Compare distToFinish < min
								(*(int *)(iVar8 + 0x488) < iVar6)
							)
						)
					)
			    )
			  )
		  {
			// set new min distToFinish
            iVar6 = *(int *)(iVar8 + 0x488);

            iVar9 = iVar4;

			// index of driver closest to finish
            iVar2 = iVar10;
          }

		  // increment loop counter
          iVar10 = iVar10 + 1;

          puVar5 = puVar5 + 4;
        } while (iVar10 < 8);

        if (iVar2 != -1)
		{
		  // puVar7 is 8008d2ac
		  // If traffic lights run out
          if (*(int *)(puVar7 + 0x1d0c) < 1)
		  {
            *(undefined2 *)(*(int *)(puVar7 + iVar2 * 4 + 0x24ec) + 0x482) = (short)iVar11;
          }

		  // if traffic lights >= 1
          else
		  {
			// set every driver position rank,
			// to the order that they spawn on the starting line
            *(ushort *)(*(int *)(puVar7 + iVar2 * 4 + 0x24ec) + 0x482) =
                 (ushort)(byte)(&DAT_8008d69c)[iVar2];
            puVar7[iVar2 + 0x257a] = (&DAT_8008d69c)[iVar2];
          }
        }
        iVar11 = iVar11 + 1;
      }

	  // loop iteration counter
      iVar11 = 0;

	  // set puVar5 to ptr-8d2ac
      puVar5 = puVar7;

	  // for iVar11 = 0; iVar11 < 8; iVar11++
      do
	  {
		// get pointer to each player structure
        iVar9 = *(int *)(puVar5 + 0x24ec);

		if (
				// Compare !=
				(iVar9 != 0) &&

				// AND

				// Compare <
				(-1 < (int)*(short *)(iVar9 + 0x482))
			)
		{
		  // puVar7 is 8008d2ac
          *(int *)(puVar7 + (int)*(short *)(iVar9 + 0x482) * 4 + 0x250c) = iVar9;
        }

		// increment loop counter
        iVar11 = iVar11 + 1;

		// increment pointer
        puVar5 = puVar5 + 4;

      } while (iVar11 < 8);

	  // iteration counter
      iVar11 = 0;

	  // reset both variables to ptr_8d2ac
      puVar5 = puVar7;
      puVar12 = puVar7;

	  // if number of screens is not zero
      if (PTR_DAT_8008d2ac[0x1ca8] != '\0') {

		// for(int iVar11 = 0; iVar11 < numScreens; iVar11++)
        do
		{
		  // pointer to each player structure
          iVar9 = *(int *)(puVar12 + 0x24ec);

		  // if player structure is not nullptr
          if (iVar9 != 0)
		  {
            iVar2 = (int)*(short *)(iVar9 + 0x482);

            if (
					(
						// Compare <
						(-1 < iVar2) &&


						// puVar7 is 8008d2ac

						// if time on the clock is not low
						(0x4b00 < *(int *)(puVar7 + 0x1d10))
					) &&

					// AND

					// Compare <
					((char)puVar5[0x257a] < iVar2))
			{
			  // Make driver talk
              FUN_8002cbe8(8,(int)(short)(&DAT_80086e84)
                                         [*(byte *)(*(int *)(PTR_DAT_8008d2ac +
                                                            (iVar2 + -1) * 4 + 0x250c) + 0x4a)],0x10);
            }
            puVar5[0x257a] = *(undefined *)(iVar9 + 0x482);
          }

		  // increment loop counter
          iVar11 = iVar11 + 1;

          puVar5 = puVar5 + 1;

		  // increment pointer
          puVar12 = puVar12 + 4;

							// number of screens
        } while (iVar11 < (int)(uint)(byte)PTR_DAT_8008d2ac[0x1ca8]);
      }

	  // puVar7 is 8008d2ac
	  // If not in end-of-race menu
      if ((*(uint *)puVar7 & 0x200000) == 0)
	  {
		// number of screens
        bVar1 = puVar7[0x1ca8];

		// Basically "if race should end",
		// then trigger end-of-race menu
        if (
				(
					(
						// If there is one screen
						(bVar1 == 1) &&

						// AND

						// Compare <
						(0 < iVar13)
					) ||

					// OR

					(
						(
							// Compare <=
							(int)((uint)bVar1 - 1) <= iVar13 &&

							// AND

							(
								(
									// If more than 1 player
									1 < bVar1 &&

									// AND

									// If you're not in Arcade Mode
									// puVar7 is 8008d2ac
									((*(uint *)puVar7 & 0x400000) == 0)
								)
							)
						)
					)
				) ||
				(
					(
						// puVar7 is 8008d2ac
						// If you're in Arcade Mode
						(*(uint *)puVar7 & 0x400000) != 0 &&

						// AND

						// Compare <=
						// puVar7 is 8008d2ac
						((int)(uint)(byte)puVar7[0x1ca8] <= iVar13)
					)
				)
		   )
		{
		  // loop iteration counter
          iVar11 = 0;

		  // =================
		  // end race for all drivers
		  // =================

		  // for iVar11 = 0; iVar11 < 8; iVar11++
          do
		  {
			// get address of each player structure
            iVar9 = *(int *)(puVar7 + 0x24ec);

            if (
					// if player structure is not nullptr
					(iVar9 != 0) &&

					//if racer hadn't finished the race
					((*(uint *)(iVar9 + 0x2c8) & 0x2000000) == 0))
            {
              // end the race for this player
              *(uint *)(iVar9 + 0x2c8) = *(uint *)(iVar9 + 0x2c8) | 0x2000000;

			  // This block executes one time

			  // you have no weapon
              *(undefined *)(iVar9 + 0x36) = 0xf;

			  // If this is human and not AI
              if ((*(uint *)(iVar9 + 0x2c8) & 0x100000) == 0)
			  {
				// Player / AI structure + 0x4a shows driver index (0-7)

				// In VS mode, this is what blows up the player in last place

				// Make the player Blasted
				// Player_ChangeState
                FUN_80064568(iVar9,2,iVar9,0);

				// reduce counter for AttackingPlayer on yourself, 
				// and AttackedByPlayer, on yourself, following ChangeState Blasted
                iVar13 = iVar9 + (uint)*(byte *)(iVar9 + 0x4a);
                *(char *)(iVar13 + 0x560) = *(char *)(iVar13 + 0x560) + -1;
                iVar9 = iVar9 + (uint)*(byte *)(iVar9 + 0x4a);
                *(char *)(iVar9 + 0x50c) = *(char *)(iVar9 + 0x50c) + -1;
              }
            }

			// increment loop counter
            iVar11 = iVar11 + 1;

			// increment pointer
            puVar7 = puVar7 + 4;

          } while (iVar11 < 8);

		  // ToggleGameState_EndOfRace
          FUN_8003a3fc();
        }
      }
      return;
    }
  } while( true );
}


// Tawna_Init
void FUN_80041c84(int param_1)

{
  char cVar1;
  short sVar2;
  int iVar3;
  int *piVar4;
  int iVar5;

  // loop counter
  iVar5 = 0;

  // pointer to player 1 structure
  piVar4 = (int *)(param_1 + 0x24ec);

  // default podium values
  *(undefined *)(param_1 + 0x2575) = 0;
  *(undefined *)(param_1 + 0x2576) = 0;
  *(undefined *)(param_1 + 0x2577) = 0;

  // STATIC_TAWNA1
  *(undefined *)(param_1 + 0x2578) = 0x8f;

  // for iVar5 = 0; iVar5 < 8; iVar5++
  do
  {
	// address to structure of current player (0-7)
    iVar3 = *piVar4;

	// if address is not nullptr
    if (iVar3 != 0)
	{
		// player structure + 0x482 is your rank in the race
		// 0 = 1st place, 1 = 2nd place, 2 = 3rd place, etc
      sVar2 = *(short *)(iVar3 + 0x482);

	  // If you're in 2nd place
      if (sVar2 == 1)
	  {
		// Player / AI structure + 0x4a shows driver index (0-7)

													// character ID						+ 126
        *(char *)(param_1 + 0x2576) = *(char *)(&DAT_80086e84 + *(byte *)(iVar3 + 0x4a)) + '~';
      }
      else {
        if (sVar2 < 2)
		{
		  // first place
          if (sVar2 == 0) {
            cVar1 = *(char *)(&DAT_80086e84 + *(byte *)(iVar3 + 0x4a));
            *(char *)(param_1 + 0x2575) = cVar1 + '~';
            switch(cVar1 + '~') {
            case '~':
            case -0x7f:
			  // STATIC_TAWNA2
              *(undefined *)(param_1 + 0x2578) = 0x90;
              break;
            case '\x7f':
            case -0x7e:
			  // STATIC_TAWNA3
              *(undefined *)(param_1 + 0x2578) = 0x92;
              break;
            case -0x7c:
            case -0x7b:
			  // STATIC_TAWNA4
              *(undefined *)(param_1 + 0x2578) = 0x91;
            }
          }
        }
        else
		{
		  // third place
          if (sVar2 == 2)
		  {
			  // Player / AI structure + 0x4a shows driver index (0-7)

														// character ID						+ 126
            *(char *)(param_1 + 0x2577) = *(char *)(&DAT_80086e84 + *(byte *)(iVar3 + 0x4a)) + '~';
          }
        }
      }
    }

	// increment loop counter
    iVar5 = iVar5 + 1;

	// pointer (int*) increment, really adds 4 to address
    piVar4 = piVar4 + 1;

  } while (iVar5 < 8);
  return;
}


// THREAD_DestroyTracker
void FUN_80041dc0(void)

{
  // If there are any missiles in play
  if (0 < *(int *)(PTR_DAT_8008d2ac + 0x1ec0))
  {
	// decrease number of missiles
    *(int *)(PTR_DAT_8008d2ac + 0x1ec0) = *(int *)(PTR_DAT_8008d2ac + 0x1ec0) + -1;
  }

  // THREAD_DestroyInstance
  FUN_80041dfc();

  return;
}


// THREAD_DestroyInstance
void FUN_80041dfc(int param_1)

{
  // INSTANCE_Death
  FUN_80030aa8(*(undefined4 *)(param_1 + 0x34));
  return;
}


// THREAD_DestroyObject
// param_1 thread's object
// param_2 thread flags
void FUN_80041e20(int param_1,uint param_2)

{
  undefined *puVar1;

  if (param_1 != 0) {
    if ((param_2 & 0x300) == 0x100)
	{
	  // Large Stack Pool
      puVar1 = PTR_DAT_8008d2ac + 0x1970;
    }
    else
	{
      if ((param_2 & 0x300) == 0x200)
	  {
		// Medium Stack Pool
        puVar1 = PTR_DAT_8008d2ac + 0x1948;
      }
      else
	  {
		// Small Stack Pool
        puVar1 = PTR_DAT_8008d2ac + 0x1920;
      }
    }

	// LIST_AddFront
	// add to free list
    FUN_80031744(puVar1,param_1 + -8);
  }
  return;
}


// THREAD_DestroySelf
// param_1 is a thread
void FUN_80041e9c(int param_1)

{
  // If thread is valid
  if (param_1 != 0) {

	// If thread has an OnDestroy funcPtr
    if (*(code **)(param_1 + 0x24) != (code *)0x0)
	{
	  // execute OnDestroy,
	  // which is usually a pointer to THREAD_DestroyInstance
      (**(code **)(param_1 + 0x24))();
    }

	// Count how many times this thread has been used?

	// x = x + 1
    *(int *)(param_1 + 0x20) = *(int *)(param_1 + 0x20) + 1;

	// THREAD_DestroyObject
    FUN_80041e20(*(undefined4 *)(param_1 + 0x30),*(undefined4 *)(param_1 + 0x1c));

	// LIST_AddFront
	// add to free list of ThreadPool
	FUN_80031744(PTR_DAT_8008d2ac + 0x18d0,param_1);
  }
  return;
}


// THREAD_DestroyBloodline
void FUN_80041f04(int param_1)

{
  // if given thread is valid
  if (param_1 != 0)
  {
    do
	{
	  // recursively find all children
      if (*(int *)(param_1 + 0x14) != 0)
	  {
		// THREAD_DestroyBloodline
        FUN_80041f04();
      }

	  // recursively find all siblings
      param_1 = *(int *)(param_1 + 0x10);

	  // THREAD_DestroySelf
      FUN_80041e9c();

    } while (param_1 != 0);
  }
  return;
}


// THREAD_CheckBloodlineForDead
// look for dead threads, and recycle them
void FUN_80041f58(int *param_1,int param_2)

{
  int iVar1;

  if (param_2 != 0)
  {
    do
	{
	  // get sibling
      iVar1 = *(int *)(param_2 + 0x10);

	  // if thread does not need to be deleted
      if ((*(uint *)(param_2 + 0x1c) & 0x800) == 0)
	  {
		// sibling thread
        param_1 = (int *)(param_2 + 0x10);

		// if there are children
        if (*(int *)(param_2 + 0x14) != 0)
		{
		  // execute recursively for all children and all siblings of
		  // all children, basically all threads "under" this one

		  // THREAD_CheckBloodlineForDead
          FUN_80041f58(param_2 + 0x14);

		  // sibling thread
          param_1 = (int *)(param_2 + 0x10);
        }
      }

	  // if thread needs to be deleted
      else
	  {
		// if there is a child thread
        if (*(int *)(param_2 + 0x14) != 0)
		{
		  // THREAD_DestroyBloodline
          FUN_80041f04();
        }

		// THREAD_DestroySelf
        FUN_80041e9c(param_2);

        *param_1 = iVar1;
      }
      param_2 = iVar1;
    } while (iVar1 != 0);
  }
  return;
}


// THREAD_CheckAllForDead
void FUN_80041ff4(void)

{
  int iVar1;
  undefined *puVar2;
  int iVar3;
  int iVar4;
  int iVar5;

  // Loop through all threadBuckets
  // check all threads in the game, check for the flag 0x800,
  // which means those threads need to be deleted

  iVar5 = 0;
  iVar4 = 0x1b2c;
  iVar3 = 0;

  // loop through 0x12 buckets
  do {
    iVar5 = iVar5 + 1;
    puVar2 = PTR_DAT_8008d2ac + iVar4;
    iVar4 = iVar4 + 0x14;
    iVar1 = iVar3 + 0x1b2c;
    iVar3 = iVar3 + 0x14;

	// THREAD_CheckBloodlineForDead
    FUN_80041f58(puVar2,*(undefined4 *)(PTR_DAT_8008d2ac + iVar1));

  } while (iVar5 < 0x12);
  return;
}


// param1 = flags
// param2 = funcPerFrame
// param3 = name of object
// param4 = another thread (parent, sibling, child)

// THREAD_BirthWithObject
// Create a thread and object, return thread
int FUN_8004205c(uint param_1,undefined4 param_2,undefined4 param_3,int param_4)
{
  int iVar1;
  undefined4 uVar2;
  undefined *puVar3;
  int iVar4;
  uint uVar5;

  // if there is no parent thread
  if (param_4 == 0)
  {
	// get thread bucket index
    uVar5 = param_1 & 0xff;
  }

  // if there is a parent thread
  else
  {
    // get parent thread bucket
    uVar5 = (uint)*(byte *)(param_4 + 0x1c);
  }

  // if large stack pool
  if ((param_1 & 0x300) == 0x100)
  {
	// size of large object
    iVar4 = 0x670;

	// Large Stack Pool
    puVar3 = PTR_DAT_8008d2ac + 0x1970;
  }

  //if not large stack pool
  else
  {
	// size of small object
    iVar4 = 0x48;

	// warpball, shield, etc
    if ((param_1 & 0x300) == 0x200)
	{
	  // size of medium object
      iVar4 = 0x88;

	  // Medium Stack Pool
      puVar3 = PTR_DAT_8008d2ac + 0x1948;
    }

	// beaker, turbo, etc
	else
	{
	  // Small Stack Pool
      puVar3 = PTR_DAT_8008d2ac + 0x1920;
    }
  }


  // LIST_RemoveFront
  // Get first free object in object pool
  iVar1 = FUN_8003186c(puVar3);

  // if threadBucket index is less than 18
  if (uVar5 < 0x12)
  {
	// if size of object passed is small enough to fit in stack
    if (param_1 >> 0x10 < iVar4 - 8U)
	{
	  // if the object allocated,
	  // then create a thread for the object in the thread pool,
	  // and then put a pointer to the object in the thread
      if (iVar1 != 0)
	  {
		// LIST_RemoveFront
		// Get first free thread in ThreadPool
        iVar4 = FUN_8003186c(PTR_DAT_8008d2ac + 0x18d0);

		// if you are out of room
        if (iVar4 == 0)
		{
		  // sep 3
		  // printf("out of threads \'%s\'\n",param_3);

		  // THREAD_DestroyObject
          FUN_80041e20(iVar1 + 8,param_1);
          return 0;
        }

		// copy the flags used to create this thread
        *(uint *)(iVar4 + 0x1c) = param_1;

		// erase cooldown
        *(undefined4 *)(iVar4 + 0x18) = 0;

		// funcOnDestroy
        *(undefined4 *)(iVar4 + 0x24) = 0;

		// funcOnCollide
        *(undefined4 *)(iVar4 + 0x28) = 0;

		// There is no instance attached to thread
        *(undefined4 *)(iVar4 + 0x34) = 0;

		// if no thread was passed
        if (param_4 == 0)
		{
		  // get pointer to thread bucket
          puVar3 = PTR_DAT_8008d2ac + uVar5 * 0x14;

		  // currThread->next = "first thread in list"
          *(undefined4 *)(iVar4 + 0x10) = *(undefined4 *)(puVar3 + 0x1b2c);

		  // new "first thread in list" = currThread
          *(int *)(puVar3 + 0x1b2c) = iVar4;

		  // parent thread
          *(undefined4 *)(iVar4 + 0xc) = 0;

		  // child thread
          *(undefined4 *)(iVar4 + 0x14) = 0;
        }

		// if a thread was passed as parameter
        else
		{
		  // if param4 is not a sibling
          if ((param_1 & 0x400) == 0)
		  {
			// If the thread passed from param4 is a parent thread
            if ((param_1 & 0x2000) == 0)
			{
			  // the thread you created has no child
              *(undefined4 *)(iVar4 + 0x14) = 0;

			  // thread->next = parent->child
              *(undefined4 *)(iVar4 + 0x10) = *(undefined4 *)(param_4 + 0x14);

			  // the parent's child is this thread
			  *(int *)(param_4 + 0x14) = iVar4;

			  // this thread's parent is param4
              *(int *)(iVar4 + 0xc) = param_4;
            }

			// inject thread between param4 and it's child
            else
			{
			  // this thread's child equals parent->child
              *(undefined4 *)(iVar4 + 0x14) = *(undefined4 *)(param_4 + 0x14);

			  // parent->child = this thread
              *(int *)(param_4 + 0x14) = iVar4;

			  // this thread's parent is param4
              *(int *)(iVar4 + 0xc) = param_4;

			  // no sibling threads
              *(undefined4 *)(iVar4 + 0x10) = 0;
            }
          }

		  // if param4 is a sibling to new thread
          else
		  {
			// this thread's sibling equals sibling->sibling
            *(undefined4 *)(iVar4 + 0x10) = *(undefined4 *)(param_4 + 0x10);

			// get the sibling's parent
            uVar2 = *(undefined4 *)(param_4 + 0xc);

			// sibling->sibling = new thread
            *(int *)(param_4 + 0x10) = iVar4;

			// erase this thread's child
            *(undefined4 *)(iVar4 + 0x14) = 0;

			// set this thread's parent
            *(undefined4 *)(iVar4 + 0xc) = uVar2;
          }
        }

		// set PerFrame funcPtr
        *(undefined4 *)(iVar4 + 0x2c) = param_2;

		// set string pointer
        *(undefined4 *)(iVar4 + 8) = param_3;

		// assign object to thread
        *(int *)(iVar4 + 0x30) = iVar1 + 8;

		// return thread
        return iVar4;
      }

	  // Sep3
	  // printf("%ld byte stack allocate failed for thread \'%s\'\n",iVar4,param_3);
    }

	// if allocation failed
    else
	{
	  // Sep3
	  // printf("stack size (%ld) too small for statics (%ld) \'%s\'\n",iVar4 - 8U,param_1 >> 0x10,
             //param_3);

      if (iVar1 != 0)
	  {
		// THREAD_DestroyObject
        FUN_80041e20(iVar1 + 8,param_1);

        return 0;
      }
    }
  }

  // if you try to access a thread bucket
  // that doesn't exist
  else
  {
	// printf("invalid thread bucket %ld \'%s\'\n",uVar5,param_3);

	// if object is allocated
    if (iVar1 != 0)
	{
	  // THREAD_DestroyObject
      FUN_80041e20(iVar1 + 8,param_1);
      return 0;
    }
  }

  return 0;
}


// param_1 is a thread
// param_2 is pointer to vec3 position
// THREAD_CollidePointWithSelf
void FUN_8004228c(int param_1,short *param_2)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;

  // if collision is not disabled for this thread
  if ((*(uint *)(param_1 + 0x1c) & 0x1800) == 0)
  {
	// get instance from thread
    iVar1 = *(int *)(param_1 + 0x34);

	// compare posX, posY, posZ
    iVar4 = (int)*param_2 - *(int *)(iVar1 + 0x44);
    iVar2 = (int)param_2[2] - *(int *)(iVar1 + 0x4c);
    iVar1 = (int)param_2[1] - *(int *)(iVar1 + 0x48);

	// This was slightly modified cause
	// Ghidra gave sloppy code, the rewritten
	// if-statment is functionally identical
	// as before, but not the same output

	// if X-distance is small
    if (iVar4 * iVar4 < 0x10000000)
	{
	  // if Y-distance is small
	  if(iVar1 * iVar1 < 0x10000000)
	  {
		// if Z-distance is small
		if(iVar2 * iVar2 < 0x10000000)
		{
		  // distance formula
		  iVar3 = iVar4 * iVar4 + iVar1 * iVar1 + iVar2 * iVar2

		  // if distance is less than radius
		  if (iVar3 < *(int *)(param_2 + 6))
		  {
		  	// store the distance the objects are apart
		  	*(int *)(param_2 + 6) = iVar3;

		  	// store which thread this instance collides with
		  	*(int *)(param_2 + 4) = param_1;

		  	// store the difference in X, Y, and Z
		  	param_2[8] = (short)iVar4;
		  	param_2[9] = (short)iVar1;
		  	param_2[10] = (short)iVar2;
		  }
		}
	  }
    }
  }
  return;
}


// param_1 is a thread
// param_2 is pointer to vec3 position
// THREAD_CollidePointWithBucket
void FUN_80042348(int param_1,undefined4 param_2)

{
  // loop through all thread siblings
  if (param_1 != 0)
  {
    do
	{
	  // THREAD_CollidePointWithSelf
      FUN_8004228c(param_1,param_2);

	  // thread = thread->next
	  param_1 = *(int *)(param_1 + 0x10);

    } while (param_1 != 0);
  }
  return;
}



int FUN_80042394(int param_1,int param_2)

{
  int iVar1;

  // if thread is valid
  if (param_1 != 0) {
    do
	{
	  // if modelIndex is the same as the parameter
      if ((int)*(short *)(param_1 + 0x44) == param_2)
	  {
		// return this thread
        return param_1;
      }

	  // check all the children for this model index
      iVar1 = FUN_80042394(*(undefined4 *)(param_1 + 0x14),param_2);

	  // if it was found, return it
      if (iVar1 != 0) {
        return iVar1;
      }

	  // thread = thread -> sibling,
	  // check siblings for model index
      param_1 = *(int *)(param_1 + 0x10);

	} while (param_1 != 0);
  }

  // if thread is not valid, return 0
  return param_1;
}


// Weapon_SearchCallback
// param_1 is VisData
void FUN_800423fc(int param_1,short *param_2)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int *piVar4;
  int *piVar5;

  piVar5 = *(int **)(param_1 + 0x14);
  if ((piVar5 != (int *)0x0) && (*piVar5 != 0)) {
    piVar4 = piVar5 + 5;
    do {
      if (((*(byte *)piVar5 & 0x80) != 0) &&
         ((piVar4[2] == 0 || ((*(uint *)(*(int *)(piVar4[2] + 0x2c) + 0x28) & 0xf) != 0)))) {
        iVar3 = (int)*param_2 - (int)*(short *)(piVar4 + -1);
        iVar1 = (int)param_2[2] - (int)*(short *)piVar4;
        iVar2 = (int)param_2[1] - (int)*(short *)((int)piVar4 + -2);
        if (iVar3 * iVar3 < 0x10000000) {
          if (((iVar2 * iVar2 < 0x10000000) && (iVar1 * iVar1 < 0x10000000)) &&
             (iVar3 * iVar3 + iVar2 * iVar2 + iVar1 * iVar1 < *(int *)(param_2 + 4))) {
            param_2[10] = (short)iVar1;
            param_2[9] = (short)iVar2;
            param_2[8] = (short)iVar3;

			// short+0x14 = byte+0x28,
			// callback on collision

			// either for colliding with lev object or nonLev
            (**(code **)(param_2 + 0x14))(param_2,piVar5);
          }
        }
      }
      piVar5 = piVar5 + 8;
      piVar4 = piVar4 + 8;
    } while (*piVar5 != 0);
  }
  return;
}


// Weapon_MakeHitboxAndSearchBSP
void FUN_80042544(short *param_1)

{
  short sVar1;
  undefined *puVar2;

  // box half-length
  sVar1 = param_1[3];

  // position of object hitting
  // tiger temple teeth

  // param[0] = posX,
  // param[1] = posY,
  // param[2] = posZ,

  // Make hitbox, min and max x,y,z
  param_1[0xe] = *param_1 - sVar1;
  param_1[0xf] = param_1[1] - sVar1;
  param_1[0x10] = param_1[2] - sVar1;
  param_1[0x11] = *param_1 + sVar1;
  param_1[0x12] = param_1[1] + sVar1;
  puVar2 = PTR_DAT_8008d2ac;
  param_1[0x13] = param_1[2] + sVar1;

  // COLL_SearchTree_WithCallback, callback is Weapon_SearchCallback
  FUN_8001ebec(*(undefined4 *)(**(int **)(puVar2 + 0x160) + 0x18),param_1 + 0xe,FUN_800423fc);
  return;
}


// weapon collision
// param1 is thread checked for collision
// param2 is weapon thread
// param3 is person who used weapon
void FUN_800425d4(int param_1,short *param_2,int param_3)

{
  int iVar1;
  int iVar2;
  int iVar3;

  // if thread is valid
  if (param_1 != 0) {
    do
	{
	  // if child thread exists
      if (*(int *)(param_1 + 0x14) != 0)
	  {
		// recursively check all children
        FUN_800425d4(*(int *)(param_1 + 0x14),param_2,param_3);
      }

      if (
			// make sure you dont hit your own weapon???
			(param_1 != param_3) &&

			// if collision is not disabled for this thread,
			// and if this thread is not dead
		    ((*(uint *)(param_1 + 0x1c) & 0x1800) == 0)
		 )
	  {
		// get instance
        iVar1 = *(int *)(param_1 + 0x34);

		// get distance of X, Y, Z
        iVar3 = (int)*param_2 - *(int *)(iVar1 + 0x44);
        iVar2 = (int)param_2[1] - *(int *)(iVar1 + 0x48);
        iVar1 = (int)param_2[2] - *(int *)(iVar1 + 0x4c);

		// if X dist is small
        if (iVar3 * iVar3 < 0x10000000)
		{
          if (
				(
					// if Y dist and Z dist are small
					(iVar2 * iVar2 < 0x10000000) &&
					(iVar1 * iVar1 < 0x10000000)
				) &&

				// if distance is less than collision radius
				(iVar3 * iVar3 + iVar2 * iVar2 + iVar1 * iVar1 < *(int *)(param_2 + 4))
			 )
		  {
			// save distances
            param_2[8] = (short)iVar3;
            param_2[9] = (short)iVar2;
            param_2[10] = (short)iVar1;

			// some collision funcPtr???
            (**(code **)(param_2 + 0x14))(param_2,param_1);
          }
        }
      }

	  // thread = thread->sibling;
      param_1 = *(int *)(param_1 + 0x10);

    } while (param_1 != 0);
  }
  return;
}


// Camera110_Init
// param_1 - camera110
// param_2 - cameraID
// param_3 - total number cameras
void FUN_800426f8(int param_1,int param_2,int param_3)

{
  undefined2 uVar1;
  undefined4 uVar2;

  // fadeStep
  *(undefined2 *)(param_1 + 0x16) = 0x88;

  // start of Proj matrix
  // 0x1c71 / 0x1000 = 16/9,
  // therefore makes image stretch horizontally (fitting 512x216),
  // then that image upscaled to 640x480 stretched vertically, is 4x3
  *(undefined2 *)(param_1 + 0x88) = 0x1c71;

  // cameraID
  *(undefined *)(param_1 + 0x108) = (char)param_2;

  // fadeFromBlack = NormalLight (no fade)
  *(undefined2 *)(param_1 + 0x12) = 0x1000;
  *(undefined2 *)(param_1 + 0x14) = 0x1000;

  // remainder of Proj matrix
  // matrix continued (from 0x88)
  *(undefined2 *)(param_1 + 0x8a) = 0;
  *(undefined2 *)(param_1 + 0x8c) = 0;
  *(undefined2 *)(param_1 + 0x8e) = 0;
  *(undefined2 *)(param_1 + 0x90) = 0x1000;
  *(undefined2 *)(param_1 + 0x92) = 0;
  *(undefined2 *)(param_1 + 0x94) = 0;
  *(undefined2 *)(param_1 + 0x96) = 0;
  *(undefined2 *)(param_1 + 0x98) = 0x1000;
  *(undefined4 *)(param_1 + 0x9c) = 0;
  *(undefined4 *)(param_1 + 0xa0) = 0;
  *(undefined4 *)(param_1 + 0xa4) = 0;

  // If this is 2P mode
  if (param_3 == 2)
  {
	// If current player is not P1
    if (param_2 != 0)
	{
	  // If current player is not P2
      if (param_2 != 1)
	  {
		// Quit
        return;
      }

	  // If current player is P2

	  // camera110 dimensions
	  // Assume +1c is 0
      *(undefined2 *)(param_1 + 0x1e) = 0x6e;
      *(undefined2 *)(param_1 + 0x20) = 0x200;
      *(undefined2 *)(param_1 + 0x22) = 0x6a;

	  // "distance" to screen, for perspective
      *(undefined4 *)(param_1 + 0x18) = 0x100;
	  *(undefined4 *)(param_1 + 0x10c) = 0x100;

	  // aspectX
      uVar1 = 8;
LAB_80042810:

	  // aspect can be 4/3 or 8/3
      *(undefined2 *)(param_1 + 0x24) = uVar1;
      *(undefined2 *)(param_1 + 0x1c) = 0;
      *(undefined2 *)(param_1 + 0x26) = 3;
      return;
    }

	// If current player is P1

	// camera110 dimensions
	// assume +0x1e and +1c is 0
    *(undefined2 *)(param_1 + 0x20) = 0x200;
    *(undefined2 *)(param_1 + 0x22) = 0x6a;

	// "distance" to screen, for perspective
    *(undefined4 *)(param_1 + 0x18) = 0x100;
	*(undefined4 *)(param_1 + 0x10c) = 0x100;

	// aspectX
    uVar1 = 8;
  }

  // If this is not 2P mode
  else {

	// If number of screens is less than 3 (1 or 2)
    if (param_3 < 3)
	{
	  // If this is not 1P mode
      if (param_3 != 1)
	  {
		// quit
        return;
      }

	  // camera110 dimensions for Player 1 in 1P mode
      *(undefined2 *)(param_1 + 0x20) = 0x200;
      *(undefined2 *)(param_1 + 0x22) = 0xd8;

	  // distanceToScreen (fov)
      uVar2 = 0x100;
    }

	// If you have 3 or more screens
    else
	{
	  // If you have more than 4 screens
      if (4 < param_3)
	  {
		// Quit
        return;
      }

	  // Player 2 in 3P/4P mode
      if (param_2 == 1)
	  {
		// camera110 dimensions
        // assume +1e is zero
		*(undefined2 *)(param_1 + 0x1c) = 0x103;
        *(undefined2 *)(param_1 + 0x20) = 0xfd;
        *(undefined2 *)(param_1 + 0x22) = 0x6a;

		// "distance" to screen, for perspective
        *(undefined4 *)(param_1 + 0x18) = 0x80;
        *(undefined4 *)(param_1 + 0x10c) = 0x80;

		// aspectX = 4, for 4/3 ratio
        *(undefined2 *)(param_1 + 0x24) = 4;
        goto LAB_800427a4;
      }

	  // If playerID is more than (1=P2)
	  // If this is P3 or P4
      if (1 < param_2)
	  {
		// If this is not P3
        if (param_2 != 2)
		{
		  // If this is P4
          if (param_2 == 3)
		  {
			// camera110 dimensions for P4 in 4P mode
            *(undefined2 *)(param_1 + 0x1c) = 0x103;
            *(undefined2 *)(param_1 + 0x1e) = 0x6e;
            *(undefined2 *)(param_1 + 0x20) = 0xfd;
            *(undefined2 *)(param_1 + 0x22) = 0x6a;

			// "distance" to screen, for perspective
            *(undefined4 *)(param_1 + 0x18) = 0x80;
            *(undefined4 *)(param_1 + 0x10c) = 0x80;

			// aspect ratio is 4/3, aspectX and aspectY
            *(undefined2 *)(param_1 + 0x24) = 4;
            *(undefined2 *)(param_1 + 0x26) = 3;

            return;
          }

		  // If this is P1 or P2
		  // This will never happen
          return;
        }

		// camera110 dimensions for P3 in 3P/4P mode
        // Assume +1c is zero
		*(undefined2 *)(param_1 + 0x1e) = 0x6e;
        *(undefined2 *)(param_1 + 0x20) = 0xfd;
        *(undefined2 *)(param_1 + 0x22) = 0x6a;

		// distanceToScreen (changes FOV)
        *(undefined4 *)(param_1 + 0x18) = 0x80;
        *(undefined4 *)(param_1 + 0x10c) = 0x80;

		// aspectX
		uVar1 = 4;

		goto LAB_80042810;
      }

	  // If this is not P1
      if (param_2 != 0)
	  {
		// Quit
        return;
      }

	  // If this is P1
      // Assume +1c and +1e are zero
	  *(undefined2 *)(param_1 + 0x20) = 0xfd;
      *(undefined2 *)(param_1 + 0x22) = 0x6a;

	  // distanceToScreen
      uVar2 = 0x80;
    }

	// distanceToScreen (changes FOV)
    *(undefined4 *)(param_1 + 0x18) = uVar2;
    *(undefined4 *)(param_1 + 0x10c) = uVar2;

	// aspectX
	uVar1 = 4;
  }

  // aspectX
  *(undefined2 *)(param_1 + 0x24) = uVar1;

  // startX
  *(undefined2 *)(param_1 + 0x1c) = 0;

LAB_800427a4:

  // startY
  *(undefined2 *)(param_1 + 0x1e) = 0;

  // aspectY
  *(undefined2 *)(param_1 + 0x26) = 3;
  return;
}


// Camera110_InitPsyqGeom
void FUN_80042910(int param_1)

{
  int iVar1;
  int iVar2;

  iVar1 = (uint)*(ushort *)(param_1 + 0x20) << 0x10;
  iVar2 = (uint)*(ushort *)(param_1 + 0x22) << 0x10;

  // Geometry Origin
  // All this bit-shifting is really just
  // SetGeomOffset(width/2, height/2),
  // Trust me, copy/paste into C++ program and try yourself
  SetGeomOffset((iVar1 >> 0x10) - (iVar1 >> 0x1f) >> 1,(iVar2 >> 0x10) - (iVar2 >> 0x1f) >> 1);

  // "distance" to screen, alters FOV
  SetGeomScreen(*(long *)(param_1 + 0x18));
  return;
}


// Camera110_LinkOT_DecalMP
// param1 - ptrOT
// param2 - gGT->backbuffer
// param3 - RECT
// param4 - ofsX
// param5 - ofsY
void FUN_80042974(void *param_1,undefined4 *param_2,undefined2 *param_3,undefined2 param_4,
                 undefined2 param_5,undefined param_6,undefined param_7,undefined param_8,
                 undefined param_9,undefined param_10)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  void *pvVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  void *p;

  // DrawEnv:

  // RECT clip
  undefined4 local_70;
  undefined2 local_6c;
  undefined2 uStack106;

  // short ofs[2]
  undefined2 local_68;
  undefined2 uStack102;

  // RECT tw
  undefined4 local_64 [2];

  // short tpage
  undefined uStack90;
  undefined local_58;

  // char dtd, dfe, isbg
  undefined uStack87;
  undefined uStack86;
  undefined uStack85;

  // Copy DrawEnv from gGT->backBuffer (param2)
  // onto stack memory at &local_70
  puVar1 = (undefined4 *)&local_70;
  puVar5 = param_2;
  do {
    puVar4 = puVar5;
    puVar2 = puVar1;
    uVar6 = puVar4[1];
    uVar7 = puVar4[2];
    uVar8 = puVar4[3];
    *puVar2 = *puVar4;
    puVar2[1] = uVar6;
    puVar2[2] = uVar7;
    puVar2[3] = uVar8;
    puVar5 = puVar4 + 4;
    puVar1 = puVar2 + 4;
  } while (puVar5 != param_2 + 0x14);
  uVar6 = puVar4[5];
  uVar7 = puVar4[6];
  puVar2[4] = *puVar5;
  puVar2[5] = uVar6;
  puVar2[6] = uVar7;

  // Now modify DrawEnv...

  // RECT viewport (startX, startY, endX, endY)
  local_70._0_2_ = *param_3;
  local_70._2_2_ = param_3[1];
  local_6c = param_3[2];
  uStack106 = param_3[3];

  // tpage-lower (always 1)
  local_58 = param_10;

  // ofs[Y]
  uStack102 = param_5;

  // dtd (dithering)
  uStack87 = param_6;

  // dfe (blocked or permitted)
  uStack86 = param_7;

  // isbg (always 0)
  uStack85 = param_8;

  // tpage-upper (always 0)
  uStack90 = param_9;

  // gGT->backBuffer->primMem.curr
  pvVar3 = (void *)param_2[0x20];

  p = (void *)0x0;

  // curr < endMin100
  if (pvVar3 <= (void *)param_2[0x21])
  {
	// advance curr
    param_2[0x20] = (int)pvVar3 + 0x40;

	// write primitive here
    p = pvVar3;
  }

  if (p != (void *)0x0)
  {
	// ofs[X]
    local_68 = param_4;

	// DrawEnv just built
    SetDrawEnv(p,&local_70);

	// This doesn't really draw a primitive,
	// it links the ptrOT from the camera,
	// into the ptrOT of backBuffer DB, allowing
	// this camera's primitives to draw
	AddPrim(param_1,p);
  }
  return;
}

// Camera110_LinkOT_Normal
// param1 otmem
// param2 camera110
// param3 backbuffer
void FUN_80042a8c(void *param_1,int param_2,undefined4 *param_3,short *param_4,undefined param_5)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  void *pvVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  void *p;

  // DrawEnv:

  // RECT clip
  undefined4 local_70;
  short local_6c;
  short sStack106;

  // short ofs[2]
  short local_68;
  short sStack102;

  // RECT tw, and short tpage
  undefined4 local_64 [3];

  // dtd
  undefined local_58;

  // Copy DrawEnv from gGT->backBuffer (param2)
  // onto stack memory at &local_70
  puVar1 = (undefined4 *)&local_70;
  puVar5 = param_3;
  do {
    puVar4 = puVar5;
    puVar2 = puVar1;
    uVar6 = puVar4[1];
    uVar7 = puVar4[2];
    uVar8 = puVar4[3];
    *puVar2 = *puVar4;
    puVar2[1] = uVar6;
    puVar2[2] = uVar7;
    puVar2[3] = uVar8;
    puVar5 = puVar4 + 4;
    puVar1 = puVar2 + 4;
  } while (puVar5 != param_3 + 0x14);
  uVar6 = puVar4[5];
  uVar7 = puVar4[6];
  puVar2[4] = *puVar5;
  puVar2[5] = uVar6;
  puVar2[6] = uVar7;

  // Now modify DrawEnv...

  // always zero?
  if (param_4 == (short *)0x0)
  {
	// XXX + camera110->rect.x
    local_70._0_2_ = (short)local_70 + *(short *)(param_2 + 0x1c);

	// XXX + camera110->rect.y
    local_70._2_2_ = local_70._2_2_ + *(short *)(param_2 + 0x1e);

	// camera110->rect.w
    local_6c = *(short *)(param_2 + 0x20);

	// camera110->rect.h
    sStack106 = *(short *)(param_2 + 0x22);

	// XXX + camera110->rect.x
    local_68 = local_68 + *(short *)(param_2 + 0x1c);

	// XXX + camera110->rect.y
    sStack102 = sStack102 + *(short *)(param_2 + 0x1e);
  }

  // option to use baked data, if it exists,
  // which it never is?
  else
  {
    local_70._0_2_ = *param_4;
    local_70._2_2_ = param_4[1];
    local_6c = param_4[2];
    sStack106 = param_4[3];
    local_68 = *param_4;
    sStack102 = param_4[1];
  }

  // drawEnv.dtd (always zero)
  local_58 = param_5;

  // gGT->backBuffer->primMem.curr
  pvVar3 = (void *)param_3[0x20];

  p = (void *)0x0;

  // curr < endMin100
  if (pvVar3 <= (void *)param_3[0x21])
  {
	// advance curr
    param_3[0x20] = (int)pvVar3 + 0x40;

	// write primitive here
	p = pvVar3;
  }

  if (p != (void *)0x0)
  {
	// DrawEnv just built
    SetDrawEnv(p,&local_70);

	// This doesn't really draw a primitive,
	// it links the ptrOT from the camera,
	// into the ptrOT of backBuffer DB, allowing
	// this camera's primitives to draw
    AddPrim(param_1,p);
  }
  return;
}

// Camera110_SetViewMatrix -- CameraMatrix, and ViewProj
// param1 is Camera110
void FUN_80042c04(short *param_1)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  short sVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  int iVar12;
  int iVar13;
  uint uVar14;
  uint uVar15;

  // camera110 rotation
  DAT_1f8003f4 = param_1[3];
  DAT_1f8003f6 = param_1[4];
  DAT_1f8003f8 = param_1[5];

  // camera matrix
  FUN_8006c2a4(&DAT_1f8003d4,&DAT_1f8003f4);

  // offsets 0x7c-0x84, 
  // camera matrix position
  iVar13 = (int)param_1[1];
  *(int *)(param_1 + 0x3e) = (int)*param_1;
  uVar1 = -(int)*param_1;
  *(int *)(param_1 + 0x40) = iVar13;
  *(int *)(param_1 + 0x42) = (int)param_1[2];
  
  // camera matrix
  sVar7 = DAT_1f8003e4;
  uVar6 = DAT_1f8003e0;
  uVar5 = DAT_1f8003dc;
  uVar4 = DAT_1f8003d8;
  uVar3 = DAT_1f8003d4;
  iVar2 = -(int)param_1[2];
  iVar12 = (int)DAT_1f8003e4;
  
  // transpose camera matrix
  uVar8 = DAT_1f8003e0 & 0xffff;
  uVar15 = uVar8 | DAT_1f8003d4 & 0xffff0000;
  uVar9 = DAT_1f8003dc & 0xffff;
  uVar14 = uVar9 | DAT_1f8003e0 & 0xffff0000;
  uVar11 = DAT_1f8003d4 & 0xffff | DAT_1f8003d8 & 0xffff0000;
  uVar10 = DAT_1f8003d8 & 0xffff | DAT_1f8003dc & 0xffff0000;

  // param1 is short* so double offsets,
  // offsets 0x68 - 0x74 is for CameraMatrix matrix
  *(uint *)(param_1 + 0x34) = DAT_1f8003d4;
  *(uint *)(param_1 + 0x36) = uVar4;
  *(uint *)(param_1 + 0x38) = uVar5;
  *(uint *)(param_1 + 0x3a) = uVar6;
  
  // USELESS, Never Used
  // offsets 0x48 - 0x68 is transpose camera matrix
  *(uint *)(param_1 + 0x24) = uVar11;
  *(uint *)(param_1 + 0x26) = uVar15;
  *(uint *)(param_1 + 0x28) = uVar14;
  *(uint *)(param_1 + 0x2a) = uVar10;
  
  param_1[0x3c] = sVar7;
  param_1[0x2c] = sVar7;

  // load transpose camera matrix  
  gte_ldL11L12(uVar11);
  gte_ldL13L21(uVar15);
  gte_ldL22L23(uVar14);
  gte_ldL31L32(uVar10);
  gte_ldL33(iVar12);
  
  // load inverted camera position
  gte_ldVXY0(uVar1 & 0xffff | iVar13 * -0x10000);
  gte_ldVZ0(iVar2);
  
  // multiply
  gte_llv0();
  
  // get result
  read_mt(uVar1,-iVar13,iVar2);

  // param1 is short* so double offsets,
  // offsets 0x28 - 0x48 is for ViewProj matrix
  *(uint *)(param_1 + 0x2e) = uVar1;
  *(uint *)(param_1 + 0x1e) = uVar1;
  *(int *)(param_1 + 0x30) = -iVar13;
  *(int *)(param_1 + 0x32) = iVar2;
  *(int *)(param_1 + 0x22) = iVar2;
  *(uint *)(param_1 + 0x14) = uVar11;
  *(uint *)(param_1 + 0x1a) = uVar10;
  param_1[0x1c] = sVar7;
  
  // 0x360/0x600 = 9/16 aspect ratio, if you render an image with 9/16 aspect,
  // at a resolution of 512x216, then the final image is a 4/3 aspect ratio. 
  // Upscaling the super-wide render target to a 640x480 TV would therefore 
  // look "normal". Math: 9/16 * 512/216, you get 4/3
  
  // apply aspect ratio to perspective matrix
  *(int *)(param_1 + 0x20) = (iVar13 * -0x360) / 0x600;
  *(uint *)(param_1 + 0x16) = uVar8 | ((((int)uVar15 >> 0x10) * 0x360) / 0x600) * 0x10000;
  *(uint *)(param_1 + 0x18) =
       ((short)uVar9 * 0x360) / 0x600 & 0xffffU |
       ((((int)uVar14 >> 0x10) * 0x360) / 0x600) * 0x10000;
	   
  // load CameraMatrix into GTE, this is useless 
  // cause it gets overwritten later anyway, which means
  // storing the result on scratchpad is also useless
  gte_ldL11L12(uVar3);
  gte_ldL13L21(uVar4);
  gte_ldL22L23(uVar5);
  gte_ldL31L32(uVar6);
  return;
}


// Camera110_SetFrustumPlane
// param_3 = cameraPos (x,y,z)
uint FUN_80042e50(undefined2 *param_1,short *param_2,short *param_3,short *param_4)
{
  int iVar1;
  int iVar2;
  uint uVar3;
  uint unaff_s0;
  int unaff_s1;
  int unaff_s2;
  int iVar4;
  int iVar5;
  int iVar6;
  
  // cameraPos(x,y,z)
  iVar6 = (int)*param_3;
  iVar4 = (int)param_3[1];
  iVar5 = (int)param_3[2];
  
  // param_4 - cameraPos
  gte_ldR11R12(*param_4 - iVar6);
  gte_ldR22R23(param_4[1] - iVar4);
  gte_ldR33(param_4[2] - iVar5);
  
  // param_2 - cameraPos
  gte_ldIR1(*param_2 - iVar6);
  gte_ldIR2(param_2[1] - iVar4);
  gte_ldIR3(param_2[2] - iVar5);
  
  // OP(sf,lm) - Outer product of 2 vectors
  gte_op0(0);
  
  read_mt(unaff_s0,unaff_s1,unaff_s2);
  
  uVar3 = unaff_s0;
  if ((int)unaff_s0 < 0) {
    uVar3 = -unaff_s0;
  }
  gte_ldLZCS(uVar3);
  iVar2 = gte_stLZCR();
  iVar1 = unaff_s1;
  if (unaff_s1 < 0) {
    iVar1 = -unaff_s1;
  }
  gte_ldLZCS(iVar1);
  iVar1 = gte_stLZCR();
  if (iVar1 < iVar2) {
    iVar2 = iVar1;
  }
  iVar1 = unaff_s2;
  if (unaff_s2 < 0) {
    iVar1 = -unaff_s2;
  }
  gte_ldLZCS(iVar1);
  iVar1 = gte_stLZCR();
  if (iVar1 < iVar2) {
    iVar2 = iVar1;
  }
  if (iVar2 < 0x12) {
    uVar3 = 0x12 - iVar2;
    unaff_s0 = (int)unaff_s0 >> (uVar3 & 0x1f);
    unaff_s1 = unaff_s1 >> (uVar3 & 0x1f);
    unaff_s2 = unaff_s2 >> (uVar3 & 0x1f);
  }
  iVar1 = FUN_8006c618(unaff_s0 * unaff_s0 + unaff_s1 * unaff_s1 + unaff_s2 * unaff_s2);
  iVar2 = unaff_s0 << 0xc;
  if (iVar1 != 0) {
    unaff_s0 = iVar2 / iVar1;
    if (iVar1 == 0) {
      trap(0x1c00);
    }
    if ((iVar1 == -1) && (iVar2 == -0x80000000)) {
      trap(0x1800);
    }
    iVar2 = unaff_s1 << 0xc;
    unaff_s1 = iVar2 / iVar1;
    if (iVar1 == 0) {
      trap(0x1c00);
    }
    if ((iVar1 == -1) && (iVar2 == -0x80000000)) {
      trap(0x1800);
    }
    iVar2 = unaff_s2 << 0xc;
    unaff_s2 = iVar2 / iVar1;
    if (iVar1 == 0) {
      trap(0x1c00);
    }
    if ((iVar1 == -1) && (iVar2 == -0x80000000)) {
      trap(0x1800);
    }
  }
  
  uVar3 = unaff_s0 >> 0x1f;
  
  // 8 bytes written to return parameter
  *param_1 = (short)unaff_s0;
  param_1[1] = (short)unaff_s1;
  param_1[2] = (short)unaff_s2;
  param_1[3] = (short)((int)(unaff_s0 * iVar6 + unaff_s1 * iVar4 + unaff_s2 * iVar5) >> 0xd);
  
  if (unaff_s1 < 0) {
    uVar3 = uVar3 | 2;
  }
  if (unaff_s2 < 0) {
    uVar3 = uVar3 | 4;
  }
  return uVar3;
}



// WARNING: Could not reconcile some variable overlaps

// Camera110_UpdateFrustum
// param_1 is Camera110
void FUN_800430f0(short *param_1)

{
  short sVar1;
  short sVar2;
  short sVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  uint uVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  undefined4 uVar12;
  int iVar13;
  int iVar14;
  undefined4 uVar15;
  int iVar16;
  int iVar17;
  undefined4 uVar18;
  int iVar19;
  int iVar20;
  int iVar21;
  uint uVar22;
  int iVar23;
  int iVar24;
  int iVar25;
  int iVar26;
  int iVar27;
  int iVar28;
  int local_3c;
  int local_38;

  // Camera110_SetViewMatrix
  FUN_80042c04(param_1);

  // disable the rest of the function by setting
  // 80043124 to 0x08010E3E (j 0x800438f8),
  // proves the rest of this function updates frustum

  // cameraPosX
  sVar1 = *param_1;
  iVar23 = (int)sVar1;

  // cameraPosY
  sVar2 = param_1[1];
  iVar25 = (int)sVar2;

  // cameraPosZ
  sVar3 = param_1[2];
  iVar26 = (int)sVar3;

  // iVar7 = rect.w
  iVar7 = (int)((uint)(ushort)param_1[0x10] << 0x10) >> 0x10;
  
  // uVar6 = rect.w/2
  uVar6 = iVar7 - ((int)((uint)(ushort)param_1[0x10] << 0x10) >> 0x1f) >> 1 & 0xffff;
  
  iVar4 = (((int)param_1[0x11] * 0x600000) / 0x360 >> 0xc) << 0x10;
  iVar9 = iVar4 >> 0x10;
  
  // bitwise
  uVar5 = (iVar9 - (iVar4 >> 0x1f) >> 1) << 0x10;
  
  // camera110 0x18, distToScreen
  iVar24 = *(int *)(param_1 + 0xc);
  
  // first "do" loop iteration
  uVar22 = uVar6 | uVar5;
  
  // distToScreen
  gte_ldVZ0(iVar24);
  
  // number of times to loop
  iVar20 = 3;
  
  // -1 * rect.w/2
  uVar8 = -iVar7 / 2 & 0xffff;
  
  iVar9 = -iVar9;
  iVar21 = 0x1f800012;
  iVar4 = iVar23;
  iVar7 = iVar25;
  iVar27 = iVar26;
  iVar28 = iVar23;
  local_3c = iVar25;
  local_38 = iVar26;
  
  do 
  {
	// multiply corner of screen,
	// by view-projection matrix, 
	// to get frustum plane world-pos
    gte_ldVXY0(uVar22);
    gte_llv0();

	if (iVar20 == 2) 
	{
	  // prepare for third iteration
      uVar22 = uVar6 | iVar9 / 2 << 0x10;
    }
    else {
      if (iVar20 < 3) {
        if (iVar20 == 1) 
		{
		  // prepare for fourth iteration
          uVar22 = uVar8 | iVar9 / 2 << 0x10;
        }
      }
      else {
        if (iVar20 == 3) 
		{
		  // prepare for second iteration
          uVar22 = uVar8 | uVar5;
        }
      }
    }
	
	// this is ViewProj matrix, loaded into GTE
	// from end of Camera110_SetViewMatrix (called earlier)
	read_mt(iVar10,iVar13,iVar16);
    
	// result of read_mt, plus cameraPos (x,y,z),
	iVar11 = iVar10 * 0x100 + iVar23;
    iVar14 = iVar13 * 0x100 + iVar25;
    iVar17 = iVar16 * 0x100 + iVar26;
    
	iVar19 = 0x1000;
    
	// result of read_mt, plus cameraPos (x,y,z),
	// over 4 loop iterations, this writes four corners,
	// 0x1f80000c = 0x1f800022
	*(short *)(iVar21 + 0x10) = (short)iVar16 + sVar3;
    *(short *)(iVar21 + 0xc) = (short)iVar10 + sVar1;
    *(short *)(iVar21 + 0xe) = (short)iVar13 + sVar2;
	
    DAT_1f800000 = iVar11;
    DAT_1f800004 = iVar14;
    DAT_1f800008 = iVar17;
    
	if (((iVar23 < -0x8000) && (-0x8000 < iVar11)) || ((-0x8000 < iVar23 && (iVar11 < -0x8000)))) {
      iVar13 = (-0x8000 - iVar23) * 0x1000;
      iVar10 = iVar11 - iVar23;
      iVar16 = iVar13 / iVar10;
      if (iVar10 == 0) {
        trap(0x1c00);
      }
      if ((iVar10 == -1) && (iVar13 == -0x80000000)) {
        trap(0x1800);
      }
      if (iVar16 < 0x1000) {
        DAT_1f800000 = -0x8000;
        DAT_1f800004 = iVar25 + (iVar16 * (iVar14 - iVar25) >> 0xc);
        DAT_1f800008 = iVar26 + (iVar16 * (iVar17 - iVar26) >> 0xc);
        iVar19 = iVar16;
      }
    }
    if (((iVar25 < -0x8000) && (-0x8000 < iVar14)) || ((-0x8000 < iVar25 && (iVar14 < -0x8000)))) {
      iVar13 = (-0x8000 - iVar25) * 0x1000;
      iVar10 = iVar14 - iVar25;
      iVar16 = iVar13 / iVar10;
      if (iVar10 == 0) {
        trap(0x1c00);
      }
      if ((iVar10 == -1) && (iVar13 == -0x80000000)) {
        trap(0x1800);
      }
      if (iVar16 < iVar19) {
        DAT_1f800004 = -0x8000;
        DAT_1f800000 = iVar23 + (iVar16 * (iVar11 - iVar23) >> 0xc);
        DAT_1f800008 = iVar26 + (iVar16 * (iVar17 - iVar26) >> 0xc);
        iVar19 = iVar16;
      }
    }
    if (((iVar26 < -0x8000) && (-0x8000 < iVar17)) || ((-0x8000 < iVar26 && (iVar17 < -0x8000)))) {
      iVar13 = (-0x8000 - iVar26) * 0x1000;
      iVar10 = iVar17 - iVar26;
      iVar16 = iVar13 / iVar10;
      if (iVar10 == 0) {
        trap(0x1c00);
      }
      if ((iVar10 == -1) && (iVar13 == -0x80000000)) {
        trap(0x1800);
      }
      if (iVar16 < iVar19) {
        DAT_1f800008 = -0x8000;
        DAT_1f800000 = iVar23 + (iVar16 * (iVar11 - iVar23) >> 0xc);
        DAT_1f800004 = iVar25 + (iVar16 * (iVar14 - iVar25) >> 0xc);
        iVar19 = iVar16;
      }
    }
    if (((iVar23 < 0x7fff) && (0x7fff < iVar11)) || ((0x7fff < iVar23 && (iVar11 < 0x7fff)))) {
      iVar13 = (0x7fff - iVar23) * 0x1000;
      iVar10 = iVar11 - iVar23;
      iVar16 = iVar13 / iVar10;
      if (iVar10 == 0) {
        trap(0x1c00);
      }
      if ((iVar10 == -1) && (iVar13 == -0x80000000)) {
        trap(0x1800);
      }
      if (iVar16 < iVar19) {
        DAT_1f800000 = 0x7fff;
        DAT_1f800004 = iVar25 + (iVar16 * (iVar14 - iVar25) >> 0xc);
        DAT_1f800008 = iVar26 + (iVar16 * (iVar17 - iVar26) >> 0xc);
        iVar19 = iVar16;
      }
    }
    if (((iVar25 < 0x7fff) && (0x7fff < iVar14)) || ((0x7fff < iVar25 && (iVar14 < 0x7fff)))) {
      iVar13 = (0x7fff - iVar25) * 0x1000;
      iVar10 = iVar14 - iVar25;
      iVar16 = iVar13 / iVar10;
      if (iVar10 == 0) {
        trap(0x1c00);
      }
      if ((iVar10 == -1) && (iVar13 == -0x80000000)) {
        trap(0x1800);
      }
      if (iVar16 < iVar19) {
        DAT_1f800004 = 0x7fff;
        DAT_1f800000 = iVar23 + (iVar16 * (iVar11 - iVar23) >> 0xc);
        DAT_1f800008 = iVar26 + (iVar16 * (iVar17 - iVar26) >> 0xc);
        iVar19 = iVar16;
      }
    }
    if (((iVar26 < 0x7fff) && (0x7fff < iVar17)) || ((0x7fff < iVar26 && (iVar17 < 0x7fff)))) {
      iVar10 = (0x7fff - iVar26) * 0x1000;
      iVar17 = iVar17 - iVar26;
      iVar13 = iVar10 / iVar17;
      if (iVar17 == 0) {
        trap(0x1c00);
      }
      if ((iVar17 == -1) && (iVar10 == -0x80000000)) {
        trap(0x1800);
      }
      if (iVar13 < iVar19) {
        DAT_1f800008 = 0x7fff;
        DAT_1f800000 = iVar23 + (iVar13 * (iVar11 - iVar23) >> 0xc);
        DAT_1f800004 = iVar25 + (iVar13 * (iVar14 - iVar25) >> 0xc);
      }
    }
    if (DAT_1f800000 < iVar28) {
      iVar28 = DAT_1f800000;
    }
    if (iVar4 < DAT_1f800000) {
      iVar4 = DAT_1f800000;
    }
    if (DAT_1f800004 < local_3c) {
      local_3c = DAT_1f800004;
    }
    if (iVar7 < DAT_1f800004) {
      iVar7 = DAT_1f800004;
    }
    if (DAT_1f800008 < local_38) {
      local_38 = DAT_1f800008;
    }
    if (iVar27 < DAT_1f800008) {
      iVar27 = DAT_1f800008;
    }
    
	// next loop index
	iVar20 = iVar20 + -1;
	
	// next corner to write
    iVar21 = iVar21 + -6;
	
  } while (-1 < iVar20);

  // 0xE8 to 0xF2
  param_1[0x74] = (short)iVar28;
  param_1[0x77] = (short)iVar4;
  param_1[0x78] = (short)iVar7;
  param_1[0x75] = (short)local_3c;
  param_1[0x79] = (short)iVar27;
  param_1[0x76] = (short)local_38;

  // cameraPos (x,y,z)
  DAT_1f800024._0_2_ = sVar1;
  DAT_1f800024._2_2_ = sVar2;
  DAT_1f800028._0_2_ = sVar3;

  // Changing stuff here is what caused EuroAli's
  // discovery for widescreen, so that polygons aren't
  // clipped outside of original 4:3 viewport

  // Camera110_SetFrustumPlane (x4)
  
  // these are four corners, two corners per func call,
  // combined with camera position, is used to make a plane
/*
	1f80000c -0x100 0x255 0x66 -- corner (-x,+y,-z)
	1f800012 +0x100 0x255 0x66 -- corner (+x,+y,-z)
	1f800018 -0x100 0x0D5 0x78 -- corner (-x,-y,-z)
	1f80001e +0x100 0x0D5 0x78 -- corner (+x,-y,-z)
	1f800024 0x0000 0x1a4 0x1af -- cameraPos
*/

  // param_1 is short*, so double offsets

  // 0xA8
  uVar5 = FUN_80042e50(param_1 + 0x54,&DAT_1f80000c,&DAT_1f800024,0x1f800012);
  // 0xD0
  *(uint *)(param_1 + 0x68) = ~uVar5 & 7;

  // 0xB0
  uVar5 = FUN_80042e50(param_1 + 0x58,0x1f800012,&DAT_1f800024,0x1f80001e);
  // 0xD4
  *(uint *)(param_1 + 0x6a) = ~uVar5 & 7;

  // 0xB8
  uVar5 = FUN_80042e50(param_1 + 0x5c,0x1f80001e,&DAT_1f800024,&DAT_1f800018);
  // 0xD8
  *(uint *)(param_1 + 0x6c) = ~uVar5 & 7;

  // 0xC0
  uVar5 = FUN_80042e50(param_1 + 0x60,&DAT_1f800018,&DAT_1f800024,&DAT_1f80000c);
  // 0xDC
  *(uint *)(param_1 + 0x6e) = ~uVar5 & 7;

  setCopReg(2,0,0);
  setCopReg(2,0x800,0x1000);

  // llv0     cop2 $04A6012  v0 * light matrix
  copFunction(2,0x4a6012);

  uVar5 = getCopReg(2,0xc800);
  iVar4 = getCopReg(2,0xd000);
  iVar7 = getCopReg(2,0xd800);

  // 0xC8, 0xCA, 0xCC
  param_1[100] = -(short)uVar5;
  param_1[0x65] = -(short)iVar4;
  param_1[0x66] = -(short)iVar7;

  iVar9 = iVar24;
  if (iVar24 < 0) {
    iVar9 = iVar24 + 3;
  }

  // 0xCE
  param_1[0x67] =
       (short)((int)-(iVar23 * uVar5 + iVar25 * iVar4 + iVar26 * iVar7) >> 0xd) -
       (short)(iVar9 >> 2);

  uVar5 = uVar5 >> 0x1f;
  if (iVar4 < 0) {
    uVar5 = uVar5 | 2;
  }
  if (iVar7 < 0) {
    uVar5 = uVar5 | 4;
  }

  // 0xE0, 0xE4
  *(uint *)(param_1 + 0x70) = ~uVar5 & 7;
  *(uint *)(param_1 + 0x72) = uVar5;

  setCopReg(2,0,0);
  setCopReg(2,0x800,iVar24 / 2);

  // llv0     cop2 $04A6012  v0 * light matrix
  copFunction(2,0x4a6012);

  uVar12 = getCopReg(2,0xc800);
  uVar15 = getCopReg(2,0xd000);
  uVar18 = getCopReg(2,0xd800);
  param_1[6] = (short)uVar12 + sVar1;
  param_1[7] = (short)uVar15 + sVar2;
  param_1[8] = (short)uVar18 + sVar3;
  return;
}


// Camera110_FadeOneWindow
void FUN_80043928(int param_1)

{
  undefined2 uVar1;
  undefined uVar2;
  short sVar3;
  int iVar4;
  void *p;

  // if camera110->fadeFromBlack_currentValue
  // is not 0x1000, which means there must be
  // some amount of fading
  if (*(short *)(param_1 + 0x12) != 0x1000)
  {
	// if we are fading to black
    if (*(short *)(param_1 + 0x12) < 0x1001)
	{
	  // backBuffer->primMem.curr
      p = *(void **)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80);

	  *(undefined *)((int)p + 3) = 7;
      *(undefined *)((int)p + 0xf) = 0x2a;

	  // fade to black
	  *(undefined4 *)((int)p + 4) = 0xe1000a40;

      *(undefined4 *)((int)p + 8) = 0;
      sVar3 = *(short *)(param_1 + 0x12);
      *(undefined2 *)((int)p + 0x10) = 0;
      *(undefined2 *)((int)p + 0x12) = 0;

	  // get strength of fade (0 to 0x1000)
      iVar4 = 0xfff - (int)sVar3;
    }
    else
	{
	  // backBuffer->primMem.curr
      p = *(void **)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80);

	  *(undefined *)((int)p + 3) = 7;
      *(undefined *)((int)p + 0xf) = 0x2a;

	  // fade to white
	  *(undefined4 *)((int)p + 4) = 0xe1000a20;

      *(undefined4 *)((int)p + 8) = 0;
      sVar3 = *(short *)(param_1 + 0x12);
      *(undefined2 *)((int)p + 0x10) = 0;
      *(undefined2 *)((int)p + 0x12) = 0;

	  // get strength of fade (0 to 0x1000)
      iVar4 = (int)sVar3 + -0x1000;
    }

	// strength of fade
    uVar2 = (undefined)(iVar4 >> 4);

	*(undefined *)((int)p + 0xe) = uVar2;
    *(undefined *)((int)p + 0xd) = uVar2;
    *(undefined *)((int)p + 0xc) = uVar2;
    uVar1 = *(undefined2 *)(param_1 + 0x20);
    *(undefined2 *)((int)p + 0x16) = 0;
    *(undefined2 *)((int)p + 0x18) = 0;
    *(undefined2 *)((int)p + 0x14) = uVar1;
    *(undefined2 *)((int)p + 0x1a) = *(undefined2 *)(param_1 + 0x22);
    *(undefined2 *)((int)p + 0x1c) = *(undefined2 *)(param_1 + 0x20);
    *(undefined2 *)((int)p + 0x1e) = *(undefined2 *)(param_1 + 0x22);
    AddPrim(*(void **)(param_1 + 0xf4),p);

	// backBuffer->primMem.curr
    // move pointer after writing polygons
    *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80) =
         *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80) + 0x20;
  }

  // alter the fade value by the fade velocity
  sVar3 = *(short *)(param_1 + 0x12) + *(short *)(param_1 + 0x16);

  // set new fade value (temporarily)
  *(short *)(param_1 + 0x12) = sVar3;

  // if fade velocity is negative
  if (*(short *)(param_1 + 0x16) < 1)
  {
	// if we go lower than the desired fade
    if (sVar3 < *(short *)(param_1 + 0x14))
	{
	  // set to desired fade
      *(undefined2 *)(param_1 + 0x12) = *(undefined2 *)(param_1 + 0x14);
    }
  }

  // if fade velocity is positive
  else
  {
	// if we go higher than the desired fade value
    if (*(short *)(param_1 + 0x14) < sVar3)
	{
	  // set to desired fade value
      *(undefined2 *)(param_1 + 0x12) = *(undefined2 *)(param_1 + 0x14);
    }
  }
  return;
}


// Camera110_FadeAllWindows
void FUN_80043ab8(void)

{
  int iVar1;
  int iVar2;

  // loop counter
  iVar1 = 0;

  // if number of screens is not zero
  if (PTR_DAT_8008d2ac[0x1ca8] != '\0')
  {
	// offset of 8008d2ac for camera110 buffers
    iVar2 = 0x168;

	// for(int iVar1 = 0; iVar1 < numScreens; iVar1++)
    do
	{
      // add fade quad for current camera

	  // Camera110_FadeOneWindow
	  // pointer to camera110 buffer
      FUN_80043928(PTR_DAT_8008d2ac + iVar2);

	  // increment loop counter
      iVar1 = iVar1 + 1;

	  // increment offset to next camera110 buffer
      iVar2 = iVar2 + 0x110;

						// number of screens
    } while (iVar1 < (int)(uint)(byte)PTR_DAT_8008d2ac[0x1ca8]);
  }

  // Camera110_FadeOneWindow
  // add quad for UI camera
  FUN_80043928(PTR_DAT_8008d2ac + 5000);
  return;
}


// loadNonAdvTrack_MenuFuncPtr
void FUN_80043b30(undefined4 param_1)

{
  undefined *puVar1;
  uint uVar2;

  // If you're in Time Trial
  if ((*(uint *)PTR_DAT_8008d2ac & 0x20000) != 0)
  {
	// Set P3 to N Tropy
    DAT_80086e88 = 0xc;

	// Set P4 to N Oxide
    DAT_80086e8a = 0xf;
  }

  // If you're in Adventure Mode
  if ((*(uint *)PTR_DAT_8008d2ac & 0x80000) != 0) {

	// Change mode to Adventure Arena
    *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac | 0x100000;
  }

  puVar1 = PTR_DAT_8008d2ac;

  // If you're not in Battle Mode
  if ((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0)
  {
    *(undefined4 *)(PTR_DAT_8008d2ac + 0x1d84) = 0x2a300;

	// Turn off 0x10000: Time limit (battle)
	// Turn off 0x4000: Point limit (battle)
	// Turn off 0x8000 Life limit (battle)
    uVar2 = *(uint *)PTR_DAT_8008d2ac;
    *(uint *)puVar1 = uVar2 & 0xfffe3fff;
  }

  // Load LEV in Track Selection
  FUN_8003cfc0((int)*(short *)(PTR_DAT_8008d2ac + 0x1eb0));

  // make MenuBox invisible
  FUN_800469c8(param_1);
  return;
}


// loadNonAdvTrack_Get_MenuBox
undefined * FUN_80043c04(void)

{
  return &DAT_80085a94;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// Restore a backup of game options,
// this is stored between GameProgress and AdventureProgress
void FUN_80043c10(void)

{
  int iVar1;

  if (DAT_8008d8f0 == 0) {
    DAT_8008d8f0 = 1;
    iVar1 = 0;

	// loop 3 times (fx, music, voice)
	do {
      howl_VolumeSet((int)(short)iVar1,(uint)(byte)(&DAT_8008fb7c)[(int)(short)iVar1 * 2]);
      iVar1 = iVar1 + 1;
      DAT_800841fc = DAT_8008fb82;
      _DAT_80084200 = DAT_8008fb86;
      DAT_80084204 = DAT_8008fb8a;
      DAT_80084208 = DAT_8008fb8e;
      DAT_8008420c = DAT_8008fb92;
      DAT_80084210 = DAT_8008fb96;
    } while (iVar1 * 0x10000 >> 0x10 < 3);

    *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac | DAT_8008fb9c & 0xf00;

	// howl_ModeSet
	FUN_8002b1fc((uint)DAT_8008fba0 & 1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// make a backup of game options,
// this is stored between GameProgress and AdventureProgress
void FUN_80043d24(void)

{
  ushort uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;

  // loop counter
  iVar4 = 0;

  // pointer counter
  iVar3 = 0;

  do
  {
	// get value for each type of volume and clamp to 0x100
    uVar1 = howl_VolumeGet(iVar3 >> 0x10);

	// store a backup of volume
	*(ushort *)(&DAT_8008fb7c + (iVar3 >> 0x10) * 2) = uVar1 & 0xff;

	// loop counter
    iVar4 = iVar4 + 1;

	// pointer counter
    iVar3 = iVar4 * 0x10000;

  } while (iVar4 * 0x10000 >> 0x10 < 3);

  DAT_8008fb82 = DAT_800841fc;
  DAT_8008fb86 = _DAT_80084200;
  DAT_8008fb8a = DAT_80084204;
  DAT_8008fb8e = DAT_80084208;
  DAT_8008fb92 = DAT_8008420c;
  DAT_8008fb96 = DAT_80084210;
  DAT_8008fb9c = *(uint *)PTR_DAT_8008d2ac & 0xf00;

  // howl_ModeGet
  uVar2 = FUN_8002b1f0();

  // store a saftery-copy of mode?
  DAT_8008fba0 = (ushort)((uVar2 & 0xff) != 0);
  return;
}


// CheckeredFlag_MoveModels
// param_1 - frame index
// param_2 - numFrames in transition
int FUN_80043e34(int param_1,int param_2)
{
  // need a better prefix than CheckeredFlag,
  // all this does is move the intro logo models
  // from the center of the screen, to the right

  // also used for transitioning driver models
  // on and off the screen in character selection

  int iVar1;
  int iVar2;

  // 0x0000 - start of transition
  iVar1 = 0;
  if (
		// index >= 0
		(-1 < param_1) &&

		(
			// 0x1000 - end of transition
			iVar1 = 0x1000,

			// frameIndex is between start and ennd
			param_1 <= param_2
		)
	 )
  {
	// iVar1 = param_2 / 2,
	// stupid over-complicated way of cutting in half
    iVar1 = (param_2 - (param_2 >> 0x1f)) * 0x8000 >> 0x10;

	// if less than half done
    if (param_1 < iVar1)
	{
	  // (half - index) * 0x400
      iVar2 = (iVar1 - param_1) * 0x400;

      if (iVar1 == 0) {
        trap(0x1c00);
      }
      if ((iVar1 == -1) && (iVar2 == -0x80000000)) {
        trap(0x1800);
      }

	  // Sine(angle)
	  iVar1 = FUN_8003d184(iVar2 / iVar1);

	  // 50% - sin(angle/2)
      iVar1 = 0x800 - iVar1 / 2;
    }

	// if more than half done
    else
	{
	  // (index - half) * 0x400
      iVar2 = (param_1 - iVar1) * 0x400;

      if (iVar1 == 0) {
        trap(0x1c00);
      }
      if ((iVar1 == -1) && (iVar2 == -0x80000000)) {
        trap(0x1800);
      }

	  // Sine(angle)
	  iVar1 = FUN_8003d184(iVar2 / iVar1);

	  // sin(angle/2) + 50%
      iVar1 = iVar1 / 2 + 0x800;
    }
  }
  return iVar1;
}

// CheckeredFlag_IsFullyOnScreen
uint FUN_80043f1c(void)

{

  // CheckeredFlag_Position
  // return true if flag is fully on screen
  // return false if flag is not fully on screen
  return (uint)(DAT_8008d444 == 0);
}


// CheckeredFlag_IsFullyOffScreen
uint FUN_80043f28(void)

{

  // CheckeredFlag_Position
  // return false, "not true", if flag is < 5000, partially on-screen
  // return true, "not false", if flag is >= 5000, fully off-screen
  return (uint)((ushort)(DAT_8008d444 + 4999U) < 9999) ^ 1;
}


// CheckeredFlag_IsTransitioning
uint FUN_80043f44(void)

{
  uint uVar1;

  // by default, assume false
  uVar1 = 0;

  // CheckeredFlag_Position
  // if checkered flag is not fully on-screen and not fully off-screen
  if (((DAT_8008d444 != 0) && (DAT_8008d444 != -5000)) && (DAT_8008d444 != 5000))
  {
	// this is true if the loading screen is being drawn, false if it is not
    uVar1 = (uint)((*(uint *)(PTR_DAT_8008d2ac + 0x256c) & 0x1000) != 0);
  }
  return uVar1;
}



// CheckeredFlag_SetDrawOrder
void FUN_80043f8c(int param_1)

{
  if (param_1 != 0) {

    // CheckeredFlag_DrawOrder = 1
    DAT_8008d44c = 1;
    return;
  }

  // CheckeredFlag_DrawOrder = -1
  DAT_8008d44c = 0xffff;
  return;
}


// CheckeredFlag_BeginTransition
void FUN_80043fb0(int param_1)

{
  // Begin Transition on-screen
  if (param_1 == 1) {

    // CheckeredFlag_LoadingTextAnimFrame = -1
    DAT_8008d450 = 0xffffffff;

    // CheckeredFlag_Position = 5000
    DAT_8008d444 = 5000;

    // CheckeredFlag_AnimationType = 0
    DAT_8008d440 = 0;
  }

  // Begin Transition off-screen
  else {
    if (param_1 == 2) {
      FUN_80043f8c(0);

      // CheckeredFlag_Position = 0
      DAT_8008d444 = 0;

      // CheckeredFlag_AnimationType = 2
      DAT_8008d440 = param_1;
    }
  }

  // enable loading screen's checkered flag
  *(uint *)(PTR_DAT_8008d2ac + 0x256c) = *(uint *)(PTR_DAT_8008d2ac + 0x256c) | 0x1000;
  return;
}


// CheckeredFlag_SetFullyOnScreen
void FUN_8004402c(void)

{
  // flag is now fully on-screen
  DAT_8008d444 = 0;

  // CheckeredFlag_AnimationType = 0
  DAT_8008d440 = 0;

  // CheckeredFlag_LoadingTextAnimFrame = -1
  DAT_8008d450 = 0xffffffff;

  // enable loading screen's checkered flag
  *(uint *)(PTR_DAT_8008d2ac + 0x256c) = *(uint *)(PTR_DAT_8008d2ac + 0x256c) | 0x1000;
  return;
}


// CheckeredFlag_SetFullyOffScreen
void FUN_80044058(void)

{
  // CheckeredFlag_LoadingTextAnimFrame = -1
  DAT_8008d450 = 0xffffffff;

  // CheckeredFlag_Position
  // flag is now fully off-screen
  DAT_8008d444 = 5000;

  // CheckeredFlag_AnimationType = 0
  DAT_8008d440 = 0;

  // disable loading screen's checkered flag
  *(uint *)(PTR_DAT_8008d2ac + 0x256c) = *(uint *)(PTR_DAT_8008d2ac + 0x256c) & 0xffffefff;
  return;
}

// CheckeredFlag_SetCanDraw
void FUN_80044088(undefined2 param_1)

{
  DAT_8008d448 = param_1;

  return;
}


// CheckeredFlag_GetCanDraw
int FUN_80044094(void)

{
  return (int)DAT_8008d448;
}


// CheckeredFlag_PerFrame_GetOT
int FUN_800440a0(void)
{
  // In Naughty Dog's code, this could have
  // been split in 2 functions, but compiler
  // optimized it into one, or maybe ND just
  // threw it into one anyway

  short sVar1;
  int iVar2;

  if (DAT_8008d44a == 0) {
    DAT_8008d44a = 1;
  }

  // if CheckeredFlag_AnimationType != 1
  if (DAT_8008d440 != 1) {

    // if CheckeredFlag_AnimationType == 0
    if (DAT_8008d440 == 0) {

      // if CheckeredFlag_Position < 0
      if ((short)DAT_8008d444 < 0) {

        // CheckeredFlag_Position = 5000
        DAT_8008d444 = 5000;
      }
      DAT_8008d446 = 300;

      // iVar2 = (CheckeredFlag_Position << 0x10) >> 0x10
      iVar2 = (int)((uint)DAT_8008d444 << 0x10) >> 0x10;
      if (iVar2 < 1) {

        // CheckeredFlag_Position = 0
        DAT_8008d444 = 0;

        // if CheckeredFlag_DrawOrder != 1
        if (DAT_8008d44c != 1) {

          // if CheckeredFlag_DrawOrder != -1
          if (DAT_8008d44c != -1) {

            // CheckeredFlag_Position = 0
            DAT_8008d444 = 0;
            DAT_8008d446 = 300;

			// pointer to Camera110->OTMem (25c-168=0xf4)
            return *(int *)(PTR_DAT_8008d2ac + 0x25c) + 0xffc;
          }

          // CheckeredFlag_DrawOrder = 0
          DAT_8008d44c = 0;
          goto LAB_80044268;
        }
      }
      else
	  {
		// if position is less than 8
        if (iVar2 < 8)
		{
		  // drop to zero

          // CheckeredFlag_Position = 0
          DAT_8008d444 = 0;
        }

		// if position is large
        else
		{
		  // decrease until position is near zero

		  // Take CheckeredFlag_Position, remove top 2 bytes, divide by 8		// elapsed milliseconds per frame, ~32
          iVar2 = ((int)((uint)DAT_8008d444 << 0x10) >> 0x13) * *(int *)(PTR_DAT_8008d2ac + 0x1d04)
                  >> 5;
          sVar1 = -(short)iVar2;
          if (iVar2 < 1) {
            sVar1 = -1;
          }

          // CheckeredFlag_Position += sVar1
          DAT_8008d444 = DAT_8008d444 + sVar1;
        }
      }
      DAT_8008d446 = 300;


	  // OTMem depending on swapchain index
      return *(undefined4 *)(PTR_DAT_8008d2ac + *(int *)(PTR_DAT_8008d2ac + 0xc) * 4 + 0x18c8);
    }

    // if CheckeredFlag_AnimationType == 2
    if (DAT_8008d440 == 2)
	{
      if ((short)DAT_8008d446 < 1000)
	  {
		// increase until 1000
										// elapsed milliseconds per frame, ~32
        DAT_8008d446 = DAT_8008d446 + (short)(*(int *)(PTR_DAT_8008d2ac + 0x1d04) * 10 >> 5);
      }

      // if CheckeredFlag_Position < -4999
      if ((short)DAT_8008d444 < -4999) {

        // CheckeredFlag_Position = 5000
        DAT_8008d444 = 5000;

        // CheckeredFlag_AnimationType = 0
        DAT_8008d440 = 0;

		// disable loading screen
        *(uint *)(PTR_DAT_8008d2ac + 0x256c) = *(uint *)(PTR_DAT_8008d2ac + 0x256c) & 0xffffefff;
      }

	  // If not -5000 yet
      else
	  {
		// decrease until -5000

        // CheckeredFlag_Position -= ???
        DAT_8008d444 = DAT_8008d444 -
                       (short)(((int)((uint)DAT_8008d446 << 0x10) >> 0x12) *

								// elapsed milliseconds per frame, ~32
                               *(int *)(PTR_DAT_8008d2ac + 0x1d04) >> 5);
      }
    }
  }
LAB_80044268:
  // OTMem depending on swapchain index
  return *(undefined4 *)(PTR_DAT_8008d2ac + *(int *)(PTR_DAT_8008d2ac + 0xc) * 4 + 0x18c8);
}


// CheckeredFlag_ResetTextAnim
void FUN_80044290(void)

{

  // CheckeredFlag_LoadingTextAnimFrame = -1
  DAT_8008d450 = 0xffffffff;

  return;
}


// CheckeredFlag_DrawLoadingString
void FUN_800442a0(void)

{
  undefined *puVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  undefined4 uVar5;
  int iVar6;
  byte *pbVar7;
  byte *pbVar8;
  int iVar9;
  int iVar10;
  undefined4 uVar11;
  byte local_30;
  byte local_2f;

  iVar2 = DAT_8008d878;

  // pointer to OT mem
  uVar11 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c);

  // pointer to OT mem
  *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c) =
       *(undefined4 *)(PTR_DAT_8008d2ac + *(int *)(PTR_DAT_8008d2ac + 0xc) * 4 + 0x18c8);

  // iVar2 + 0x8c4
  // LOADING...
  pbVar7 = *(byte **)(iVar2 + 0x8c4);

  // get length of "LOADING..." string
  iVar2 = strlen();

  // DecalFont_GetLineWidth
  iVar3 = FUN_800224d0(pbVar7,1);

  // loop counter
  iVar6 = 0;

  // if game is not loading
  if (DAT_8008d0f8 == -1) {
    if (-1000 < (int)DAT_8008d454) {
      DAT_8008d454 = DAT_8008d454 - 0x28;
    }
  }
  else {
    DAT_8008d454 = 0;
  }
  iVar10 = (DAT_8008d454 & 0xffff) - (((iVar3 << 0x10) >> 0x10) - ((iVar3 << 0x10) >> 0x1f) >> 1);

  // iVar3 = CheckeredFlag_LoadingTextAnimFrame
  iVar3 = DAT_8008d450;

  if (0 < iVar2) {

    // iVar9 = CheckeredFlag_LoadingTextAnimFrame * -0x3C + 0x23C
    iVar9 = DAT_8008d450 * -0x3c + 0x23c;

	// for iVar6 = 0; iVar6 < strlen("LOADING..."); iVar6++)
	do {
      if (iVar3 < 0) {
LAB_800443c4:

		// draw text off screen
        iVar4 = 0x23c;
      }
      else {
        iVar4 = iVar9;
        if (
				// if frame > 4,
				// if text starts moving on-screen?
				(4 < iVar3) &&
				(
					// draw letter at midpoint of screen
					iVar4 = 0x100,

					// if frame > 0x4a,
					// if text starts moving off-screen?
					0x4a < iVar3
				)
			)
		{
		  // if frame > 0x4f,
		  // if letter is fully off-screen
          if (0x4f < iVar3) goto LAB_800443c4;

		  // letter is moving off-screen
		  iVar4 = (0x4b - iVar3) * 0x3c + 0x100;
        }
      }
      local_30 = *pbVar7;
      pbVar8 = pbVar7 + 1;
      uVar5 = 1;
      if (local_30 < 4) {
        local_2f = *pbVar8;
        pbVar8 = pbVar7 + 2;

		// increment loop counter
        iVar6 = iVar6 + 1;

        uVar5 = 2;
      }
      if ((short)iVar4 != 0x23c)
	  {
		// DecalFont_DrawLineStrlen
        FUN_800224fc(&local_30,uVar5,(iVar10 + iVar4) * 0x10000 >> 0x10,0x6c,1,0);
      }

	  // DecalFont_GetLineWidthStrlen
      iVar4 = FUN_800223f4(&local_30,uVar5,1);

      iVar10 = iVar10 + iVar4;
      iVar9 = iVar9 + 0xf0;

	  // increment loop counter
      iVar6 = iVar6 + 1;

	  // treat all letters with 4 frame difference
      iVar3 = iVar3 + -4;

      pbVar7 = pbVar8;
    } while (iVar6 < iVar2);
  }
  puVar1 = PTR_DAT_8008d2ac;

  // pointer to OT mem
  *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c) = uVar11;

  if (iVar3 < 0x50)
  {
    iVar2 = *(int *)(puVar1 + 0x1d04) >> 5;

	if (iVar2 < 1) {
      iVar2 = 1;
    }

    // CheckeredFlag_LoadingTextAnimFrame += iVar2
    DAT_8008d450 = DAT_8008d450 + iVar2;
  }

  else {

    // CheckeredFlag_LoadingTextAnimFrame = -1
    DAT_8008d450 = -1;
    if (DAT_8008d0f8 - 6U < 2) {

      // CheckeredFlag_LoadingTextAnimFrame = 0
      DAT_8008d450 = 0;
    }
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

// CheckeredFlag_DrawSelf
void FUN_800444e8(void)

{
  bool bVar1;
  short sVar2;
  uint *puVar3;
  undefined uVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  SVECTOR *pSVar9;
  int iVar10;
  uint *puVar11;
  uint uVar12;
  int iVar13;
  uint uVar14;
  SVECTOR *r0;
  int iVar15;
  uint uVar16;
  uint uVar17;
  uint *puVar18;
  long *r0_00;
  uint *puVar19;
  undefined *puVar20;
  uint *puVar21;
  int iVar22;
  uint uVar23;
  undefined *puVar24;
  undefined *puVar25;
  int iVar26;
  undefined auStack136 [96];
  
  puVar24 = &DAT_8008cf6c;
  puVar25 = auStack136;
  
  // if CheckeredFlag_CanDraw == false
  if (DAT_8008d448 == 0) 
  {
	// don't draw
    return;
  }
  
  // if CheckeredFlag_LoadingTextAnimFrame < 0
  if (DAT_8008d450 < 0) 
  {
	// if loading stage is 6 or 7,
	// during the level loading
    if ((5 < DAT_8008d0f8) && (DAT_8008d0f8 < 8)) {
		
	  // CheckeredFlag_LoadingTextAnimFrame = 0
      DAT_8008d450 = 0;
    }
	
	// if CheckeredFlag_LoadingTextAnimFrame < 0 goto ???
    if (DAT_8008d450 < 0) goto LAB_80044568;
  }
  
  // CheckeredFlag_DrawLoadingString
  FUN_800442a0();
  
LAB_80044568:
  DAT_8009d45c = DAT_8008d0f8;
  
  // get ptr OTMem
  puVar3 = (uint *)FUN_800440a0();
  
  gte_SetRotMatrix((MATRIX *)0x80085ac0);
  gte_SetTransMatrix((MATRIX *)0x80085ac0);
  gte_SetGeomOffset(0x100,0x78);
  gte_ldH(0x100);
  
  // elapsed milliseconds per frame, ~32
  iVar26 = DAT_80085aec * *(int *)(PTR_DAT_8008d2ac + 0x1d04);
  
  puVar18 = (uint *)0x0;
  r0_00 = &DAT_1f800000;
  uVar23 = 1;
  
  // some kind of elapsed time in CheckeredFlag,
  // 8008d458
  uVar16 = *(int *)(puVar24 + 0x4ec) >> 5;
  
  *(uint *)(puVar25 + 0x4c) = uVar16;
  DAT_80085af0 = DAT_80085af0 + iVar26;
  uVar14 = (int)DAT_80085af0 >> 5;
  if (0xfff < uVar14) 
  {
    DAT_80085af0 = DAT_80085af0 & 0x1ffff;
    uVar14 = (int)DAT_80085af0 >> 5;
    DAT_80085ae0 = DAT_80085ae0 + 0x200;
	
	// approximate trigonometry
    iVar26 = *(int *)(&DAT_800845a0 + (DAT_80085ae0 & 0x3ff) * 4);
	
    if ((DAT_80085ae0 & 0x400) == 0) {
      iVar26 = iVar26 << 0x10;
    }
    iVar26 = iVar26 >> 0x10;
    if ((DAT_80085ae0 & 0x800) != 0) {
      iVar26 = -iVar26;
    }
    
	DAT_80085ae4 = ((iVar26 + 0xfff) * 0x20 >> 0xd) + 0x96;
    DAT_80085ae8 = DAT_80085ae8 + 200;
    
	// approximate trigonometry
	iVar26 = *(int *)(&DAT_800845a0 + (DAT_80085ae8 & 0x3ff) * 4);
	
    if ((DAT_80085ae8 & 0x400) == 0) {
      iVar26 = iVar26 << 0x10;
    }
    iVar26 = iVar26 >> 0x10;
    if ((DAT_80085ae8 & 0x800) != 0) {
      iVar26 = -iVar26;
    }
    DAT_80085aec = ((iVar26 + 0xfff) * 0x40 >> 0xd) + 0xb4;
  }
  
  // approximate trigonometry
  iVar26 = *(int *)(&DAT_800845a0 + (uVar14 & 0x3ff) * 4);
  
  if ((uVar14 & 0x400) == 0) {
    iVar26 = iVar26 << 0x10;
  }
  iVar26 = iVar26 >> 0x10;
  if ((uVar14 & 0x800) != 0) {
    iVar26 = -iVar26;
  }
  uVar14 = uVar14 + 0xc80;
  
  // approximate trigonometry
  iVar5 = *(int *)(&DAT_800845a0 + (uVar14 & 0x3ff) * 4);
  
  if ((uVar14 & 0x400) == 0) {
    iVar5 = iVar5 << 0x10;
  }
  iVar5 = iVar5 >> 0x10;
  if ((uVar14 & 0x800) != 0) {
    iVar5 = -iVar5;
  }
  
  // loop counter
  iVar22 = 0;
  
  puVar20 = &DAT_800845a0;
  r0 = (SVECTOR *)(puVar25 + 0x10);
  *(int *)(puVar25 + 0x48) = iVar5 + 0xfff;
  iVar26 = (iVar26 + 0xfff) * DAT_80085ae4;
  *(undefined2 *)(puVar25 + 0x12) = 0xfc72;
  
  // 8008d444
  // CheckeredFlag_Position
  sVar2 = *(short *)(puVar24 + 0x4d8);
  
  *(undefined2 *)(puVar25 + 0x1a) = 0xfcd0;
  *(undefined2 *)(puVar25 + 0x22) = 0xfd2e;
  
  // sVar3 = -0xBBE - CheckeredFlag_Position
  sVar2 = -0xbbe - sVar2;
  
  // flag position
  *(short *)(puVar25 + 0x10) = sVar2;
  *(short *)(puVar25 + 0x18) = sVar2;
  *(short *)(puVar25 + 0x20) = sVar2;
  
  iVar26 = (iVar26 >> 0xd) + 0x280;
  
  // for iVar22 = 0; iVar22 < 10; iVar22++
  do 
  {
	// loop counter
    iVar5 = 0;
	
    pSVar9 = r0;
	
	// for iVar5 = 0; iVar5 < 3; iVar5++
    do {
      iVar6 = *(int *)(puVar20 + (uVar16 & 0x3ff) * 4);
      if ((uVar16 & 0x400) == 0) {
        iVar6 = iVar6 << 0x10;
      }
      iVar6 = iVar6 >> 0x10;
      if ((uVar16 & 0x800) != 0) {
        iVar6 = -iVar6;
      }
      pSVar9->vz = (short)iVar26 + (short)((iVar6 + 0xfff) * 0x20 >> 0xd);
      uVar16 = uVar16 + 300;
      
	  // increment loop counter
	  iVar5 = iVar5 + 1;
	  
      pSVar9 = pSVar9 + 1;
    } while (iVar5 < 3);
	
    gte_ldv3(r0,(SVECTOR *)(puVar25 + 0x18),(SVECTOR *)(puVar25 + 0x20));
    gte_rtpt();
	
    *(short *)(puVar25 + 0x12) = *(short *)(puVar25 + 0x12) + 0x11a;
    *(short *)(puVar25 + 0x22) = *(short *)(puVar25 + 0x22) + 0x11a;
    *(short *)(puVar25 + 0x1a) = *(short *)(puVar25 + 0x1a) + 0x11a;
	
    gte_stsxy3(r0_00,r0_00 + 1,r0_00 + 2);
	
	// increment loop counter
    iVar22 = iVar22 + 1;
	
    r0_00 = r0_00 + 3;
	
  } while (iVar22 < 10);
  
  iVar5 = 1;
  puVar20 = &DAT_800845a0;
  uVar14 = 0x80008000;
  iVar22 = *(int *)(puVar25 + 0x48);
  *(undefined **)(puVar25 + 0x50) = puVar25 + 0x48;
  *(undefined **)(puVar25 + 0x5c) = puVar25 + 0x10;
  
  // screen dimensions
  iVar26 = 0xd80200;
  
  *(uint *)(puVar25 + 0x28) = DAT_80085ae0;
  *(int *)(puVar25 + 0x2c) = DAT_80085ae4;
  *(uint *)(puVar25 + 0x30) = DAT_80085ae8; // angle of wave effect
  *(int *)(puVar25 + 0x34) = DAT_80085aec; // set zero makes all light dark
  *(uint *)(puVar25 + 0x38) = DAT_80085af0; // set zero makes all light bright
  
  // vertical strips
  do 
  {
    puVar19 = (uint *)(uVar23 * 0x78 + 0x1f7ffffc);
    uVar23 = uVar23 ^ 1;
    puVar21 = (uint *)(uVar23 * 0x78 + 0x1f800000);
    uVar17 = *(int *)(puVar25 + 0x4c) + 0x100;
    uVar16 = *(int *)(puVar25 + 0x38) + *(int *)(puVar25 + 0x34) * 0x40;
    uVar12 = (int)uVar16 >> 5;
    *(uint *)(puVar25 + 0x4c) = uVar17;
    *(uint *)(puVar25 + 0x38) = uVar16;
	
    if (0xfff < uVar12) 
	{
      uVar12 = (int)(uVar16 & 0x1ffff) >> 5;
      *(uint *)(puVar25 + 0x38) = uVar16 & 0x1ffff;
	  
	  // increment 0x200
      uVar16 = *(int *)(puVar25 + 0x28) + 0x200;
      *(uint *)(puVar25 + 0x28) = uVar16;
	  
	  // approximate trigonometry
      iVar6 = *(int *)(puVar20 + (uVar16 & 0x3ff) * 4);
      
	  if ((uVar16 & 0x400) == 0) {
        iVar6 = iVar6 << 0x10;
      }
      iVar6 = iVar6 >> 0x10;
      if ((uVar16 & 0x800) != 0) {
        iVar6 = -iVar6;
      }
      *(int *)(puVar25 + 0x2c) = ((iVar6 + 0xfff) * 0x20 >> 0xd) + 0x96;
      uVar16 = *(int *)(puVar25 + 0x30) + 200;
      *(uint *)(puVar25 + 0x30) = uVar16;
	  
	  // approximate trigonometry
      iVar6 = *(int *)(puVar20 + (uVar16 & 0x3ff) * 4);
      
	  if ((uVar16 & 0x400) == 0) {
        iVar6 = iVar6 << 0x10;
      }
      iVar6 = iVar6 >> 0x10;
      if ((uVar16 & 0x800) != 0) {
        iVar6 = -iVar6;
      }
      *(int *)(puVar25 + 0x34) = ((iVar6 + 0xfff) * 0x40 >> 0xd) + 0xb4;
    }
	
	// approximate trigonometry
    iVar6 = *(int *)(puVar20 + (uVar12 & 0x3ff) * 4);
	
    if ((uVar12 & 0x400) == 0) {
      iVar6 = iVar6 << 0x10;
    }
    iVar6 = iVar6 >> 0x10;
    if ((uVar12 & 0x800) != 0) {
      iVar6 = -iVar6;
    }
    uVar12 = uVar12 + 0xc80;
	
	// approximate trigonometry
    iVar7 = *(int *)(puVar20 + (uVar12 & 0x3ff) * 4);
	
    if ((uVar12 & 0x400) == 0) {
      iVar7 = iVar7 << 0x10;
    }
    iVar7 = iVar7 >> 0x10;
    if ((uVar12 & 0x800) != 0) {
      iVar7 = -iVar7;
    }
	
	// loop counter
    iVar13 = 0;
	
    iVar15 = *(int *)(puVar25 + 0x5c);
    **(int **)(puVar25 + 0x50) = iVar7 + 0xfff;
    *(undefined2 *)(puVar25 + 0x12) = 0xfc72;
    *(undefined2 *)(puVar25 + 0x1a) = 0xfcd0;
    *(undefined2 *)(puVar25 + 0x22) = 0xfd2e;
	
	// move to next position to draw
    *(short *)(puVar25 + 0x10) = *(short *)(puVar25 + 0x10) + 100;
    *(short *)(puVar25 + 0x18) = *(short *)(puVar25 + 0x18) + 100;
    *(short *)(puVar25 + 0x20) = *(short *)(puVar25 + 0x20) + 100;
    
	iVar6 = ((iVar6 + 0xfff) * *(int *)(puVar25 + 0x2c) >> 0xd) + 0x280;
	
	// for iVar13 = 0; iVar13 < 3; iVar3++
    do 
	{
	  // approximate trigonometry
      iVar7 = *(int *)(puVar20 + (uVar17 & 0x3ff) * 4);
	  
      if ((uVar17 & 0x400) == 0) {
        iVar7 = iVar7 << 0x10;
      }
      iVar7 = iVar7 >> 0x10;
      if ((uVar17 & 0x800) != 0) {
        iVar7 = -iVar7;
      }
      *(short *)(iVar15 + 4) = (short)iVar6 + (short)((iVar7 + 0xfff) * 0x20 >> 0xd);
      uVar17 = uVar17 + 300;
	  
	  // increment loop counter
      iVar13 = iVar13 + 1;
	  
      iVar15 = iVar15 + 8;
    } while (iVar13 < 3);
    
	gte_ldv3(*(SVECTOR **)(puVar25 + 0x5c),(SVECTOR *)(puVar25 + 0x18),(SVECTOR *)(puVar25 + 0x20));
    gte_rtpt();
	
    iVar13 = 0;
    iVar7 = 1;
	
	// horizontal strips
    do 
	{
      if (iVar7 < 0xb) 
	  {
        
		gte_stsxy3((long *)(puVar19 + 1),(long *)(puVar19 + 2),(long *)(puVar19 + 3));
        
		iVar15 = 0;
        
		if (iVar7 < 10) {
          iVar10 = *(int *)(puVar25 + 0x5c);
		  
		  // for iVar15 = 0; iVar15 < 3; iVar15++
          do 
		  {
			// approximate trigonometry
            iVar8 = *(int *)(puVar20 + (uVar17 & 0x3ff) * 4);
			
            if ((uVar17 & 0x400) == 0) {
              iVar8 = iVar8 << 0x10;
            }
            iVar8 = iVar8 >> 0x10;
            if ((uVar17 & 0x800) != 0) {
              iVar8 = -iVar8;
            }
            *(short *)(iVar10 + 4) = (short)iVar6 + (short)((iVar8 + 0xfff) * 0x20 >> 0xd);
            uVar17 = uVar17 + 300;
			
			// increment loop counter
            iVar15 = iVar15 + 1;
			
            iVar10 = iVar10 + 8;
          } while (iVar15 < 3);
          
		  *(short *)(puVar25 + 0x12) = *(short *)(puVar25 + 0x12) + 0x11a;
          *(short *)(puVar25 + 0x22) = *(short *)(puVar25 + 0x22) + 0x11a;
          *(short *)(puVar25 + 0x1a) = *(short *)(puVar25 + 0x1a) + 0x11a;
          gte_ldv3(*(SVECTOR **)(puVar25 + 0x5c),(SVECTOR *)(puVar25 + 0x18),
                   (SVECTOR *)(puVar25 + 0x20));
          gte_rtpt();
        }
      }
      if (iVar13 == 0) {
        puVar19 = puVar19 + 1;
      }
      uVar16 = (uint)(iVar13 == 0);
	  
	  // color of black tile
      *(int *)(puVar25 + 0x58) = iVar22 * 0x69 + (0x2000 - iVar22) * 0xa0 >> 0xd;
      
	  // loop 3 times
	  do 
	  {
        if (((*puVar21 & puVar21[1] & uVar14 & uVar14 & *puVar19 & uVar14 & puVar19[1]) == 0) &&
           ((iVar26 - *puVar21 & iVar26 - puVar21[1] & uVar14 & uVar14 & iVar26 - *puVar19 & uVar14
            & iVar26 - puVar19[1]) == 0)) 
		{
		  // gGT->backBuffer
          iVar15 = *(int *)(PTR_DAT_8008d2ac + 0x10);
		  
		  // gGT->backBuffer.primMem.curr
          puVar11 = *(uint **)(iVar15 + 0x80);
		  
		  // if room is remaining
          if (puVar11 <= *(uint **)(iVar15 + 0x84)) 
		  {
			// POLY_G4 ???
			// increment primMem.curr by 0x24 bytes
            *(uint **)(iVar15 + 0x80) = puVar11 + 9;
            puVar18 = puVar11;
          }
          if (puVar18 == (uint *)0x0) {
            return;
          }
          
		  // white tile
		  if (((iVar5 >> 2) + (iVar13 >> 2) & 1U) == 0) 
		  {
			// RGB 1 and 3
            puVar25[0x40] = (char)(iVar22 * 0x82 + (0x2000 - iVar22) * 0xff >> 0xd);
			
			// RGB 0 and 2
            uVar4 = (undefined)(*(int *)(puVar25 + 0x48) * -0x7d + 0x1fe000 >> 0xd);
          }
		  
		  // black tile
          else 
		  {
			// RGB 1 and 3
            uVar4 = (undefined)(*(int *)(puVar25 + 0x48) * -0x37 + 0x140000 >> 0xd);
			
			// RGB 0 and 2
			// color black = iVar22 * 0x69 + (0x2000 - iVar22) * 0xa0 >> 0xd;
            puVar25[0x40] = puVar25[0x58];
          }
		  
		  // RGB 0 and 2
          puVar25[0x41] = uVar4;
		  
		  // x0, y0
          puVar18[2] = *puVar21;
          
		  // x2, y2
		  puVar18[6] = puVar21[1];
		  
		  // x1, y1
          puVar18[4] = *puVar19;
		  
		  // x3, y3
          puVar18[8] = puVar19[1];
		  
		  // rgb0 and rgb2
          uVar12 = (uint)(byte)puVar25[0x40];
          uVar12 = uVar12 | uVar12 << 0x10 | uVar12 << 8;
          puVar18[1] = uVar12;
          puVar18[5] = uVar12;
		  
		  // rgb1 and rgb3
          uVar12 = (uint)(byte)puVar25[0x41];
          
		  // part of tag?
		  *(undefined *)((int)puVar18 + 3) = 8;
		  
		  // primID
          *(undefined *)((int)puVar18 + 7) = 0x38;
		  
		  // rgb1 and rgb3
          uVar12 = uVar12 | uVar12 << 0x10 | uVar12 << 8;
          puVar18[3] = uVar12;
		  puVar18[7] = uVar12;
		  
		  // tag
          *puVar18 = *puVar18 & 0xff000000 | *puVar3 & 0xffffff;
          *puVar3 = *puVar3 & 0xff000000 | (uint)puVar18 & 0xffffff;
        }
        puVar21 = puVar21 + 1;
        puVar19 = puVar19 + 1;
        uVar16 = uVar16 + 1;
        iVar13 = iVar13 + 1;
      } while ((int)uVar16 < 3);
	  
	  // count horizontal strips,
	  // stop at 10
      bVar1 = iVar7 < 10;
      iVar7 = iVar7 + 1;
	  
    } while (bVar1);
    
	iVar22 = *(int *)(puVar25 + 0x48);
	
	// count vertical strips
    iVar5 = iVar5 + 1;
    
	// stop vertical strips at 0x23 (35)
	if (0x22 < iVar5) 
	{	
		// 8008d458
		// some kind of elapsed time in CheckeredFlag
      *(int *)(puVar24 + 0x4ec) =
           *(int *)(puVar24 + 0x4ec) + *(int *)(PTR_DAT_8008d2ac + 0x1d04) * 100;
      return;
    }
	
  } while( true );
}


// DecalHUD_DrawPolyGT4_Safe
void FUN_80044ef8(int param_1)

{
  // safety check for nullptr
  if (param_1 != 0)
  {
	// DecalHUD_DrawPolyGT4
    FUN_80023054();
  }

  return;
}


// DrawRectangle
void FUN_80044f90(undefined4 param_1,undefined4 param_2,uint param_3,undefined4 param_4)
{
  if ((param_3 & 0x20) == 0)
  {
	// solid border

	// CTR_Box_DrawSolidBox
    FUN_80021894(
					param_1,
					param_2,
					param_4,

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);
  }
  else
  {
	// transparent border

	// CTR_Box_DrawClearBox
    FUN_8002177c(
					param_1,
					param_2,
					1,
					param_4,

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);
  }
  return;
}


// Make time string
undefined * FUN_80044ff8(int param_1)

{
  // param_1 keeps track of time in milliseconds

  // Here's how it works:
  // 32 is added to param_1 every frame,
  // 30 fps, so param_1 gets 960 added every second,
  // 60 seconds per minute, so param_1 gets 57600
  // added per minute, which is 0xe100 in hex

  // 32 is the number of milliseconds passed since
  // last frame, which is calculated here:
  // PTR_DAT_8008d2ac + 0x1d04

  // build a string
  sprintf(

		// where string will be stored
		&DAT_80099264,

		// Format
	    // Minute:Seconds:Milliseconds
		"%ld:%ld%ld:%ld%ld",

		// minutes
		param_1 / 0xe100,

		// seconds / 10
        param_1 / 0x2580 + (param_1 / 0xe100) * -6,

		// seconds
		param_1 / 0x3c0 + (param_1 / 0x2580) * -10,

		// milliseconds / 10
        ((param_1 / 6 + (param_1 >> 0x1f) >> 4) - (param_1 >> 0x1f)) + (param_1 / 0x3c0) * -10,

		// milliseconds
        ((param_1 * 100) / 0x3c0) % 10);

  // return the string
  return &DAT_80099264;
}


// BackgroundBlueRect_Subset
void FUN_80045134(uint *param_1,uint *param_2,uint *param_3,int param_4)

{
  uint *puVar1;
  uint *puVar2;

  puVar1 = *(uint **)(param_4 + 0xc);
  puVar2 = (uint *)0x0;
  if (puVar1 <= *(uint **)(param_4 + 0x10)) {
    *(uint **)(param_4 + 0xc) = puVar1 + 9;
    puVar2 = puVar1;
  }
  if (puVar2 != (uint *)0x0) {
    puVar2[1] = *param_2 & 0xffffff | 0x38000000;
    puVar2[3] = param_2[1] & 0xffffff;
    puVar2[5] = param_2[2] & 0xffffff;
    puVar2[7] = param_2[3] & 0xffffff;
    puVar2[2] = *param_1;
    puVar2[4] = (int)(short)*(ushort *)param_1 + (int)(short)*(ushort *)(param_1 + 1) & 0xffffU |
                (int)(short)*(ushort *)((int)param_1 + 2) << 0x10;
    puVar2[6] = (uint)*(ushort *)param_1 |
                ((int)(short)*(ushort *)((int)param_1 + 2) +
                (int)(short)*(ushort *)((int)param_1 + 6)) * 0x10000;
    puVar2[8] = (int)(short)*(ushort *)param_1 + (int)(short)*(ushort *)(param_1 + 1) & 0xffffU |
                ((int)(short)*(ushort *)((int)param_1 + 2) +
                (int)(short)*(ushort *)((int)param_1 + 6)) * 0x10000;
    *puVar2 = *param_3 & 0xffffff | 0x8000000;
    *param_3 = (uint)puVar2 & 0xffffff;
  }
  return;
}


// BackgroundBlueRect
// RaceWheelConfig + ArcadeDriverSelect
void FUN_80045254(undefined2 *param_1,int param_2,undefined4 param_3,undefined4 param_4)

{
  int iVar1;
  undefined4 *puVar2;
  int iVar3;
  undefined2 local_38;
  short local_36;
  undefined2 local_34;
  short local_32;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;

  local_38 = *param_1;
  local_34 = param_1[2];
  iVar3 = 0;
  if (*(char *)(param_2 + 3) != 'd') {
    iVar1 = 0;
    do {
      puVar2 = (undefined4 *)((iVar1 >> 0xe) + param_2);
      local_30 = *puVar2;
      local_28 = puVar2[1];
      local_36 = param_1[1] +
                 (short)((int)((uint)*(byte *)((int)puVar2 + 3) * (int)(short)param_1[3]) / 100);
      local_32 = ((param_1[1] +
                  (short)((int)((uint)*(byte *)((int)puVar2 + 7) * (int)(short)param_1[3]) / 100)) -
                 local_36) + 1;
      local_2c = local_30;
      local_24 = local_28;

	  // BackgroundBlueRect_Subset
      FUN_80045134(&local_38,&local_30,param_3,param_4);

      iVar3 = iVar3 + 1;
      iVar1 = iVar3 * 0x10000;
    } while (*(char *)((iVar3 * 0x10000 >> 0xe) + param_2 + 3) != 'd');
  }
  return;
}


// DrawTriangle
// (square gorard icon, not actual triangle)
void FUN_800453e8(undefined2 *param_1,undefined *param_2,void *param_3,int param_4)

{
  void *p;
  void *pvVar1;

  pvVar1 = *(void **)(param_4 + 0xc);
  p = (void *)0x0;
  if (pvVar1 <= *(void **)(param_4 + 0x10)) {
    *(int *)(param_4 + 0xc) = (int)pvVar1 + 0x24;
    p = pvVar1;
  }
  if (p != (void *)0x0) {
    
	// psyq macro setPolyG4
	*(undefined *)((int)p + 3) = 8;
    *(undefined *)((int)p + 7) = 0x38;
	
	// RGB
    *(undefined *)((int)p + 4) = *param_2;
    *(undefined *)((int)p + 5) = param_2[1];
    *(undefined *)((int)p + 6) = param_2[2];
	
	// rest of the primitive (four xy, four uv)
    *(undefined *)((int)p + 0xc) = param_2[4];
    *(undefined *)((int)p + 0xd) = param_2[5];
    *(undefined *)((int)p + 0xe) = param_2[6];
    *(undefined *)((int)p + 0x14) = *param_2;
    *(undefined *)((int)p + 0x15) = param_2[1];
    *(undefined *)((int)p + 0x16) = param_2[2];
    *(undefined *)((int)p + 0x1c) = param_2[8];
    *(undefined *)((int)p + 0x1d) = param_2[9];
    *(undefined *)((int)p + 0x1e) = param_2[10];
    *(undefined2 *)((int)p + 8) = *param_1;
    *(short *)((int)p + 10) = param_1[1] + -1;
    *(undefined2 *)((int)p + 0x10) = param_1[2];
    *(undefined2 *)((int)p + 0x12) = param_1[3];
    *(undefined2 *)((int)p + 0x18) = *param_1;
    *(undefined2 *)((int)p + 0x1a) = param_1[1];
    *(undefined2 *)((int)p + 0x20) = param_1[4];
    *(undefined2 *)((int)p + 0x22) = param_1[5];
	
    AddPrim(param_3,p);
  }
  return;
}


// Draw a 2D box made of four rectangles
// param1 is a pointer RECT
// param2 is x offset from edge
// param3 is y offset from edge
// DrawBoxOutline_LowLevel
void FUN_80045534(short *param_1,short param_2,ushort param_3,undefined4 param_4,short param_5,
                 undefined4 param_6)

{
  int iVar1;
  short local_28;
  short local_26;
  short local_24;
  ushort local_22;

  // startX
  local_28 = *param_1;

  iVar1 = (int)param_5;

  // startY
  local_26 = param_1[1];

  // sizeX
  local_24 = param_1[2];

  // y offset from edge
  local_22 = param_3;

  // Draw rectangle 1
  // DrawRectangle
  FUN_80044f90(&local_28,param_4,iVar1,param_6);

  // 					sizeY - y offset from edge
  local_26 = local_26 + (param_1[3] - param_3);

  // Draw rectangle 2
  // DrawRectangle
  FUN_80044f90(&local_28,param_4,iVar1,param_6);

  // startY + y offset from edge
  local_26 = param_1[1] + param_3;

  local_22 = param_1[3] - (short)((int)((uint)param_3 << 0x10) >> 0xf);

  // x offset from edge
  local_24 = param_2;

  // Draw rectangle 3
  // DrawRectangle
  FUN_80044f90(&local_28,param_4,iVar1,param_6);

  //					sizeX - x offset frome edge
  local_28 = local_28 + (param_1[2] - param_2);

  // Draw rectangle 4
  // DrawRectangle
  FUN_80044f90(&local_28,param_4,iVar1,param_6);
  return;
}


// Draw a 2D box made of four rectangles
// DrawBoxOutline_HighLevel
// for colored boxes in battle mode
void FUN_80045650(undefined4 param_1,undefined4 param_2,short param_3,undefined4 param_4)

{
  // Draw a 2D box made of four rectangles
  // DrawBoxOutline_LowLevel
  FUN_80045534(param_1,3,2,param_2,(int)param_3,param_4);
  return;
}


// Only used for drawing player comments
void FUN_8004568c(undefined4 param_1,short param_2,int param_3,uint param_4,short param_5,
                 short param_6,short param_7)

{
  int iVar1;
  short local_28;
  undefined2 local_26;
  undefined2 local_24;
  undefined2 local_22;

  if ((param_4 & 0xffff) == 0)
  {
	// DecalFont_GetLineWidth
    iVar1 = FUN_800224d0(param_1,(int)param_5);
    param_4 = iVar1 + 0xc;
  }

  // posX
  local_28 = param_2;

  // if text is not centered
  if (((int)param_6 & 0x8000U) != 0)
  {
	// posX with text un-centered
    local_28 = param_2 - (short)(((int)(param_4 << 0x10) >> 0x10) - ((int)(param_4 << 0x10) >> 0x1f)
                                >> 1);
  }

  iVar1 = (int)param_5 * 2;

  // sizeX
  local_24 = (undefined2)param_4;

  // posY
  local_26 = (undefined2)param_3;

  // sizeY
  local_22 = *(undefined2 *)(&DAT_80085af4 + iVar1);

  // Draw string
  FUN_80022878(param_1,(int)param_2,
               (int)((param_3 + (uint)*(ushort *)(&DAT_80085afc + iVar1)) * 0x10000) >> 0x10,
               (int)param_5,(int)param_6);

  // Draw 2D Menu rectangle background
  FUN_800457b0(&local_28,(int)param_7,*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0));
  return;
}



// WARNING: Could not reconcile some variable overlaps

// Draw 2D Menu rectangle background
// param1 is a pointer to RECT (x,y,w,h)
// param2 is type of camera110
	// 0: transparent, like main menu
	// 1: Black, like "controller unplugged"
void FUN_800457b0(undefined4 *param_1,ushort param_2,undefined4 param_3)

{
  undefined4 *puVar1;
  undefined *puVar2;
  undefined4 uVar3;
  short sVar4;
  short sVar5;
  undefined4 local_20;
  undefined4 local_1c;

  puVar1 = &DAT_8008d438;
  if ((param_2 & 0x10) != 0) {
    puVar1 = (undefined4 *)&DAT_8008d43c;
  }

  if ((param_2 & 2) == 0)
  {
	// DrawBoxOutline_HighLevel (transparent)
    FUN_80045650(param_1,puVar1,(int)(short)(param_2 | 0x20),param_3);
  }

  if ((param_2 & 8) == 0) {
    local_20 = *param_1;
    local_1c = param_1[1];
    if ((param_2 & 2) == 0) {
      local_20._2_2_ = (short)((uint)local_20 >> 0x10);
      local_20 = CONCAT22(local_20._2_2_ + 2,(short)local_20 + 3);
      local_1c._2_2_ = (short)((uint)local_1c >> 0x10);
      local_1c = CONCAT22(local_1c._2_2_ + -4,(short)local_1c + -6);
    }
    if ((param_2 & 1) == 0) {
      uVar3 = 2;
      if ((param_2 & 0x100) == 0) {
        puVar2 = &DAT_8008d468;
        uVar3 = 0;
      }
      else {
        puVar2 = &DAT_8008d464;
      }

	  // CTR_Box_DrawClearBox
      FUN_8002177c(
					&local_20,
					puVar2,
					uVar3,
					param_3,

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);
    }
    else
	{
	  // draw a rectangle
	  // CTR_Box_DrawSolidBox
      FUN_80021894(
					&local_20,
					&DAT_8008d460,
					param_3,

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);
    }
  }
  if ((param_2 & 4) == 0) {
    sVar4 = 0xc;
    if ((param_2 & 0x80) != 0) {
      sVar4 = 4;
    }
    sVar5 = 6;
    if ((param_2 & 0x40) != 0) {
      sVar5 = 2;
    }
    local_20 = CONCAT22(*(short *)((int)param_1 + 2) + sVar5,
                        *(short *)param_1 + *(short *)(param_1 + 1));
    local_1c = CONCAT22(*(short *)((int)param_1 + 6),sVar4);

	// CTR_Box_DrawClearBox
    FUN_8002177c(
					&local_20,
					&DAT_8008d460,
					0,
					param_3,

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

	local_20 = CONCAT22(*(short *)((int)param_1 + 2) + *(short *)((int)param_1 + 6),
                        *(short *)param_1 + sVar4);

    local_1c = CONCAT22(sVar5,*(short *)(param_1 + 1) - sVar4);

	// CTR_Box_DrawClearBox
    FUN_8002177c(
					&local_20,
					&DAT_8008d460,
					0,
					param_3,

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);
  }
  return;
}


// Draw MenuBox background
void FUN_800459ec(short *param_1,short *param_2)

{
  undefined4 *puVar1;
  short local_18;
  short local_16;
  short local_14;
  undefined2 local_12;

  if (
		// if title text exists
		(-1 < *param_1) &&

		((*(uint *)(param_1 + 4) & 4) == 0)
	 )
  {
    puVar1 = &DAT_8008d438;
    if ((param_1[10] & 0x10U) != 0) {
      puVar1 = (undefined4 *)&DAT_8008d43c;
    }
    local_18 = *param_2 + 3;
    local_16 = param_2[1] + 6;
    if ((*(uint *)(param_1 + 4) & 0x80) == 0) {
      local_16 = param_2[1] + 9 + DAT_8008236a;
    }
    else {
      if ((*(uint *)(param_1 + 4) & 0x4000) == 0)
	  {
		// pixel-height of title menu rows
        local_16 = local_16 + DAT_8008236c;
      }
      else
	  {
		// pixel-height of non-title menu rows
        local_16 = local_16 + DAT_8008236a;
      }
    }
    local_12 = 2;
    local_14 = param_2[2] + -6;

	// DrawRectangle (transparent)
    FUN_80044f90(&local_18,puVar1,(int)(short)(param_1[10] | 0x20),
                 *(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0));
  }

  // Draw 2D Menu rectangle background
  FUN_800457b0(param_2,(int)param_1[10],*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0));
  return;
}


// Get MenuBox Height
// param_1 MenuBox
// param_2 return value
// param_3 bool check submenus
void FUN_80045b1c(short *param_1,short *param_2,short param_3)

{
  short sVar1;
  short sVar2;
  short *psVar3;

  // height of small text
  sVar1 = DAT_8008236c;

  // if tiny text is disabled
  if ((*(uint *)(param_1 + 4) & 0x80) == 0)
  {
	// height of large text
    sVar1 = DAT_8008236a + 3;
  }

  if ((*(uint *)(param_1 + 4) & 0x40) == 0) {
    if ((*(uint *)(param_1 + 4) & 4) == 0) {

	  // MenuRow array
	  psVar3 = *(short **)(param_1 + 6);

	  // deref to get string
	  sVar2 = *psVar3;

	  // loop through all valid rows
	  while (sVar2 != -1)
	  {
		// go to next row
        psVar3 = psVar3 + 3;

		// increment menubox height by row height
        *param_2 = *param_2 + sVar1;

		// get next string
		sVar2 = *psVar3;
      }
      goto LAB_80045bd0;
    }
    sVar2 = *param_2 + -6;
  }
  else {
    sVar2 = *param_2;
  }
  *param_2 = sVar1 + sVar2;

LAB_80045bd0:

  // if title text exists
  if (-1 < *param_1)
  {
    if ((*(uint *)(param_1 + 4) & 0x4000) == 0) {
      sVar2 = *param_2 + 6;
    }
    else {
      sVar1 = *param_2 + 9;
      sVar2 = DAT_8008236a;
    }

	// increment menubox height by text height
    *param_2 = sVar2 + sVar1;
  }

  if (
		// if submenu should be checked
		(param_3 != 0) &&

		// if submenu will be drawn
		((*(uint *)(param_1 + 4) & 0x10) != 0)
	 )
  {
	// recursively check height from submenus
    FUN_80045b1c(*(undefined4 *)(param_1 + 0x12),param_2,1);
  }
  return;
}

// get width of menubox
// param_1 MenuBox
// param_2 return value
// param_3 bool check submenus
void FUN_80045c50(short *param_1,short *param_2,short param_3)

{
  ushort uVar1;
  int iVar2;
  undefined4 uVar3;
  ushort *puVar4;
  undefined4 uVar5;

  // if large text
  uVar5 = 1;

  // if menu should have tiny text
  if ((*(uint *)(param_1 + 4) & 0x80) != 0) {
    uVar5 = 2;
  }

  // Menu Rows
  puVar4 = *(ushort **)(param_1 + 6);

  // deref row, to get string index
  uVar1 = *puVar4;

  // if string is valid
  if (*puVar4 != 0xffff)
  {
	// loop through all rows
    do
	{
	  // DecalFont_GetLineWidth
      iVar2 = FUN_800224d0(*(undefined4 *)(((uint)uVar1 & 0x7fff) * 4 + DAT_8008d878),
                           (int)(short)uVar5);

	  // if menuBox width is less than width of this string
	  if ((int)*param_2 < (iVar2 + 1) * 0x10000 >> 0x10)
	  {
		// set new width of menuBox
        *param_2 = (short)(iVar2 + 1);
      }

	  // next row
	  puVar4 = puVar4 + 3;

	  // next string
	  uVar1 = *puVar4;

    } while (*puVar4 != 0xffff);
  }

  // if MenuBox title has a string
  if (-1 < (int)*param_1)
  {
    uVar3 = 1;
    if ((*(uint *)(param_1 + 4) & 0x4000) == 0) {
      uVar3 = uVar5;
    }

	// DecalFont_GetLineWidth
    iVar2 = FUN_800224d0(*(undefined4 *)((int)*param_1 * 4 + DAT_8008d878),uVar3);

	// if menuBox width is less than width of this string
	if ((int)*param_2 < (iVar2 + 1) * 0x10000 >> 0x10)
	{
	  // set new width of menuBox
      *param_2 = (short)(iVar2 + 1);
    }
  }

  if (
		// if submenus should be checked
		(param_3 != 0) &&

		// if submenu will be drawn
		((*(uint *)(param_1 + 4) & 0x10) != 0))
  {
	// recursively check submenus for width
    FUN_80045c50(*(undefined4 *)(param_1 + 0x12),param_2,1);
  }
  return;
}


// draw entire menubox
// param_1 - ptrMenuBox
// param_4 - menuBox width
void FUN_80045db0(short *param_1,int param_2,short param_3,ushort param_4)

{
  ushort uVar1;
  uint uVar2;
  int iVar3;
  undefined4 uVar4;
  int iVar5;
  undefined4 *puVar6;
  short sVar7;
  ushort uVar8;
  short sVar9;
  ushort *puVar10;
  short sVar11;
  short sVar12;
  ushort uVar13;
  uint local_78;
  short local_70;
  short local_6e;
  ushort local_6c;
  short local_6a;
  short local_68;
  short local_66;
  short local_64;
  short local_62;
  short local_60;
  short local_5e [3];
  short local_58;
  short local_50;
  short local_48;
  short local_40;
  short local_38;
  int local_30;
  int local_2c;

  // default text color (orange)
  local_78 = 0;

  local_40 = 0;
  local_38 = 0;

  // if MenuBox should be drawn green
  // for save/load screen
  if ((param_1[10] & 0x10U) != 0)
  {
	// make text color green
    local_78 = 0x1d;
  }
  uVar13 = (ushort)local_78;
  local_58 = param_3;

  // setting flag 0x60000 disables input in pause menu,
  // so how does this "if" make sense?
  if ((*(uint *)(param_1 + 4) & 0x60000) == 0x60000)
  {
    param_1[0xf] = 2;

	// short "+8" is really + 0x10,
	// if funcPtr exists, execute it
	if (*(code **)(param_1 + 8) != (code *)0x0) {
      (**(code **)(param_1 + 8))(param_1);
    }
  }
  sVar11 = 2;

  // if large text in rows
  if ((*(uint *)(param_1 + 4) & 0x80) == 0) {
    sVar11 = 1;
    local_50 = 2;

	// row height + 3
    local_62 = DAT_8008236a + 3;
  }

  // & 80 == 1
  // if tiny text in rows
  else {
    local_50 = 0;

	// row height
    local_62 = DAT_8008236c;

	// if tiny text in title
    if ((*(uint *)(param_1 + 4) & 0x4000) == 0) {

	  // row height
	  local_48 = DAT_8008236c;

      goto LAB_80045e94;
    }
  }

  // if large text in title
  // row height + 3
  local_48 = DAT_8008236a + 3;

LAB_80045e94:
  local_60 = 0;
  param_1[0xb] = param_1[1];
  param_1[0xc] = param_1[2];

  // get height of menubox
  FUN_80045b1c(param_1,&local_60,0);

  uVar2 = *(uint *)(param_1 + 4);

  // set menuBox width
  param_1[0x10] = param_4;

  *(uint *)(param_1 + 4) = uVar2 & 0xfffffff7;

  // set menuBox height
  param_1[0x11] = local_60;

  if ((uVar2 & 2) != 0) {
    local_5e[0] = 0;
    FUN_80045b1c(param_1,local_5e,1);
    local_38 = (short)((uint)(-(int)local_5e[0] - (-(int)local_5e[0] >> 0x1f)) >> 1);
  }
  uVar2 = *(uint *)(param_1 + 4);
  if ((uVar2 & 1) != 0) {
    local_40 = (short)((uint)(-(int)(short)param_4 - (-(int)(short)param_4 >> 0x1f)) >> 1);
  }
  sVar12 = 0;

  // short +6 is really +C,
  // MenuRow array, deref to get string index
  puVar10 = *(ushort **)(param_1 + 6);

  // dereference short, then cast short to int,
  // get string index of the MenuBox title
  iVar3 = (int)*param_1;

  sVar9 = local_50 + local_38 + local_58 + param_1[0xc];

  if (
		// if title is not 0xFFFF
		(-1 < iVar3) &&

		((uVar2 & 4) == 0)
	 )
  {
    sVar7 = 1;
    if ((uVar2 & 0x4000) == 0) {
      sVar7 = sVar11;
    }
    if ((uVar2 & 0x200) == 0) {
      iVar5 = param_2 + (uint)(ushort)param_1[0xb];
      uVar8 = uVar13;
      if ((uVar2 & 1) != 0) {
        uVar8 = uVar13 | 0x8000;
      }
      local_78 = SEXT24((short)uVar8);

	  // get string from LNG
      uVar4 = *(undefined4 *)(iVar3 * 4 + DAT_8008d878);
    }
    else
	{
      local_78 = local_78 | 0xffff8000;

	  // get string from LNG
      uVar4 = *(undefined4 *)(iVar3 * 4 + DAT_8008d878);

	  iVar5 = param_2 + (uint)(ushort)param_1[0xb] +
              (((int)((uint)param_4 << 0x10) >> 0x10) - ((int)((uint)param_4 << 0x10) >> 0x1f) >> 1)
      ;
    }

	// draw title string
    FUN_80022878(uVar4,iVar5 * 0x10000 >> 0x10,(int)sVar9,(int)sVar7,local_78);

	sVar9 = local_48 + sVar9 + 6;
  }

  // if row string is not 0xFFFF
  if (*puVar10 != 0xffff)
  {
    local_30 = (((int)((uint)param_4 << 0x10) >> 0x10) - ((int)((uint)param_4 << 0x10) >> 0x1f) >> 1
               ) + 1;
    local_2c = (int)sVar11;

	// loop through all menu rows
	do
	{
      local_78 = *(uint *)(param_1 + 4);

	  if (
			// flags are disabled
			((local_78 & 0x44) == 0) ||

			// if this row is the highlighted row
			(sVar12 == param_1[0xd])
		 )
	  {
		// dereference row to get string
        uVar8 = *puVar10;

		// color of "locked" text (gray)
        uVar1 = 0x17;

		// if row is not "locked"
		if ((uVar8 & 0x8000) == 0)
		{
		  // change color to unlocked
          uVar1 = uVar13;
        }

		// if string is valid
		if ((uVar8 & 0x7fff) != 0)
		{

		  if ((local_78 & 0x200) == 0)
		  {
            iVar3 = param_2 + (uint)(ushort)param_1[0xb] + 1;

			if ((local_78 & 1) != 0)
			{
			  // center text
              uVar1 = uVar1 | 0x8000;
            }

			// get pointer to string, from index
            uVar4 = *(undefined4 *)(((uint)uVar8 & 0x7fff) * 4 + DAT_8008d878);

			iVar5 = local_2c;
          }
          else
		  {
			// center text
            uVar1 = uVar1 | 0x8000;

            iVar3 = param_2 + (uint)(ushort)param_1[0xb] + local_30;

			// get pointer to string, from index
			uVar4 = *(undefined4 *)(((uint)uVar8 & 0x7fff) * 4 + DAT_8008d878);

            iVar5 = (int)sVar11;
          }

		  // Draw string
          FUN_80022878(uVar4,iVar3 * 0x10000 >> 0x10,(int)sVar9,iVar5,(int)(short)uVar1);
        }
        sVar9 = sVar9 + local_62;
      }

	  // skip 6 bytes to next row
      puVar10 = puVar10 + 3;

	  // keep count of row
      sVar12 = sVar12 + 1;

	// as long as another row is valid
	} while (*puVar10 != 0xffff);
  }

  if ((*(uint *)(param_1 + 4) & 0x104) == 0) {
    local_70 = local_40 + (short)param_2 + param_1[0xb];
    local_6e = local_58 + param_1[0xc] + local_38;
    if ((*(uint *)(param_1 + 4) & 0x40) == 0) {
      local_6e = local_6e + param_1[0xd] * local_62 + local_50 + -1;
    }
    else {
      local_6e = local_6e + local_50 + -1;
    }
    if ((*(uint *)(param_1 + 4) & 0x80) == 0) {
      local_6a = -3;
    }
    else {
      local_6a = 1;
    }
    local_6a = local_62 + local_6a;
    if (-1 < *param_1) {
      local_6e = local_48 + local_6e + 6;
    }

	// if normal,
	// draw menu row highlight
	puVar6 = &DAT_8008d94c;

	// if draw green save/load
    if ((param_1[10] & 0x10U) != 0)
	{
	  // draw green menu row highlight
      puVar6 = &DAT_8008d948;
    }

    local_6c = param_4;

	// CTR_Box_DrawClearBox
    FUN_8002177c(&local_70,puVar6,1,

					*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0),

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);
  }

  // if a submenu is being drawn in a hierarchy structure
  if ((*(uint *)(param_1 + 4) & 0x10) != 0)
  {
	// recursively call this function,
	// draw the next menu within this menu
    FUN_80045db0(
				 // offset 0x24, pointer to next menu
				 *(undefined4 *)(param_1 + 0x12),

                 (int)((param_2 + (uint)(ushort)param_1[0xb]) * 0x10000) >> 0x10,
                 (int)(short)(local_38 + local_58 + param_1[0xc] + local_62 + 0xc),

				 // same width in parent and child
                 (int)(short)param_4);
  }
  if ((*(uint *)(param_1 + 4) & 4) == 0) {
    sVar11 = param_1[0xb];
    sVar9 = param_1[0xc];
    local_62 = (local_60 + 8) - (ushort)(*(byte *)(param_1 + 4) >> 7);
  }
  else {
    sVar11 = param_1[0xb];
    sVar9 = param_1[0xc];
    local_62 = local_62 + 8;
  }
  local_64 = param_4 + 0xc;
  local_66 = local_38 + local_58 + sVar9 + -4;
  local_68 = local_40 + (short)param_2 + sVar11 + -6;

  // draw background of menubox
  FUN_800459ec(param_1,&local_68);
  return;
}


// MenuBox_ClearInput
void FUN_80046404(void)

{
  int iVar1;
  int iVar2;

  iVar2 = 0;

  // Reset button input
  DAT_8008d950 = 0;
  DAT_8008d974 = 0;

  // for iVar2 = 0; iVar2 < 4; iVar2++
  do
  {
    iVar1 = iVar2 << 0x10;

	// increment loop counter
	iVar2 = iVar2 + 1;

	iVar1 = iVar1 >> 0xe;

	// clear all controller input for all players
    *(undefined4 *)((int)&DAT_8009a990 + iVar1) = 0;
    *(undefined4 *)((int)&DAT_8009a964 + iVar1) = 0;

  } while (iVar2 * 0x10000 >> 0x10 < 4);

  return;
}


// MenuBox_CollectInput
void FUN_80046458(void)

{
  undefined *puVar1;
  uint uVar2;
  int iVar3;
  int iVar4;

  // pointer to controller input for all players
  puVar1 = PTR_DAT_8008d2b0;

  // Reset button input
  DAT_8008d950 = 0;
  DAT_8008d974 = 0;

  if ((DAT_8008d954 == 0) || (uVar2 = 4, (*(uint *)(DAT_8008d954 + 8) & 0x8000) == 0))
  {
	// uvar2 = number of players
    uVar2 = (uint)(byte)PTR_DAT_8008d2ac[0x1ca9];
  }

  // loop counter
  iVar4 = 0;

  // if number of players is not zero
  if (uVar2 != 0)
  {
    iVar3 = 0;

	// for iVar4 = 0; iVar4 < numPlayers; iVar4++
	do
	{
	  // increment pointer counter
      iVar4 = iVar4 + 1;
      iVar3 = iVar3 >> 0x10;

	  // save input each controller into variables that can be re-used

	  // Detect buttons "tapped" which only show on the first frame they are pressed
      (&DAT_8009a990)[iVar3] = *(uint *)(puVar1 + iVar3 * 0x50 + 0x14);

	  // Detect buttons "held" which show from when they are pressed, until released
      (&DAT_8009a964)[iVar3] = *(uint *)(puVar1 + iVar3 * 0x50 + 0x10);

	  // Set button input for menus. This combines input from multiple players,
	  // and is used in menus. That's why all 4 players can fight in menus

	  // Tapped buttons from any player
      DAT_8008d950 = DAT_8008d950 | (&DAT_8009a990)[iVar3];

	  // Held buttons from any player
      DAT_8008d974 = DAT_8008d974 | (&DAT_8009a964)[iVar3];

	  // distance between each player's button managment addresses
	  iVar3 = iVar4 * 0x10000;

    } while (iVar4 * 0x10000 >> 0x10 < (int)uVar2);
  }
  return;
}


// MenuBox_ProcessInput
int FUN_80046534(int param_1)

{
  // When navigating main menu, the pointer in the value
  // of param_1 changes any time you press X or Triangle,
  // to change the submenu. DAT_8008d954 holds a copy

  // ptr + 0x1a: which row is highlighted
  // param_1 + 0x24: Pointer to next submenu (will be 0 at bottom sublevel)
  // param_1 + 0x28: Pointer to prev submenu (will be 0 at top of level of main menu)

  short sVar1;
  uint uVar2;
  ushort uVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  short sVar7;

  FUN_8006c684(&DAT_8008d668);
  sVar7 = 0;
  sVar1 = 0;

  if (((*(uint *)(param_1 + 8) & 4) == 0) && ((*(uint *)(param_1 + 8) & 0x60000) != 0x60000))
  {
	// save the row you are hovering over
    uVar3 = *(ushort *)(param_1 + 0x1a);

	// save it again
    uVar4 = (uint)uVar3;

	// At any time, the address (pointer + offset) that holds
	// the value of the row you are highlighting is
	// 8d954 + 0x1a

	// pointer to row selected
    iVar6 = *(int *)(param_1 + 0xc) + (int)*(short *)(param_1 + 0x1a) * 6;

    if (
			// If the submenu you're in has changed
			(DAT_8008d954 != param_1) &&

			(
				// save the current submenu address
				DAT_8008d954 = param_1,

				(*(uint *)(param_1 + 8) & 0x10000) == 0
			)
		)
	{
	  // clear controller input (for menus)
      FUN_80046404();
    }

	// Get button input
    uVar2 = DAT_8008d950;

    if ((*(uint *)(param_1 + 8) & 0x8000) == 0) {

		// controller input of P1
		uVar2 = DAT_8009a990;
    }

	// If you dont press L1 or R1
	if ((DAT_8009a964 & 0xc00) == 0) {
      sVar1 = sVar7;

	  // If you press D-Pad, Cross, Square, Triangle, Circle
      if ((uVar2 & 0x4007f) != 0)
	  {
		// If you dont press Up
        if ((uVar2 & 1) == 0)
		{
		  // If you dont press Down
          if ((uVar2 & 2) == 0)
		  {
			// If you dont press Left
            if ((uVar2 & 4) == 0)
			{
			  // if you press nothing,
			  // keep old row
              uVar5 = uVar4;

			  // If you press Right
			  if ((uVar2 & 8) != 0)
			  {
                uVar5 = (uint)*(byte *)(iVar6 + 5);
              }
            }

			// If you press Left
            else {
              uVar5 = (uint)*(byte *)(iVar6 + 4);
            }
          }

		  // If you press Down
          else {
            uVar5 = (uint)*(byte *)(iVar6 + 3);
          }
        }

		// If you press Up
        else {
          uVar5 = (uint)*(byte *)(iVar6 + 2);
        }

		// copy new row
        uVar3 = (ushort)uVar5;

        if (
				// if row has changed
				(uVar4 << 0x10 != uVar5 << 0x10) &&

				// if cursor moving sound is not muted
				((*(uint *)(param_1 + 8) & 0x800000) == 0)
			)
		{
		  // OtherFX_Play that moves cursor
          FUN_80028468(0,1);
        }

		// If you dont press Cross or Circle
        if ((uVar2 & 0x50) == 0)
		{
          if ((
				(*(uint *)(param_1 + 8) & 0x100000) == 0) &&

				// If you press Triangle or Square
				((uVar2 & 0x40020) != 0)
			)
		  {
            if ((*(uint *)(param_1 + 8) & 0x800000) == 0)
			{
			  // OtherFX_Play for "go back"
              FUN_80028468(2,1);
            }
            sVar1 = -1;

			// you are not at the top level of main menu
            *(undefined2 *)(param_1 + 0x1e) = 0;

			// set the current selected row
            *(undefined2 *)(param_1 + 0x1a) = 0xffff;

			// if you have not reached the bottom of the submenu
            if (*(int *)(param_1 + 0x10) != 0)
			{
			  // clear controller input (for menus)
              FUN_80046404();

			  // call the function this menu has,
			  // pass itself as a parameter. Maybe
			  // this means "Draw itself"
              (**(code **)(param_1 + 0x10))(param_1);
            }

			// set the current selected row
            *(ushort *)(param_1 + 0x1a) = uVar3;
          }
        }

		// If you press Cross or Circle
		else
		{
		  // breakpoint at 800466c4, try to enter 4P menu,
		  // then set r2 to zero, resume, and you enter

		  // if you can enter this submenu

		  // menuBox->rows[menuBox->rowSelected] & LOCKED == false
          if (((int)*(short *)((int)*(short *)(param_1 + 0x1a) * 6 + *(int *)(param_1 + 0xc)) &
              0x8000U) == 0)
		  {
            if ((*(uint *)(param_1 + 8) & 0x800000) == 0)
			{
			  // OtherFX_Play for "enter"
              FUN_80028468(1,1);
            }

			// you are not on the top of the main menu
            *(undefined2 *)(param_1 + 0x1e) = 0;

			// set the current selected row
            *(ushort *)(param_1 + 0x1a) = uVar3;

            sVar1 = 1;

			// if you have not reached the bottom of the submenu
            if (*(int *)(param_1 + 0x10) != 0)
			{
			  // clear controller input (for menus)
              FUN_80046404();

			  // call the function this menu has,
			  // pass itself as a parameter. Maybe
			  // this means "Draw itself"
              (**(code **)(param_1 + 0x10))(param_1);
            }
          }

		  // if you cant enter this submenu,
		  // like 4P VS with 2 controllers
          else
		  {
            if ((*(uint *)(param_1 + 8) & 0x800000) == 0)
			{
			  // OtherFX_Play "womp" sound
              FUN_80028468(5,1);
            }
          }
        }

		// clear controller input (for menus)
        FUN_80046404();
      }

	  // set the current selected row
      *(ushort *)(param_1 + 0x1a) = uVar3;
    }
  }

  // if you are not at the bottom level of
  // the submenu, go to the next level
  if ((*(uint *)(param_1 + 8) & 0x10) != 0)
  {
	// param_1 + 0x24: Pointer to next submenu
	// param_1 + 0x28: Pointer to prev submenu

	// Store the address of the next submenu's previous submenu, to this submenu
    *(int *)(*(int *)(param_1 + 0x24) + 0x28) = param_1;

	// Call this function again, going to the next submenu
    sVar1 = FUN_80046534(*(undefined4 *)(param_1 + 0x24));
  }

  // If you've reached the end of the submenu, return
  return (int)sVar1;
}

// MenuBox_ProcessState
// birth, life, and death of MenuBox
void FUN_8004680c(void)

{
  code **ppcVar1;
  uint uVar2;
  int iVar3;
  short local_10 [4];

  // get ptrDesiredMenuBox
  iVar3 = DAT_8008d924;

  // This is a timer feature so that you
  // can give "amount of life" to a menu,
  // but this variable is never used so
  // it serves no purpose
  if (DAT_8008d90c != 0) {
    DAT_8008d90c = DAT_8008d90c + -1;
  }

  // if you want to change the MenuBox
  if (DAT_8008d924 != 0)
  {
    uVar2 = *(uint *)(DAT_8008d924 + 8);

	// change ActiveMenuBox to DesiredMenuBox
	DAT_8008d908 = DAT_8008d924;

	// erase DesiredMenuBox
    DAT_8008d924 = 0;

    *(uint *)(iVar3 + 8) = uVar2 & 0xffffefff;
    while ((uVar2 & 0x10) != 0) {
      iVar3 = *(int *)(iVar3 + 0x24);
      uVar2 = *(uint *)(iVar3 + 8);
    }
    *(uint *)(iVar3 + 8) = *(uint *)(iVar3 + 8) & 0xfffffffb;
  }


  if ((*(uint *)(DAT_8008d908 + 8) & 0x420) != 0) {

	// Get function pointer that MenuBox executes each frame
	ppcVar1 = (code **)(DAT_8008d908 + 0x10);

	// you are at the top level of main menu and can't go back
    *(undefined2 *)(DAT_8008d908 + 0x1e) = 1;

	// execute MenuBox function
    (**ppcVar1)();
  }

  if ((*(uint *)(DAT_8008d908 + 8) & 0x20) == 0)
  {
	// Navigate main menu
    FUN_80046534();

    if ((*(uint *)(DAT_8008d908 + 8) & 0x2000) == 0)
	{
	  // set width to zero
      local_10[0] = 0;

	  // get width of menubox
	  FUN_80045c50(DAT_8008d908,local_10,1);

	  // draw menubox
      FUN_80045db0(DAT_8008d908,0,0,(int)local_10[0]);
    }
  }

  // If you aren't drawing the menu with tiny text
  if ((*(uint *)(DAT_8008d908 + 8) & 0x800) == 0)
  {
    iVar3 = FUN_80044094();

	// if the value is zero
    if (iVar3 == 0)
	{
	  // enable checkered flag
      FUN_80044088(1);
    }

	// enable 3d cars on track? pause the game?
    *(uint *)(PTR_DAT_8008d2ac + 0x256c) = *(uint *)(PTR_DAT_8008d2ac + 0x256c) | 0x20;
  }

  // If the menu is invisible, which is only if you
  // left the menu, and no longer need the menu,
  if ((*(uint *)(DAT_8008d908 + 8) & 0x1000) != 0)
  {
	// set ActiveMenuBox to nullptr
    DAT_8008d908 = 0;
  }
  return;
}


// MenuBox_Show
void FUN_80046990(int param_1)

{
  // clear controller input (for menus)
  FUN_80046404();

  // save the pointer to the menu buffer
  // that is stored at bottom of 221 dll
  DAT_8008d908 = param_1;

  // Remove 0x1000 flag, making sure the menu is visible,
  // this is called in DLL 221 to keep the menu visible
  *(uint *)(param_1 + 8) = *(uint *)(param_1 + 8) & 0xffffefff;
  return;
}


// MenuBox_Hide
void FUN_800469c8(int param_1)

{
  // Enable 0x1000 flag to make menu invisible, this is used
  // when the menu is diabled in 221 dll after making a choice
  *(uint *)(param_1 + 8) = *(uint *)(param_1 + 8) | 0x1000;
  return;
}

// MenuBox_BoolHidden
uint FUN_800469dc(int param_1)

{
  return *(uint *)(param_1 + 8) >> 0xc & 1;
}

// GhostData_NumGhostsForLEV
int FUN_800469f0(short param_1)

{
  short sVar1;
  int iVar2;
  short sVar3;

  sVar3 = 0;
  iVar2 = 0;
  sVar1 = 0;

  // if ghost profiles are present
  if (0 < DAT_8009aa5c)
  {
	// loop through ghost profiles
    do {
      sVar3 = sVar1;
      sVar1 = (short)iVar2;
      iVar2 = iVar2 + 1;

	  // Check trackID of each profile
      if ((&DAT_8009aa88)[sVar1 * 0x1a] == param_1) {
        sVar3 = sVar3 + 1;
      }
      sVar1 = sVar3;
    } while (iVar2 * 0x10000 >> 0x10 < (int)DAT_8009aa5c);
  }
  return (int)sVar3;
}


void FUN_80046a74(void)

{
  DAT_8009aa30 = DAT_8009aa30 & 0xfffffff7 | 6;
  return;
}



uint FUN_80046a90(short param_1)

{
  uint uVar1;

  if ((param_1 == 8) && ((DAT_8009aa30 & 6) != 0)) {
    return 1;
  }
  uVar1 = 0;
  if ((((DAT_8009aa30 & 6) == 0) && (DAT_8009aa3e == DAT_8009aa42)) &&
     (DAT_8009aa40 == DAT_8009aa44)) {
    uVar1 = (uint)(DAT_8009aa34 == param_1);
  }
  return uVar1;
}



void FUN_80046b1c(undefined2 param_1,undefined2 param_2,undefined4 param_3,undefined4 param_4,
                 undefined4 param_5,undefined2 param_6)

{
  // param2 is 1 for SLOTS
  // param2 is 3 for ghost data

  DAT_8009aa30 = DAT_8009aa30 & 0xfffffff7;

  DAT_8009aa3a = param_2;

  // slotIndex
  DAT_8009aa3c = param_1;

  DAT_8009aa42 = param_2;

  // param1 always zero?
  DAT_8009aa44 = param_1;

  // Name of the save
  DAT_8009aa48 = param_3;

  DAT_8009aa4c = param_4;

  // if reading, copy data to this address
  DAT_8009aa50 = param_5;

  // if reading, copy data of this size
  DAT_8009aa54 = param_6;
  return;
}


// GhostData_Encode
uint FUN_80046b60(int param_1)
{
  // only called from GhostData_SaveProfile

  uint uVar1;
  short sVar2;

  sVar2 = (short)param_1;
  if (sVar2 < 10) {
    return param_1 + 0x30U & 0xff;
  }
  if (sVar2 < 0x24) {
    return param_1 + 0x37U & 0xff;
  }
  if (sVar2 < 0x3e) {
    uVar1 = param_1 + 0x3dU & 0xff;
  }
  else {
    uVar1 = 0x2d;
    if (sVar2 != 0x3e) {
      return 0x5f;
    }
  }
  return uVar1;
}


// GhostData_Decode
int FUN_80046bc0(byte param_1)
{
  // only called from GhostData_LoadProfile

  if (param_1 == 0x2d) {
    return 0x3e;
  }
  if (param_1 == 0x5f) {
    return 0x3f;
  }
  if (param_1 < 0x3a) {
    return (uint)param_1 - 0x30;
  }
  if (0x5a < param_1) {
    return (int)(((uint)param_1 + 0xffc3) * 0x10000) >> 0x10;
  }
  return (int)(((uint)param_1 + 0xffc9) * 0x10000) >> 0x10;
}


// WARNING: Removing unreachable block (ram,0x80046e88)
// WARNING: Removing unreachable block (ram,0x80046ed4)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// GhostData_SaveProfile
void FUN_80046c30(
	uint param_1,	// index to save (or load) to
	ushort param_2, // character ID array
	ushort param_3, // Level ID Array
	int param_4,	// amount of time
	undefined4 *param_5) // string typed from OSK

{
  bool bVar1;
  undefined4 *puVar2;
  undefined uVar3;
  byte bVar4;
  int iVar5;
  char *pcVar6;
  undefined4 *puVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  int iVar14;
  undefined4 *puVar15;
  undefined4 *puVar16;
  char local_138 [128];
  undefined4 local_b8 [32];
  ushort local_38;
  uint local_30;

  local_30 = SEXT24((short)param_2);
  local_38 = param_2;
  do {
    bVar1 = true;

	// if time is more than 9:59:99
    if (0x8c9ff < param_4)
	{
	  // set time to 9:59:99
      param_4 = 0x8c9ff;
    }

    uVar11 = local_30 | (int)((uint)param_3 << 0x10) >> 0xc;
    uVar12 = uVar11 | param_4 << 9;
    uVar13 = uVar12 | param_1 << 0x1d;

	// GhostData_Encode
    uVar3 = FUN_80046b60(uVar11 & 0x3f);

    _DAT_80085a3c = CONCAT11(uVar3,DAT_80085a3c);
    _DAT_80085a3c = _DAT_80085a3c & 0xffff0000 | (uint)_DAT_80085a3c;

	// GhostData_Encode
    uVar3 = FUN_80046b60((uVar12 & 0xfc0) >> 6);

    _DAT_80085a3c = CONCAT12(uVar3,_DAT_80085a3c);
    _DAT_80085a3c = _DAT_80085a3c & 0xff000000 | (uint)_DAT_80085a3c;

	// GhostData_Encode
    bVar4 = FUN_80046b60((uVar12 & 0x3f000) >> 0xc);

    _DAT_80085a3c = _DAT_80085a3c & 0xffffff | (uint)bVar4 << 0x18;
    bVar4 = FUN_80046b60((uVar12 & 0xfc0000) >> 0x12);
    _DAT_80085a40 = _DAT_80085a40 & 0xffffff00 | (uint)bVar4;

	// GhostData_Encode
    uVar3 = FUN_80046b60(uVar13 >> 0x18 & 0x3f);

    _DAT_80085a40 = CONCAT11(uVar3,DAT_80085a40);
    _DAT_80085a40 = _DAT_80085a40 & 0xffff0000 | (uint)_DAT_80085a40;

	// GhostData_Encode
    uVar3 = FUN_80046b60(uVar13 >> 0x1e);

	// loop counter
    iVar14 = 0;

	_DAT_80085a40 = (uint)CONCAT12(uVar3,_DAT_80085a40);

	// If there is ghost data to load
    if (0 < DAT_8009aa5c)
	{
	  // for iVar14 = 0; iVar14 < numGhosts; iVar14++
      do {
        iVar5 = strcmp();

		// increment loop counter
        iVar14 = iVar14 + 1;

        if (iVar5 == 0) {
          bVar1 = false;
          break;
        }
      } while (iVar14 * 0x10000 >> 0x10 < (int)DAT_8009aa5c);
    }
    param_1 = param_1 + 1 & 7;
    if (bVar1)
	{
      local_138[0] = '\0';

	  // length of string
	  iVar14 = strlen();

	  // param_3 = levelID
      strcat(

		// append end of string
		local_138 + iVar14,

		// lngStrings[MetaDataLEV[id].name_LNG]
        *(char **)((int)*(short *)(&DAT_80083a88 + (int)(short)param_3 * 0x18) * 4 +
				DAT_8008d878)
	  );

	  // ":"
      strcat(local_138,&DAT_8008d46c);

	  // length of string
      iVar14 = strlen();

	  // local_38 = 80086E84
      strcat(

		// append end of string
		local_138 + iVar14,

		// lngStrings[MetaDataCharacters[id].name_LNG_long]
		*(char **)((int)*(short *)(&DAT_80086d8a + ((int)((uint)local_38 << 0x10) >> 0xc)) * 4
                + DAT_8008d878)
	  );

	  // ":"
	  strcat(local_138,&DAT_8008d46c);

	  // make a string with amount of time
	  // param_4 is the number of milliseconds in the race (or lap)
      pcVar6 = (char *)FUN_80044ff8(param_4);

	  // append end of string
      strcat(local_138,pcVar6);

	  // CTR_ScrambleGhostString (why?)
	  FUN_80022234(local_b8,local_138);

      puVar2 = &DAT_800992a4;
      puVar16 = local_b8;
      do {
        puVar15 = puVar16;
        puVar7 = puVar2;
        uVar9 = puVar15[1];
        uVar8 = puVar15[2];
        uVar10 = puVar15[3];
        *puVar7 = *puVar15;
        puVar7[1] = uVar9;
        puVar7[2] = uVar8;
        puVar7[3] = uVar10;
        puVar16 = puVar15 + 4;
        puVar2 = puVar7 + 4;
      } while (puVar16 != local_b8 + 0xc);
      uVar10 = puVar15[5];
      uVar8 = puVar15[6];
      uVar3 = *(undefined *)(puVar15 + 7);
      puVar7[4] = *puVar16;
      puVar7[5] = uVar10;
      puVar7[6] = uVar8;
      *(undefined *)(puVar7 + 7) = uVar3;
      *(undefined *)((int)puVar7 + 0x1d) = *(undefined *)((int)puVar15 + 0x1d);
                    // WARNING: Read-only address (ram,0x8009abe5) is written
                    // WARNING: Read-only address (ram,0x8009abe9) is written

	  // copy string into ghostProfile_current
	  DAT_8009abcc = DAT_80085a30;
      DAT_8009abd0 = DAT_80085a34;
      DAT_8009abd4 = DAT_80085a38;
      DAT_8009abd8 = _DAT_80085a3c;
      DAT_8009abdc = _DAT_80085a40;

	  // 80085a44
	  // BASCUS-94426G*
      DAT_8009abe0._0_1_ = s_BASCUS_94426G__80085a44[0];

	  // OSK name
      ram0x8009abe1 = *param_5;
      ram0x8009abe5 = param_5[1];
      ram0x8009abe9 = param_5[2];
      DAT_8009abed = param_5[3];
      DAT_8009abf1 = *(undefined *)(param_5 + 4);

      DAT_8009abf2 = 1;

	  // trackID
      DAT_8009abf4 = param_3;

	  // characterID
      DAT_8009abf6 = local_38;

      DAT_8009abf8 = (short)param_1;
      DAT_8009abfc = param_4;
      return;
    }
  } while( true );
}


// GhostData_LoadProfile
void FUN_80047034(undefined4 *param_1,undefined4 *param_2)

{
  undefined uVar1;
  ushort uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  uint uVar11;
  uint uVar12;

  // GhostData_Decode
  uVar2 = FUN_80046bc0((uint)*(byte *)((int)param_2 + 0xd));
  iVar3 = FUN_80046bc0((uint)*(byte *)((int)param_2 + 0xe));
  iVar4 = FUN_80046bc0((uint)*(byte *)((int)param_2 + 0xf));
  iVar5 = FUN_80046bc0((uint)*(byte *)((int)param_2 + 0x10));
  iVar6 = FUN_80046bc0((uint)*(byte *)((int)param_2 + 0x11));
  iVar7 = FUN_80046bc0((uint)*(byte *)((int)param_2 + 0x12));

  uVar11 = (int)(short)uVar2 | (iVar3 << 0x10) >> 10;
  uVar12 = uVar11 | (iVar4 << 0x10) >> 4 | iVar5 << 0x12 | iVar6 << 0x18;
  *(ushort *)((int)param_1 + 0x2a) = uVar2 & 0xf;
  *(short *)(param_1 + 10) = (short)((uVar11 & 0x1f0) >> 4);
  param_1[0xc] = (uVar12 & 0x1ffffe00) >> 9;
  *(ushort *)(param_1 + 0xb) =
       ((ushort)(uVar12 >> 0x10) | (ushort)((uint)(iVar7 << 0x1e) >> 0x10)) >> 0xd;
  *(undefined *)((int)param_1 + 0x26) = 0;
  uVar8 = param_2[1];
  uVar9 = param_2[2];
  uVar10 = param_2[3];
  *param_1 = *param_2;
  param_1[1] = uVar8;
  param_1[2] = uVar9;
  param_1[3] = uVar10;
  uVar1 = *(undefined *)(param_2 + 5);
  param_1[4] = param_2[4];
  *(undefined *)(param_1 + 5) = uVar1;
  *(undefined *)((int)param_1 + 0x29) = 0;
  return;
}


// LoadSave_StartMemcardAction
// 2 = null
// 3 = save main CTR save file (adv, high score, etc)
// 5 = load ghost profile
// 6 = save ghost files
// 7 = load main ctr save file (adv, high score, etc)
void FUN_80047198(undefined2 param_1)

{
  DAT_8008d478 = param_1;
  DAT_8008d964 = 0;
  DAT_8008d984 = 0;
  return;
}


// LoadSave_StopMemcardAction
void FUN_800471ac(void)

{
  // memcard action = null
  DAT_8008d478 = 2;
  
  DAT_8008d964 = 1;
  return;
}



void FUN_800471c4(undefined2 param_1)

{
  DAT_8008d47a = param_1;
  FUN_80046a74();
  return;
}



void FUN_800471e8(void)

{
  // if data has not been wiped to "default state"
  // before reading memcard, then wipe it now
  if (DAT_8008d968 == 0)
  {
	// 8008d474 is ptr to memcard data
	// GAMEPROG_InitFullMemcard
    FUN_80026c24(PTR_DAT_8008d474);

	// dont do this a second time
    DAT_8008d968 = 1;
  }

  DAT_8008d928 = 0;
  DAT_8008d95c = 1;
  return;
}


// GhostData_ResetNumGhosts
void FUN_80047224(void)

{
  // By default, there are zero ghosts available to load
  DAT_8009aa5c = 0;
  return;
}


// LoadFromCard_GameProgressAndOptions
void FUN_80047230(void)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 *puVar8;

  DAT_8008d95c = 1;
  DAT_8008d928 = 1;
  DAT_8008d96c = 0xffff;

  // GAMEPROG_SaveTimeTrialProgress
  // params are: memcardPtr, ram ptr
  // not "save", more like "sync" memcard and ram
  FUN_80026d7c(PTR_DAT_8008d474 + 0x144,&DAT_8008e6e8);

  // pointer to memcard GameProgress and partially GameOptions
  puVar2 = (undefined4 *)(PTR_DAT_8008d474 + 0x15f4);
  puVar4 = (undefined4 *)(PTR_DAT_8008d474 + 0x144);

  // GameProgress struct
  puVar1 = &DAT_8008e6e8;

  // Copy to memory card
  do {
    puVar8 = puVar1;
    puVar3 = puVar4;
    uVar5 = puVar3[1];
    uVar6 = puVar3[2];
    uVar7 = puVar3[3];
    *puVar8 = *puVar3;
    puVar8[1] = uVar5;
    puVar8[2] = uVar6;
    puVar8[3] = uVar7;
    puVar4 = puVar3 + 4;
    puVar1 = puVar8 + 4;
  } while (puVar4 != puVar2);

  uVar5 = puVar3[5];
  uVar6 = puVar3[6];
  puVar8[4] = *puVar4;
  puVar8[5] = uVar5;
  puVar8[6] = uVar6;

  // load game options from memcard
  FUN_80043c10();
  return;
}



void FUN_800472d0(void)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  undefined4 local_1c;
  undefined4 *puVar4;
  undefined4 uVar5;
  char *pcVar6;
  undefined4 *puVar7;
  undefined4 uVar8;
  undefined *local_20;

  bVar1 = false;
  switch(DAT_8008d47a) {
  case 0:
    bVar1 = true;
    
	// memcard action = null
	DAT_8008d478 = 2;
	
    DAT_8008d984 = 1;
    break;
  case 1:
  
	// if not loading profile
    if (DAT_8008d478 != 7) 
	{
	  // memcard action = null
      DAT_8008d478 = 2;
      goto LAB_800475b4;
    }
	
	// if DAT_8008d478 == 7, continue here...
	
	// memcard action = null
    DAT_8008d478 = 2;
	
    FUN_800471c4();
    uVar5 = 4;

	// 800859e4
	// BASCUS-94426-SLOTS
    pcVar6 = s_BASCUS_94426_SLOTS_800859e4;

	puVar7 = (undefined4 *)0x0;
    local_20 = (undefined *)0x0;
    local_1c = 0;
LAB_80047544:
    FUN_80046b1c(0,uVar5,pcVar6,puVar7,local_20,local_1c);
    DAT_8008d984 = 0;
    break;
  case 5:
  case 6:
    bVar1 = true;
    break;
  case 7:
  case 8:
  case 9:

	// if loading ghost profile
	if (DAT_8008d478 == 5)
	{
      FUN_800471c4(4);

	  // ghost profile (save or load?)
	  FUN_80046b1c(0,3,&DAT_8009aa60 + (int)DAT_8009aa5a * 0x34,0,DAT_8008d754,0x3e00);
    }
    else {
      if (DAT_8008d478 < 6) 
	  {
		// if saving main CTR save file
        if (DAT_8008d478 == 3) 
		{
		  // memcard action = null
          DAT_8008d478 = 2;
          
		  FUN_800471c4(3);

		  // 800859e4
		  // BASCUS-94426-SLOTS
          pcVar6 = s_BASCUS_94426_SLOTS_800859e4;

		  puVar7 = (undefined4 *)&DAT_800859f8;

		  // size of memory card buffer
          local_1c = 0x1680;

		  // 8008d470 -> 800992E4, holds all memory card bytes
          local_20 = PTR_DAT_8008d470;
LAB_8004753c:
          uVar5 = 2;
          goto LAB_80047544;
        }
      }
      else {
        
		// if saving ghost profile
		if (DAT_8008d478 == 6) 
		{
          if (-1 < (int)DAT_8009aa56)
		  {
			// Get offset in array based on index,
			// the string of each profile is 0x34 bytes apart
            iVar2 = (int)DAT_8009aa56 * 0x34;

			// This happens as soon as you start saving ghost,
			// and "Saving..." appears on the screen

			// Generate 0x14-character string for profile name
			// BASCUS-94426GT xxxxx
			DAT_80099284 = *(undefined4 *)(&DAT_8009aa60 + iVar2);
            DAT_80099288 = *(undefined4 *)(&DAT_8009aa64 + iVar2);
            DAT_8009928c = *(undefined4 *)(&DAT_8009aa68 + iVar2);
            DAT_80099290 = *(undefined4 *)(&DAT_8009aa6c + iVar2);
            DAT_80099294 = *(undefined4 *)(&DAT_8009aa70 + iVar2);
            DAT_80099298 = (&DAT_8009aa74)[iVar2];

			FUN_800471c4(3);

			// Name of Ghost profile to save to
            FUN_80046b1c(0,5,&DAT_80099284,0,0,0);

            DAT_8008d984 = 0;
            iVar2 = ((int)DAT_8009aa5c + -1) - (int)DAT_8009aa56;
            if (iVar2 != 0)
			{
			  // Get byte index, given array index
              iVar3 = (int)DAT_8009aa56 * 0x34;

			  // copy the string
              memmove(&DAT_8009aa60 + iVar3,&DAT_8009aa94 + iVar3,iVar2 * 0x34);
            }

			// decrease number of ghost profiles
            DAT_8009aa5c = DAT_8009aa5c + -1;
            break;
          }
          FUN_800471c4(3);
          pcVar6 = (char *)&DAT_80085a30;
          puVar7 = &DAT_800992a4;

		  // size of two memcard slots
          local_1c = 0x3e00;

		  // address of ghost recording buffer
          local_20 = DAT_8008fbf4;

          goto LAB_8004753c;
        }
      }
    }
LAB_800475b4:
    bVar1 = true;
    DAT_8008d984 = 1;
  }
  iVar2 = FUN_80046a90(3);
  if (iVar2 != 0) {
    FUN_800471e8();

	// GhostData_ResetNumGhosts
    FUN_80047224();

    goto LAB_80047a08;
  }
  iVar2 = FUN_80046a90(0);
  if (iVar2 == 0) {
    iVar2 = FUN_80046a90(1);
    local_1c = 6;
    if (iVar2 == 0) {
      iVar2 = FUN_80046a90(2);
      if (iVar2 == 0) {
        iVar2 = FUN_80046a90(5);
        if (iVar2 == 0) {
          iVar2 = FUN_80046a90(4);
          if (iVar2 != 0) {
LAB_800479bc:
            FUN_800471e8();
            DAT_8008d95c = 0;
            DAT_8008d968 = 0;
            FUN_800471c4(4);
            uVar5 = 3;

			// 800859e4
			// BASCUS-94426-SLOTS
            pcVar6 = s_BASCUS_94426_SLOTS_800859e4;

			puVar7 = (undefined4 *)0x0;

			// size of memory card buffer
            local_1c = 0x1680;

			// 8008d470 -> 800992E4, holds all memory card bytes
            local_20 = PTR_DAT_8008d470;
LAB_800479f4:
            bVar1 = false;
            FUN_80046b1c(0,uVar5,pcVar6,puVar7,local_20,local_1c);
            DAT_8008d984 = 0;
            goto LAB_80047a08;
          }
          iVar2 = FUN_80046a90(6);
          if (iVar2 != 0)
		  {
			// GhostData_ResetNumGhosts
            FUN_80047224();

            FUN_800471e8();
            local_1c = 1;
            goto LAB_800476b4;
          }
          iVar2 = FUN_80046a90(7);
          if (iVar2 == 0) goto LAB_80047a08;
          DAT_8008d984 = 1;
          if (DAT_8008d47a == 3) 
		  {
			// if saving ghost profile
            if (DAT_8008d478 == 6) {
              if (-1 < DAT_8009aa56) {
                DAT_8009aa56 = -1;
                FUN_800471c4(3);
                uVar5 = 2;
                pcVar6 = (char *)&DAT_80085a30;
                puVar7 = &DAT_800992a4;

				// max size of ghost recording buffer
				local_1c = 0x3e00;

				// address of ghost recording buffer
                local_20 = DAT_8008fbf4;

                goto LAB_800479f4;
              }

              iVar2 = ((int)DAT_8009aa5c + -1) - (int)DAT_8009aa58;

			  if (iVar2 != 0)
			  {
				// get ghost profile
                iVar3 = (int)DAT_8009aa58 * 0x34;

				// copy from profile array to current profile
                memmove(&DAT_8009aa94 + iVar3,&DAT_8009aa60 + iVar3,iVar2 * 0x34);
              }

              puVar4 = &DAT_8009abcc;
              puVar7 = (undefined4 *)(&DAT_8009aa60 + (int)DAT_8009aa58 * 0x34);

			  // increment number of ghost profiles
              DAT_8009aa5c = DAT_8009aa5c + 1;

              do {
                local_1c = puVar4[1];
                uVar5 = puVar4[2];
                uVar8 = puVar4[3];
                *puVar7 = *puVar4;
                puVar7[1] = local_1c;
                puVar7[2] = uVar5;
                puVar7[3] = uVar8;
                puVar4 = puVar4 + 4;
                puVar7 = puVar7 + 4;
              } while (puVar4 != &DAT_8009abfc);
              *puVar7 = DAT_8009abfc;
            }
            DAT_8008d964 = 1;
            local_1c = 8;
            
			// memcard action = null
			DAT_8008d478 = 2;
			
            goto LAB_80047984;
          }
          if (DAT_8008d47a < 4) {
            if (DAT_8008d47a == 2)
			{
			  // GhostData_ResetNumGhosts
              FUN_80047224();

			  FUN_800471e8();
              DAT_8008d928 = 1;
              if (-1 < DAT_8008d978)
			  {
				// if chose load or save (0 or 1)
                if (DAT_8008d978 < 2)
				{
				  // 8008d474 is ptr to memcard data
				  // GAMEPROG_InitFullMemcard
                  FUN_80026c24(PTR_DAT_8008d474);

                  FUN_800471c4(8);

				  // 800859e4
				  // BASCUS-94426-SLOTS
                  FUN_80046b1c(0,1,s_BASCUS_94426_SLOTS_800859e4,0,0,0);

				  bVar1 = false;
                }
                else {

				  // if you are deleting data
                  if (DAT_8008d978 == 2) {
                    DAT_8008d984 = 1;
                  }
                }
              }
            }
            goto LAB_80047a08;
          }
          if (DAT_8008d47a != 4) {
            if (DAT_8008d47a != 5) goto LAB_80047a08;

			// GhostData_ResetNumGhosts
            FUN_80047224();

			goto LAB_800479bc;
          }
		  
		  // if loading ghost profile
          if (DAT_8008d478 == 5)
		  {
			// you want to show a ghost during a race
            DAT_8008d958 = 1;

			DAT_8008d964 = 1;
            local_1c = 8;
          }
          else
		  {
			// If memory card save has correct version number
            if (*(int *)PTR_DAT_8008d474 == 0x1600ffee)
			{
			  // the save is not outdated
              DAT_8008d944 = 0;

			  // LoadFromCard_GameProgressAndOptions
              FUN_80047230();

              local_1c = 8;
            }
            else
			{
			  // the save is outdated
              DAT_8008d944 = 1;

              FUN_800471e8();
              local_1c = 9;
            }
          }
          FUN_800471c4(local_1c);
		  
		  // memcard action = null
          DAT_8008d478 = 2;
        }
        else
		{
		  // the save is not outdated
          DAT_8008d944 = 0;
          FUN_800471e8();
          DAT_8008d984 = 1;
          local_1c = 9;
          if ((DAT_8008d978 != 0) && ((DAT_8008d978 < 0 || (local_1c = 8, 2 < DAT_8008d978))))
          goto LAB_80047a08;
LAB_80047984:
          DAT_8008d984 = 1;
          FUN_800471c4(local_1c);
        }

		// 800859e4
		// BASCUS-94426-SLOTS
        FUN_80046b1c(0,1,s_BASCUS_94426_SLOTS_800859e4,0,0,0);

		bVar1 = false;
        goto LAB_80047a08;
      }
      FUN_800471e8();
      local_1c = 7;
    }
  }
  else {
    FUN_800471e8();

	// GhostData_ResetNumGhosts
    FUN_80047224();

	local_1c = 0;
  }
LAB_800476b4:
  FUN_800471c4(local_1c);

  // 800859e4
  // BASCUS-94426-SLOTS
  FUN_80046b1c(0,1,s_BASCUS_94426_SLOTS_800859e4,0,0,0);

  DAT_8008d984 = 1;
  bVar1 = false;
LAB_80047a08:
  if ((bVar1) && (iVar2 = FUN_80046a90(8), iVar2 == 0))
  {
	// 800859e4
	// BASCUS-94426-SLOTS
    FUN_80046b1c(0,1,s_BASCUS_94426_SLOTS_800859e4,0,0,0);
  }
  return;
}



void FUN_80047a58(void)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  int iVar4;

  iVar4 = -1;
  if ((DAT_8009aa30 & 1) == 0) {
    if (DAT_8009aa36 != 0) {
      iVar4 = FUN_8003ddac();
      DAT_8009aa3e = DAT_8009aa36;
      DAT_8009aa40 = DAT_8009aa38;
    }
  }
  else {
    DAT_8009aa3e = DAT_8009aa36;
    DAT_8009aa40 = DAT_8009aa38;
    uVar1 = DAT_8009aa30 & 0xfffffffe;
    if ((DAT_8009aa30 & 2) == 0) {
      uVar1 = DAT_8009aa30 & 0xfffffffa;
    }
    DAT_8009aa30 = uVar1;

    switch(DAT_8009aa36)
	{
    case 1:
	  // MEMCARD_GetInfo
      iVar4 = FUN_8003e238((int)DAT_8009aa38);
      break;
    case 2:
	  // MEMCARD_Save
      iVar4 = FUN_8003e344((int)DAT_8009aa38,DAT_8009aa48,DAT_8009aa4c,DAT_8009aa50,
                           (int)DAT_8009aa54,0);
      break;
    case 3:
	  // MEMCARD_Load
      iVar4 = FUN_8003e29c((int)DAT_8009aa38,DAT_8009aa48,DAT_8009aa50,(int)DAT_8009aa54,0);
      break;

    case 4:
      // MEMCARD_Format
	  iVar4 = FUN_8003e51c((int)DAT_8009aa38);
      break;

    case 5:
	  // MEMCARD_EraseFile (unused)
      iVar4 = FUN_8003e6d4((int)DAT_8009aa38,DAT_8009aa48);
    }
  }
  iVar2 = iVar4 << 0x10;

  if (
		(DAT_8009aa36 == 1) &&
		(
			iVar3 = iVar2 >> 0x10,
			iVar2 = iVar4 << 0x10,
			iVar3 == 3
		)
	  )
  {
    iVar4 = 0;

	// Set number of ghost profiles to zero
    DAT_8009aa5c = 0;

	// 80085a44
	// BASCUS-94426G*
	// MEMCARD_FindFirstGhost
    iVar3 = FUN_8003e600((int)DAT_8009aa38,s_BASCUS_94426G__80085a44);

	iVar2 = 0;

	// loop until you have gone through all memory card saves
    while (iVar3 != 0)
	{
	  // If there are less than 7 ghosts loaded
      if (iVar2 >> 0x10 < 7)
	  {
		// GhostData_LoadProfile
        FUN_80047034(&DAT_8009aa60 + (iVar2 >> 0x10) * 0x34);

		// increment ghost counter
        DAT_8009aa5c = DAT_8009aa5c + 1;
      }

	  // increment number of ghosts loaded
      iVar4 = iVar4 + 1;

	  // MEMCARD_FindNextGhost
      iVar3 = FUN_8003e678();

	  // bitshifted version of numGhosts
      iVar2 = iVar4 * 0x10000;
    }

	// slotIndex, and saveName
	FUN_8003e59c((int)DAT_8009aa38,DAT_8009aa48);

    DAT_8009aa30 = DAT_8009aa30 | 8;

	// slotIndex, and saveName
    iVar2 = FUN_8003e59c((int)DAT_8009aa38,DAT_8009aa48);

	iVar2 = iVar2 << 0x10;
  }
  switch(iVar2 >> 0x10) {
  case 0:
    DAT_8009aa34 = 7;
    if ((DAT_8009aa36 == 1) && (DAT_8009aa34 = 4, (DAT_8009aa30 & 8) == 0)) {
      DAT_8009aa34 = 7;
    }
    break;
  case 1:
    DAT_8009aa34 = 2;
    break;
  case 2:
    DAT_8009aa34 = 0;
    DAT_8009aa36 = 0;
    goto switchD_80047c84_caseD_8;
  case 3:
    DAT_8009aa34 = 3;
    if (DAT_8009aa36 == 4) {
      DAT_8009aa34 = 7;
    }
    break;
  case 4:
    DAT_8009aa34 = 1;
    break;
  case 5:
    DAT_8009aa34 = 6;
    break;
  case 6:
    DAT_8009aa34 = 5;
    break;
  case 7:
    DAT_8009aa34 = 8;
  default:
    goto switchD_80047c84_caseD_8;
  }
  DAT_8009aa36 = 0;
switchD_80047c84_caseD_8:
  if ((DAT_8009aa36 == 0) && (DAT_8009aa3a != 0)) {
    DAT_8009aa36 = DAT_8009aa3a;
    DAT_8009aa3a = 0;

	// slotIndex
	DAT_8009aa38 = DAT_8009aa3c;

    DAT_8009aa30 = DAT_8009aa30 & 0xfffffffd | 1;
  }
  return;
}

// spammed in main menu, adv arena, and end-of-race
// supposedly triggers memcard routines. if noped, game hangs at CHECKING... screen
// the 2 functions are only called here.
void FUN_80047d64(void)
{
  // if PauseAllThreads is diabled
  if ((*(uint *)PTR_DAT_8008d2ac & 0x10) == 0)
  {
    FUN_80047a58();

	// Handles BASCUS-94426-SLOTS file for
	// Adventure saves and time trial scores
    FUN_800472d0();
  }
  return;
}

// LoadSave_LoadProfileFromHub_MenuBoxFuncPtr
void FUN_80047da8(undefined4 param_1)

{
  undefined *puVar1;

  // main structure of game
  puVar1 = PTR_DAT_8008d2ac;

  // set level ID to main menu
  *(undefined4 *)(PTR_DAT_8008d2ac + 0x1a10) = 0x27;

  // change character ID to icon ID
  DAT_80086e84 = DAT_8008fbce;

  // Load AdvHub LEV depending on new profile
  FUN_8003cfc0((int)*(short *)(puVar1 + 0x1eb0));

  // make MenuBox invisible
  FUN_800469c8(param_1);
  return;
}


// LoadSave_PerFrame
void FUN_80047dfc(int param_1)

{
  int iVar1;
  int iVar2;
  int *piVar3;
  int *piVar4;
  ushort uVar5;
  undefined2 local_28;
  undefined2 local_26;
  undefined2 local_24;

  uVar5 = 0;
  piVar4 = *(int **)(*(int *)(param_1 + 0x30) + 4);
  piVar3 = piVar4 + 1;

  // loop through 12 instances,
  // 3 per profile, 4 profiles
  do {
    iVar2 = (int)(short)uVar5;
    iVar1 = (iVar2 % 3) * 0x10000 >> 0x10;
    *(short *)((int)piVar3 + 2) = *(short *)((int)piVar3 + 2) + (&DAT_8008d47c)[iVar1];

	 // convert 3 rotation shorts into rotation matrix
    FUN_8006c2a4(*piVar4 + 0x30,piVar3);

    if (iVar1 != 1)
	{
	  // from MetaDataSaveLoad
      local_28 = (&DAT_80085c68)[iVar2 * 7];
      local_26 = (&DAT_80085c6a)[iVar2 * 7];
      local_24 = (&DAT_80085c6c)[iVar2 * 7];

	  // SpecularLight_Spinning3D
      FUN_8005741c(*piVar4,piVar3,&local_28);
    }

    uVar5 = uVar5 + 1;
    piVar3 = piVar3 + 3;
    piVar4 = piVar4 + 3;
  } while (uVar5 < 0xc);
  return;
}


// LoadSave_PrintInteger
void FUN_80047f20(undefined4 param_1,short param_2,short param_3,short param_4,short param_5)

{
  // format of sprintf
  char *fmt;

  // char array for generated sprintf message
  char acStack80 [64];

  if (param_4 == 1)
  {
	// %02ld
    fmt = s__02ld_8008d484;
  }
  else
  {
	// %ld
    fmt = &DAT_8008d48c;
  }

  // convert param_1 to string
  sprintf(acStack80,fmt,param_1);

  // Draw string
  FUN_80022878(acStack80,(int)param_2,(int)param_3,1,(int)param_5);
  return;
}


// LoadSave_UI_ConvertX
int FUN_80047fb8(int param_1,int param_2)

{
  param_2 = (param_1 + -0x100) * param_2;
  if (param_2 < 0) {
    param_2 = param_2 + 0xff;
  }
  return param_2 >> 8;
}


// LoadSave_UI_ConvertY
int FUN_80047fd8(int param_1,int param_2)

{
  param_2 = (param_1 + -0x6c) * param_2;
  if (param_2 < 0) {
    param_2 = param_2 + 0xff;
  }
  return param_2 >> 8;
}


// LoadSave_DrawAdvProfile
void FUN_80047ff8(int param_1,int param_2,int param_3,short param_4,short param_5,ushort param_6)

{
  int iVar1;
  undefined4 *puVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  int iVar7;
  uint uVar8;
  int iVar9;
  undefined4 uVar10;
  undefined4 local_58;
  short local_50;
  short local_4e;
  undefined2 local_4c;
  undefined2 local_4a;
  short local_48;
  short local_46;
  undefined2 local_44;
  undefined2 local_42;
  short local_40;
  ushort local_38;
  ushort local_30;

  local_30 = param_6;
  if ((param_6 & 0x10) == 0) {
    uVar8 = 0;
    uVar3 = 3;
    uVar6 = 1;
    uVar10 = 4;
  }
  else {
    uVar8 = 0x1d;
    uVar3 = 0x1e;
    uVar6 = 0x1d;
    uVar10 = 0x1d;
  }
  local_38 = param_5 * 3;
  local_40 = param_4;
  FUN_800265c0(param_1);
  local_4e = (short)param_3;
  local_50 = (short)param_2;

  // If Adventure Profile is empty
  if (*(short *)(param_1 + 0x2a) < 0)
  {
	// DAT_8008d878 + 0x2d4
	// EMPTY
    FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x2d4),(param_2 + 0x6c) * 0x10000 >> 0x10,
                 (param_3 + 0x17) * 0x10000 >> 0x10,1,uVar3 | 0xffff8000);
  }

  // If Adventure Profile is not empty
  else {
    iVar1 = (int)local_50;
    if ((local_30 & 0x10) == 0)
	{
	  // grey
      local_58 = DAT_8008d490;
    }
    else
	{
	  // black
      local_58 = DAT_8008d494;
    }

    iVar9 = (int)local_4e;

	// Character Icon
	// DecalHUD_DrawPolyGT4_Safe
    FUN_80044ef8(*(undefined4 *)
                  (PTR_DAT_8008d2ac +
                  (int)*(short *)(&DAT_80086d8c + (int)*(short *)(param_1 + 0x2a) * 0x10) * 4 +
                  0x1eec),iVar1 + 10,iVar9 + 6,

				  // pointer to PrimMem struct
				  *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

				 // pointer to OT mem
				  *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				  local_58,local_58,local_58,local_58,1,
                  0x1000);

	// Draw String
	FUN_80022878(param_1 + 0x18,(param_2 + 0x6c) * 0x10000 >> 0x10,
                 (param_3 + 0x29) * 0x10000 >> 0x10,1,uVar6 | 0xffff8000);

	// X position to draw
    iVar4 = (param_2 + 0x6a) * 0x10000 >> 0x10;

	// Y position to draw
    iVar7 = (param_3 + 0x17) * 0x10000 >> 0x10;

	// Color to draw
    uVar8 = uVar8 | 0x4000;

	// (PTR_DAT_8008d2ac + 0x1e54) is percentage of completion (0 - 101)
	// Convert to a string and draw
    FUN_80047f20(*(undefined4 *)(PTR_DAT_8008d2ac + 0x1e54),iVar4,iVar7,0,uVar8);

	// Y position to draw
    iVar5 = (param_3 + 5) * 0x10000 >> 0x10;

	// (PTR_DAT_8008d2ac + 0x1e30) is the number of trophies
	// Convert to a string and draw
    FUN_80047f20(*(undefined4 *)(PTR_DAT_8008d2ac + 0x1e30),iVar4,iVar5,0,uVar8);

	// X position to draw
    iVar4 = (param_2 + 0xb5) * 0x10000 >> 0x10;

	// (PTR_DAT_8008d2ac + 0x1e38) is the number of keys
	// Convert to a string and draw
    FUN_80047f20(*(undefined4 *)(PTR_DAT_8008d2ac + 0x1e38),iVar4,iVar5,0,uVar8);

	// (PTR_DAT_8008d2ac + 0x1e34) is the number of relics
	// Convert to a string and draw
    FUN_80047f20(*(undefined4 *)(PTR_DAT_8008d2ac + 0x1e34),iVar4,iVar7,0,uVar8);

	// Draw Name of profile
    FUN_80022878(&DAT_8008d498,(param_2 + 0x70) * 0x10000 >> 0x10,iVar7,1,uVar10);

	// convert x
    uVar10 = FUN_80047fb8(iVar1 + 0xc3,0x100);
    iVar5 = (int)(short)local_38 * 0xc;
    *(undefined4 *)(*(int *)(iVar5 + *(int *)(DAT_8008d8f4 + 4)) + 0x44) = uVar10;

	// convert y
	uVar10 = FUN_80047fd8(iVar9 + 0x1f,0x100);
    iVar4 = DAT_8008d8f4;
    *(undefined4 *)(*(int *)(iVar5 + *(int *)(DAT_8008d8f4 + 4)) + 0x48) = uVar10;
    *(undefined4 *)(*(int *)(iVar5 + *(int *)(iVar4 + 4)) + 0x4c) = 0x100;
    iVar4 = *(int *)(iVar5 + *(int *)(iVar4 + 4));

	// make visible
    *(uint *)(iVar4 + 0x28) = *(uint *)(iVar4 + 0x28) & 0xffffff7f;

	// convert x
	uVar10 = FUN_80047fb8(iVar1 + 0x78,0x100);
    uVar3 = (uint)local_38;
    iVar5 = ((int)((uVar3 + 1) * 0x10000) >> 0x10) * 0xc;
    *(undefined4 *)(*(int *)(iVar5 + *(int *)(DAT_8008d8f4 + 4)) + 0x44) = uVar10;

	// convert y
	uVar10 = FUN_80047fd8(iVar9 + 0xd,0x100);
    iVar4 = DAT_8008d8f4;
    *(undefined4 *)(*(int *)(iVar5 + *(int *)(DAT_8008d8f4 + 4)) + 0x48) = uVar10;
    *(undefined4 *)(*(int *)(iVar5 + *(int *)(iVar4 + 4)) + 0x4c) = 0x100;
    iVar4 = *(int *)(iVar5 + *(int *)(iVar4 + 4));

	// make visible
    *(uint *)(iVar4 + 0x28) = *(uint *)(iVar4 + 0x28) & 0xffffff7f;

	// convert x
    uVar10 = FUN_80047fb8(iVar1 + 0xc3,0x100);
    iVar4 = ((int)((uVar3 + 2) * 0x10000) >> 0x10) * 0xc;
    *(undefined4 *)(*(int *)(iVar4 + *(int *)(DAT_8008d8f4 + 4)) + 0x44) = uVar10;

	// convert y
	uVar10 = FUN_80047fd8(iVar9 + 0xd,0x100);
    iVar1 = DAT_8008d8f4;
    *(undefined4 *)(*(int *)(iVar4 + *(int *)(DAT_8008d8f4 + 4)) + 0x48) = uVar10;
    *(undefined4 *)(*(int *)(iVar4 + *(int *)(iVar1 + 4)) + 0x4c) = 0x100;
    iVar1 = *(int *)(iVar4 + *(int *)(iVar1 + 4));

	// make visible
    *(uint *)(iVar1 + 0x28) = *(uint *)(iVar1 + 0x28) & 0xffffff7f;
  }
  local_4c = 0xdc;
  local_4a = 0x3d;
  if (local_40 != 0)
  {
	// highlight
    puVar2 = &DAT_8008d94c;

	// if green load/save
    if ((local_30 & 0x10) != 0)
	{
	  // highlight
      puVar2 = &DAT_8008d948;
    }

    local_48 = local_50 + 6;
    local_46 = local_4e + 4;
    local_44 = 0xd0;
    local_42 = 0x35;

	// CTR_Box_DrawClearBox
    FUN_8002177c(&local_48,puVar2,1,

					*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0) + 0xc,

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);
  }

  // Draw 2D Menu rectangle background
  FUN_800457b0(&local_50,(int)(short)local_30,
               *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0) + 0xc);
  return;
}


// LoadSave_GetTrackID
void FUN_800485a8(void)

{
  DAT_80085b76 = 1;

  // level ID
  DAT_8008fbd2 = *(undefined2 *)(PTR_DAT_8008d2ac + 0x1a10);

  return;
}


// LoadSave_Init
void FUN_800485cc(uint param_1)
{
  bool bVar1;
  byte bVar2;
  undefined2 uVar3;
  undefined *puVar4;
  int iVar5;
  uint uVar6;
  int iVar7;
  int iVar8;
  byte *pbVar9;
  int *piVar10;
  int *piVar11;
  ushort uVar12;
  short *psVar13;

  // if loadsave object does not exist
  if (DAT_8008d8f4 == (int *)0x0)
  {
	// THREAD_BirthWithObject
	// 0x8 = size
	// 0 = no relation to param4
	// 0x300 flag = SmallStackPool
	// 0xd = "other" thread bucket
    iVar5 = FUN_8004205c(0x8030d,FUN_80047dfc,"LoadSave",0);

	// Get the object attached to the thread
	// store object globally
    DAT_8008d8f4 = *(int **)(iVar5 + 0x30);

    DAT_8008d8f4[1] = -0x7ff65660; // 0x8009A9A0
    memset(&DAT_8009a9a0,0,0x90);

	// check if creation failed
    bVar1 = DAT_8008d8f4 == (int *)0x0;

	// store thread in object
    *DAT_8008d8f4 = iVar5;

	// if creation failed
    if (bVar1) {
      return;
    }
  }

  // Instances MetaData
  psVar13 = &DAT_80085c64;

  uVar12 = 0;
  piVar10 = (int *)DAT_8008d8f4[1];
  pbVar9 = &DAT_80085c70;
  piVar11 = piVar10 + 2;
  do {
    if (*piVar10 == 0) {
      if (*(int *)(PTR_DAT_8008d2ac + (int)*psVar13 * 4 + 0x2160) != 0)
	  {
		// INSTANCE_Birth3D -- ptrModel, name, thread
        iVar5 = FUN_8003086c(*(int *)(PTR_DAT_8008d2ac + (int)*psVar13 * 4 + 0x2160),"loadsave",
                             *DAT_8008d8f4);
        *piVar10 = iVar5;
		
		// if instance exists
        if (iVar5 != 0) 
		{
		  // flags
          uVar6 = *(uint *)(iVar5 + 0x28);
          *(uint *)(iVar5 + 0x28) = uVar6 | 0x480;
          if (((int)(short)uVar12 % 3) * 0x10000 >> 0x10 != 1) {
            *(uint *)(iVar5 + 0x28) = uVar6 | 0x20480;
          }
          puVar4 = PTR_DAT_8008d2ac;

		  // instance -> InstDrawPerPlayer[0].camera110 = Camera110_UI
          *(undefined **)(iVar5 + 0x74) = PTR_DAT_8008d2ac + 5000;

		  iVar8 = 1;

		  // if more than 1 screen
          if (1 < (byte)puVar4[0x1ca8])
		  {
            iVar7 = 0x10000;
			
			// every InstDrawPerPlayer (except for first)
            do 
			{
			  // loop index
              iVar8 = iVar8 + 1;
			  
			  // erase camera110
              *(undefined4 *)(iVar5 + (iVar7 >> 0x10) * 0x88 + 0x74) = 0;
			  
              iVar7 = iVar8 * 0x10000;
            } while (iVar8 * 0x10000 >> 0x10 < (int)(uint)(byte)puVar4[0x1ca8]);
          }

          if ((param_1 & 0x10) == 0) {
            bVar2 = *pbVar9;
            uVar6 = (uint)pbVar9[-2] << 0x14 | (uint)pbVar9[-1] << 0xc;
          }
          else {
            uVar6 = (uint)(pbVar9[-2] >> 1) << 0x14 | (uint)pbVar9[-1] << 0xc;
            bVar2 = *pbVar9 >> 1;
          }
          *(uint *)(iVar5 + 0x24) = uVar6 | (uint)bVar2 << 4;
          uVar3 = (&DAT_80085c66)[(int)(short)uVar12 * 7];

		  // scale (x, y, z)
		  *(undefined2 *)(iVar5 + 0x20) = uVar3;
          *(undefined2 *)(iVar5 + 0x1e) = uVar3;
          *(undefined2 *)(iVar5 + 0x1c) = uVar3;

          *(undefined2 *)((int)piVar11 + -2) = 0;
          *(undefined2 *)(piVar11 + -1) = 0;
          *(undefined2 *)piVar11 =
               *(undefined2 *)((int)&DAT_80085d0c + (((int)(short)uVar12 % 3) * 0x10000 >> 0xf));

		  // set rotation (5 direction vectors)
		  *(undefined4 *)(iVar5 + 0x30) = 0x1000;
          *(undefined4 *)(iVar5 + 0x34) = 0;
          *(undefined4 *)(iVar5 + 0x38) = 0x1000;
          *(undefined4 *)(iVar5 + 0x3c) = 0;
          *(undefined2 *)(iVar5 + 0x40) = 0x1000;
        }
      }
      if (*piVar10 != 0) goto LAB_80048878;
    }
    else {
LAB_80048878:

	  // make invisible
      *(uint *)(*piVar10 + 0x28) = *(uint *)(*piVar10 + 0x28) | 0x80;
    }
    uVar12 = uVar12 + 1;
    piVar11 = piVar11 + 3;
    piVar10 = piVar10 + 3;
    pbVar9 = pbVar9 + 0xe;
    psVar13 = psVar13 + 7;
    if (0xb < uVar12) {
      return;
    }
  } while( true );
}


// LoadSave_Destroy
void FUN_800488e0(void)

{
  int iVar1;
  ushort uVar2;
  int *piVar3;

  // if loadsave object exists
  if (DAT_8008d8f4 != (int *)0x0) {
    piVar3 = (int *)DAT_8008d8f4[1];

	// loop iteration counter
    uVar2 = 0;

	// destroy 12 instances, for LoadSave's
	// 4x trophy, 4x relic, and 4x key

	// for uVar2 = 0; uVar2 < 0xc; uVar2++
	do
	{
      if (*piVar3 != 0)
	  {
		// INSTANCE_Death
        FUN_80030aa8();
      }

	  // increment loop counter
      uVar2 = uVar2 + 1;
      piVar3 = piVar3 + 3;

    } while (uVar2 < 0xc);

	// get pointer to thread, from object
    iVar1 = *DAT_8008d8f4;

	// erase pointer to object
    DAT_8008d8f4 = (int *)0x0;

	// 0x800 = this thread needs to be deleted
    *(uint *)(iVar1 + 0x1c) = *(uint *)(iVar1 + 0x1c) | 0x800;
  }
  return;
}

// "OneProfile" means you see one profile on screen,
// and four options (load/save/delete/exit)

// LoadSave_OneProfile_MenuBoxFuncPtr
void FUN_80048960(int param_1)

{
  short sVar1;

  // if have not chosen any option
  // if you see current profile, and load/save/delete/exit rows
  if (*(short *)(param_1 + 0x1e) != 0)
  {
	// LoadSave_Init
    FUN_800485cc((int)*(short *)(param_1 + 0x14));

	// 0x8fba4 is where the adventure profile (currently loaded) begins

	// Draw Adventure Profile
    FUN_80047ff8(&DAT_8008fba4,0x92,0x32,0,0,0x10);

	// exit the function
    return;
  }

  // only here if you chose one of the rows (save/load/delete/exit)

  // get value of row selected
  sVar1 = *(short *)(param_1 + 0x1a);

  // no submenu can have more than 3 rows

  // if submenu row is less than 3
  if (sVar1 < 3) {

	// if row is more or equal to zero
    if (-1 < sVar1)
	{
	  // Set Load/Save to "Green" mode,
	  // remembering the last selected row
      FUN_80048e2c((int)(short)(*(ushort *)(param_1 + 0x1a) | 0x20));

	  // Set MenuBox to a menu box
	  // that draws four adv profiles
	  DAT_8008d924 = &DAT_80085b88;

	  return;
    }

	// if row is invalid, return
    if (sVar1 != -1) {
      return;
    }
  }

  // if row is not 3, invalid row
  else {
    if (sVar1 != 3) {
      return;
    }
  }

  // does that mean row = 3 (4th row) is valid??

  // make MenuBox invisible
  FUN_800469c8(param_1);

  // LoadSave_Destroy
  FUN_800488e0();

  return;
}


// Draw Profile
void FUN_80048a30(int param_1,short param_2,short param_3,short param_4,undefined4 param_5,
                 ushort param_6,short param_7,short param_8)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 *puVar3;
  short local_38;
  short local_36;
  undefined2 local_34;
  undefined2 local_32;
  short local_30;
  short local_2e;
  undefined2 local_2c;
  undefined2 local_2a;

  local_34 = 200;
  local_32 = 0x29;
  local_30 = param_2 + 6;
  local_2e = param_3 + 3;
  local_2c = 0xbc;
  local_2a = 0x23;
  local_38 = param_2;
  local_36 = param_3;

  if (param_8 != 0)
  {
	// DAT_8008d878 + 0x1b4
	// NOT AVAILABLE
    FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x1b4),(int)(short)(param_2 + 100),
                 (int)(short)(param_3 + 0x11),2,0xffff8016);

	// CTR_Box_DrawClearBox
    FUN_8002177c(&local_30,&DAT_8008d49c,2,

					*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0),

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);
  }

  // If there is no ghost data
  if (param_1 == 0)
  {
    // If you are saving a ghost
	if (param_7 == 0)
	{
	  // DAT_8008d878 + 0x2d4
	  // EMPTY
      uVar1 = *(undefined4 *)(DAT_8008d878 + 0x2d4);
    }

	// If you are loading a ghost
	else
	{
	  // DAT_8008d878 + 0x1b0
	  // NO GHOST
      uVar1 = *(undefined4 *)(DAT_8008d878 + 0x1b0);
    }
    uVar2 = 0xffff8001;
    if (param_7 == 0) {
      uVar2 = 0xffff8003;
    }
    FUN_80022878(uVar1,(int)(short)(param_2 + 100),(int)(short)(param_3 + 0x11),2,uVar2);
  }

  // If Ghost data is valid
  else
  {
	// Draw name of player that saved the ghost (from OSK screen)
    FUN_80022878(*(undefined4 *)
                  ((int)*(short *)(&DAT_80083a88 + (int)*(short *)(param_1 + 0x28) * 0x18) * 4 +
                  DAT_8008d878),(int)(short)(param_2 + 100),(int)(short)(param_3 + 0x1e),2,
                 0xffff801d);

	// make a string with amount of time
    uVar1 = FUN_80044ff8(*(undefined4 *)(param_1 + 0x30));

	// Draw String
    FUN_80022878(uVar1,(int)(short)(param_2 + 0x78),(int)(short)(param_3 + 10),1,0xffff8001);

	// character icon
	// DecalHUD_DrawPolyGT4_Safe
    FUN_80044ef8(*(undefined4 *)
                  (PTR_DAT_8008d2ac +
                  (int)*(short *)(&DAT_80086d8c + (int)*(short *)(param_1 + 0x2a) * 0x10) * 4 +
                  0x1eec),(int)param_2 + 8,(int)param_3 + 5,

				  // pointer to PrimMem struct
				  *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

				  // pointer to OT mem
				  *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				  DAT_8008d4a0,DAT_8008d4a0,DAT_8008d4a0,
                 DAT_8008d4a0,1,0x1000);
  }

  if (param_4 != 0)
  {
	// normal highlight
    puVar3 = &DAT_8008d94c;

	// if load/save screen
	if ((param_6 & 0x10) != 0)
	{
	  // green highlight
      puVar3 = &DAT_8008d948;
    }

	// CTR_Box_DrawClearBox
    FUN_8002177c(&local_30,puVar3,1,

					*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0),

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);
  }

  // Draw 2D Menu rectangle background
  FUN_800457b0(&local_38,(int)(short)param_6,
               *(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0));
  return;
}


// LoadSave_MuteCursors
void FUN_80048da0(void)

{
  // offset 8 of menuBox_drawFourAdvProfiles
  DAT_80085b90 = DAT_80085b90 | 0x800000;

  // offset 8 of menuBox_GhostSelection
  DAT_80085bbc = DAT_80085bbc | 0x800000;

  // offset 8 of menuBox_warning
  DAT_80085be8 = DAT_80085be8 | 0x800000;
  return;
}


// LoadSave_UnMuteCursors
void FUN_80048de4(void)

{
  // offset 8 of menuBox_drawFourAdvProfiles
  DAT_80085b90 = DAT_80085b90 & 0xff7fffff;

  // offset 8 of menuBox_GhostSelection
  DAT_80085bbc = DAT_80085bbc & 0xff7fffff;

  // offset 8 of menuBox_warning
  DAT_80085be8 = DAT_80085be8 & 0xff7fffff;
  return;
}


// LoadSave_ToggleMode
void FUN_80048e2c(undefined4 param_1)

{
  // remember last row selected
  DAT_8008d978 = (ushort)param_1 & 0xf;

  // 0x00 - AdvNew (garage) mode
  // 0x10 - AdvLoad (main menu) mode
  // 0x20 - Green mode
  // 0x30 - Ghost mode
  // 0x40 - SlotSelected (exiting) mode
  DAT_8008d8f8 = (ushort)param_1 & 0xf0;

  DAT_8008d8fc = 0;
  DAT_8008d8fe = 0;
  DAT_8008d900 = 0;
  DAT_8008d902 = 0;
  DAT_8008d904 = 0;

  // LoadSave_UnMuteCursors
  FUN_80048de4();

  DAT_80085b9c = DAT_80085b9c & 0xffef;
  DAT_80085d44 = DAT_80085d44 & 0xffef;
  if (DAT_8008d8f8 == 0x20) {
    DAT_80085b9c = DAT_80085b9c | 0x10;
    DAT_80085d44 = DAT_80085d44 | 0x10;
  }

  // LoadSave_Init
  FUN_800485cc((int)(short)DAT_80085b9c);

  DAT_80085ba2 = DAT_8008d73c;
  DAT_8008d8fa = 0;
  return;
}


// LoadSave_InitAndDestroy
void FUN_80048edc(void)

{
  // LoadSave_Init
  FUN_800485cc((int)DAT_80085b9c);

  // LoadSave_Destroy
  FUN_800488e0();
  return;
}


// LoadSave_InputLogic
uint FUN_80048f0c(int param_1,short param_2,uint param_3)

{
  bool bVar1;
  ushort uVar2;
  ushort uVar3;
  short sVar4;
  uint uVar5;

  uVar5 = 0;

  // If you press D-Pad, Cross, Square, Triangle, Circle
  if ((DAT_8009a990 & 0x4007f) != 0)
  {
    if ((param_3 & 1) == 0)
	{
	  // get which row is selected
      uVar2 = *(ushort *)(param_1 + 0x1a);

      uVar3 = uVar2 - 2;

      if (
			(
				// If you press Up
				((DAT_8009a990 & 1) != 0) ||
				(
					uVar3 = uVar2 + 2,

					// If you press Down
					(DAT_8009a990 & 2) != 0
				)
			) ||
			(
				uVar3 = uVar2 ^ 1,

				// If you press Left or Right
				(DAT_8009a990 & 0xc) != 0
			)
		  )
	  {
        *(ushort *)(param_1 + 0x1a) = uVar3;
      }

	  // get row selected
      sVar4 = *(short *)(param_1 + 0x1a);

	  // if row is less than zero
	  if (sVar4 < 0)
	  {
		// make the new value zero
        *(undefined2 *)(param_1 + 0x1a) = 0;

		// refresh
        sVar4 = *(short *)(param_1 + 0x1a);
      }

	  // maybe?
	  // alter row selected, if there is no empty slot
      if (param_2 <= sVar4) {
        *(short *)(param_1 + 0x1a) = param_2 + -1;
      }


      if (*(ushort *)(param_1 + 0x1a) != uVar2)
	  {
		// OtherFX_Play
        FUN_80028468(0,1);
      }

      if (
			// If you do not press Cross or Circle
			((DAT_8009a990 & 0x50) == 0) ||
			(
				(
					param_2 == 0 &&

					// if you are not saving data
					(DAT_8008d978 != 1)
				)
			)
		 )
	  {
		// If you press Triangle or Square
        if ((DAT_8009a990 & 0x40020) != 0)
		{
		  // OtherFX_Play
          FUN_80028468(2,1);

          uVar5 = 1;

		  // row selected is -1, so we know to reinitialize
		  // the menu when we return to it next time
          *(undefined2 *)(param_1 + 0x1a) = 0xffff;
        }
      }

	  // If you do not press Cross or Circle
      else
	  {
		// OtherFX_Play
        FUN_80028468(1,1);

        uVar5 = 1;

        if (DAT_8008d47a == 1)
		{
		  // back to the first row
          *(undefined2 *)(param_1 + 0x1a) = 0;
        }
      }
    }

	// param_3 & 1
    else
	{
	  // If you press Triangle or Square
      bVar1 = (DAT_8009a990 & 0x40020) != 0;

	  // Triangle or Square
      if (bVar1)
	  {
		// OtherFX_Play
        FUN_80028468(2,1);

		// row selected is -1, so we know to reinitialize
		// the menu when we return to it next time
		*(undefined2 *)(param_1 + 0x1a) = 0xffff;
      }

      uVar5 = (uint)bVar1;

      if (
			((param_3 & 2) != 0) &&

			// If you press Cross or Circle
			((DAT_8009a990 & 0x50) != 0)
		 )
	  {
		// OtherFX_Play
        FUN_80028468(1,1);

        uVar5 = 1;
      }
    }

	// clear controller input (for menus)
    FUN_80046404();
  }
  return uVar5;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// Used to draw four Adventure Profiles
// Load, Save, Delete, etc, also used to
// draw Ghost Profiles in Time Trial

// LoadSave_AllProfiles_MenuBoxFuncPtr
void FUN_800490c4(int param_1)

{
  bool bVar1;
  bool bVar2;
  undefined *puVar3;
  undefined uVar4;
  short sVar5;
  undefined4 *puVar6;
  undefined4 *puVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  undefined4 *puVar11;
  int iVar12;
  undefined4 *puVar13;
  ushort uVar14;
  undefined4 uVar15;
  undefined4 uVar16;
  undefined4 uVar17;
  uint uVar18;
  ushort uVar19;
  undefined *puVar20;
  uint uVar21;
  short sVar22;
  int iVar23;
  uint uVar24;
  short local_58;
  short local_56 [3];
  ushort local_50;
  ushort local_48;
  short local_40;
  ushort local_38;
  ushort local_30;

  local_50 = 0;
  if ((*(ushort *)(param_1 + 0x14) & 0x10) != 0) {
    local_50 = 0x1d;
  }
  uVar24 = 0;

  // DAT_8009aa5c = number of ghosts saved
  local_48 = DAT_8009aa5c;

  bVar2 = false;
  local_40 = 0;
  if (DAT_8008d47a == 0) {
    DAT_8008d900 = 0;
  }
  if (DAT_8008d47a < 2) {
    DAT_8008d8fa = 0;
  }

  // LoadSave_UnMuteCursors
  FUN_80048de4();

  if (((DAT_8008d8fc != 0) || (DAT_8008d8fe != 0)) || (DAT_8008d8fa != 0))
  {
    // LoadSave_MuteCursors
	FUN_80048da0();
  }

  if (DAT_8008d900 != 0)
  {
	// If you press D-pad or Cross, Square, Triangle, Circle
    if ((DAT_8009a990 & 0x4007f) != 0) {

	  // If you dont press Up
      if ((DAT_8009a990 & 1) == 0) {

		// If you dont press Down
        if ((DAT_8009a990 & 2) == 0) {

		  // If you press Cross, Square, Triangle, Circle
          if ((DAT_8009a990 & 0x40070) != 0) {

			// If you dont press Cross or Circle
			// If you press Triangle or Square
            if ((DAT_8009a990 & 0x50) == 0)
			{
			  // OtherFX_Play
              FUN_80028468(2,1);
            }

			// If you press Cross or Circle
            else
			{
			  // OtherFX_Play
              FUN_80028468(1,1);

              if (DAT_80085d4a == 0) {
                bVar2 = true;
              }
            }
            DAT_8008d900 = 0;
          }
        }

		// If you press Down
		else {
          if (DAT_80085d4a < 1)
		  {
			// OtherFX_Play
            FUN_80028468(0,1);

            DAT_80085d4a = DAT_80085d4a + 1;
          }
        }
      }

	  // If you press Up
	  else
	  {
		// If there is room to move up
        if (0 < DAT_80085d4a)
		{
		  // OtherFX_Play
          FUN_80028468(0,1);

		  // Move up
          DAT_80085d4a = DAT_80085d4a + -1;
        }
      }

	  // clear controller input (for menus)
      FUN_80046404();

	  DAT_80085d76 = DAT_80085d4a;
    }
    goto LAB_800499e4;
  }

  // If this is "Choose a Ghost" screen in Time Trial
  if (DAT_8008d8f8 == 0x30)
  {
	// If you are saving
    if (DAT_8008d978 == 1)
	{
	  // if enough room remains on memory card to save ghost
      uVar24 = (uint)((int)DAT_8008d8ac < 0x3e00) ^ 1;

	  // bool is enough room left
	  local_40 = (short)uVar24;

	  // DAT_8009aa5c = number of ghosts saved
      uVar24 = DAT_8009aa5c + uVar24;

	  // DAT_8009aa5c = number of ghosts saved
      local_48 = DAT_8009aa5c;

	  // if attempted to save more than 7 ghosts
      if (7 < (int)(uVar24 * 0x10000) >> 0x10)
	  {
		// assume only 7 are saved
        uVar24 = 7;

		// can't save another
        local_40 = 0;
      }
    }

	// if you are loading
    else {
      local_40 = 1;

	  // number of ghsots saved, plus 1,
	  // which should be the first "empty" slot
      uVar24 = (uint)local_48 + 1;
    }

	// if your row selected is negative
    if (*(short *)(param_1 + 0x1a) < 0)
	{
	  // reset to zero
      *(undefined2 *)(param_1 + 0x1a) = 0;
    }

	// compare against the row selected
    if ((short)uVar24 <= *(short *)(param_1 + 0x1a)) {
      *(short *)(param_1 + 0x1a) = (short)uVar24 + -1;
    }
  }

  if (DAT_8008d8fa != 0) goto LAB_800499e4;
  iVar10 = 0;
  if ((DAT_8008d8f8 == 0x30) && (DAT_8008d900 == 0)) {
    iVar10 = (int)(short)uVar24;
    iVar23 = 0;
LAB_800495a0:

	// LoadSave_InputLogic
    iVar10 = FUN_80048f0c(param_1,iVar10,iVar23);
LAB_800495ac:
    iVar10 = iVar10 << 0x10;
  }
  else {
    if (DAT_8008d8f8 != 0x40) {
      uVar14 = 0;
      if (
			(DAT_8008d47a < 2) ||
			(
				(
					// if memcard has no room
					(DAT_8008d8ac < 0x1680 && (DAT_8008d928 == 0))

					&& (DAT_8008d978 == 1)
				)
			)
		  )
	  {
        uVar14 = 1;
      }
      if (DAT_8008d47a < 2) {
        uVar14 = uVar14 | 2;
      }
      iVar10 = 4;
      iVar23 = (int)(short)uVar14;
      goto LAB_800495a0;
    }
    if (DAT_8008d47a == 0) {

	  // If you press Cross or Circle
      if ((DAT_8009a990 & 0x50) != 0)
	  {
		// OtherFX_Play
        FUN_80028468(1,1);

        if (DAT_8008d918 == 0)
		{
		  // EndOfRace_TimeTrial_Relic_SaveHighScore
          FUN_8003a2b4();
        }

		// clear controller input (for menus)
        FUN_80046404();

        DAT_8008d8fa = 1;
        DAT_8008d8fc = 1;
        iVar10 = 0;
        goto LAB_800495b0;
      }
      goto LAB_800495ac;
    }
    if (DAT_8008d47a == 1) {
      iVar10 = 0;

	  // If you press Circle
      if ((DAT_8009a990 & 0x40) != 0)
	  {
		// clear controller input (for menus)
        FUN_80046404();

		// OtherFX_Play
		FUN_80028468(1,1);

		// load main ctr memcard file (adv, high score, etc)
        FUN_80047198(7);
		
        iVar10 = 0;
      }
    }
    else {
      if (
			(
				(
					// if enough room is on memcard to save
					(0x167f < DAT_8008d8ac) ||

					(DAT_8008d928 != 0)
				) ||

				(
					iVar10 = 0,

					// if you are not saving data
					DAT_8008d978 != 1
				)
			) &&
			(
				(
					DAT_8008d95c != 0 ||
					(iVar10 = 0, DAT_8008d928 != 0)
				)
			)
		)
	{
        if (DAT_8008d918 == 0)
		{
		  // EndOfRace_TimeTrial_Relic_SaveHighScore
          FUN_8003a2b4();
        }

		// save game options
		FUN_80043d24();

		// GAMEPROG_SaveCupProgress
		FUN_80026cf4();

		// GAMEPROG_SaveTimeTrialProgress
		// params are: memcardPtr, ram ptr
		// not "save", more like "sync" memcard and ram
        FUN_80026d7c(PTR_DAT_8008d474 + 0x144,&DAT_8008e6e8);

		// pointer to memcard GameProgress
        puVar7 = (undefined4 *)(PTR_DAT_8008d474 + 0x144);

        puVar13 = &DAT_8008e6e8;
        do {
          puVar11 = puVar13;
          puVar6 = puVar7;
          uVar15 = puVar11[1];
          uVar16 = puVar11[2];
          uVar17 = puVar11[3];
          *puVar6 = *puVar11;
          puVar6[1] = uVar15;
          puVar6[2] = uVar16;
          puVar6[3] = uVar17;
          puVar7 = puVar6 + 4;
          puVar13 = puVar11 + 4;
        } while (puVar11 + 4 != (undefined4 *)((int)&DAT_8008fb96 + 2));
        uVar15 = puVar11[5];
        uVar16 = puVar11[6];
        puVar6[4] = ram0x8008fb98;
        puVar6[5] = uVar15;
        puVar6[6] = uVar16;

		// MEMCARD_SetIcon to CrashHead
        FUN_8003d4e4(0);

		// save main CTR save file (3 = main file)
		FUN_80047198(3);
		
        DAT_8008d928 = 1;
        DAT_8008d8fa = 1;
        iVar10 = 0;
      }
    }
  }
LAB_800495b0:
  if (iVar10 == 0) goto LAB_800499e4;
  bVar1 = true;
  if (*(short *)(param_1 + 0x1a) == -1) {
    DAT_8008d8fa = 1;
    DAT_8008d8fc = 1;
    goto LAB_800499e4;
  }
  if (DAT_8008d47a == 0) {
    bVar1 = false;

	// if you are saving data
    if (DAT_8008d978 == 1) {
      DAT_8008d8fa = DAT_8008d978;
      DAT_8008d8fe = DAT_8008d978;
      goto LAB_80049624;
    }

	// if you are not loading data
    if (DAT_8008d978 != 0) goto LAB_80049624;

	// if you are handling time trial ghosts
    if (DAT_8008d8f8 == 0x30) {
      bVar1 = true;
      goto LAB_80049624;
    }

LAB_80049634:
    if (
			(
				(DAT_8008d47a != 1) &&

				// if not enough room on memcard
				(DAT_8008d8ac < 0x1680)
			) &&
			((DAT_8008d928 == 0 && (DAT_8008d978 == 1)))
		)
	{
      bVar1 = false;
    }
  }
  else {
LAB_80049624:
    if (DAT_8008d8f8 != 0x30) goto LAB_80049634;
  }
  if (!bVar1) goto LAB_800499e4;
  if (DAT_8008d47a == 1) 
  {
	// load main ctr file (adv, high scores, etc)
    FUN_80047198(7);
    
	goto LAB_800499e4;
  }
  if ((DAT_8008d95c == 0) && (DAT_8008d928 == 0)) goto LAB_800499e4;

  // if you are saving data
  if (DAT_8008d978 == 1)
  {
	// if you are handling time trial data
    if (DAT_8008d8f8 == 0x30)
	{
	  // if lap row is less than number of ghosts
      if (*(short *)(param_1 + 0x1a) < (short)DAT_8009aa5c) {
        DAT_80085d4a = 1;
        DAT_8008d900 = 1;
        DAT_80085d76 = 1;
        DAT_8009aa56 = *(short *)(param_1 + 0x1a);
        goto LAB_800499e4;
      }
    }

	// if you are handling adventure data
    else {
      if ((DAT_8008d902 == 0) && (DAT_8008d47a == 7)) {
        DAT_8008d902 = 1;
        goto LAB_800499e4;
      }

	  // 8008d474 is ptr to memcard data
      if ((-1 < *(short *)(PTR_DAT_8008d474 + (int)*(short *)(param_1 + 0x1a) * 0x50 + 0x2e)) &&
         ((int)*(short *)(param_1 + 0x1a) != (int)DAT_8008d96c)) {
        DAT_80085d4a = 1;
        DAT_80085d76 = 1;
        DAT_8008d900 = 1;
        goto LAB_800499e4;
      }
    }
    bVar2 = true;
    goto LAB_800499e4;
  }

  // If 0 or 1 (load, save)
  if (DAT_8008d978 < 2)
  {
	// if you are not loading data
    if (DAT_8008d978 != 0) goto LAB_800499e4;

	// If you are handling time trial ghosts
    if (DAT_8008d8f8 == 0x30) {
      if ((int)(short)uVar24 + -1 <= (int)*(short *)(param_1 + 0x1a)) {
        DAT_8008d8fa = 1;
        DAT_8008d8fe = 1;
        memset(DAT_8008d754,0,0x28);
        goto LAB_800499e4;
      }

	  // if track of ghost profile matches the track selected
      if ((int)*(short *)(&DAT_8009aa88 + (int)*(short *)(param_1 + 0x1a) * 0x34) ==

			// Level in Track Selection
          *(int *)(PTR_DAT_8008d2ac + 0x1eb0))
	  {
		// set selected ghost profile index
        DAT_8009aa5a = *(undefined2 *)(param_1 + 0x1a);

		// load ghost profile
        FUN_80047198(5);
		
        goto LAB_800499e0;
      }
    }

	// if you are handling adventure data
	else {
      if (DAT_8008d47a == 7) {
        DAT_8008d8fa = 1;
        DAT_8008d8fc = 1;
        goto LAB_800499e4;
      }

	  // 8008d474 is ptr to memcard data
      if (-1 < *(short *)(PTR_DAT_8008d474 + (int)*(short *)(param_1 + 0x1a) * 0x50 + 0x2e))
	  {
		// GAMEPROG_SaveTimeTrialProgress
		// params are: memcardPtr, ram ptr
		// not "save", more like "sync" memcard and ram
        FUN_80026d7c(PTR_DAT_8008d474 + 0x144,&DAT_8008e6e8);

		// 0x8fba4 is where the adventure profile (currently loaded) begins
        puVar13 = &DAT_8008fba4;

		// 8008d474 is ptr to memcard data
		puVar20 = PTR_DAT_8008d474 + (int)*(short *)(param_1 + 0x1a) * 0x50;
        puVar7 = (undefined4 *)(puVar20 + 4);
        do {
          uVar15 = puVar7[1];
          uVar16 = puVar7[2];
          uVar17 = puVar7[3];
          *puVar13 = *puVar7;
          puVar13[1] = uVar15;
          puVar13[2] = uVar16;
          puVar13[3] = uVar17;
          uVar17 = DAT_8008fbc8;
          uVar16 = DAT_8008fbc4;
          uVar15 = DAT_8008fbc0;
          puVar3 = PTR_DAT_8008d2ac;
          puVar7 = puVar7 + 4;
          puVar13 = puVar13 + 4;
        } while (puVar7 != (undefined4 *)(puVar20 + 0x54));

		// DAT_8008fbce is the Icon ID of the character you want
		// for the adventure mode character

		// Set P1 Character ID to Adventure Icon ID
        DAT_80086e84 = DAT_8008fbce;

		// related to name at OSK screen
        *(undefined4 *)(PTR_DAT_8008d2ac + 0x1d54) = DAT_8008fbbc;
        *(undefined4 *)(puVar3 + 0x1d58) = uVar15;
        *(undefined4 *)(puVar3 + 0x1d5c) = uVar16;
        *(undefined4 *)(puVar3 + 0x1d60) = uVar17;
        puVar3[0x1d64] = DAT_8008fbcc;

        DAT_8008d73c = *(undefined2 *)(param_1 + 0x1a);
        DAT_8008d8fa = 1;
        DAT_8008d8fe = 1;
        goto LAB_800499e4;
      }
    }

	// OtherFX_Play
    FUN_80028468(5,1);
  }
  
  // if 2 or 3 (delete or exit)
  else
  {
    if (

			(
				// if you are not erasing data
				(DAT_8008d978 != 2) ||

				// if this is time trial ghost data
				(DAT_8008d8f8 == 0x30)
			) ||
			(
				iVar10 = (int)*(short *)(param_1 + 0x1a) * 0x50,

				// 8008d474 is ptr to memcard data
				*(short *)(PTR_DAT_8008d474 + iVar10 + 0x2e) < 0
			)
			
		// skip deletion
		) goto LAB_800499e4;

	// At this point, assume you pressed Delete

	// GAMEPROG_NewProfile_InsideAdv
    FUN_80026cb8(PTR_DAT_8008d474 + iVar10 + 4);

	// MEMCARD_SetIcon to CrashHead
    FUN_8003d4e4(0);

	// save main CTR save file (3 = main file)
	FUN_80047198(3);
	
    DAT_8008d928 = 1;
LAB_800499e0:
    DAT_8008d8fa = 1;
  }
LAB_800499e4:
  if (((DAT_8008d47a == 7) && (DAT_8008d8fc == 0)) && (DAT_8008d8fe == 0)) {
    DAT_8008d8fa = 0;
    DAT_8008d900 = 0;
  }
  if (bVar2) {
    DAT_8008d902 = 0;
    if (DAT_8008d8f8 == 0x30) {
      uVar15 = 0x8ca00;

	  // If player structure pointer is not nullptr
      if (*(int *)(PTR_DAT_8008d2ac + 0x24ec) != 0)
	  {
										//player structure pointer
        uVar15 = *(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x24ec) + 0x514);
      }

	  // GhostData_SaveProfile
      FUN_80046c30(
					// index highlighted by cursor
					(int)*(short *)(param_1 + 0x1a),

					// Character ID Array
					(int)DAT_80086e84,

					// Level ID
					(int)*(short *)(PTR_DAT_8008d2ac + 0x1a10),

					// amount of time
					uVar15,

					// pointer to string typed in OSK
					PTR_DAT_8008d2ac + 0x1d54);

	  // index highlighted by cursor
      DAT_8009aa58 = *(undefined2 *)(param_1 + 0x1a);

      DAT_8009aa56 = -1;
      if (*(short *)(param_1 + 0x1a) < (short)DAT_8009aa5c) {
        DAT_8009aa56 = *(short *)(param_1 + 0x1a);
      }

	  // MEMCARD_SetIcon to GhostIcon
      FUN_8003d4e4(1);

	  // save ghost profile (6 = ghost)
      FUN_80047198(6);
	  
      DAT_8008d8fa = 1;
      *(uint *)(PTR_DAT_8008d2ac + 0x1d44) = *(uint *)(PTR_DAT_8008d2ac + 0x1d44) | 1;
    }
    else {
      DAT_8008d73c = *(undefined2 *)(param_1 + 0x1a);

	  // save game options
	  FUN_80043d24();

	  // GAMEPROG_SaveCupProgress
	  FUN_80026cf4();

	  // GAMEPROG_SaveTimeTrialProgress
	  // params are: memcardPtr, ram ptr
	  // not "save", more like "sync" memcard and ram
      FUN_80026d7c(PTR_DAT_8008d474 + 0x144,&DAT_8008e6e8);


	  // 0x8fba4 is where the adventure profile (currently loaded) begins
      puVar13 = &DAT_8008fba4;

	  // 8008d474 is ptr to memcard data
	  puVar7 = (undefined4 *)(PTR_DAT_8008d474 + (int)*(short *)(param_1 + 0x1a) * 0x50 + 4);

	  // keep doing this while the pointer does
	  // not get to the Ghost Recording Buffer
	  do {
        uVar15 = puVar13[1];
        uVar16 = puVar13[2];
        uVar17 = puVar13[3];
        *puVar7 = *puVar13;
        puVar7[1] = uVar15;
        puVar7[2] = uVar16;
        puVar7[3] = uVar17;
        puVar13 = puVar13 + 4;
        puVar7 = puVar7 + 4;

		// &DAT_8008fbf4 is where the
		// ghost recording is stored

      } while (puVar13 != &DAT_8008fbf4);

	  // 8008d474 is ptr to memcard data
      puVar7 = (undefined4 *)(PTR_DAT_8008d474 + 0x144);

	  puVar13 = &DAT_8008e6e8;

      do {
        puVar11 = puVar13;
        puVar6 = puVar7;
        uVar15 = puVar11[1];
        uVar16 = puVar11[2];
        uVar17 = puVar11[3];
        *puVar6 = *puVar11;
        puVar6[1] = uVar15;
        puVar6[2] = uVar16;
        puVar6[3] = uVar17;
        puVar7 = puVar6 + 4;
        puVar13 = puVar11 + 4;
      } while (puVar11 + 4 != (undefined4 *)((int)&DAT_8008fb96 + 2));
      uVar15 = puVar11[5];
      uVar16 = puVar11[6];
      puVar6[4] = ram0x8008fb98;
      puVar6[5] = uVar15;
      puVar6[6] = uVar16;

	  // MEMCARD_SetIcon to CrashHead
      FUN_8003d4e4(0);

	  // save main CTR save file (3 = main file)
	  FUN_80047198(3);
	  
      DAT_8008d928 = 1;
      DAT_8008d8fa = 1;
    }
    DAT_8008d904 = 0x3c;
  }
  if (*(short *)(param_1 + 0x1e) == 1) {
    bVar1 = false;
    if (((DAT_8008d8fa == 0) && (DAT_8008d95c != 0)) && ((DAT_8008d928 != 0 || (DAT_8008d47a == 8)))
       ) {
      bVar1 = true;
    }
    if (
		(
			// If you are loading data
			(DAT_8008d978 == 0) &&

			// if you are handling time trial ghosts
			(DAT_8008d8f8 == 0x30)
		) &&
       (((DAT_8008d47a == 9 || (DAT_8008d47a == 0)) && ((uVar24 & 0xffff) != 0)))) {
      bVar1 = true;
    }
    uVar14 = DAT_8008d47a;

	// If you are saving data
    if (DAT_8008d978 == 1)
	{
      if ((uint)DAT_8008d47a - 8 < 2) {
        bVar1 = false;
        if (bVar2) {
          uVar14 = 3;
        }

        else {

		  // If you are handling time trial ghosts
          if (DAT_8008d8f8 == 0x30)
		  {
            bVar1 = true;

			// if not enough room to save ghost
			if (((int)DAT_8008d8ac < 0x3e00) && (local_48 == 0)) {
              bVar1 = false;
              uVar14 = 6;
            }
          }

		  // If you are handling adventure profiles
          else
		  {
            bVar1 = true;

			// if not enough room to save profile
			if ((DAT_8008d8ac < 0x1680) && (DAT_8008d928 == 0)) {
              uVar14 = 6;
              bVar1 = false;
            }
          }
        }
      }
      if ((uVar14 == 7) && (DAT_8008d902 != 0)) {
        bVar1 = true;
      }
    }

	// LoadSave_Init
    FUN_800485cc((int)*(short *)(param_1 + 0x14));

    if ((bVar1) && (DAT_8008d8fa == 0)) {

	  // if this is ghost data
	  if (DAT_8008d8f8 == 0x30) {
        if (DAT_8008d900 == 0) {
          uVar21 = 0;
          iVar10 = strlen();
          local_30 = (ushort)(iVar10 != 0);

		  // If number of boxes (ghosts + "no ghost")
		  // is less than 7
          if ((short)uVar24 < 7)
		  {
			// Make the text big
            uVar15 = 1;

			iVar23 = 0x12;
            iVar10 = 0x10;

			// If you are not saving
			if (DAT_8008d978 != 1)
			{
			  // DAT_8008d878 + 0x33c
			  // INSERT ANY MEMORY CARD WITH GHOST DATA IN MEMORY CARD SLOT 1

			  // DecalFont_DrawMultiLine
              FUN_80022b34(*(undefined4 *)(DAT_8008d878 + 0x33c),0x100,0xbe,0x1ce,2,
                           (uint)local_50 | 0xffff8000);
            }
          }

		  // If there are 7 or more boxes
          else
		  {
			// Make the text small
            uVar15 = 2;

            iVar23 = 0x12;
            if (iVar10 != 0) {
              iVar23 = 0xc;
            }
            iVar10 = 8;
          }
          uVar18 = (uint)local_50;
          sVar22 = (short)(iVar23 + iVar10);

		  // Top line text

		  // CHOOSE A GHOST, or
		  // CHOOSE A MEMORY CARD SLOT
          FUN_80022878(*(undefined4 *)
                        ((int)*(short *)(&DAT_80085d14 + (int)DAT_8008d978 * 4) * 4 + DAT_8008d878),
                       0x100,(int)(short)iVar23,uVar15,uVar18 | 0xffff8000);

		  if (local_30 != 0) {
            sVar22 = (short)iVar10 + sVar22;

			// TO LOAD or
			// TO SAVE TO
			FUN_80022878(*(undefined4 *)
                          ((int)*(short *)(&DAT_80085d16 + (int)DAT_8008d978 * 4) * 4 + DAT_8008d878
                          ),0x100,(iVar23 + iVar10) * 0x10000 >> 0x10,uVar15,uVar18 | 0xffff8000);
          }

		  // pointer to first profile
          puVar20 = &DAT_8009aa60;

          local_38 = DAT_8009aa5c + local_40;
          iVar10 = 0;
          if (0 < (int)((uint)local_38 << 0x10)) {
            iVar23 = (int)(short)uVar24;
            do {
              if (uVar21 << 0x10 == (uint)local_48 << 0x10) {
                puVar20 = (undefined *)0x0;
              }
              if (((int)(uVar21 << 0x10) >> 0x10 < iVar23 + -1) || ((uVar21 & 1) != 0)) {
                iVar8 = (uVar21 & 1) * 0xd4 + 0x2e;
              }
              else {
                iVar8 = 0x98;
              }
              iVar12 = ((int)(uVar21 << 0x10) >> 0x10) - ((int)(uVar21 << 0x10) >> 0x1f) >> 1;
              if (6 < iVar23) {
                iVar9 = iVar12 * 0x2c;
              }
              else {
                iVar9 = iVar12 * 0x30;
              }
              sVar5 = (short)uVar21;
              uVar24 = SEXT24(*(short *)(param_1 + 0x14));
              if (6 < iVar23) {
                uVar24 = uVar24 | 0x40;
              }
              uVar18 = 0;
              if ((puVar20 != (undefined *)0x0) &&
														// Level in Track Selection
                 ((int)*(short *)(puVar20 + 0x28) != *(int *)(PTR_DAT_8008d2ac + 0x1eb0))) {

				// If you are not saving
				uVar18 = (uint)(DAT_8008d978 != 1);
              }

			  // Draw Profile
              FUN_80048a30(puVar20,iVar8,((int)sVar22 + 6 + (iVar9 - iVar12)) * 0x10000 >> 0x10,
                           (uint)(sVar5 == *(short *)(param_1 + 0x1a)),(int)sVar5,uVar24,

						   // If you are loading
						   (uint)(DAT_8008d978 == 0),uVar18);

			  uVar21 = uVar21 + 1;
              if ((int)sVar5 == iVar23) break;
              iVar10 = iVar10 + 1;

			  // Go to next profile
              puVar20 = puVar20 + 0x34;

            } while (iVar10 * 0x10000 < (int)((uint)local_38 << 0x10));
          }
        }
        else
		{
		  // set menubox width to zero
          local_56[0] = 0;

		  // get width of menubox
          FUN_80045c50(&DAT_80085d5c,local_56,1);

		  // draw menubox
		  FUN_80045db0(&DAT_80085d5c,0,0,(int)local_56[0]);

		  // Draw Ghost Profile
          FUN_80048a30(&DAT_8009aa60 + (int)DAT_8009aa56 * 0x34,0x9c,0x3c,0,0,
                       (int)*(short *)(param_1 + 0x14),0,0);
        }
      }

	  // if this is adventure data
	  else {
        if (DAT_8008d900 == 0) {
          iVar10 = strlen();
          uVar24 = (uint)local_50;

		  // Top line text
		  // CHOOSE A GAME,
		  // CHOOSE A MEMORY CARD SLOT, or
		  // CHOOSE A GAME
          FUN_80022878(*(undefined4 *)
                        ((int)*(short *)(&DAT_80085d88 + (int)DAT_8008d978 * 4) * 4 + DAT_8008d878),
                       0x100,(uint)(iVar10 == 0) << 3 | 0x12,1,uVar24 | 0xffff8000);

		  if (iVar10 != 0)
		  {
			// bottom line text
			// TO LOAD,
			// TO SAVE TO, or
			// TO DELETE
            FUN_80022878(*(undefined4 *)
                          ((int)*(short *)(&DAT_80085d8a + (int)DAT_8008d978 * 4) * 4 + DAT_8008d878
                          ),0x100,0x22,1,uVar24 | 0xffff8000);
          }

		  // loop counter
		  uVar21 = 0;

		  // determine even or odd
          uVar24 = 0;

		  // for uVar21 = 0; uVar21 < 4; uVar21++
		  // Draw all Adventure Profiels
          do {
            iVar10 = (int)(uVar21 << 0x10) >> 0x10;

			// 8008d474 is ptr to memcard data

			// Draw Adventure Profile
            FUN_80047ff8(PTR_DAT_8008d474 + iVar10 * 0x50 + 4,
                         (int)((uVar24 * 0xea + 0x1a) * 0x10000) >> 0x10,
                         ((iVar10 - ((int)(uVar21 << 0x10) >> 0x1f) >> 1) * 0x43 + 0x3c) * 0x10000
                         >> 0x10,(uint)(iVar10 == (int)*(short *)(param_1 + 0x1a)),iVar10,
                         (int)*(short *)(param_1 + 0x14));

			// increment loop counter
            uVar21 = uVar21 + 1;

			// determine even or odd (left side of screen or right)
            uVar24 = uVar21 & 1;
          } while ((int)(uVar21 * 0x10000) >> 0x10 < 4);
        }
        else
		{
		  // set width to zero
          local_58 = 0;

		  // Open "Overwrite" menuBox

		  // get width of menuBox
		  FUN_80045c50(&DAT_80085d30,&local_58,1);

		  // draw menuBox
          FUN_80045db0(&DAT_80085d30,0,0,(int)local_58);

		  // 8008d474 is ptr to memcard data

		  // Draw Adventure Profile
          FUN_80047ff8(PTR_DAT_8008d474 + (int)*(short *)(param_1 + 0x1a) * 0x50 + 4,0x92,0x3c,0,
                       (int)*(short *)(param_1 + 0x1a),(int)*(short *)(param_1 + 0x14));
        }

		if (
				// If you are saving data
				(DAT_8008d978 == 1) &&

				// if the save is out-dated
				(DAT_8008d944 != 0))
		{
		  // DAT_8008d878 + 0x340
		  // ...DATA ON MEMORY CARD IS OUT OF DATE...
          FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x340),0x100,0xc3,2,0xffff8003);
        }
      }
    }
    else {
      DAT_8008d900 = 0;
      if (((DAT_8008d8fa == 0) ||
          (((DAT_8008d964 == 0 || (DAT_8008d8fc != 0)) || (DAT_8008d8fe != 0)))) ||
         (DAT_8008d904 == 0)) {
        iVar10 = (int)(short)uVar14 * 4;
        uVar19 = *(ushort *)(iVar10 + -0x7ff7a4fc); // 0x80085B04
        if (((int)(short)uVar14 == 9) && (DAT_8008d8f8 == 0x40)) {
          uVar19 = 0xffff;
        }
        iVar23 = (uint)uVar19 << 0x10;
        if ((DAT_8008d8fa != 0) && (iVar23 = (uint)uVar19 << 0x10, DAT_8008d964 != 0)) {
          uVar19 = 0xffff;
          iVar23 = -0x10000;
        }
        if ((-1 < iVar23 >> 0x10) && (DAT_8008d8fe == 0))
		{
          if (
				(iVar23 >> 0x10 == 0x10f) &&

				// If you are saving data
				(DAT_8008d978 == 1)
			 )
		  {
			// Displays this string
			// WARNING:
			// on the screen
            uVar19 = 0x106;
          }

		  if (
				(
					// if you are handling adventure data
					(DAT_8008d8f8 != 0x30) &&
					(uVar14 == 9)
				) &&

				// If the save is out-dated
				(DAT_8008d944 != 0)
			 )
		  {
			// DAT_8008d878 + 0x340
			// ...DATA ON MEMORY CARD IS OUT OF DATE...
            FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x340),0x100,0xc3,2,0xffff8003);
          }

		  // 0xea
		  // SAVING TO MEMORY CARD...

          if (
				// If you are deleting data
				(DAT_8008d978 == 2) &&

				(uVar19 == 0xea)
			 )
		  {
			// DELETING GAME SLOT...
            uVar19 = 0xfc;
          }
          if (*(short *)(iVar10 + -0x7ff7a4fa) == 0)  // 0x80085B06
		  {
												// really just uVar19 * 4
            FUN_80022878(*(undefined4 *)(((int)((uint)uVar19 << 0x10) >> 0xe) + DAT_8008d878),0x108,
                         0x12,1,(uint)local_50 | 0xffff8000);
          }
          else {
            iVar23 = 0;
            uVar24 = (uint)local_50;
            iVar10 = 0;
            do {
              iVar10 = iVar10 >> 0x10;
              uVar15 = *(undefined4 *)(((short)uVar19 + iVar10) * 4 + DAT_8008d878);
              iVar8 = strlen();
              if (iVar8 != 0) {
                iVar8 = 2;
                if (iVar10 != 0) {
                  iVar8 = 4;
                }
                iVar12 = iVar10 * ((int)*(short *)(&DAT_80082368 + iVar8) + 2);
                iVar8 = iVar12 + 0x26;
                if (0 < iVar10) {
                  iVar8 = iVar12 + 0x2e;
                }

				// Draw big string
                uVar16 = 1;

                uVar21 = uVar24 | 0xffff8000;

                if (
						(
							((short)iVar23 == 0) ||
							(
								// Draw small string
								uVar16 = 2,

								(short)iVar23 == 0
							)
						) &&
						((DAT_8008d970 & 4) == 0)
					)
				{
                  uVar21 = 0xffff8003;
                }

				// Draw String
                FUN_80022878(uVar15,0x100,iVar8 * 0x10000 >> 0x10,uVar16,uVar21);
              }
              iVar23 = iVar23 + 1;
              iVar10 = iVar23 * 0x10000;
            } while (iVar23 * 0x10000 >> 0x10 < 9);
          }

		  // Draw 2D Menu rectangle background
          FUN_800457b0(&DAT_8008d4a4,(int)*(short *)(param_1 + 0x14),
                       *(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0));
        }
      }
      else {
        uVar15 = 0xffff8004;
        if ((DAT_8008d970 & 4) == 0) {
          uVar15 = 0xffff8000;
        }

		// DAT_8008d878 + 0x4f4
		// SAVE COMPLETED.
        FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x4f4),0x108,100,1,uVar15);
      }
    }
  }
  sVar22 = DAT_8008d904;
  if ((((DAT_8008d8fa != 0) && (DAT_8008d984 != 0)) &&
      ((DAT_8008d964 != 0 || ((DAT_8008d8fc != 0 || (DAT_8008d8fe != 0)))))) &&
     ((DAT_8008d8fa == 0 ||
      ((((DAT_8008d964 == 0 || (DAT_8008d8fc != 0)) || (DAT_8008d8fe != 0)) ||
       (sVar22 = DAT_8008d904 + -1, DAT_8008d904 == 0))))))
  {
	// LoadSave_InitAndDestroy
	FUN_80048edc();

	// LoadSave_StopMemcardAction
	FUN_800471ac();
	
    uVar16 = DAT_8008fbc4;
    uVar15 = DAT_8008fbc0;
    puVar20 = PTR_DAT_8008d2ac;

	// If you are handling Adventure Profiles
    if (DAT_8008d8f8 == 0x20)
	{
      if (
			(DAT_8008d8fc == 0) &&
			(DAT_8008d96c = *(short *)(param_1 + 0x1a),

			// If you are loading data
			DAT_8008d978 == 0)
		  )
	  {

		// 0x8fba4 is where the adventure profile (currently loaded) begins
		FUN_800265c0(&DAT_8008fba4);

		// LoadSave_LoadProfileFromHub_MenuBoxFuncPtr,
		// open menubox to load profile, while already on adv hub
        DAT_8008d924 = &DAT_80085c38;

		// DAT_8008fbd2
		// holds Level ID of the hub that your adventure
		// profile was saved in

		// Level in Track Selection
		// The level you want to load is the level you
		// Get from the Adventure Profile that you are loading
        *(int *)(PTR_DAT_8008d2ac + 0x1eb0) = (int)DAT_8008fbd2;
        DAT_80085b76 = 3;
        sVar22 = DAT_8008d904;
      }
      else
	  {
		// Change MenuBox to Green Save/Load screen
        DAT_8008d924 = &DAT_80085b5c;

        DAT_80085b76 = 3;
        sVar22 = DAT_8008d904;
      }
    }
    else {
      if (DAT_8008d8f8 < 0x21) {
        if (DAT_8008d8f8 == 0) {
          if (DAT_8008d8fc != 0)
		  {
			// Change active MenuBox to OSK
            DAT_8008d924 = &DAT_80085c0c;

			// OSK_RestoreName
            FUN_8004aa08(0);

            return;
          }
          DAT_8008d96c = *(short *)(param_1 + 0x1a);

		  // Level in Track Selection = 0x1a
		  // This means the level you want to load is N Sanity Beach Adventure Hub
		  // Which means you're creating a new adventure profile
          *(undefined4 *)(PTR_DAT_8008d2ac + 0x1eb0) = 0x1a;

		  // Garage_Leave
          FUN_8003074c();
        }
        else {
          if (DAT_8008d8f8 != 0x10) {
            return;
          }
          if (DAT_8008d8fc != 0)
		  {
			// TransitionTo_MainMenu_Returning
            FUN_800b4334();

			// GetMenuBox_AdvNewLoad
			iVar10 = FUN_800ad980();

            *(uint *)(iVar10 + 8) = *(uint *)(iVar10 + 8) & 0xfffffffb;
            return;
          }

          DAT_8008d96c = *(short *)(param_1 + 0x1a);

		  // play with the name you entered in OSK
		  *(undefined4 *)(PTR_DAT_8008d2ac + 0x1d54) = DAT_8008fbbc;
          *(undefined4 *)(puVar20 + 0x1d58) = uVar15;
          *(undefined4 *)(puVar20 + 0x1d5c) = uVar16;
          uVar4 = DAT_8008fbcc;
          *(undefined4 *)(puVar20 + 0x1d60) = DAT_8008fbc8;
          puVar20[0x1d64] = uVar4;
          uVar16 = DAT_8008fbc4;
          uVar15 = DAT_8008fbc0;
          *(undefined4 *)(puVar20 + 0x1d65) = DAT_8008fbbc;
          *(undefined4 *)(puVar20 + 0x1d69) = uVar15;
          *(undefined4 *)(puVar20 + 0x1d6d) = uVar16;
          uVar4 = DAT_8008fbcc;
          *(undefined4 *)(puVar20 + 0x1d71) = DAT_8008fbc8;
          puVar20[0x1d75] = uVar4;

		  // Track to load is N Sanity Beach Adventure HUB
          iVar10 = 0x1a;

		  // If your save profile has a Level ID of where
		  // you saved the profile (if you ever manually saved)
          if ((int)DAT_8008fbd2 != 0) {

			// Set iVar10 to the levl ID of the adventure hub
			// you last saved the profile in
            iVar10 = (int)DAT_8008fbd2;
          }

		  // set the level you want to load to iVar10
          *(int *)(PTR_DAT_8008d2ac + 0x1eb0) = iVar10;
        }
      }
      else {
        if (DAT_8008d8f8 != 0x30) {
          if (DAT_8008d8f8 != 0x40) {
            return;
          }

		  // LoadSave_Destroy
          FUN_800488e0();
          if (DAT_8008d918 == 0) {
            *(uint *)(PTR_DAT_8008d2ac + 0x1d44) = *(uint *)(PTR_DAT_8008d2ac + 0x1d44) & 0xf6ffffff
            ;
          }
          else {
            if (DAT_8008d8fc != 0)
			{
			  // Change active MenuBox to
			  // "Save Game?" "Yes/No"
              DAT_8008d924 = &DAT_80085a68;
              return;
            }
          }

		  // make MenuBox invisible
          FUN_800469c8(param_1);
          return;
        }

		// LoadSave_Destroy
        FUN_800488e0();

		// if you are saving data
        if (DAT_8008d978 == 1)
		{
          if (DAT_8008d8fc != 0)
		  {
			// Change active MenuBox to
			// end of race menu with "Save Ghost" option
            DAT_8008d924 = &DAT_800a0458;
            return;
          }

		  // Change active MenuBox to
		  // end of race menu without "Save Ghost" option
          DAT_8008d924 = &DAT_800a04a4;
          return;
        }
        if (DAT_8008d8fc != 0)
		{
		  // Erase ghost of previous race from RAM
          FUN_80028410();

		  // MM_TrackSelect_GetMenuBox
          DAT_8008d924 = (undefined *)FUN_800b0eac();

		  // set default track selection values
		  FUN_800affd0();
          return;
        }

		// Make P2 the character that is saved in the
		// header of the ghost that you will see in the race
        DAT_80086e86 = *(undefined2 *)(DAT_8008d754 + 6);
      }

	  // change active MenuBox to loadNonAdvTrack
      DAT_8008d924 = (undefined *)FUN_80043c04();

	  sVar22 = DAT_8008d904;
    }
  }
                    // WARNING: Read-only address (ram,0x8008fbce) is written
                    // WARNING: Read-only address (ram,0x8008fbd2) is written
  DAT_8008d904 = sVar22;
  return;
}


// OSK_RestoreName
void FUN_8004aa08(undefined2 param_1)

{
  undefined2 uVar1;

  DAT_8008d906 = param_1;

  // copy the last string you typed the last time you were in
  // the OSK menu, back into the menu, avoid typing a second time
  memmove(PTR_DAT_8008d2ac + 0x1d65,PTR_DAT_8008d2ac + 0x1d54,0x11);

  // move cursor to 'A' letter
  uVar1 = 0;

  // if string exists
  if (PTR_DAT_8008d2ac[0x1d65] != '\0')
  {
	// move cursor to 'save' button
    uVar1 = 0x3e9;
  }

  // set cursor position of OSK
  *(undefined2 *)(PTR_DAT_8008d2ac + 0x1d4c) = uVar1;

  return;
}


// OSK_DrawMenu (on-screen keyboard)
// called from funcptr function,
// as well as one other place
int FUN_8004aa60(ushort param_1)

{
  byte bVar1;
  short sVar2;
  uint uVar3;
  uint uVar4;
  byte *pbVar5;
  int iVar6;
  int iVar7;
  short sVar8;
  int iVar9;
  short sVar10;
  undefined local_58;
  undefined local_57;
  undefined local_56;
  undefined2 local_50;
  undefined2 local_4e;
  undefined2 local_4c;
  undefined2 local_4a;
  ushort local_48;
  short local_40;
  short local_38;
  int local_30;

  iVar9 = 0;
  local_38 = 0;

  // size of name entered is zero
  local_40 = 0;

  local_48 = param_1;
  _sVar2 = strlen();
  sVar2 = (short)_sVar2;

  // The string you typed for OSK
  pbVar5 = PTR_DAT_8008d2ac + 0x1d65;


  // if the string is not empty
  if (PTR_DAT_8008d2ac[0x1d65] != '\0') {
    bVar1 = *pbVar5;
    do
	{
	  // if character is valid
      if (2 < bVar1)
	  {
		// add to length?
        local_40 = local_40 + 1;
      }

	  // go to next character
      pbVar5 = pbVar5 + 1;

	  // get next character
      bVar1 = *pbVar5;

	  // till you hit nullptr
    } while (bVar1 != 0);
  }

  // character currently being highlighted in OSK
  _sVar2 = (int)*(short *)(PTR_DAT_8008d2ac + 0x1d4c);

  // characters in 3x13 grid are 0x0 to 0x26
  // "cancel" is 1000
  // "save" is 1001

  // if cursor doesn't know where to go, then
  // back to the 3x13 grid of characters
  if ((0x26 < _sVar2) && (_sVar2 < 1000)) {
    _sVar2 = 0x26;
  }

  // make a copy of the index that
  // the cursor is highlighting in the menu
  sVar8 = (short)_sVar2;

  DAT_8008d8f2 = DAT_8008d8f2 + 1;

  // loop counter
  iVar7 = 0;

  local_30 = 1;

  // Draw every character in each row (0 - 2)
  // for iVar7 = 0; iVar7 < 0xd; iVar7++
  do {
    iVar6 = 0;
    if (local_30 != 0) {

	  // Draw every character in each column (0 - 13)
	  // for iVar6 = 0; iVar6 < 0xd; iVar6++
      do
	  {
        sVar10 = 0;

		// if the character you are highlighting is the
		// one being drawn in this iteration of the loop
        if ((int)sVar8 == (iVar6 + iVar7 * 0xd) * 0x10000 >> 0x10)
		{
		  // make the text flash colors
          sVar10 = (short)(((uint)DAT_8008d8f2 & 1) << 2);
        }

		// 80085d94
		// Every character A-Z then 0-9

		// uVar4 is the character you are highlighting
        uVar4 = SEXT24(u_ABCDEFGHIJKLMNOPQRSTUVWXYZ012345_80085d94

						// row * 0xd + column, get the character to
						// draw in iteration of the loop
					   [(int)(short)iVar7 * 0xd + (int)(short)iVar6]);


		uVar3 = uVar4 & 0xff00;
        if ((uVar4 & 0xff00) == 0x1000) {
          uVar4 = uVar4 & 0xff;
          uVar3 = 0;
        }
        if (uVar3 == 0) {
          local_57 = 0;
          local_58 = (char)uVar4;
        }
        else {
          local_56 = 0;
          local_58 = (char)((uVar4 << 0x10) >> 0x18);
          local_57 = (char)uVar4;
        }

		// draw character
        FUN_80022878(&local_58,((int)(short)iVar6 * 0x16 + 0x74) * 0x10000 >> 0x10,
                     ((int)(short)iVar7 * 0x12 + 0x58) * 0x10000 >> 0x10,1,(int)sVar10);

		// iterate loop counter
		iVar6 = iVar6 + 1;

	  } while (iVar6 * 0x10000 >> 0x10 < 0xd);
    }

	// iterate loop counter
    iVar7 = iVar7 + 1;

  } while (iVar7 * 0x10000 >> 0x10 < 3);

  // DAT_8008d878 + 0x4f8
  // PLEASE ENTER YOUR NAME
  FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x4f8),0x100,0x2c,1,0xffff8000);

  // PTR_DAT_8008d2ac + 0x1d65
  // The string you typed for OSK
  FUN_80022878(PTR_DAT_8008d2ac + 0x1d65,0xc0,0x44,1,4);

  if (((DAT_8008d8f2 & 2) != 0) && (sVar2 < 0x10))
  {
	// DecalFont_GetLineWidth
    iVar7 = FUN_800224d0(PTR_DAT_8008d2ac + 0x1d65,1);

	// DAT_8008d4ac
	// _

	// This draws the blinking red underscore that comes
	// after the string you entered in OSK
	FUN_80022878(&DAT_8008d4ac,(iVar7 + 0xc0) * 0x10000 >> 0x10,0x44,1,0);
  }
  iVar7 = (int)sVar8;
  uVar3 = 0;
  if (iVar7 == 0x3e9) {
    uVar3 = ((uint)DAT_8008d8f2 & 1) << 2;
  }

  // Draw String
  FUN_80022878(*(undefined4 *)(((int)((uint)local_48 << 0x10) >> 0xe) + DAT_8008d878),0x1d8,0x96,1,
               uVar3 | 0x4000);
  sVar10 = 0;
  if (iVar7 == 1000) {
    sVar10 = (short)(((uint)DAT_8008d8f2 & 1) << 2);
  }

  // DAT_8008d878 + 0x504
  // CANCEL
  FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x504),0x28,0x96,1,(int)sVar10);

  local_50 = 0x20;
  local_4c = 0x1c0;
  local_4e = 0x3e;
  local_4a = 2;

  // DrawRectangle (transparent)
  FUN_80044f90(&local_50,&DAT_8008d438,0x20,
               *(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0));
  local_4e = 0x27;
  local_4a = 0x82;

  // Draw 2D Menu rectangle background
  FUN_800457b0(&local_50,0,*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0));

  // If you dont press D-pad
  if ((DAT_8009a990 & 0xf) == 0) {

	// If you dont press Start
    if ((DAT_8009a990 & 0x1000) == 0) {

	  // If you dont press Triangle or Square
      if ((DAT_8009a990 & 0x40020) == 0) {

		// If you press Cross or Circle
        if ((DAT_8009a990 & 0x50) != 0) {
          if (iVar7 == 0x26) {
            iVar9 = 2;
            if ((int)sVar2 == 0) {
              iVar9 = 2;
            }
            else {
              PTR_DAT_8008d2ac[(int)sVar2 + 0x1d64] = 0;
            }
          }
          else {

			// If you hit any character within the 3x13 grid
            if (iVar7 < 0x26) {
              uVar3 = (uint)(ushort)u_ABCDEFGHIJKLMNOPQRSTUVWXYZ012345_80085d94[iVar7];
              if (((int)u_ABCDEFGHIJKLMNOPQRSTUVWXYZ012345_80085d94[iVar7] & 0xff00U) == 0x1000) {
                uVar3 = uVar3 & 0xff;
              }

			  // if name entered is less than 8 characters long
              if (local_40 < 8)
			  {
                sVar10 = sVar2;
                if ((uVar3 & 0xff00) != 0) {
                  sVar10 = sVar2 + 1;

				  // append string of your name
                  PTR_DAT_8008d2ac[(int)sVar2 + 0x1d65] = (char)((uVar3 << 0x10) >> 0x18);
                }

                iVar9 = 1;

				// replace existing character?
				PTR_DAT_8008d2ac[(int)sVar10 + 0x1d65] = (char)uVar3;
              }

			  // if name length is too long
              else {
                iVar9 = 5;
              }
            }

			// if you are not in the 3x13 grid
            else {

			  // If you hit "Save" with ID 1000 (0x3e9)
              if (iVar7 == 0x3e9) {
                iVar9 = 2;
                local_38 = 1;

				// copy the string you typed at OSK so it can be
				// used again later, when is time to enter your name again
                memmove(PTR_DAT_8008d2ac + 0x1d54,PTR_DAT_8008d2ac + 0x1d65,0x11);
              }

			  // If you did not hit "Save", which would
			  // only be if you hit "Cancel" instead
              else {
                iVar9 = 0;
                if (iVar7 != 1000) goto LAB_8004b0dc;
                iVar9 = 3;
                local_38 = -1;
              }

			  // clear controller input (for menus)
              FUN_80046404();
            }
          }
        }
      }

	  // If you press Triangle or Square
	  else {
        _sVar2 = (int)sVar2;
        iVar9 = 0;
        if (_sVar2 != 0) {
          PTR_DAT_8008d2ac[_sVar2 + 0x1d64] = 0;
          iVar9 = 4;
          if ((byte)(PTR_DAT_8008d2ac + _sVar2 + -2)[0x1d65] < 3) {
            (PTR_DAT_8008d2ac + _sVar2 + -2)[0x1d65] = 0;
          }
        }
      }
    }

	// If you press Start
	else {
      iVar9 = 3;
      if (iVar7 == 1000) {
        local_38 = -1;
      }
      else {
        sVar8 = 1000;
        iVar9 = 1;
      }
    }
  }

  // If you dont press D-pad
  else {

	// If you press Up
    if ((DAT_8009a990 & 1) != 0) {
      _sVar2 = _sVar2 + -0xd;
    }

	// If you press Down
    if ((DAT_8009a990 & 2) != 0) {
      _sVar2 = _sVar2 + 0xd;
    }

	// If you press Left
    if ((DAT_8009a990 & 4) != 0) {
      _sVar2 = _sVar2 + -1;
    }

    iVar9 = _sVar2 << 0x10;

	// If you press Right
	if ((DAT_8009a990 & 8) != 0) {
      _sVar2 = _sVar2 + 1;
      iVar9 = _sVar2 * 0x10000;
    }

    iVar7 = _sVar2 << 0x10;
    if (iVar9 < 0) {
      _sVar2 = 0x3e9;
      iVar7 = 0x3e90000;
    }

	sVar8 = (short)_sVar2;

    uVar3 = _sVar2 - 500;
    if ((0x26 < iVar7 >> 0x10) && (uVar3 = _sVar2 - 500, iVar7 >> 0x10 < 500)) {
      sVar8 = 0x3e9;
      uVar3 = 0x1f5;
    }
    if ((uVar3 & 0xffff) < 500) {
      sVar8 = 0x26;
    }
    iVar9 = 1;

	// if cursor goes too far
    if (0x3ea < sVar8)
	{
	  // go back to 'A' letter
      sVar8 = 0;
    }
  }
LAB_8004b0dc:

// if you want to play a sound
  if (iVar9 != 0)
  {
	// OtherFX_Play
											// 0x80085DE4
    FUN_80028468((uint)*(ushort *)(iVar9 * 4 + -0x7ff7a21c),1);
  }

  // update cursor position
  *(short *)(PTR_DAT_8008d2ac + 0x1d4c) = sVar8;

  return (int)local_38;
}


// OSK_MenuBoxFuncPtr (on-screen keyboard)
void FUN_8004b144(int param_1)

{
  short sVar1;

  // OSK_DrawMenu
  sVar1 = FUN_8004aa60(0x13f);

  *(short *)(param_1 + 0x1a) = sVar1;
  if (sVar1 != 0) {
    if (DAT_8008d906 == 1) {
      if (sVar1 < 0)
	  {
		// Change active MenuBox to
		//  end of race menu with "Save Ghost" option
        DAT_8008d924 = &DAT_800a0458;
      }
      else
	  {
		// Set Load/Save to Ghost mode, with slot 1 selected
        FUN_80048e2c(0x31);

		// Change active MenuBox to GhostSelection
		DAT_8008d924 = &DAT_80085bb4;
      }
    }
    else {
      if ((DAT_8008d906 < 2) && (DAT_8008d906 == 0)) {
        if (sVar1 < 0)
		{
		  // ptrDesiredMenuBox = CS_Garage_GetMenuBox
          DAT_8008d924 = (undefined *)FUN_800b854c();

		  // CS_Garage_ZoomOut (1 = just hit OSK cancel)
          FUN_800b7784(1);
        }
        else {

		  // make backup of name entered
		  DAT_8008fbbc = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1d54);
          DAT_8008fbc0 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1d58);
          DAT_8008fbc4 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1d5c);
          DAT_8008fbc8 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1d60);
          DAT_8008fbcc = PTR_DAT_8008d2ac[0x1d64];

		  // Set Load/Save to New Adventure mode
          FUN_80048e2c(1);

		  // Change active menuBox to draw four adv profiles
          DAT_8008d924 = &DAT_80085b88;
        }
      }
    }
  }
  return;
}


// PrixSaveBox_Activate (beta 'Arcade' was Gran Prix)
// Only called from 233, when you are at the cup
// podium and you need to save progress
void FUN_8004b230(undefined2 param_1)

{
  // string index to print
  DAT_8008d938 = param_1;

  // 80085a68 is where a menu buffer is stored
  // for "Save Game", "yes / no"

  // Draw the menu
  FUN_80046990(&DAT_80085a68);

  return;
}


// PrixSaveBox_MenuBoxFuncPtr (beta 'Arcade' was Gran Prix)
void FUN_8004b258(int param_1)

{
  short sVar1;

  if (*(short *)(param_1 + 0x1e) == 1)
  {
	// if there is a string to print
    if ((int)DAT_8008d938 != 0)
	{
	  // print "Save your cup progress?"
	  // and optionally "New Battle Arena Opened!"

	  // DecalFont_DrawMultiLine
      FUN_80022b34(*(undefined4 *)((int)DAT_8008d938 * 4 + DAT_8008d878),0x100,0x3c,0x1cc,1,
                   0xffff8000);
    }
  }
  else {
    sVar1 = *(short *)(param_1 + 0x1a);
    if (sVar1 == 0) {
      DAT_8008d918 = 1;

	  // Set Load/Save to "Slot Selected" mode
      FUN_80048e2c(0x41);

	  // Change active MenuBox to Warning
      DAT_8008d924 = &DAT_80085be0;
    }
    else {
      if (sVar1 < 1) {
        if (sVar1 != -1) {
          return;
        }
      }
      else {
        if (sVar1 != 1) {
          return;
        }
      }

	  // Make the menu disappear
      FUN_800469c8();
    }
  }
  return;
}


// RCNT_Init
void FUN_8004b31c(void)

{
  EnterCriticalSection();
  StopRCnt(0xf2000001);
  SetRCnt(0xf2000001,0xffff,0x2000);
  StartRCnt(0xf2000001);
  ExitCriticalSection();
  return;
}


// RCNT_Destroy
void FUN_8004b370(void)

{
  EnterCriticalSection();
  StopRCnt(0xf2000001);
  ExitCriticalSection();
  return;
}


// RCNT_GetTime_Total
// not milliseconds
int FUN_8004b3a4(void)

{
  long lVar1;
  int iVar2;

  // current system timer,
  // updated on every vsync
  iVar2 = DAT_8008d988;

  // time past since vsync
  lVar1 = GetRCnt(0xf2000001);

  // if less than 100 units past,
  // which is less than 0.006 seconds
  if (lVar1 < 100)
  {
	// do nothing?
    iVar2 = DAT_8008d988;
  }

  // 0x147e = 5246
  // (timeAtVsync + timeSinceVsync) / 5
  return ((iVar2 + lVar1) * 1000) / 0x147e;
}


// RCNT_GetTime_Elapsed
int FUN_8004b41c(int param_1,int *param_2)

{
  int iVar1;

  // RCNT_GetTime_Total
  iVar1 = FUN_8004b3a4();

  // if pointer exists, write to it
  if (param_2 != (int *)0x0) {
    *param_2 = iVar1;
  }

  if (iVar1 < param_1) {
    iVar1 = iVar1 + 0xc7e18;
  }

  // sysclock current, minus
  // sysclock previous, equals
  // elapsed time
  return iVar1 - param_1;
}


// draws heat effect as found in tiger temple (fire) or behind rockets
void FUN_8004b470(int *param_1,int param_2,int param_3,int param_4,undefined4 param_5)

{
  bool bVar1;
  short sVar2;
  int iVar3;
  undefined4 uVar4;
  uint uVar5;
  int iVar6;
  undefined4 uVar7;
  uint uVar8;
  undefined4 uVar9;
  int iVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  int iVar14;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  uint uVar15;
  undefined4 unaff_s7;
  uint uVar16;
  uint uVar17;
  int iVar18;
  undefined4 unaff_s8;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];
  
  iVar3 = 0x1f800000;
  DAT_1f800020 = &DAT_8008cf6c;
  param_4 = param_4 + -1;
  uVar4 = *(undefined4 *)(param_3 + 0xc);
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800024 = (undefined *)register0x00000074;
  DAT_1f800028 = unaff_s8;
  DAT_1f80002c = unaff_retaddr;
  DAT_1f800030 = (int)param_1;
  if (param_1 != (int *)0x0) {
    DAT_1f800038 = param_5;
    iVar18 = 0xc;
    DAT_1f80005c._2_2_ = 0;
    do {
      uVar11 = *(uint *)(param_2 + 0x28);
      uVar12 = *(uint *)(param_2 + 0x30);
      uVar5 = *(uint *)(param_2 + 0x3c);
      iVar6 = *(int *)(param_2 + 0x40);
      uVar7 = *(undefined4 *)(param_2 + 0x44);
      gte_ldL11L12(uVar11);
      gte_ldL13L21(*(undefined4 *)(param_2 + 0x2c));
      gte_ldL22L23(uVar12);
      gte_ldL31L32(*(undefined4 *)(param_2 + 0x34));
      gte_ldL33(*(undefined4 *)(param_2 + 0x38));
      gte_ldbkdir(uVar5,iVar6,uVar7);
      gte_ldR11R12(0x1000);
      gte_ldR13R21(0);
      gte_ldR31R32(0);
      gte_ldR33(0x1000);
      gte_ldtr(0,0,0);
      sVar2 = *(short *)(param_2 + 0x22);
      uVar9 = *(undefined4 *)(param_2 + 0x18);
      *(int *)(iVar3 + 0x48) = (int)*(short *)(param_2 + 0x20) << 0xf;
      *(int *)(iVar3 + 0x4c) = (int)sVar2 << 0xf;
      gte_ldH(uVar9);
      sVar2 = *(short *)(param_2 + 0x1e);
      *(undefined2 *)(iVar3 + 0x50) = *(undefined2 *)(param_2 + 0x1c);
      *(short *)(iVar3 + 0x52) = sVar2 + (short)*(undefined4 *)(iVar3 + 0x38);
      sVar2 = *(short *)(param_2 + 0x22);
      *(short *)(iVar3 + 0x54) = *(short *)(param_2 + 0x20) + -1;
      *(short *)(iVar3 + 0x56) = sVar2 + -1;
      iVar14 = *(int *)(param_2 + 0x20);
      while (param_1 != (int *)0x0) {
        gte_ldVXY0(param_1[9] >> 8 & 0xffffU | (param_1[0xb] >> 8) << 0x10);
        gte_ldVZ0(param_1[0xd] >> 8);
        uVar15 = (uint)*(byte *)((int)param_1 + 0x3d);
        uVar16 = (uint)*(byte *)((int)param_1 + 0x45);
        gte_llv0bk_b();
        uVar17 = (uint)*(byte *)((int)param_1 + 0x4d);
        *(uint *)(iVar3 + 0x44) =
             (uint)CONCAT12(*(undefined *)((int)param_1 + 0x6d),
                            CONCAT11(*(undefined *)((int)param_1 + 0x65),
                                     *(undefined *)((int)param_1 + 0x5d)));
        read_mt(uVar5,iVar6,uVar7);
        gte_ldVZ0(uVar7);
        gte_ldVZ1(uVar7);
        gte_ldVZ2(uVar7);
        gte_ldR22R23(0x1000);
        gte_ldOFX(*(undefined4 *)(iVar3 + 0x48));
        gte_ldOFY(*(undefined4 *)(iVar3 + 0x4c));
        gte_ldVXY0(iVar6 << 0x10 | uVar5 & 0xffff);
        gte_rtps_b();
        uVar8 = (int)(uVar15 * 0xb50) >> 0xc;
        uVar5 = gte_stSXY2();
        iVar10 = gte_stFLAG();
        iVar6 = (int)uVar5 >> 0x10;
        uVar5 = uVar5 & 0xffff;
        if (-1 < iVar10 << 0xe) {
          gte_stSXY2();
          gte_ldR22R23(0xa00);
          gte_ldOFX(0);
          gte_ldOFY(0);
          gte_ldVXY0(uVar15);
          gte_ldVXY1(uVar15 << 0x10);
          gte_ldVXY2(uVar8 | uVar8 << 0x10);
          gte_rtpt_b();
          uVar8 = (int)(uVar16 * 0xb50) >> 0xc;
          uVar15 = gte_stSXY0();
          uVar13 = gte_stSXY1();
          gte_ldVXY0(uVar16);
          if ((int)(uVar15 - 0x80) < 0) {
            gte_ldVXY1(uVar16 << 0x10);
            gte_ldVXY2(uVar8 | uVar8 << 0x10);
            uVar4 = FUN_8004b914(uVar5,iVar6);
            if (((0 < ((int)uVar12 >> 0x10) + -0x18) &&
                (uVar8 = ~(uVar11 - iVar14 | uVar15 - iVar14 | uVar12 - iVar14 | uVar13 - iVar14) |
                         uVar11 & uVar15 & uVar12 & uVar13, -1 < (int)uVar8)) &&
               (-1 < (int)(uVar8 << 0x10))) {
              FUN_8004b94c();
              gte_rtpt_b();
              uVar5 = (int)(uVar17 * 0xb50) >> 0xc;
              gte_stSXY0();
              gte_stSXY1();
              gte_ldVXY0(uVar17);
              gte_ldVXY1(uVar17 << 0x10);
              gte_ldVXY2(uVar5 | uVar5 << 0x10);
              FUN_8004b914();
              FUN_8004b94c();
              gte_rtpt_b();
              gte_stSXY0();
              gte_stSXY1();
              FUN_8004b914();
              FUN_8004b94c();
              FUN_8004b9cc();
              FUN_8004bd84(iVar3 + 8,iVar3 + 4);
              FUN_8004c348(iVar3 + 4,iVar3 + 8);
              FUN_8004b9cc();
              FUN_8004bd84(iVar3 + 8,iVar3 + 0xc);
              FUN_8004c348(iVar3 + 0xc,iVar3 + 8);
              FUN_8004b9cc();
              FUN_8004bd84(iVar3 + 0xc,iVar3 + 0x10);
              FUN_8004c348(iVar3 + 0xc,iVar3 + 0x10);
              FUN_8004bd84(iVar3 + 0x10,iVar3 + 0x14);
              FUN_8004c348(iVar3 + 0x14,iVar3 + 0x10);
              FUN_8004b9cc();
              FUN_8004bbe8(iVar3 + 0x18,iVar3 + 0x14);
              FUN_8004c134(iVar3 + 0x18,iVar3 + 0x14);
              FUN_8004b9cc();
              FUN_8004ba4c(iVar3 + 0x1c,iVar3 + 0x18);
              FUN_8004bf20(iVar3 + 0x1c,iVar3 + 0x18);
              FUN_8004b9cc();
              FUN_8004ba4c(iVar3 + 0x20,iVar3 + 0x1c);
              FUN_8004bf20(iVar3 + 0x20,iVar3 + 0x1c);
              FUN_8004b9cc();
              FUN_8004bbe8(iVar3 + 0x20,iVar3 + 4);
              uVar5 = iVar3 + 0x20;
              iVar6 = iVar3 + 4;
              uVar4 = FUN_8004c134(uVar5,iVar6);
            }
          }
        }
        iVar18 = iVar18 + -1;
        param_1 = (int *)*param_1;
        if (iVar18 < 1) goto LAB_8004b8d8;
      }
      param_1 = *(int **)(iVar3 + 0x30);
      param_2 = param_2 + 0x110;
      bVar1 = 0 < param_4;
      param_4 = param_4 + -1;
    } while (bVar1);
  }
LAB_8004b8d8:
  *(undefined4 *)(param_3 + 0xc) = uVar4;
  return;
}


// Should not be empty, Ghidra fail
void FUN_8004b914(void)

{
  // For some reason, Ghidra gives no C code for this

                             **************************************************************
                             *                          FUNCTION                          *
                             **************************************************************
                             undefined FUN_8004b914()
             undefined         v0:1           <RETURN>
                             FUN_8004b914                                    XREF[3]:     FUN_8004b470:8004b6c0(c),
                                                                                          FUN_8004b470:8004b74c(c),
                                                                                          FUN_8004b470:8004b790(c)
        8004b914 23 58 8c 00     subu       t3,a0,t4
             assume gp = <UNKNOWN>
        8004b918 21 60 8c 00     addu       t4,a0,t4
        8004b91c ff ff 6b 31     andi       t3,t3,0xffff
        8004b920 ff ff 8c 31     andi       t4,t4,0xffff
        8004b924 25 58 63 01     or         t3,t3,v1
        8004b928 25 60 83 01     or         t4,t4,v1
        8004b92c 03 74 0e 00     sra        t6,t6,0x10
        8004b930 23 68 ae 00     subu       t5,a1,t6
        8004b934 21 70 ae 00     addu       t6,a1,t6
        8004b938 00 6c 0d 00     sll        t5,t5,0x10
        8004b93c 00 74 0e 00     sll        t6,t6,0x10
        8004b940 25 68 a4 01     or         t5,t5,a0
        8004b944 08 00 e0 03     jr         ra
        8004b948 25 70 c4 01     _or        t6,t6,a0

  return;
}



void FUN_8004b94c(int param_1,int param_2,undefined4 param_3,int param_4)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  undefined4 in_t3;
  undefined4 in_t4;
  undefined4 in_t5;
  undefined4 in_t6;

  uVar2 = getCopReg(2,0x7000);
  *(undefined4 *)(param_4 + 0x1c) = in_t3;
  *(undefined4 *)(param_4 + 0xc) = in_t4;
  *(undefined4 *)(param_4 + 4) = in_t5;
  *(undefined4 *)(param_4 + 0x14) = in_t6;
  uVar1 = uVar2 & 0xffff;
  iVar3 = (int)uVar2 >> 0x10;
  *(uint *)(param_4 + 0x20) = param_1 - uVar1 & 0xffff | (param_2 - iVar3) * 0x10000;
  *(uint *)(param_4 + 8) = param_1 + uVar1 & 0xffff | (param_2 - iVar3) * 0x10000;
  *(uint *)(param_4 + 0x18) = param_1 - uVar1 & 0xffff | (param_2 + iVar3) * 0x10000;
  *(uint *)(param_4 + 0x10) = param_1 + uVar1 & 0xffff | (param_2 + iVar3) * 0x10000;
  return;
}



void FUN_8004b9cc(void)

{
  int in_at;
  uint in_v1;
  uint in_t0;

  if ((int)in_v1 < 0) {
    in_v1 = 0;
  }
  else {
    if (-1 < (int)(in_v1 - *(ushort *)(in_at + 0x54))) {
      in_v1 = (uint)*(ushort *)(in_at + 0x54);
    }
  }
  if ((int)in_t0 < 0) {
    in_t0 = 0;
  }
  else {
    if (-1 < (int)(in_t0 - *(ushort *)(in_at + 0x56))) {
      in_t0 = (uint)*(ushort *)(in_at + 0x56);
    }
  }
  *(ushort *)(in_at + 0x62) =
       (ushort)((in_v1 + (int)*(short *)(in_at + 0x50) & 0x3ff) >> 6) |
       (ushort)((in_t0 + (int)*(short *)(in_at + 0x52) & 0x100) >> 4) | 0x100;
  return;
}



// WARNING: Removing unreachable block (ram,0x8004bb5c)

uint * FUN_8004ba4c(int param_1,int param_2)

{
  ushort uVar1;
  ushort uVar2;
  int in_at;
  uint *in_v0;
  char cVar3;
  char cVar4;
  uint uVar5;
  uint uVar6;
  uint *unaff_s6;
  char unaff_s7;

  uVar1 = *(ushort *)(in_at + 0x68);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(in_at + 0x6a);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x5c) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x5d) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_1 + 0xb0);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_1 + 0xb2);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x60) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x61) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_2 + 0xb0);
  cVar3 = (char)uVar1;
  cVar4 = (char)*(ushort *)(param_2 + 0xb2);
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if (-1 < (int)((uint)*(ushort *)(param_2 + 0xb2) - (uint)*(ushort *)(in_at + 0x56))) {
    cVar4 = (char)*(undefined2 *)(in_at + 0x56);
  }
  *(char *)(in_at + 100) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x65) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar5 = *(uint *)(param_1 + 0x8c);
  uVar6 = *(uint *)(param_2 + 0x8c);
  in_v0[2] = *(uint *)(in_at + 0x68);
  in_v0[4] = uVar5;
  in_v0[6] = uVar6;
  in_v0[1] = *(uint *)(in_at + 0x44) | 0x24000000;
  uVar5 = *(uint *)(in_at + 0x60);
  uVar6 = *(uint *)(in_at + 100);
  in_v0[3] = *(uint *)(in_at + 0x5c);
  in_v0[5] = uVar5;
  in_v0[7] = uVar6;
  *in_v0 = *unaff_s6 | 0x7000000;
  *unaff_s6 = (uint)in_v0 & 0xffffff;
  return in_v0 + 8;
}



// WARNING: Removing unreachable block (ram,0x8004bcf8)

uint * FUN_8004bbe8(int param_1,int param_2)

{
  ushort uVar1;
  ushort uVar2;
  int in_at;
  uint *in_v0;
  char cVar3;
  char cVar4;
  uint uVar5;
  uint uVar6;
  uint *unaff_s6;
  char unaff_s7;

  uVar1 = *(ushort *)(in_at + 0x68);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(in_at + 0x6a);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x5c) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x5d) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_1 + 0xb0);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_1 + 0xb2);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x60) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x61) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_2 + 0x8c);
  cVar3 = (char)uVar1;
  cVar4 = (char)*(ushort *)(param_2 + 0x8e);
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if (-1 < (int)((uint)*(ushort *)(param_2 + 0x8e) - (uint)*(ushort *)(in_at + 0x56))) {
    cVar4 = (char)*(undefined2 *)(in_at + 0x56);
  }
  *(char *)(in_at + 100) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x65) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar5 = *(uint *)(param_1 + 0x8c);
  uVar6 = *(uint *)(param_2 + 0xb0);
  in_v0[2] = *(uint *)(in_at + 0x68);
  in_v0[4] = uVar5;
  in_v0[6] = uVar6;
  in_v0[1] = *(uint *)(in_at + 0x44) | 0x24000000;
  uVar5 = *(uint *)(in_at + 0x60);
  uVar6 = *(uint *)(in_at + 100);
  in_v0[3] = *(uint *)(in_at + 0x5c);
  in_v0[5] = uVar5;
  in_v0[7] = uVar6;
  *in_v0 = *unaff_s6 | 0x7000000;
  *unaff_s6 = (uint)in_v0 & 0xffffff;
  return in_v0 + 8;
}



// WARNING: Removing unreachable block (ram,0x8004be94)

uint * FUN_8004bd84(int param_1,int param_2)

{
  ushort uVar1;
  ushort uVar2;
  int in_at;
  uint *in_v0;
  char cVar3;
  char cVar4;
  uint uVar5;
  uint uVar6;
  uint *unaff_s6;
  char unaff_s7;

  uVar1 = *(ushort *)(in_at + 0x68);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(in_at + 0x6a);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x5c) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x5d) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_1 + 0x8c);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_1 + 0x8e);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x60) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x61) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_2 + 0x8c);
  cVar3 = (char)uVar1;
  cVar4 = (char)*(ushort *)(param_2 + 0x8e);
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if (-1 < (int)((uint)*(ushort *)(param_2 + 0x8e) - (uint)*(ushort *)(in_at + 0x56))) {
    cVar4 = (char)*(undefined2 *)(in_at + 0x56);
  }
  *(char *)(in_at + 100) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x65) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar5 = *(uint *)(param_1 + 0xb0);
  uVar6 = *(uint *)(param_2 + 0xb0);
  in_v0[2] = *(uint *)(in_at + 0x68);
  in_v0[4] = uVar5;
  in_v0[6] = uVar6;
  in_v0[1] = *(uint *)(in_at + 0x44) | 0x24000000;
  uVar5 = *(uint *)(in_at + 0x60);
  uVar6 = *(uint *)(in_at + 100);
  in_v0[3] = *(uint *)(in_at + 0x5c);
  in_v0[5] = uVar5;
  in_v0[7] = uVar6;
  *in_v0 = *unaff_s6 | 0x7000000;
  *unaff_s6 = (uint)in_v0 & 0xffffff;
  return in_v0 + 8;
}



// WARNING: Removing unreachable block (ram,0x8004c098)

uint * FUN_8004bf20(int param_1,int param_2)

{
  ushort uVar1;
  ushort uVar2;
  int in_at;
  uint *in_v0;
  char cVar3;
  char cVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint *unaff_s6;
  char unaff_s7;

  uVar1 = *(ushort *)(param_1 + 0x68);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_1 + 0x6a);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x5c) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x5d) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_2 + 0x68);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_2 + 0x6a);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x60) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x61) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_1 + 0xb0);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_1 + 0xb2);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 100) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x65) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_2 + 0xb0);
  cVar3 = (char)uVar1;
  cVar4 = (char)*(ushort *)(param_2 + 0xb2);
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if (-1 < (int)((uint)*(ushort *)(param_2 + 0xb2) - (uint)*(ushort *)(in_at + 0x56))) {
    cVar4 = (char)*(undefined2 *)(in_at + 0x56);
  }
  *(char *)(in_at + 0x66) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x67) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  in_v0[1] = *(uint *)(in_at + 0x44) | 0x2c000000;
  uVar5 = *(uint *)(in_at + 0x60);
  uVar6 = *(uint *)(in_at + 100);
  in_v0[3] = *(uint *)(in_at + 0x5c);
  in_v0[5] = uVar5;
  in_v0[7] = uVar6;
  in_v0[9] = uVar6 >> 0x10;
  uVar5 = *(uint *)(param_2 + 0x68);
  uVar6 = *(uint *)(param_1 + 0x8c);
  uVar7 = *(uint *)(param_2 + 0x8c);
  in_v0[2] = *(uint *)(param_1 + 0x68);
  in_v0[4] = uVar5;
  in_v0[6] = uVar6;
  in_v0[8] = uVar7;
  *in_v0 = *unaff_s6 | 0x9000000;
  *unaff_s6 = (uint)in_v0 & 0xffffff;
  return in_v0 + 10;
}



// WARNING: Removing unreachable block (ram,0x8004c2ac)

uint * FUN_8004c134(int param_1,int param_2)

{
  ushort uVar1;
  ushort uVar2;
  int in_at;
  uint *in_v0;
  char cVar3;
  char cVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint *unaff_s6;
  char unaff_s7;

  uVar1 = *(ushort *)(param_1 + 0x68);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_1 + 0x6a);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x5c) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x5d) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_2 + 0x68);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_2 + 0x6a);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x60) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x61) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_1 + 0xb0);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_1 + 0xb2);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 100) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x65) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_2 + 0x8c);
  cVar3 = (char)uVar1;
  cVar4 = (char)*(ushort *)(param_2 + 0x8e);
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if (-1 < (int)((uint)*(ushort *)(param_2 + 0x8e) - (uint)*(ushort *)(in_at + 0x56))) {
    cVar4 = (char)*(undefined2 *)(in_at + 0x56);
  }
  *(char *)(in_at + 0x66) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x67) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  in_v0[1] = *(uint *)(in_at + 0x44) | 0x2c000000;
  uVar5 = *(uint *)(in_at + 0x60);
  uVar6 = *(uint *)(in_at + 100);
  in_v0[3] = *(uint *)(in_at + 0x5c);
  in_v0[5] = uVar5;
  in_v0[7] = uVar6;
  in_v0[9] = uVar6 >> 0x10;
  uVar5 = *(uint *)(param_2 + 0x68);
  uVar6 = *(uint *)(param_1 + 0x8c);
  uVar7 = *(uint *)(param_2 + 0xb0);
  in_v0[2] = *(uint *)(param_1 + 0x68);
  in_v0[4] = uVar5;
  in_v0[6] = uVar6;
  in_v0[8] = uVar7;
  *in_v0 = *unaff_s6 | 0x9000000;
  *unaff_s6 = (uint)in_v0 & 0xffffff;
  return in_v0 + 10;
}



// WARNING: Removing unreachable block (ram,0x8004c4c0)

uint * FUN_8004c348(int param_1,int param_2)

{
  ushort uVar1;
  ushort uVar2;
  int in_at;
  uint *in_v0;
  char cVar3;
  char cVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint *unaff_s6;
  char unaff_s7;

  uVar1 = *(ushort *)(param_1 + 0x8c);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_1 + 0x8e);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x5c) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x5d) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_2 + 0x8c);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_2 + 0x8e);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 0x60) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x61) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_1 + 0x68);
  cVar3 = (char)uVar1;
  uVar2 = *(ushort *)(param_1 + 0x6a);
  cVar4 = (char)uVar2;
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if ((int)(uint)uVar2 < 0) {
    cVar4 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar2 - (uint)*(ushort *)(in_at + 0x56))) {
      cVar4 = (char)*(undefined2 *)(in_at + 0x56);
    }
  }
  *(char *)(in_at + 100) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x65) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  uVar1 = *(ushort *)(param_2 + 0x68);
  cVar3 = (char)uVar1;
  cVar4 = (char)*(ushort *)(param_2 + 0x6a);
  if ((int)(uint)uVar1 < 0) {
    cVar3 = '\0';
  }
  else {
    if (-1 < (int)((uint)uVar1 - (uint)*(ushort *)(in_at + 0x54))) {
      cVar3 = (char)*(undefined2 *)(in_at + 0x54);
    }
  }
  if (-1 < (int)((uint)*(ushort *)(param_2 + 0x6a) - (uint)*(ushort *)(in_at + 0x56))) {
    cVar4 = (char)*(undefined2 *)(in_at + 0x56);
  }
  *(char *)(in_at + 0x66) = (cVar3 - unaff_s7) + (char)*(undefined2 *)(in_at + 0x50);
  *(char *)(in_at + 0x67) = cVar4 + (char)*(undefined2 *)(in_at + 0x52);
  in_v0[1] = *(uint *)(in_at + 0x44) | 0x2c000000;
  uVar5 = *(uint *)(in_at + 0x60);
  uVar6 = *(uint *)(in_at + 100);
  in_v0[3] = *(uint *)(in_at + 0x5c);
  in_v0[5] = uVar5;
  in_v0[7] = uVar6;
  in_v0[9] = uVar6 >> 0x10;
  uVar5 = *(uint *)(param_2 + 0xb0);
  uVar6 = *(uint *)(param_1 + 0x68);
  uVar7 = *(uint *)(param_2 + 0x68);
  in_v0[2] = *(uint *)(param_1 + 0xb0);
  in_v0[4] = uVar5;
  in_v0[6] = uVar6;
  in_v0[8] = uVar7;
  *in_v0 = *unaff_s6 | 0x9000000;
  *unaff_s6 = (uint)in_v0 & 0xffffff;
  return in_v0 + 10;
}


// Save Lap Time -- called every frame
// param1 is number of laps
// param2 lap time
// param3 driverID
void FUN_8004c55c(int param_1,int param_2,short param_3)

{
  int iVar1;
  int iVar2;

  /*
	Stores all laps for all racers

	driver[0] Minute (10s) lap 0
	driver[0] Minute (10s) lap 1
	driver[0] Minute (10s) lap 2
	...
	driver[0] Minute (10s) lap 6

	driver[1] Minute (10s) lap 0
	driver[1] Minute (10s) lap 1
	driver[1] Minute (10s) lap 2
	...
	driver[1] Minute (10s) lap 6

	Only stores for two drivers

  */


  // ( (driverID * 7) + lapIndex) * 4
  iVar2 = ((int)param_3 * 7 + param_1) * 4;

  iVar1 = param_2 / 0xe100;
  *(int *)(&DAT_8009ac00 + iVar2) = iVar1;

  // if number of minutes is more than 9
  if (9 < iVar1)
  {
	// rig to 9:59:99
    *(int *)(&DAT_8009ac00 + iVar2) = 9;
    *(undefined4 *)(&DAT_8009aca8 + iVar2) = 5;
    *(undefined4 *)(&DAT_8009ace0 + iVar2) = 9;
    *(undefined4 *)(&DAT_8009ac38 + iVar2) = 9;
    *(undefined4 *)(&DAT_8009ac70 + iVar2) = 9;
    return;
  }

  // calculate proper lap time
  *(int *)(&DAT_8009aca8 + iVar2) = param_2 / 0x2580 + iVar1 * -6;
  *(int *)(&DAT_8009ace0 + iVar2) = param_2 / 0x3c0 + (param_2 / 0x2580) * -10;
  *(int *)(&DAT_8009ac38 + iVar2) =
       ((param_2 / 6 + (param_2 >> 0x1f) >> 4) - (param_2 >> 0x1f)) + (param_2 / 0x3c0) * -10;
  *(int *)(&DAT_8009ac70 + iVar2) = ((param_2 * 100) / 0x3c0) % 10;
  return;
}


// fruitdisp and timebox
void FUN_8004c718(int param_1)

{
  undefined *puVar1;
  short sVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int iVar6;

  puVar1 = PTR_DAT_8008d2ac;

  // object from thread
  iVar6 = *(int *)(param_1 + 0x30);

  // instance from thread
  iVar5 = *(int *)(param_1 + 0x34);

  // instance color
  *(undefined4 *)(iVar5 + 0x24) = 0xffff0000;

  // if number of screens is 1
  if (puVar1[0x1ca8] == '\x01')
  {
	// if instance->model->modelID is not timebox
    if (*(short *)(*(int *)(iVar5 + 0x18) + 0x10) != 0x5c)
	{
	  // If player's wumpa is less than 10
      if (*(char *)(*(int *)(puVar1 + 0x24ec) + 0x30) < '\n')
	  {
		// no shine
        *(undefined2 *)(iVar5 + 0x22) = 0;
      }
      else
	  {
		// wumpaShineResult
        *(short *)(iVar5 + 0x22) = ((short)DAT_8008d994 + -0x80) * 0x10;
      }
      goto LAB_8004c7a4;
    }
  }

  // if number of screens is not 1
  else {
LAB_8004c7a4:

	// if HUD item is not timecrate
    if (*(short *)(*(int *)(iVar5 + 0x18) + 0x10) != 0x5c)
	{
	  // rotation speed 0x80
      sVar2 = *(short *)(iVar6 + 2) + 0x80;
      goto LAB_8004c7d4;
    }
  }

  // if wumpa or crystal,
  // rotation speed 0x40
  sVar2 = *(short *)(iVar6 + 2) + 0x40;

LAB_8004c7d4:
  *(short *)(iVar6 + 2) = sVar2;
  iVar4 = iVar5 + 0x30;

   // convert 3 rotation shorts into rotation matrix
  FUN_8006c2a4(iVar4,iVar6);

  FUN_8006c3b0(iVar4,iVar6 + 8,iVar4);

  // if hud is enabled, and this is not demo mode
  if ((*(uint *)(PTR_DAT_8008d2ac + 0x1d30) & 0xff0100) == 0x100)
  {
	// make visible
    uVar3 = *(uint *)(iVar5 + 0x28) & 0xffffff7f;
  }
  else
  {
	// make invisible
    uVar3 = *(uint *)(iVar5 + 0x28) | 0x80;
  }
  *(uint *)(iVar5 + 0x28) = uVar3;
  return;
}


// Draw various objects, like relic,
// key trophy, token, crystal, etc
// PerFrame_Hud_Object3D
void FUN_8004c850(int param_1)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  int iVar4;

  // Get instance
  iVar4 = *(int *)(param_1 + 0x34);

  // Get object
  iVar2 = *(int *)(param_1 + 0x30);

  // Spin on the Y axis
  *(short *)(iVar2 + 2) = *(short *)(iVar2 + 2) + 0x40;

  // SpecularLight_Spinning2D
  // instance, ptr rot[6], cop registers
  FUN_800572d0(iVar4,iVar2,iVar2 + 0x28);

  // pointer to matrix
  iVar3 = iVar4 + 0x30;

   // convert 3 rotation shorts into rotation matrix
  FUN_8006c2a4(iVar3,iVar2);

  FUN_8006c3b0(iVar3,iVar2 + 8,iVar3);
  if (
		((*(uint *)(PTR_DAT_8008d2ac + 0x1d30) & 0xff0100) == 0x100) &&

		// if any fade-in-from-black transition is over
		(0xfff < *(short *)(PTR_DAT_8008d2ac + 0x139a))
	 )
  {
	// make visible
    uVar1 = *(uint *)(iVar4 + 0x28) & 0xffffff7f;
  }
  else
  {
	// make invisible
    uVar1 = *(uint *)(iVar4 + 0x28) | 0x80;
  }
  *(uint *)(iVar4 + 0x28) = uVar1;
  return;
}


// Handle CTR letters in HUD
void FUN_8004c914(int param_1)

{
  int iVar1;
  int iVar2;
  int iVar3;
  undefined2 local_18;
  short local_16;
  undefined2 local_14;

  // thread -> instance
  iVar2 = *(int *)(param_1 + 0x34);

  // thread -> object
  iVar3 = *(int *)(param_1 + 0x30);

  // I know they dont look like they rotate in HUD,
  // believe, me, there is "rotation" to some degree,
  // that's why the lighting changes in the HUD

  // Rotate on the Y axis
  *(short *)(iVar3 + 2) = *(short *)(iVar3 + 2) + 0x40;

  // SpecularLight_Spinning2D
  // instance, ptr rot[6], cop registers
  FUN_800572d0(iVar2,iVar3,iVar3 + 0x28);

  if (
		// If you're in End-Of-Race menu
		((*(uint *)PTR_DAT_8008d2ac & 0x200000) != 0) &&

		(
			// CheckeredFlag_IsTransitioning
			iVar1 = FUN_80043f44(),
			iVar1 != 0
		)
	)
  {
	// Set Scale to zero, basically stop
	// drawing letters in the HUD
    *(undefined2 *)(iVar2 + 0x1c) = 0;
    *(undefined2 *)(iVar2 + 0x1e) = 0;
    *(undefined2 *)(iVar2 + 0x20) = 0;
  }

  if (*(short *)(iVar2 + 0x1c) == 0x800) {
    local_16 = 0;
  }
  else {
    iVar1 = (int)*(short *)(iVar2 + 0x1c) + -0x800;
    if (iVar1 < 0) {
      iVar1 = (int)*(short *)(iVar2 + 0x1c) + -0x401;
    }
    local_16 = ((short)(iVar1 >> 10) + 1) * 0x200;
  }
  local_18 = 0;
  local_14 = 0;
  iVar2 = iVar2 + 0x30;

   // convert 3 rotation shorts into rotation matrix
  FUN_8006c2a4(iVar2,&local_18);

  FUN_8006c3b0(iVar2,iVar3 + 8,iVar2);
  return;
}


// function for "big1"
void FUN_8004ca04(int param_1)

{
  undefined2 uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;

  // Get object from thread
  iVar3 = *(int *)(param_1 + 0x30);

  // Get instance from thread
  iVar4 = *(int *)(param_1 + 0x34);

  uVar1 = *(undefined2 *)(iVar3 + 6);
  *(undefined2 *)(iVar4 + 0x32) = 0;
  *(undefined2 *)(iVar4 + 0x34) = 0;
  *(undefined2 *)(iVar4 + 0x36) = 0;
  *(undefined2 *)(iVar4 + 0x30) = uVar1;
  uVar1 = *(undefined2 *)(iVar3 + 6);
  *(undefined2 *)(iVar4 + 0x3a) = 0;
  *(undefined2 *)(iVar4 + 0x3c) = 0;
  *(undefined2 *)(iVar4 + 0x3e) = 0;
  *(undefined2 *)(iVar4 + 0x38) = uVar1;
  *(undefined2 *)(iVar4 + 0x40) = *(undefined2 *)(iVar3 + 6);
  FUN_8006c3b0(iVar4 + 0x30,iVar3 + 8,iVar4 + 0x30);
  if ((*(uint *)(PTR_DAT_8008d2ac + 0x1d30) & 0xff0100) == 0x100)
  {
	// make visible
    uVar2 = *(uint *)(iVar4 + 0x28) & 0xffffff7f;
  }
  else
  {
	// make invisible
    uVar2 = *(uint *)(iVar4 + 0x28) | 0x80;
  }
  *(uint *)(iVar4 + 0x28) = uVar2;
  return;
}

// UI_ConvertX_2
int FUN_8004caa8(int param_1,int param_2)

{
  // new posX = (oldPosX - midpointX) * param_2
  param_2 = (param_1 + -0x100) * param_2;
  if (param_2 < 0) {
    param_2 = param_2 + 0xff;
  }

  // divide by 256 (0x100)
  return param_2 >> 8;
}


// UI_ConvertY_2
int FUN_8004cac8(int param_1,int param_2)

{
  // new posY = (oldPosY - midpointY) * param_2
  param_2 = (param_1 + -0x6c) * param_2;

  // If new posY is on the left of the screen
  if (param_2 < 0) {
    param_2 = param_2 + 0xff;
  }

  // divide by 256 (0x100)
  return param_2 >> 8;
}


// HUD_INSTANCE_BirthWithThread
int FUN_8004cae8(int param_1,undefined4 param_2,int param_3,int param_4,int param_5,
                undefined4 param_6)

{
  short sVar1;
  short sVar2;
  short sVar3;
  ushort uVar4;
  undefined2 uVar5;
  int iVar6;
  long lVar7;
  undefined *puVar8;
  undefined4 uVar9;
  undefined *puVar10;
  short *psVar11;
  undefined2 *puVar12;
  int iVar13;
  int iVar14;
  int iVar15;
  int iVar16;
  short local_30;
  undefined2 local_2e;
  undefined2 local_2c;

  // get model pointer
  iVar16 = *(int *)(PTR_DAT_8008d2ac + param_1 * 4 + 0x2160);

								// number of screens - 1
  puVar8 = (&PTR_DAT_8008625c)[(uint)(byte)PTR_DAT_8008d2ac[0x1ca8] - 1];

  iVar13 = 0;
  if (iVar16 != 0)
  {
	// pointer to first Player thread
    iVar15 = *(int *)(PTR_DAT_8008d2ac + 0x1b2c);

    while (iVar15 != 0)
	{
	  // thread -> object
      iVar14 = *(int *)(iVar15 + 0x30);

	  // Create a new thread for this HUD element
	  // THREAD_BirthWithObject
	  // 0x38 = size
	  // 0 = no relation to param4
	  // 0x300 = SmallStackPool
	  // 0x10 = hud thread bucket
      iVar6 = FUN_8004205c(0x380310,param_2,param_6,0);

	  // Get the object attached to the thread
      puVar12 = *(undefined2 **)(iVar6 + 0x30);

	  // INSTANCE_Birth2D: Big Number HUD element
      iVar13 = FUN_800308e4(iVar16,0,iVar6);

	  // give the Instance to the thread
      *(int *)(iVar6 + 0x34) = iVar13;

      if (*(short *)(iVar16 + 0x10) == 0x38)
	  {
		// set pointer to instance of Big Number in HUD
        *(int *)(iVar14 + 0x498) = iVar13;
      }
      else {
        if (*(short *)(iVar16 + 0x10) == 0x37) {
          *(int *)(iVar14 + 0x49c) = iVar13;
        }
      }

	  // model -> id
	  sVar1 = *(short *)(iVar16 + 0x10);

	  // if this is a gem
	  if (sVar1 == 0x5f) {
        uVar9 = 0x6c08080;
LAB_8004cc4c:
        puVar12[0x14] = 0xf368;
        puVar12[0x15] = 0x99f;
        puVar12[0x16] = 0x232;
LAB_8004cc58:
        *(undefined4 *)(iVar13 + 0x24) = uVar9;

		// specular lighting
        *(uint *)(iVar13 + 0x28) = *(uint *)(iVar13 + 0x28) | 0x20000;
      }
      else
	  {
		// relic
        if (sVar1 == 0x61) {
          uVar9 = 0x60a5ff0;
          goto LAB_8004cc4c;
        }

		// crystal
        if (sVar1 == 0x60) {
          puVar12[0x14] = 0xf4a0;
          puVar12[0x15] = 0xb60;
          uVar9 = 0xd22fff0;
          puVar12[0x16] = 0xfd28;
          goto LAB_8004cc58;
        }

		// key
        if (sVar1 == 99) {
          uVar9 = 0xdca6000;
          goto LAB_8004cc4c;
        }

		// if C-T-R letters
        if ((ushort)(*(short *)(iVar16 + 0x10) - 0x93U) < 3) {
          puVar12[0x14] = 0xf368;
          puVar12[0x15] = 0x99f;
          puVar12[0x16] = 0x232;
          puVar12[0x19] = 0xc;

		  // modelID
          sVar1 = *(short *)(iVar16 + 0x10);

		  // letter C
          if (sVar1 == 0x93) {
            uVar5 = 0xfffc;
LAB_8004ccc8:
            puVar12[0x18] = uVar5;
          }
          else
		  {
			// letter T
            if (sVar1 == 0x94)
			{
              puVar12[0x18] = 0;
            }

			else
			{
			  // letter R
              if (sVar1 == 0x95) {
                uVar5 = 4;
                goto LAB_8004ccc8;
              }
            }
          }

		  // Set color
          *(undefined4 *)(iVar13 + 0x24) = 0xffc8000;

		  // specular lighting
          *(uint *)(iVar13 + 0x28) = *(uint *)(iVar13 + 0x28) | 0x30000;
        }
        else
		{
		  // token model
          if (sVar1 == 0x7d)
		  {
			// get AdvCup ID from level metadata
            uVar4 = (&DAT_80083a92)[*(int *)(PTR_DAT_8008d2ac + 0x1a10) * 0xc];

			puVar12[0x14] = 0xf368;
            puVar12[0x15] = 0x99f;
            puVar12[0x16] = 0x232;

			// get color from Adv Cup ID
			iVar6 = (int)((uint)uVar4 << 0x10) >> 0xd;
            sVar1 = *(short *)(&DAT_80084116 + iVar6);
            sVar2 = *(short *)(&DAT_80084118 + iVar6);
            sVar3 = *(short *)(&DAT_8008411a + iVar6);

			*(uint *)(iVar13 + 0x28) = *(uint *)(iVar13 + 0x28) | 0x30000;
            *(uint *)(iVar13 + 0x24) = (int)sVar1 << 0x14 | (int)sVar2 << 0xc | (int)sVar3 << 4;
          }
        }
      }

	  // if no camera110 is supplied
	  if (param_5 == 0)
	  {
        psVar11 = (short *)(puVar8 + param_3 * 8);

		// Convert X
        uVar9 = FUN_8004caa8((int)*psVar11,(int)psVar11[2]);
        *(undefined4 *)(iVar13 + 0x44) = uVar9;

		// Convert Y
		uVar9 = FUN_8004cac8((int)psVar11[1],(int)psVar11[2]);
        *(undefined4 *)(iVar13 + 0x48) = uVar9;

		*(int *)(iVar13 + 0x4c) = (int)psVar11[2];
      }

	  // if camera110 is supplied
      else
	  {
		// instance->camera110
        *(int *)(iVar13 + 0x74) = param_5;

		// record that camera110 is present
		*(uint *)(iVar13 + 0x28) = *(uint *)(iVar13 + 0x28) | 0x100;

        *(undefined4 *)(iVar13 + 0x44) = 0;
        *(undefined4 *)(iVar13 + 0x48) = 0;
        *(undefined4 *)(iVar13 + 0x4c) = 0x200;
      }

	  puVar10 = puVar8 + param_3 * 8;
      *(undefined2 *)(iVar13 + 0x1c) = *(undefined2 *)(puVar10 + 6);
      *(undefined2 *)(iVar13 + 0x1e) = *(undefined2 *)(puVar10 + 6);
      uVar5 = *(undefined2 *)(puVar10 + 6);
      *(undefined *)(iVar13 + 0x50) = 0x80;
      *(undefined *)(iVar13 + 0x51) = 0x80;
      *(undefined2 *)(iVar13 + 0x20) = uVar5;
      if (param_4 == 0) {
        local_30 = 0;
      }
      else {
        lVar7 = ratan2(*(long *)(iVar13 + 0x48),*(long *)(iVar13 + 0x4c));
        local_30 = -(short)lVar7;
      }
      local_2e = 0;
      local_2c = 0;

	   // convert 3 rotation shorts into rotation matrix
      FUN_8006c2a4(puVar12 + 4,&local_30);

      *puVar12 = 0;
      puVar12[1] = 0;
      puVar12[2] = 0;
      puVar12[3] = 0x1000;

	  // thread = thread -> next
      iVar15 = *(int *)(iVar15 + 0x10);

	  puVar8 = puVar8 + 0xa0;
    }
  }
  return iVar13;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// HUD_INSTANCE_InitAll
void FUN_8004cec4(void)

{
  undefined *puVar1;
  int iVar2;
  uint uVar3;
  undefined *puVar4;
  int iVar5;
  undefined2 *puVar6;
  undefined2 *puVar7;
  int iVar8;

  DAT_8008d4bc = DAT_8008d4bc & 0xfffffffe;
  *(uint *)(PTR_DAT_8008d2ac + 0x256c) = *(uint *)(PTR_DAT_8008d2ac + 0x256c) | 0x8000;


  puVar1 = PTR_DAT_8008d2ac;
  uVar3 = *(uint *)puVar1;

  // uVar3 is same as PTR_DAT_8008d2ac
  // For most of the function

  // If you're not in Crystal Challenge (in adventure mode)
  if ((uVar3 & 0x8000000) == 0)
  {
	// If you're in Adventure Arena
    if ((uVar3 & 0x100000) != 0)
	{
	  // HUD_INSTANCE_BirthWithThread
      FUN_8004cae8(0x61,FUN_8004c850,0xe,1,0,s_relic1_8008d4c8);   // "relic1"
      FUN_8004cae8(99,FUN_8004c850,0xf,1,0,&DAT_8008d4d0);		   // "key1"
      FUN_8004cae8(0x62,FUN_8004c850,0x10,0,0,s_trophy1_8008d4d8); // "trophy1"

	  // 0x8fba4 is where the adventure profile (currently loaded) begins
      FUN_800265c0(&DAT_8008fba4);
      return;
    }

	// loop iteration counter
    iVar8 = 0;

	// ???
	// If you're loading, or on adventure map, or in main menu ???
    if ((uVar3 & 0x4120000) != 0) {
      puVar7 = &DAT_800862d8;
      puVar6 = &DAT_800862c8;

	  // puVar4 = PTR_DAT_8008d2ac
      puVar4 = puVar1;

	  // for iVar8 = 0; iVar8 < 8; iVar8++
      do
	  {
		// loop through all player structures

		// player structure + 0x482 is your rank in the race
		// 0 = 1st place, 1 = 2nd place, 2 = 3rd place, etc
        *puVar6 = *(undefined2 *)(*(int *)(puVar4 + 0x24ec) + 0x482);

		// if more than 1 screen
        if (1 < (byte)puVar1[0x1ca8]) {
          *puVar7 = 5;
        }

		puVar7 = puVar7 + 1;
        puVar6 = puVar6 + 1;

		// increment loop counter
        iVar8 = iVar8 + 1;

		// increment pointer to next player structure
        puVar4 = puVar4 + 4;
      } while (iVar8 < 8);

	  // If you're not in a Relic Race
      if ((*(uint *)PTR_DAT_8008d2ac & 0x4000000) == 0) {
        return;
      }

	  // The rest of this block only happens in Relic Mode

	  // HUD_INSTANCE_BirthWithThread
      DAT_8008d9b4 = FUN_8004cae8(0x61,FUN_8004c850,0xe,1,0,s_relic1_8008d4c8); // "relic1"
      DAT_8008d9d8 = FUN_8004cae8(0x5c,FUN_8004c718,0x13,1,0,"timebox1");

	  iVar8 = DAT_8008d9b4;

	  // if instance
      if (DAT_8008d9b4 != 0)
	  {
		// set scale to zero
        *(undefined2 *)(DAT_8008d9b4 + 0x20) = 0;
        *(undefined2 *)(iVar8 + 0x1e) = 0;
        *(undefined2 *)(iVar8 + 0x1c) = 0;
      }

	  // Level ID
      iVar8 = *(int *)(PTR_DAT_8008d2ac + 0x1a10);

	  // 0x8fba4 is where the adventure profile (currently loaded) begins
      if ((((uint)(&DAT_8008fba4)[(int)(iVar8 + 0x3aU) >> 5] >> (iVar8 + 0x3aU & 0x1f) & 1) == 0) &&
         (((uint)(&DAT_8008fba4)[(int)(iVar8 + 0x28U) >> 5] >> (iVar8 + 0x28U & 0x1f) & 1) == 0)) {
        uVar3 = (uint)(&DAT_8008fba4)[(int)(iVar8 + 0x16U) >> 5] >> (iVar8 + 0x16U & 0x1f) & 1;
      }
      else {
        uVar3 = 2;
      }

	  // Level ID
      iVar5 = *(int *)(PTR_DAT_8008d2ac + 0x1a10);
      iVar2 = uVar3 * 4;

												// Level ID
      iVar8 = *(int *)(&DAT_80086340 + iVar2 + *(int *)(PTR_DAT_8008d2ac + 0x1a10) * 0xc) >> 0x1f;

	  // store relic time globally,
	  // store every digit in RDATA
      _DAT_8008d9b0 = *(int *)(&DAT_80086340 + iVar2 + iVar5 * 0xc) / 0xe100;

														// Level ID
      _DAT_8008d9b8 =
           ((*(int *)(&DAT_80086340 + iVar2 + *(int *)(PTR_DAT_8008d2ac + 0x1a10) * 0xc) * 100) /
           0x3c0) % 10;

														// Level ID
      _DAT_8008d9d4 =
           ((*(int *)(&DAT_80086340 + iVar2 + *(int *)(PTR_DAT_8008d2ac + 0x1a10) * 0xc) / 6 + iVar8
            >> 4) - iVar8) % 10;
      _DAT_8008d9e0 = (*(int *)(&DAT_80086340 + iVar2 + iVar5 * 0xc) / 0x2580) % 6;
      _DAT_8008d9e8 = (*(int *)(&DAT_80086340 + iVar2 + iVar5 * 0xc) / 0x3c0) % 10;
      return;
    }
    DAT_8008d4b4 = (undefined2 *)0x0;

	// if more than 1 screen
	if (1 < (byte)puVar1[0x1ca8])
	{
      DAT_8008d4b4 = &DAT_8009ad18;
    }
	
	// second half of pixel-LOD camera110, copy from Camera110_UI
    DAT_8009ad40 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x13b0);
    DAT_8009ad44 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x13b4);
    DAT_8009ad48 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x13b8);
    DAT_8009ad4c = *(undefined4 *)(PTR_DAT_8008d2ac + 0x13bc);
    DAT_8009ad50 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x13c0);
    DAT_8009ad54 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x13c4);
    DAT_8009ad58 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x13c8);
    DAT_8009ad5c = *(undefined4 *)(PTR_DAT_8008d2ac + 0x13cc);
	
	// first half of pixel-LOD camera110, copy from Camera110_UI
    DAT_8009ad18 = *(undefined2 *)(PTR_DAT_8008d2ac + 5000); // 0x1388
    DAT_8009ad1a = *(undefined2 *)(PTR_DAT_8008d2ac + 0x138a);
    DAT_8009ad1c = *(undefined2 *)(PTR_DAT_8008d2ac + 0x138c);
    DAT_8009ad34 = *(undefined2 *)(PTR_DAT_8008d2ac + 0x13a4);
    DAT_8009ad36 = *(undefined2 *)(PTR_DAT_8008d2ac + 0x13a6);
    DAT_8009ad38 = *(undefined2 *)(PTR_DAT_8008d2ac + 0x13a8);
    DAT_8009ad3a = *(undefined2 *)(PTR_DAT_8008d2ac + 0x13aa);

	// pointer to OT mem
    DAT_8009ae0c = *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c);

    DAT_8009ad30 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x13a0);

	// create thread and Instance for "fruitdisp"
	// the function returns an enttity
    DAT_8008d4b8 = FUN_8004cae8(0x37,FUN_8004c718,3,1,DAT_8008d4b4,"fruitdisp");

    if (
			// If number of screens is less than 3
			((byte)PTR_DAT_8008d2ac[0x1ca8] < 3) &&

			// If you're not in Battle Mode
			((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0)
		)
	{
	  // HUD_INSTANCE_BirthWithThread
      FUN_8004cae8(0x38,FUN_8004ca04,2,0,0,&DAT_8008d4e0); // "big1"
    }

	// If you're not in Adventure Mode
    if ((*(uint *)PTR_DAT_8008d2ac & 0x80000) == 0) {
      return;
    }

	// HUD_INSTANCE_BirthWithThread
    DAT_8008d9cc = FUN_8004cae8(0x93,FUN_8004c914,0x12,0,0,&DAT_8008d4e8); // "hudc"
    DAT_8008d9c4 = FUN_8004cae8(0x94,FUN_8004c914,0x12,0,0,&DAT_8008d4f0); // "hudt"
    DAT_8008d9c8 = FUN_8004cae8(0x95,FUN_8004c914,0x12,0,0,&DAT_8008d4f8); // "hudr"
    iVar2 = FUN_8004cae8(0x7d,FUN_8004c850,0x12,0,0,s_token_8008d4c0); // "token"

	// letter T
	iVar8 = DAT_8008d9c4;

	// make letter C invisible
    *(uint *)(DAT_8008d9cc + 0x28) = *(uint *)(DAT_8008d9cc + 0x28) | 0x80;

	// copy pointer to letter R in HUD
	iVar5 = DAT_8008d9c8;

	// make letter T invisible invisible
    *(uint *)(iVar8 + 0x28) = *(uint *)(iVar8 + 0x28) | 0x80;
  }

  // If you're in Crystal Challenge
  else
  {
	// HUD_INSTANCE_BirthWithThread

	//Make a separate crystal for End of Race menu
    DAT_8008d9c0 = FUN_8004cae8(0x60,FUN_8004c850,0x11,0,0,"crystal1");

	// Make a crystal for HUD
    DAT_8008d9bc = FUN_8004cae8(0x60,FUN_8004c850,0x11,0,0,"crystal1");

	// Make a token
    iVar2 = FUN_8004cae8(0x7d,FUN_8004c850,0x12,0,0,s_token_8008d4c0); // "token"

	// copy pointer to crystal in HUD
	iVar5 = DAT_8008d9bc;
  }

  // make invisible, either crystal in HUD, or letter R in HUD
  *(uint *)(iVar5 + 0x28) = *(uint *)(iVar5 + 0x28) | 0x80;

  // make copy of Token pointer
  DAT_8008d9d0 = iVar2;

  // set Token scale (x, y, z) to zero
  *(undefined2 *)(iVar2 + 0x1c) = 0;
  *(undefined2 *)(iVar2 + 0x1e) = 0;
  *(undefined2 *)(iVar2 + 0x20) = 0;

  // make Token invisible
  *(uint *)(iVar2 + 0x28) = *(uint *)(iVar2 + 0x28) | 0x80;
  return;
}


// Draw map
void FUN_8004d614(int param_1,int param_2,short param_3,short param_4,int param_5,void *param_6,
                 byte param_7)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  undefined2 uVar5;
  short sVar6;
  short sVar7;
  short sVar8;
  int iVar9;
  void *p;
  // uVar10 is used for checking if the minimap is drawn in a color other than white; set to 1 if white, set to 0 if blue or black
  uint uVar10;
  // uVar11 stores the color that the minimap gets recolored to
  undefined4 uVar11;

  uVar10 = (uint)param_7;
  iVar9 = 0;

  // draw map with neutral/none vertex color, minimap's regular color is white
  uVar11 = 0x808080; 

  // draw map black
  // used for the minimap shadow in the track select screen
  if (param_7 == 2) {
    uVar10 = 0;
    uVar11 = 0;
  }

  // draw map blue
  // used for the minimap outline in the track select screen
  else {
    if (param_7 == 3) {
      uVar10 = 0;
      uVar11 = 0x402000;
    }
  }

  // LEV -> trial_data -> numPointers
  if (**(int **)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x134) != 0)
  {
	// LEV -> trial_data -> ptr_map
    iVar9 = (*(int **)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x134))[1];
  }

  bVar1 = *(byte *)(param_2 + 0x18);
  bVar2 = *(byte *)(param_2 + 0x14);
  sVar6 = (ushort)*(byte *)(param_2 + 0x1d) - (ushort)*(byte *)(param_2 + 0x15);

  if (
		((iVar9 != 0) && (*(short *)(iVar9 + 0x12) == 0)) ||

		// If in main menu (character selection, track selection, any part of it)
		((*(uint *)PTR_DAT_8008d2ac & 0x2000) != 0)
	)
  {
	// draw top half of map (param1)

    p = *(void **)(param_5 + 0xc);
    bVar3 = *(byte *)(param_1 + 0x1d);
    bVar4 = *(byte *)(param_1 + 0x15);
    sVar8 = param_3 - ((ushort)*(byte *)(param_1 + 0x18) - (ushort)*(byte *)(param_1 + 0x14));

	// color
	*(undefined4 *)((int)p + 4) = uVar11;

	// u0, v0, clut
    *(undefined4 *)((int)p + 0xc) = *(undefined4 *)(param_1 + 0x14);
    
	// u1, v1, tpage
	*(undefined4 *)((int)p + 0x14) = *(undefined4 *)(param_1 + 0x18);
    
	sVar7 = param_4 - (((ushort)bVar3 - (ushort)bVar4) + sVar6);
    
	// u2, v2, pad1
	*(undefined4 *)((int)p + 0x1c) = *(undefined4 *)(param_1 + 0x1c);
    
	uVar5 = *(undefined2 *)(param_1 + 0x1e);
    *(short *)((int)p + 0x1a) = param_4 - sVar6;
    *(short *)((int)p + 0x22) = param_4 - sVar6;
	
	// psyq macro setPolyFT4
    *(undefined *)((int)p + 3) = 9;
    *(undefined *)((int)p + 7) = 0x2c;
	
	// x0
    *(short *)((int)p + 8) = sVar8;
    
	// y0
	*(short *)((int)p + 10) = sVar7;
    
	// x1
	*(short *)((int)p + 0x10) = param_3;
    
	// y1
	*(short *)((int)p + 0x12) = sVar7;
    
	*(short *)((int)p + 0x18) = sVar8;
    *(short *)((int)p + 0x20) = param_3;
    *(undefined2 *)((int)p + 0x24) = uVar5;

	// if this is the white map
    if (uVar10 != 0)
	{
	  // tpage
      *(ushort *)((int)p + 0x16) = *(ushort *)((int)p + 0x16) & 0xff9f | (ushort)(uVar10 << 5);
    }

    *(byte *)((int)p + 7) = *(byte *)((int)p + 7) | 2;
    AddPrim(param_6,p);

	// POLY_FT4 is 0x28 bytes large
    *(int *)(param_5 + 0xc) = *(int *)(param_5 + 0xc) + 0x28;
  }

  // draw bottom half of map (param2)

  p = *(void **)(param_5 + 0xc);

  // color
  *(undefined4 *)((int)p + 4) = uVar11;

  // uv0
  *(undefined4 *)((int)p + 0xc) = *(undefined4 *)(param_2 + 0x14);

  // uv1
  *(undefined4 *)((int)p + 0x14) = *(undefined4 *)(param_2 + 0x18);

  // x - size
  sVar7 = param_3 - ((ushort)bVar1 - (ushort)bVar2);

  // uv2
  *(undefined4 *)((int)p + 0x1c) = *(undefined4 *)(param_2 + 0x1c);

  // uv3
  uVar5 = *(undefined2 *)(param_2 + 0x1e);

  // y0
  *(short *)((int)p + 10) = param_4 - sVar6;

  // y1
  *(short *)((int)p + 0x12) = param_4 - sVar6;

  // psyq macro setPolyFT4
  *(undefined *)((int)p + 3) = 9;
  *(undefined *)((int)p + 7) = 0x2c;

  // x0
  *(short *)((int)p + 8) = sVar7;

  // x1
  *(short *)((int)p + 0x10) = param_3;

  // x2
  *(short *)((int)p + 0x18) = sVar7;

  // y2
  *(short *)((int)p + 0x1a) = param_4;

  // x3
  *(short *)((int)p + 0x20) = param_3;

  // y3
  *(short *)((int)p + 0x22) = param_4;

  // uv3
  *(undefined2 *)((int)p + 0x24) = uVar5;

  // if this is the white map
  if (uVar10 != 0)
  {
	// tpage
    *(ushort *)((int)p + 0x16) = *(ushort *)((int)p + 0x16) & 0xff9f | (ushort)(uVar10 << 5);
  }

  *(byte *)((int)p + 7) = *(byte *)((int)p + 7) | 2;
  AddPrim(param_6,p);
  *(int *)(param_5 + 0xc) = *(int *)(param_5 + 0xc) + 0x28;
  return;
}


// Map_GetIconDemensions
void FUN_8004d8b4(short *param_1,int *param_2,int *param_3)

{
  short sVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;

  iVar5 = (int)param_1[7] + -0x10;
  iVar3 = (int)*param_1 - (int)param_1[2];
  sVar1 = param_1[8];
  iVar4 = (int)param_1[1] - (int)param_1[3];
  if (sVar1 == 0) {
    if (iVar3 == 0) {
      trap(0x1c00);
    }
    if ((iVar3 == -1) && (*param_2 * (int)param_1[4] == -0x80000000)) {
      trap(0x1800);
    }
    iVar2 = *param_3 * (int)param_1[5] * 2;
    if (iVar4 == 0) {
      trap(0x1c00);
    }
    if ((iVar4 == -1) && (iVar2 == -0x80000000)) {
      trap(0x1800);
    }
    iVar3 = (int)param_1[6] + (*param_2 * (int)param_1[4]) / iVar3;
    iVar5 = iVar5 + iVar2 / iVar4;
  }
  else {
    if (sVar1 == 1) {
      iVar2 = *param_2 * (int)param_1[5] * 2;
      if (iVar3 == 0) {
        trap(0x1c00);
      }
      if ((iVar3 == -1) && (iVar2 == -0x80000000)) {
        trap(0x1800);
      }
      if (iVar4 == 0) {
        trap(0x1c00);
      }
      if ((iVar4 == -1) && (*param_3 * (int)param_1[4] == -0x80000000)) {
        trap(0x1800);
      }
      iVar5 = iVar5 + iVar2 / iVar3;
      iVar3 = (int)param_1[6] - (*param_3 * (int)param_1[4]) / iVar4;
    }
    else {
      if (sVar1 == 2) {
        if (iVar3 == 0) {
          trap(0x1c00);
        }
        if ((iVar3 == -1) && (*param_2 * (int)param_1[4] == -0x80000000)) {
          trap(0x1800);
        }
        iVar2 = *param_3 * (int)param_1[5] * 2;
        if (iVar4 == 0) {
          trap(0x1c00);
        }
        if ((iVar4 == -1) && (iVar2 == -0x80000000)) {
          trap(0x1800);
        }
        iVar3 = (int)param_1[6] - (*param_2 * (int)param_1[4]) / iVar3;
        iVar5 = iVar5 - iVar2 / iVar4;
      }
      else {
        iVar2 = *param_2 * (int)param_1[5] * 2;
        if (iVar3 == 0) {
          trap(0x1c00);
        }
        if ((iVar3 == -1) && (iVar2 == -0x80000000)) {
          trap(0x1800);
        }
        if (iVar4 == 0) {
          trap(0x1c00);
        }
        if ((iVar4 == -1) && (*param_3 * (int)param_1[4] == -0x80000000)) {
          trap(0x1800);
        }
        iVar5 = iVar5 - iVar2 / iVar3;
        iVar3 = (int)param_1[6] + (*param_3 * (int)param_1[4]) / iVar4;
      }
    }
  }

  // If number of screens is 3
  if (PTR_DAT_8008d2ac[0x1ca8] == '\x03') {
    iVar3 = iVar3 + -0x3c;
    iVar5 = iVar5 + 10;
  }
  *param_2 = iVar3;
  *param_3 = iVar5;
  return;
}



// WARNING: Could not reconcile some variable overlaps

// Draw dot for Player on 2D Adv Map
void FUN_8004dbac(undefined4 param_1,undefined4 *param_2,undefined4 param_3,undefined4 param_4,
                 short param_5,short param_6)

{
  undefined *puVar1;
  undefined4 local_18;
  undefined4 local_14;

  local_18 = *param_2;
  local_14 = param_2[2];

  // Get Icon Dimensions
  FUN_8004d8b4(param_1,&local_18,&local_14);

  puVar1 = &DAT_80086424;
  if ((*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 2) != 0) {
    puVar1 = &DAT_80086430;
  }

  // AH_Map_HubArrow
  FUN_800b0f18((int)(short)local_18,(int)(short)local_14,&DAT_80086418,puVar1,(int)param_6,
               (int)param_5);
  return;
}


// Draw icon on map
// param_4 color index
// param_6 scale
void FUN_8004dc44(undefined4 param_1,undefined4 *param_2,int param_3,int param_4,undefined4 param_5,
                 short param_6)

{
  int *piVar1;
  undefined4 local_18;
  undefined4 local_14;

  local_18 = *param_2;
  local_14 = param_2[2];

  // Icon dimensions
  FUN_8004d8b4(param_1,&local_18,&local_14);

  // color data
  piVar1 = (int *)((int)&PTR_DAT_80081d70 + ((param_4 << 0x10) >> 0xe));

  // DecalHUD_DrawPolyGT4
  FUN_80023054(*(undefined4 *)
                (*(int *)(PTR_DAT_8008d2ac + 0x2128) + ((param_3 << 0x10) >> 0xe) + 0x14),

			   // dimensions
			   local_18,
               local_14,

			   // pointer to PrimMem struct
			   *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

			   // pointer to OT mem
			   *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

			   // color data
			   *(undefined4 *)*piVar1,
               *(undefined4 *)(*piVar1 + 4),
			   *(undefined4 *)(*piVar1 + 8),
               *(undefined4 *)(*piVar1 + 0xc),

			   0,

			   // scale
			   (int)param_6);
  return;
}


// Map_DrawDrivers
void FUN_8004dd5c(undefined4 param_1,int param_2,short *param_3)

{
  int iVar1;
  undefined4 uVar2;
  int iVar3;

  if (param_2 != 0)
  {
	// loop through all drivers
    do
	{
	  // If number of screens is 1, or 3
      if ((PTR_DAT_8008d2ac[0x1ca8] == '\x01') || (PTR_DAT_8008d2ac[0x1ca8] == '\x03'))
	  {
		// Player structure
        iVar3 = *(int *)(param_2 + 0x30);

		// Player / AI structure + 0x4a shows driver index (0-7)

		// color data index 5 is where color
		// of each kart is stored in the array

		// characterID + 5
        iVar1 = (uint)(ushort)(&DAT_80086e84)[*(byte *)(iVar3 + 0x4a)] + 5;

        // if this is human and not AI
        if ((*(uint *)(iVar3 + 0x2c8) & 0x100000) == 0) {

		  // If you're in Adventure Arena
          if ((*(uint *)PTR_DAT_8008d2ac & 0x100000) != 0)
		  {
            // If this is an even-numbered frame
            if ((*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 2) == 0) {
              iVar1 = 4;
            }

			// If this is an odd numbered frame
            else
			{
			  // cast to short, remove higher bits
              iVar1 = iVar1 * 0x10000 >> 0x10;
            }

			// Draw dot for Player on 2D Adv Map
            FUN_8004dbac(param_1,*(int *)(param_2 + 0x34) + 0x44,0x32,iVar1,
                         (int)(short)(*(short *)(iVar3 + 0x2ee) + 0x800U | 0x1000),0x800);

            goto LAB_8004dea8;
          }

		  // If this is an even numbered frame
          if ((*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 2) == 0) {
            iVar1 = 4;
          }

		  // If this is an odd numbered frame
          else {
            iVar1 = iVar1 * 0x10000 >> 0x10;
          }
          uVar2 = 0x32;
        }
        else {
          uVar2 = 0x31;
          iVar1 = iVar1 * 0x10000 >> 0x10;
        }

		// Draw icon on map
        FUN_8004dc44(param_1,*(int *)(param_2 + 0x34) + 0x44,uVar2,iVar1,0,0x1000);
      }
LAB_8004dea8:

	  // count how many icons have been drawn,
	  // this was used in prototypes to draw
	  // ascii numbers on maps, wasn't fully removed
      *param_3 = *param_3 + 1;

	  // thread = thread->sibling
      param_2 = *(int *)(param_2 + 0x10);

    } while (param_2 != 0);
  }
  return;
}


// Draw all ghosts on 2D map
void FUN_8004dee8(undefined4 param_1,int param_2)
{
  undefined4 uVar1;

  //if (ghost struct pointer?) is not 0 (if you are in Time Trial mode)
  if (param_2 != 0)
  {
	// loop through all ghosts
    do {
      //if you have beaten Nefarious Tropy
      if (*(short *)(*(int *)(param_2 + 0x30) + 0x632) != 0) {
        if (*(short *)(*(int *)(param_2 + 0x30) + 0x630) == 0) {
          uVar1 = 6;
          //if the number of elapsed frames since boot is odd
          if ((*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 1) != 0) {
            uVar1 = 5;
          }
        }
        else {
          uVar1 = 0x11;

		  // if timeTrialFlags for this track show [ n tropy beaten ]
          if (((*(uint *)(&DAT_8008e814 + *(int *)(PTR_DAT_8008d2ac + 0x1a10) * 0x124) & 2) != 0) &&
             (uVar1 = 3, (*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 1) != 0)) {
            uVar1 = 4;
          }
        }

		// Draw icon on map
        FUN_8004dc44(param_1,*(int *)(param_2 + 0x34) + 0x44,0x31,uVar1,0,0x1000);
      }

	  // Go to next ghost
	  // thread = thread->sibling
      param_2 = *(int *)(param_2 + 0x10);

    } while (param_2 != 0);
  }
  return;
}


// Draw all "Tracking" warp balls on 2D map
void FUN_8004dffc(undefined4 param_1,int param_2)

{
  undefined4 uVar1;
  int iVar2;

  if (param_2 != 0) {
    do {

	  // thread -> instance
      iVar2 = *(int *)(param_2 + 0x34);

	  // instance -> model -> modelID == warpball
      if (*(short *)(*(int *)(iVar2 + 0x18) + 0x10) == 0x36)
	  {
		// Draw icon on map
        FUN_8004dc44(param_1,iVar2 + 0x44,0x20,0,0,0x1000);

		// get object from thread
        iVar2 = **(int **)(*(int *)(iVar2 + 0x6c) + 0x30);

        uVar1 = 4;

		// if object exists
        if (iVar2 != 0) {
          if ((*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 1) != 0) {
            uVar1 = 3;
          }

		  // Draw icon on map
          FUN_8004dc44(param_1,*(int *)(iVar2 + 0x1c) + 0x44,0x21,uVar1,0,0x1000);
        }
      }

      param_2 = *(int *)(param_2 + 0x10);
    } while (param_2 != 0);
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

// WeaponBackground_AnimateShine
void FUN_8004e0e0(void)

{
  int iVar1;
  uint local_18;
  uint local_14;
  uint local_10;

  // Sine(wumpaShineTheta)
  iVar1 = FUN_8003d184((int)DAT_8008d990);

  if (iVar1 < 0) {
    iVar1 = -iVar1;
  }
  local_18._0_2_ =
       CONCAT11((char)(iVar1 * 0x7f >> 0xc) + '\x7f',(char)(iVar1 * 0x7f >> 0xc) + '\x7f');
  local_18 = (uint)(ushort)local_18;
  DAT_8008d998 = local_18;
  local_14._0_2_ = CONCAT11((char)(iVar1 * 0x32 >> 0xc) + '2',(char)(iVar1 * 0x7f >> 0xc) + '\x7f');
  local_14 = (uint)(ushort)local_14;
  DAT_8008d99c = local_14;
  local_10._0_2_ = CONCAT11((char)(iVar1 * 0x10 >> 0xc) + '\x10',(char)(iVar1 * 0x21 >> 0xc) + '!');
  local_10 = (uint)(ushort)local_10;
  DAT_8008d9a0 = local_10;
  local_18._0_2_ = CONCAT11((char)(iVar1 * 0x5f >> 0xc) + '_',(char)(iVar1 * 0x5f >> 0xc) + '_');
  local_18 = (uint)CONCAT12((char)(iVar1 * 0x5f >> 0xc) + '_',(ushort)local_18);
  local_14._0_2_ = CONCAT11((char)(iVar1 * 0x5f >> 0xc) + '_',(char)(iVar1 * 0x5f >> 0xc) + '_');
  local_14 = (uint)CONCAT12((char)(iVar1 * 0x5f >> 0xc) + '_',(ushort)local_14);
  local_10._0_2_ = CONCAT11((char)(iVar1 * 0x5f >> 0xc) + '_',(char)(iVar1 * 0x5f >> 0xc) + '_');
  local_10 = (uint)CONCAT12((char)(iVar1 * 0x5f >> 0xc) + '_',(ushort)local_10);

  // wumpaShineResult
  DAT_8008d994 = (iVar1 * 0xff >> 0xd) + 0x80;

  DAT_8008d9a4 = local_18;
  DAT_8008d9a8 = local_14;
  DAT_8008d9ac = local_10;
  return;
}


// WeaponBackground_DrawShine
void FUN_8004e37c(int param_1,short param_2,short param_3,int param_4,void *param_5,byte param_6,
                 short param_7,short param_8)

{
  short sVar1;
  short sVar2;
  short sVar3;
  short sVar4;
  short sVar5;
  short sVar6;
  void *p;
  undefined4 uVar7;
  int iVar8;
  undefined4 uVar9;
  int iVar10;
  short sVar11;
  short sVar12;
  undefined4 uVar13;

  uVar7 = DAT_8008d9a4;
  uVar9 = DAT_8008d9a8;
  uVar13 = DAT_8008d9ac;
  if (param_6 != 3) {
    uVar7 = DAT_8008d998;
    uVar9 = DAT_8008d99c;
    uVar13 = DAT_8008d9a0;
  }
  iVar10 = 0;
  iVar8 = (int)(((uint)*(byte *)(param_1 + 0x18) - (uint)*(byte *)(param_1 + 0x14)) * (int)param_7)
          >> 0xc;
  sVar3 = (short)iVar8;
  sVar1 = param_2 + sVar3;
  param_7 = param_7 >> 0xc;
  sVar12 = sVar1 - param_7;
  sVar4 = (short)((int)(((uint)*(byte *)(param_1 + 0x1d) - (uint)*(byte *)(param_1 + 0x15)) *
                       (int)param_8) >> 0xc);
  sVar2 = param_3 + sVar4;
  param_8 = param_8 >> 0xc;
  sVar11 = sVar2 - param_8;
  
  // loop 4 times
  do 
  {
    p = *(void **)(param_4 + 0xc);
    *(undefined4 *)((int)p + 0xc) = *(undefined4 *)(param_1 + 0x14);
    *(undefined4 *)((int)p + 0x18) = *(undefined4 *)(param_1 + 0x18);
    *(undefined4 *)((int)p + 0x24) = *(undefined4 *)(param_1 + 0x1c);
    *(undefined2 *)((int)p + 0x30) = *(undefined2 *)(param_1 + 0x1e);
    
	// first
	if (iVar10 == 0) 
	{
	  // xy0
      *(short *)((int)p + 8) = param_2;
      *(short *)((int)p + 10) = param_3;
	  
      *(short *)((int)p + 0x14) = sVar1;
      *(short *)((int)p + 0x16) = param_3;
      *(short *)((int)p + 0x20) = param_2;
      *(short *)((int)p + 0x22) = sVar2;
      *(short *)((int)p + 0x2c) = sVar1;
      *(short *)((int)p + 0x2e) = sVar2;
    }
    else 
	{
	  // second
      if (iVar10 == 1) 
	  {  
		// xy0
		sVar5 = (param_2 + (short)(iVar8 << 1)) - param_7;
        *(short *)((int)p + 8) = sVar5;
        *(short *)((int)p + 10) = param_3;
		
        *(short *)((int)p + 0x14) = sVar12;
        *(short *)((int)p + 0x16) = param_3;
        *(short *)((int)p + 0x20) = sVar5;
        *(short *)((int)p + 0x22) = sVar2;
        *(short *)((int)p + 0x2c) = sVar12;
        *(short *)((int)p + 0x2e) = sVar2;
      }
      else 
	  {
		// third  
        if (iVar10 == 2) 
		{
		  // xy0
          sVar5 = (param_3 + sVar4 * 2) - param_8;
          *(short *)((int)p + 8) = param_2;
          *(short *)((int)p + 10) = sVar5;
          
		  *(short *)((int)p + 0x14) = sVar1;
          *(short *)((int)p + 0x16) = sVar5;
          *(short *)((int)p + 0x20) = param_2;
          *(short *)((int)p + 0x22) = sVar11;
          *(short *)((int)p + 0x2c) = sVar1;
        }
        
		// fourth
		else 
		{
		  // xy0
          sVar5 = (param_2 + sVar3 * 2) - param_7;
          sVar6 = (param_3 + sVar4 * 2) - param_8;
          *(short *)((int)p + 8) = sVar5;
          *(short *)((int)p + 10) = sVar6;
		  
          *(short *)((int)p + 0x14) = sVar12;
          *(short *)((int)p + 0x16) = sVar6;
          *(short *)((int)p + 0x20) = sVar5;
          *(short *)((int)p + 0x22) = sVar11;
          *(short *)((int)p + 0x2c) = sVar12;
        }
        *(short *)((int)p + 0x2e) = sVar11;
      }
    }
    
	// color RGB
	*(undefined4 *)((int)p + 4) = uVar13;
	
    *(undefined4 *)((int)p + 0x10) = uVar9;
    *(undefined4 *)((int)p + 0x1c) = uVar9;
    *(undefined4 *)((int)p + 0x28) = uVar7;
	
	// psyq macro setPolyGT4
    *(undefined *)((int)p + 3) = 0xc;
    *(undefined *)((int)p + 7) = 0x3c;
    
	if (param_6 != 0) {
      *(ushort *)((int)p + 0x1a) =
           *(ushort *)((int)p + 0x1a) & 0xff9f | ((ushort)param_6 - 1) * 0x20;
      *(byte *)((int)p + 7) = *(byte *)((int)p + 7) | 2;
    }
	
    AddPrim(param_5,p);
    
	// count
	iVar10 = iVar10 + 1;
	
	// increment primMem
    *(int *)(param_4 + 0xc) = *(int *)(param_4 + 0xc) + 0x34;
	
  } while (iVar10 < 4);
  return;
}


// DrawTrackerTargetBackground
void FUN_8004e660(int param_1,short param_2,short param_3,int param_4,void *param_5,byte param_6,
                 short param_7,short param_8,undefined4 param_9)

{
  short sVar1;
  short sVar2;
  short sVar3;
  short sVar4;
  short sVar5;
  short sVar6;
  void *p;
  int iVar7;
  int iVar8;
  short sVar9;
  short sVar10;

  iVar8 = 0;
  iVar7 = (int)(((uint)*(byte *)(param_1 + 0x18) - (uint)*(byte *)(param_1 + 0x14)) * (int)param_7)
          >> 0xc;
  sVar3 = (short)iVar7;
  sVar1 = param_2 + sVar3;
  param_7 = param_7 >> 0xc;
  sVar10 = sVar1 - param_7;

  // wumpaShineTheta (given to sine)
  DAT_8008d990 = DAT_8008d990 + 0x100;

  sVar4 = (short)((int)(((uint)*(byte *)(param_1 + 0x1d) - (uint)*(byte *)(param_1 + 0x15)) *
                       (int)param_8) >> 0xc);
  sVar2 = param_3 + sVar4;
  param_8 = param_8 >> 0xc;
  sVar9 = sVar2 - param_8;
  
  // loop 4 times
  do {
    p = *(void **)(param_4 + 0xc);
    *(undefined4 *)((int)p + 4) = param_9;
    *(undefined4 *)((int)p + 0xc) = *(undefined4 *)(param_1 + 0x14);
    *(undefined4 *)((int)p + 0x14) = *(undefined4 *)(param_1 + 0x18);
    *(undefined4 *)((int)p + 0x1c) = *(undefined4 *)(param_1 + 0x1c);
    *(undefined2 *)((int)p + 0x24) = *(undefined2 *)(param_1 + 0x1e);
	
	// first
    if (iVar8 == 0) 
	{
	  // xy0
      *(short *)((int)p + 8) = param_2;
      *(short *)((int)p + 10) = param_3;
	  
      *(short *)((int)p + 0x10) = sVar1;
      *(short *)((int)p + 0x12) = param_3;
      *(short *)((int)p + 0x18) = param_2;
      *(short *)((int)p + 0x1a) = sVar2;
      *(short *)((int)p + 0x20) = sVar1;
      *(short *)((int)p + 0x22) = sVar2;
    }
    else 
	{
	  // second
      if (iVar8 == 1) 
	  {
		// xy0
        sVar5 = (param_2 + (short)(iVar7 << 1)) - param_7;
        *(short *)((int)p + 8) = sVar5;
        *(short *)((int)p + 10) = param_3;
		
        *(short *)((int)p + 0x10) = sVar10;
        *(short *)((int)p + 0x12) = param_3;
        *(short *)((int)p + 0x18) = sVar5;
        *(short *)((int)p + 0x1a) = sVar2;
        *(short *)((int)p + 0x20) = sVar10;
        *(short *)((int)p + 0x22) = sVar2;
      }
      else 
	  {
		// third
        if (iVar8 == 2) 
		{
		  // xy0
          sVar5 = (param_3 + sVar4 * 2) - param_8;
          *(short *)((int)p + 8) = param_2;
          *(short *)((int)p + 10) = sVar5;
          
		  *(short *)((int)p + 0x10) = sVar1;
          *(short *)((int)p + 0x12) = sVar5;
          *(short *)((int)p + 0x18) = param_2;
          *(short *)((int)p + 0x1a) = sVar9;
          *(short *)((int)p + 0x20) = sVar1;
        }
		
		// fourth
        else 
		{
		  // xy0
          sVar6 = (param_2 + sVar3 * 2) - param_7;
          sVar5 = (param_3 + sVar4 * 2) - param_8;
          *(short *)((int)p + 8) = sVar6;
          *(short *)((int)p + 10) = sVar5;
          
		  *(short *)((int)p + 0x10) = sVar10;
          *(short *)((int)p + 0x12) = sVar5;
          *(short *)((int)p + 0x18) = sVar6;
          *(short *)((int)p + 0x1a) = sVar9;
          *(short *)((int)p + 0x20) = sVar10;
        }
        *(short *)((int)p + 0x22) = sVar9;
      }
    }
    
	// psyq macro setPolyFT4
	*(undefined *)((int)p + 3) = 9;
    *(undefined *)((int)p + 7) = 0x2c;
	
    if (param_6 != 0) {
      *(ushort *)((int)p + 0x16) =
           *(ushort *)((int)p + 0x16) & 0xff9f | ((ushort)param_6 - 1) * 0x20;
      *(byte *)((int)p + 7) = *(byte *)((int)p + 7) | 2;
    }
    AddPrim(param_5,p);
    iVar8 = iVar8 + 1;
    *(int *)(param_4 + 0xc) = *(int *)(param_4 + 0xc) + 0x28;
  } while (iVar8 < 4);
  return;
}


// Only used for drawing character icon
void FUN_8004e8d8(int param_1,short param_2,int param_3,int param_4,void *param_5,byte param_6,
                 short param_7,undefined4 param_8)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  undefined2 uVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  void *p;

  // PrimMem->curr
  p = *(void **)(param_4 + 0xc);

  bVar1 = *(byte *)(param_1 + 0x18);
  bVar2 = *(byte *)(param_1 + 0x14);
  bVar3 = *(byte *)(param_1 + 0x1d);
  bVar4 = *(byte *)(param_1 + 0x15);
  *(undefined4 *)((int)p + 4) = param_8;
  *(undefined4 *)((int)p + 0xc) = *(undefined4 *)(param_1 + 0x14);
  *(undefined4 *)((int)p + 0x14) = *(undefined4 *)(param_1 + 0x18);
  iVar8 = (uint)bVar1 - (uint)bVar2;
  *(undefined4 *)((int)p + 0x1c) = *(undefined4 *)(param_1 + 0x1c);
  uVar5 = *(undefined2 *)(param_1 + 0x1e);
  *(short *)((int)p + 8) = param_2;
  *(undefined2 *)((int)p + 0x24) = uVar5;
  iVar7 = (uint)bVar3 - (uint)bVar4;
  if (param_3 < 0xa6) {
    *(undefined2 *)((int)p + 10) = (short)param_3;
  }
  else {
    *(undefined2 *)((int)p + 10) = 0xa5;
  }
  *(short *)((int)p + 0x10) = param_2 + (short)(iVar8 * param_7 >> 0xc);
  if (param_3 < 0xa6) {
    *(undefined2 *)((int)p + 0x12) = (short)param_3;
  }
  else {
    *(undefined2 *)((int)p + 0x12) = 0xa5;
  }
  iVar6 = param_3 + (iVar7 * param_7 >> 0xc);
  *(short *)((int)p + 0x18) = param_2;
  if (iVar6 < 0xa6) {
    *(undefined2 *)((int)p + 0x1a) = (short)iVar6;
  }
  else {
    *(undefined2 *)((int)p + 0x1a) = 0xa5;
  }
  *(short *)((int)p + 0x20) = param_2 + (short)(iVar8 * param_7 >> 0xc);
  iVar7 = param_3 + (iVar7 * param_7 >> 0xc);
  if (iVar7 < 0xa6) {
    *(undefined2 *)((int)p + 0x22) = (short)iVar7;
  }
  else {
    *(undefined2 *)((int)p + 0x22) = 0xa5;
  }
  
  // psyq macro setPolyFT4
  *(undefined *)((int)p + 3) = 9;
  *(undefined *)((int)p + 7) = 0x2c;
  
  *(char *)((int)p + 0x1d) = (*(char *)((int)p + 0xd) + *(char *)((int)p + 0x1a)) - (char)param_3;
  *(char *)((int)p + 0x25) = (*(char *)((int)p + 0xd) + *(char *)((int)p + 0x22)) - (char)param_3;
  if (param_6 != 0) {
    *(ushort *)((int)p + 0x16) = *(ushort *)((int)p + 0x16) & 0xff9f | ((ushort)param_6 - 1) * 0x20;
    *(byte *)((int)p + 7) = *(byte *)((int)p + 7) | 2;
  }
  AddPrim(param_5,p);

  // increment PrimMem->curr
  *(int *)(param_4 + 0xc) = *(int *)(param_4 + 0xc) + 0x28;

  return;
}


// get position of icon based on a circular motion to move
// the driver up or down in the ranks (left of screen in Arcade or Boss race)
// param1 = pointer to (x,y) position
// param2 = drawn position
// param3 = absolute position
// param4 = frame counter
void FUN_8004eaa8(short *param_1,short param_2,short param_3,short param_4)

{
  int iVar1;
  int iVar2;
  int iVar3;
  short sVar4;

  // all rotations are counter-clockwise,
  // param4 * 0x1b * x
  // is used to make the circular motion
  // (x,y) positive or negative, to change
  // the radius and side of rotation.
  // Moving up moves icon to the right,
  // Moving down moves icon to the left,
  // 0x1b is a constant for base radius

  // drawn position
  iVar2 = (int)param_2;

  // absolute position
  iVar3 = (int)param_3;

  // if driver "just" passed another driver
  if (iVar3 < iVar2)
  {
	// Sine(angle)
	iVar1 = FUN_8003d184(((int)param_4 << 0xb) / 5);

	// ivar3 - ivar2 is a negative number
	iVar2 = (int)param_4 * 0x1b * (iVar3 - iVar2);

    sVar4 = (short)((uint)iVar2 >> 0x10);
    iVar2 = (int)((ulonglong)((longlong)iVar2 * 0x66666667) >> 0x20);
    *param_1 = (short)(iVar1 * 0x14 >> 0xc) + 0x14;
  }

  // if driver "was" passed another driver
  else {

	// Sine(angle)
	iVar1 = FUN_8003d184(((int)param_4 << 0xb) / 5);

	// ivar3 - ivar2 is a positive number
	iVar2 = (int)param_4 * 0x1b * (iVar3 - iVar2);

    sVar4 = (short)((uint)iVar2 >> 0x10);
    iVar2 = (int)((ulonglong)((longlong)iVar2 * 0x66666667) >> 0x20);
    *param_1 = 0x14 - (short)(iVar1 * 0x14 >> 0xc);
  }
  param_1[1] = param_2 * 0x1b + ((short)(iVar2 >> 1) - (sVar4 >> 0xf)) + 0x39;
  return;
}


// InterpolatePosition2D_HUD
// param1 pointer to array of two shorts (x,y)
// param2 startX
// param3 startY
// param4 endX
// param5 endY
// param6 curFrame
// param7 endFrame
void FUN_8004ec18(short *param_1,short param_2,short param_3,short param_4,short param_5,int param_6
                 ,short param_7)

{
  int iVar1;
  int iVar2;

  iVar2 = param_6 * ((int)param_2 - (int)param_4);
  iVar1 = (int)param_7;
  if (iVar1 == 0) {
    trap(0x1c00);
  }
  if ((iVar1 == -1) && (iVar2 == -0x80000000)) {
    trap(0x1800);
  }
  param_6 = param_6 * ((int)param_3 - (int)param_5);
  if (iVar1 == 0) {
    trap(0x1c00);
  }
  if ((iVar1 == -1) && (param_6 == -0x80000000)) {
    trap(0x1800);
  }
  *param_1 = param_4 + (short)(iVar2 / iVar1);
  param_1[1] = param_5 + (short)(param_6 / iVar1);
  return;
}


// param1 pointer to array of two shorts (x,y)
// param2 startX
// param3 startY
// param4 endX
// param5 endY
// param6 curFrame
// param7 endFrame
void FUN_8004ecd4(short *param_1,short param_2,short param_3,short param_4,short param_5,int param_6
                 ,short param_7)

{
  int iVar1;
  int iVar2;

  // Get end frame
  iVar1 = (int)param_7;

  // If interpolation is not done yet
  if (param_6 <= iVar1)
  {
	// newPosX = frame * (endX - startX)
    iVar2 = param_6 * ((int)param_4 - (int)param_2);

	// check for error
    if (iVar1 == 0) {
      trap(0x1c00);
    }
    if ((iVar1 == -1) && (iVar2 == -0x80000000)) {
      trap(0x1800);
    }

	// newPosY = frame * (endY - startY)
    param_6 = param_6 * ((int)param_5 - (int)param_3);

	// check for error
    if (iVar1 == 0) {
      trap(0x1c00);
    }
    if ((iVar1 == -1) && (param_6 == -0x80000000)) {
      trap(0x1800);
    }

	// posX = startX + newPosX / endFrame
    *param_1 = param_2 + (short)(iVar2 / iVar1);

	// posY = startY + newPosY / endFrame
    param_1[1] = param_3 + (short)(param_6 / iVar1);
    return;
  }

  // if you already reached the end

  // Set X and Y to EndX and EndY
  *param_1 = param_4;
  param_1[1] = param_5;
  return;
}


// param4 is the pointer to player structure
// DrawRaceClock, both lap time and race time
void FUN_8004edac(ushort param_1,ushort param_2,uint param_3,int param_4)

{
  short sVar1;
  int local_58;
  uint uVar2;
  uint uVar3;
  undefined1 *puVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  undefined4 uVar8;
  int iVar9;
  char cVar10;
  ushort uVar11;
  short *psVar12;
  char cVar13;
  char cVar14;
  int iVar15;
  char cVar16;
  short sVar17;
  ushort uVar18;
  char cVar19;
  char cVar20;
  char acStack80 [8];
  ushort local_48;
  ushort local_40;
  char *local_38;
  int local_34;
  int local_30;

  cVar20 = '\0';

  // if pointer is nullptr
  if (param_4 == 0)
  {
	// quit the function
    return;
  }

  // if number of laps is 7
  if (PTR_DAT_8008d2ac[0x1d33] == '\a')
  {
	// timer ms in full race
    iVar9 = *(int *)(param_4 + 0x514);

	// number of minutes (10s)
    cVar20 = (char)(iVar9 / 0x8ca00);

    if (iVar9 / 0x8ca00 < 10)
	{
	  // number of minutes (1s digit)
      cVar13 = (char)(iVar9 / 0xe100);

	  // number of minutes (1s digit)
      cVar19 = cVar13 + cVar20 * -10;

	  // number of seconds (10s digit)
	  cVar10 = (char)(iVar9 / 0x2580);

	  // number of seconds (10s digit)
      cVar16 = cVar10 + cVar13 * -6;

	  // number of seconds (1s digit)
	  iVar6 = (iVar9 * 100) / 0x3c0;
      iVar5 = (int)((ulonglong)((longlong)iVar6 * 0x66666667) >> 0x20);
      cVar13 = (char)(iVar9 / 0x3c0);
      cVar14 = cVar13 + cVar10 * -10;
      cVar13 = ((char)(iVar9 / 6 + (iVar9 >> 0x1f) >> 4) - (char)(iVar9 >> 0x1f)) + cVar13 * -10;
      goto LAB_8004f02c;
    }

	// set time to 99:59:99
    cVar20 = '\t';
LAB_8004ef58:
    cVar19 = '\t';
    cVar16 = '\x05';
    cVar14 = '\t';
    cVar13 = '\t';
    cVar10 = '\t';
  }

  // if numLaps is not 7
  else
  {
	// timer ms in full race
    iVar9 = *(int *)(param_4 + 0x514);

	// number of minutes (1s digit)
    cVar19 = (char)(iVar9 / 0xe100);

	// if timer runs over 10 minutes,
	// set time to 9:59:99
    if (9 < iVar9 / 0xe100) goto LAB_8004ef58;

	// seconds (10s)
    cVar13 = (char)(iVar9 / 0x2580);

	// seconds (10s)
    cVar16 = cVar13 + cVar19 * -6;

    iVar6 = (iVar9 * 100) / 0x3c0;
    iVar5 = (int)((ulonglong)((longlong)iVar6 * 0x66666667) >> 0x20);

	// seconds (1s)
    cVar10 = (char)(iVar9 / 0x3c0);

	// seconds (1s)
    cVar14 = cVar10 + cVar13 * -10;

	// ms (10s)
    cVar13 = ((char)(iVar9 / 6 + (iVar9 >> 0x1f) >> 4) - (char)(iVar9 >> 0x1f)) + cVar10 * -10;

LAB_8004f02c:

	// ms (1s)
    cVar10 = (char)iVar6 + ((char)(iVar5 >> 2) - (char)(iVar6 >> 0x1f)) * -10;
  }

  if ((param_3 & 1) == 0)
  {
	// TIME
    iVar9 = 0x12;

	// If you're in Time Trial
    if ((*(uint *)PTR_DAT_8008d2ac & 0x20000) != 0)
	{
	  // TIME TRIAL
      iVar9 = 0x4d;
    }

	// Draw small string
    uVar8 = 2;

    sVar17 = 0;
  }
  else
  {
	// TOTAL
    iVar9 = 0xc4;

	// If you're in a Relic Race
    if ((*(uint *)PTR_DAT_8008d2ac & 0x4000000) != 0)
	{
	  // YOUR TIME
      iVar9 = 0xc5;
    }

	// Draw big string
    uVar8 = 1;

    if (((param_3 & 4) == 0) || (sVar17 = 0x4004, (*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 2) != 0))
    {
      sVar17 = 0x4000;
    }
  }
  local_48 = param_1;
  local_40 = param_2;

  // iVar9 = 0x12: TIME
  // iVar9 = 0x4d: TIME TRIAL
  // iVar9 = 0xc4: TOTAL
  // iVar9 = 0xc5: YOUR TIME
  FUN_80022878(*(undefined4 *)(iVar9 * 4 + DAT_8008d878),(int)(short)param_1,(int)(short)param_2,
               uVar8,(int)sVar17);

  // set text to white
  sVar17 = 1;

  if (
		(*(int *)(PTR_DAT_8008d2ac + 0x1e20) == 0) &&

		(
			sVar17 = 0,

			// if total time should flash
			(param_3 & 4) != 0
		)
	 )
  {
	// use timer to change color on even and odd frames,
	// alternate between white (1) and orange (0)
    sVar17 = (ushort)((*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 2) == 0) << 2;
  }

  // if number of laps is 7
  if (PTR_DAT_8008d2ac[0x1d33] == '\a')
  {
	// String for amount of time in total race
    puVar4 = &DAT_800116d4;

	// Convert each number from the binary
	// version of the number to the ascii version
	// of the number by adding ascii value of '0'
    DAT_800116d4 = cVar20 + '0'; // minutes (10s)
    DAT_800116d5 = cVar19 + '0'; // minutes (1s)
    DAT_800116d7 = cVar16 + '0'; // seconds (10s)
    DAT_800116d8 = cVar14 + '0'; // seconds (1s)
    DAT_800116da = cVar13 + '0'; // ms (10s)
    DAT_800116db = cVar10 + '0'; // ms (1s)
  }

  // if number of laps is not 7
  else
  {
	// String for amount of time in lap
    puVar4 = &DAT_8008d504;

	// Convert each number from the binary
	// version of the number to the ascii version
	// of the number by adding ascii value of '0'
    DAT_8008d504 = cVar19 + '0';
    DAT_8008d506 = cVar16 + '0';
    DAT_8008d507 = cVar14 + '0';
    DAT_8008d509 = cVar13 + '0';
    DAT_8008d50a = cVar10 + '0';
  }

  if ((param_3 & 1) == 0) {
    iVar9 = (int)(short)local_48;
    iVar6 = ((uint)local_40 + 8) * 0x10000;
  }
  else {
    iVar9 = (int)(((uint)local_48 + 0x11) * 0x10000) >> 0x10;
    iVar6 = (uint)local_40 << 0x10;
  }

  // Draw String
  FUN_80022878(puVar4,iVar9,iVar6 >> 0x10,1,(int)sVar17);

  if (
		// If you're not in a Relic Race
		((*(uint *)PTR_DAT_8008d2ac & 0x4000000) == 0) ||
		((param_3 & 2) != 0)
	)
  {
	  // If you're not in Arcade mode,
	  // nor Time Trial, nor adventure mode
    if ((*(uint *)PTR_DAT_8008d2ac & 0x4a0000) == 0) {
      return;
    }

	// uVar2 lap counter
	// param4 is PTR_DAT_8008d2ac + 0x24ec (player structure)

    uVar2 = (uint)*(byte *)(param_4 + 0x44);
    iVar9 = 0;
    if (uVar2 == 0xffffffff) {
      return;
    }
    local_38 = acStack80;
    iVar6 = 1;
    local_30 = (uint)local_48 << 0x10;
    local_34 = local_30 >> 0x10;
    do {
      if (
			// lap counter is more loop counter
			(iVar9 <= (int)uVar2) &&

			// number of laps in race is more than loop counter
			(iVar9 < (char)PTR_DAT_8008d2ac[0x1d33])
		  )
	  {
		// Save Lap Time
        FUN_8004c55c(

					// lapID
					uVar2,

					//time on the clock - lap time to substract
					*(int *)(PTR_DAT_8008d2ac + 0x1d10) - *(int *)(param_4 + 0x40),

					// Player / AI structure + 0x4a shows driver index (0-7)
                     (uint)*(byte *)(param_4 + 0x4a));

        iVar5 = iVar9 * 4;

		// set to empty
        DAT_800116d4 = ' ';

		// Convert each number from the binary
		// version of the number to the ascii version
		// of the number by adding ascii value of '0'

		// Player / AI structure + 0x4a shows driver index (0-7)
		// This is dynamically programmed to handle time for more than one player

		// 5 numbers because 9:59:99
        DAT_800116d5 = (&DAT_8009ac00)[iVar5 + (uint)*(byte *)(param_4 + 0x4a) * 0x1c] + '0';
        DAT_800116d7 = (&DAT_8009aca8)[iVar5 + (uint)*(byte *)(param_4 + 0x4a) * 0x1c] + '0';
        DAT_800116d8 = (&DAT_8009ace0)[iVar5 + (uint)*(byte *)(param_4 + 0x4a) * 0x1c] + '0';
        DAT_800116da = (&DAT_8009ac38)[iVar5 + (uint)*(byte *)(param_4 + 0x4a) * 0x1c] + '0';
        DAT_800116db = (&DAT_8009ac70)[iVar5 + (uint)*(byte *)(param_4 + 0x4a) * 0x1c] + '0';

        if (
				(
					// if this is lap 1, and if lap 1 should flash
					((iVar9 == 0) && ((param_3 & 8) != 0)) ||

					// if this is lap 2, and if lap 2 should flash
					((iVar9 == 1 && ((param_3 & 0x10) != 0)))
				) ||

				// if this is lap 3, and if lap 3 should flash
				((uVar18 = 1, iVar9 == 2 && ((param_3 & 0x20) != 0)))
			)
		{
		  // Change color based on frame counter
          uVar18 = ((ushort)(*(uint *)(PTR_DAT_8008d2ac + 0x1cec) >> 1) ^ 1) & 1;
        }

		// Otherwise, color is white by default,    ^^^
		// you can see that in "uVar18 = 1" near lap 3 check

        if ((param_3 & 1) == 0) {

		  // If you're in Arcade Mode
          if ((*(uint *)PTR_DAT_8008d2ac & 0x400000) != 0) goto LAB_8004f84c;

		  // Set lap number in "Ln" string
          DAT_8008d50d = (char)iVar9 + '1';

          iVar7 = (int)(((uint)local_40 + iVar6 * 8 + 0x10) * 0x10000) >> 0x10;

		  // draw "Ln" string
          FUN_80022878(&DAT_8008d50c,local_30 >> 0x10,iVar7,2,3);

          iVar15 = 2;
          local_58 = 1;
          iVar5 = (int)(((uint)local_48 + 0x1a) * 0x10000) >> 0x10;
        }
        else
		{
		  // draw big text for time in each lap
          iVar15 = 1;

		  // if number of laps is more than 3
          if ('\x03' < (char)PTR_DAT_8008d2ac[0x1d33])
		  {
			// draw small text for time in each lap
            iVar15 = 2;
          }

		  // DAT_8008d510
		  // %d

          sprintf(local_38,&DAT_8008d510,iVar6);
          psVar12 = (short *)(&DAT_80082368 + iVar15 * 2);

		  // draw string
          FUN_80022878(local_38,local_34,
                       (int)(((uint)local_40 -
                             ((char)PTR_DAT_8008d2ac[0x1d33] - iVar9) * (int)*psVar12) * 0x10000) >>
                       0x10,iVar15,0x4003);

		  // DAT_8008d878 + 0x60
		  // LAP
          FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x60),
                       (int)(((uint)local_48 - (uint)*(ushort *)(&DAT_80082360 + iVar15 * 2)) *
                            0x10000) >> 0x10,
                       (int)(((uint)local_40 -
                             ((char)PTR_DAT_8008d2ac[0x1d33] - iVar9) * (int)*psVar12) * 0x10000) >>
                       0x10,iVar15,0x4003);


          local_58 = (int)(short)uVar18;
          iVar7 = (int)(((uint)local_40 - ((char)PTR_DAT_8008d2ac[0x1d33] - iVar9) * (int)*psVar12)
                       * 0x10000) >> 0x10;
          iVar5 = local_34;
        }

		// draw string for total amount of time in race
        FUN_80022878(&DAT_800116d4,iVar5,iVar7,iVar15,local_58);
      }
LAB_8004f84c:
				// lap counter
      uVar2 = (uint)*(byte *)(param_4 + 0x44);

      iVar9 = iVar9 + 1;
      iVar6 = iVar6 + 1;
      if ((int)(uVar2 + 1) <= iVar9) {
        return;
      }
    } while( true );
  }

  if ((*(uint *)(PTR_DAT_8008d2ac + 0x1d44) & 0x2000000) == 0)
  {
	  // Level ID
    iVar9 = *(int *)(PTR_DAT_8008d2ac + 0x1a10);

	// 3a is bit index for unlocking plat relics
	// 28 is bit index for unlocking gold relics

    if (
			//If you have unlocked a platinum relic on this track
			(((uint)(&DAT_8008fba4)[(int)(iVar9 + 0x3aU) >> 5] >> (iVar9 + 0x3aU & 0x1f) & 1) != 0) ||

			//If you have unlocked a gold relic on this track
			(((uint)(&DAT_8008fba4)[(int)(iVar9 + 0x28U) >> 5] >> (iVar9 + 0x28U & 0x1f) & 1) != 0)
		)
	{
LAB_8004f338:
      iVar9 = 200;
      uVar18 = 0x16;
      goto LAB_8004f378;
    }

	// If you have not unlocked Gold or Plat relic on this track

	// 16 is bit index for unlocking blue relics

	// Check if you unlocked a Blue relic
    uVar2 = (uint)(&DAT_8008fba4)[(int)(iVar9 + 0x16U) >> 5] >> (iVar9 + 0x16U & 0x1f);
  }

  else {
	// Level ID = PTR_DAT_8008d2ac + 0x1a10
	// uVar3 is bit index for unlocking platinum relic on this track
	// uVar2 is bit index for unlocking gold relic on this track
    uVar3 = *(int *)(PTR_DAT_8008d2ac + 0x1a10) + 0x3a;
    uVar2 = *(int *)(PTR_DAT_8008d2ac + 0x1a10) + 0x28;


	// 0x8fba4 is where the adventure profile (currently loaded) begins
    if (((uint)(&DAT_8008fba4)[(int)uVar3 >> 5] >> (uVar3 & 0x1f) & 1) != 0) goto LAB_8004f338;

	// Check if you unlocked a gold relic
    uVar2 = (uint)(&DAT_8008fba4)[(int)uVar2 >> 5] >> (uVar2 & 0x1f);
  }
  if ((uVar2 & 1) == 0)
  {
	// SAPPHIRE
    iVar9 = 0xc6;

	// blue color
	uVar18 = 0x11;
  }
  else
  {
	// GOLD
    iVar9 = 199;

	// yellow color
    uVar18 = 0xe;
  }
LAB_8004f378:
  uVar8 = 1;
  if ((param_3 & 1) == 0) {
    uVar8 = 2;
    sVar1 = local_40 + 0x18;
    sVar17 = local_40 + 0x20;
    uVar11 = local_48;
  }
  else {
    uVar18 = uVar18 | 0x4000;
    sVar1 = local_40 - 0x11;
    sVar17 = sVar1;
    uVar11 = local_48 + 0x11;
  }

  // ivar9 0xc6: SAPPHIRE
  // ivar9 199 (c7): GOLD
  // ivar9 0xc8: PLATINUM
  FUN_80022878(*(undefined4 *)(iVar9 * 4 + DAT_8008d878),(int)(short)local_48,(int)sVar1,uVar8,
               (int)(short)uVar18);

  // Convert each number from the binary
  // version of Relic Time to the ascii version
  // of the number by adding ascii value of '0'
  DAT_8008d504 = DAT_8008d9b0 + '0';
  DAT_8008d506 = DAT_8008d9e0 + '0';
  DAT_8008d507 = DAT_8008d9e8 + '0';
  DAT_8008d509 = DAT_8008d9d4 + '0';
  DAT_8008d50a = DAT_8008d9b8 + '0';
  FUN_80022878(&DAT_8008d504,(int)(short)uVar11,(int)sVar17,1,(int)(short)(uVar18 & 0xbfff));
  return;
}


// countdown clock, used for Battle Mode and Crystal Challenge
// param1: X coordinate on the screen
// param2: Y coordinate on the screen
// param3: text size
// (0,0) is the top left corner
void FUN_8004f894(short param_1,short param_2,short param_3)

{
  undefined *puVar1;
  undefined4 uVar2;
  int iVar3;
  undefined4 uVar4;
  int iVar5;
  int iVar6;

  // amount of time event should last, minus, time elapsed in the event.
  // basically, time remaining in the event
  iVar6 = *(int *)(PTR_DAT_8008d2ac + 0x1d84) - *(int *)(PTR_DAT_8008d2ac + 0x1d10);

  // if you run out of time
  if (iVar6 < 0)
  {
	// Make a time string with zero milliseconds on the clock
    uVar2 = FUN_80044ff8(0);
    puVar1 = PTR_DAT_8008d2ac;

    // If you're not in End-Of-Race menu
    if ((*(uint *)PTR_DAT_8008d2ac & 0x200000) == 0)
	{
	  // count iterations of loop
      iVar5 = 0;

	  // If number of screens is not zero
      if (PTR_DAT_8008d2ac[0x1ca8] != '\0')
	  {
		// loop iteration * 4,
		// pointer incrementation (4 bytes per pointer)
        iVar3 = 0;

		// ============
		// End Race for all Players
		// ============

		// for iVar5 = 0; iVar5 < numScreens; iVar5++
        do
		{
		  // pointer of each player (P1, P2, P3, P4)
          iVar3 = *(int *)(puVar1 + iVar3 + 0x24ec);

          //end the race for every racer
          *(uint *)(iVar3 + 0x2c8) = *(uint *)(iVar3 + 0x2c8) | 0x2000000;

		  // increment the iteration counter
		  iVar5 = iVar5 + 1;

		  // increment the pointer
          iVar3 = iVar5 * 4;
        } while (iVar5 < (int)(uint)(byte)puVar1[0x1ca8]);
      }

	  // ToggleGameState_EndOfRace
      FUN_8003a3fc();
    }
  }

  // if you have not run out of time
  else
  {
	// make a string with the remaining time
    uVar2 = FUN_80044ff8(iVar6);
  }

  // default color is dark red
  uVar4 = 0x1c;

  if (
		// if less than 15 seconds remain
		(iVar6 < 0x3840) &&

		(
			// set color to white
			uVar4 = 4,

			// if number of frames is an odd number
			(*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 1) != 0
		)
	  )
  {
	// set color back to red
    uVar4 = 0x1c;
  }

  // put the time string on the screen
  FUN_80022878(uVar2,(int)param_1,(int)param_2,(int)param_3,uVar4);
  return;
}


// Draw arrows over the heads of players
void FUN_8004f9d8(int param_1)

{
  ushort uVar1;
  undefined4 uVar2;
  MATRIX* r0;
  short sVar3;
  short sVar4;
  undefined4 in_zero;
  undefined4 in_at;
  undefined *puVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  uint uVar9;
  uint **ppuVar10;
  uint *puVar11;
  int iVar12;
  uint *puVar13;
  uint uVar14;
  short sVar15;
  uint uVar16;
  undefined4 local_18;
  uint local_14;
  short sStack14;

  // Player ID of param_1 player
  uVar9 = (uint)*(byte *)(param_1 + 0x4a);

  puVar5 = PTR_DAT_8008d2ac + uVar9 * 0x110;

  // camera110 ViewProj
  r0 = (MATRIX *)(PTR_DAT_8008d2ac + uVar6 * 0x110 + 0x168 + 0x28);
  gte_SetRotMatrix(r0);
  gte_SetTransMatrix(r0);

  // loop counter
  uVar14 = 0;

  // if number of screens is not zero
  if (PTR_DAT_8008d2ac[0x1ca8] != '\0') {
    iVar6 = 0;

	// for(int iVar14 = 0; iVar14 < numScreens; iVar14++)
    do
	{
	  // something related to player structure address
      iVar6 = *(int *)(PTR_DAT_8008d2ac + iVar6 + 0x24ec);

      if (
			(
				(uVar14 != uVar9) &&

				// If player is visible (not using invisibility powerup)
				(*(int *)(iVar6 + 0x28) == 0)
			) &&

			//if racer finished the race
			((*(uint *)(iVar6 + 0x2c8) & 0x2000000) == 0)
		  )
	  {
		// If 3 or 4 Players
        sVar15 = 5;

		// If number of screens is less than 3
        if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 3) {
          sVar15 = 3;
        }

        iVar12 = *(int *)(iVar6 + 0x1c);

		// Get X distance and Z distance between two players
        iVar7 = *(int *)(*(int *)(param_1 + 0x1c) + 0x44) - *(int *)(iVar12 + 0x44);
        iVar8 = *(int *)(*(int *)(param_1 + 0x1c) + 0x4c) - *(int *)(iVar12 + 0x4c);

		// Start doing Distance formula, but avoid sqrt to save performance
		iVar7 = iVar7 * iVar7 + iVar8 * iVar8;

		// sqrt(0x90000) is 768

		// If players are more than 768 units away from each other
        if (0x90000 < iVar7)
		{
		  // Battle Team of Player
          uVar1 = *(ushort *)(iVar6 + 0x4e8);

		  // Something with X and Height (Y)
          local_18 = CONCAT22(*(undefined2 *)(*(int *)(iVar6 + 0x1c) + 0x48),
                              *(undefined2 *)(iVar12 + 0x44));

												// something with Z position
          local_14 = local_14 & 0xffff0000 | (uint)*(ushort *)(*(int *)(iVar6 + 0x1c) + 0x4c);
          
		  // put instance position on GTE
		  setCopReg(2,in_zero,local_18);
          setCopReg(2,in_at,local_14);

		  // RTPS - Perspective Transformation (single)
		  copFunction(2,0x180001);

		  // get screenspace pos (x,y)
		  uVar2 = getCopReg(2,0xe);
		  
		  // get depth on screen (I think?)
          uVar16 = getCopControlWord(2,0xf800);

		  if ((uVar16 & 0x40000) == 0)
		  {
            // gGT->backBuffer
			iVar6 = *(int *)(PTR_DAT_8008d2ac + 0x10);

			// primMem curr
            puVar11 = *(uint **)(iVar6 + 0x80);

            puVar13 = (uint *)0x0;

			// if curr < near-end
			if (puVar11 <= *(uint **)(iVar6 + 0x84))
			{
			  // increment curr
              *(uint **)(iVar6 + 0x80) = puVar11 + 9;
              puVar13 = puVar11;
            }

            if (puVar13 == (uint *)0x0) {
              return;
            }
            sStack14 = (short)((uint)uVar2 >> 0x10);
            sStack14 = sStack14 + sVar15;
            sVar4 = (short)uVar2;
            iVar6 = (0x1000 - ((iVar7 / 6 + (iVar7 >> 0x1f) >> 0xd) - (iVar7 >> 0x1f))) * 0x10000 >>
                    0x10;
            sVar15 = (short)(iVar6 * 3 >> 10);
            *(short *)(puVar13 + 8) = sVar4 + sVar15;
            sVar3 = (short)(iVar6 * 7 >> 0xc) + 0xc;
            *(short *)((int)puVar13 + 0x22) = sStack14 - sVar3;
            *(short *)(puVar13 + 6) = sVar4;
            *(short *)((int)puVar13 + 0x1a) = sStack14 + -0xc;
            *(short *)(puVar13 + 4) = sVar4 - sVar15;
            *(undefined *)((int)puVar13 + 3) = 8;
            *(undefined *)((int)puVar13 + 0xf) = 0x32;
            puVar13[1] = 0xe1000a20;
            puVar13[2] = 0;

			// color data
            ppuVar10 = (uint **)((int)&PTR_DAT_80081d70 +
                                ((int)(((uint)uVar1 + 0x18) * 0x10000) >> 0xe));

            *(short *)((int)puVar13 + 0x12) = sStack14 - sVar3;
            puVar13[5] = (*ppuVar10)[1] | 0x30000000;
            puVar13[3] = **ppuVar10 & 0xffffff | 0x30000000;
            puVar13[7] = (*ppuVar10)[2] | 0x30000000;

			// pointer to OTMem (25c-168=0xf4)
            puVar11 = *(uint **)(PTR_DAT_8008d2ac + uVar9 * 0x110 + 0x25c);

			*puVar13 = *puVar11 | 0x8000000;
            *puVar11 = (uint)puVar13 & 0xffffff;
          }
        }
      }

	  // increment loop counter
      uVar14 = uVar14 + 1;

      iVar6 = uVar14 * 4;

	  // for(int iVar14 = 0; iVar14 < numScreens; iVar14++)
    } while ((int)uVar14 < (int)(uint)(byte)PTR_DAT_8008d2ac[0x1ca8]);
  }
  return;
}


// UpdateTrackerTargets
// draw lock-on target for driver, if
// a missile or warpball is chasing them
// param_1 is a player/AI structure
void FUN_8004fd34(int param_1)

{
  short sVar1;
  short sVar2;
  undefined4 uVar3;
  short sVar4;
  short sVar5;
  short sVar6;
  undefined4 in_zero;
  undefined4 in_at;
  int iVar7;
  uint uVar8;
  short *psVar9;
  uint uVar10;
  undefined *puVar11;
  uint *puVar12;
  uint uVar13;
  uint *puVar14;
  short sVar15;
  undefined4 uVar16;
  int iVar17;
  short sVar18;
  uint uVar19;
  int iVar20;
  undefined4 local_30;
  uint local_2c;
  short local_28;
  short sStack38;

  // get index of driver in driver array
  uVar19 = (uint)*(byte *)(param_1 + 0x4a);

  if (
		// if there is no missile chasing this player
		(*(int *)(param_1 + 0x4a4) == 0) &&

		// ???
		(*(short *)(&DAT_800862e8 + uVar19 * 2) == 0)
	 )
  {
	// clear type of object tracking the player
    *(undefined2 *)(&DAT_800862f8 + uVar19 * 2) = 0;

    return;
  }
  iVar20 = 0;

  // If no missile or warpball is chasing this driver
  if (*(int *)(param_1 + 0x4a4) == 0) {
    sVar1 = *(short *)(&DAT_800862e8 + uVar19 * 2);
    puVar11 = &DAT_8008628c;
  }

  // if a missile or warpball is chasing this driver
  else {
    sVar1 = *(short *)(&DAT_800862e8 + uVar19 * 2);
    puVar11 = &DAT_8008626c;
  }

  sVar2 = *(short *)(puVar11 + (int)sVar1 * 4);
  sVar1 = *(short *)(puVar11 + (int)sVar1 * 4 + 1);

  // RB_GetThread_ClosestTracker (missile or warpball)
  iVar7 = FUN_800b28c0(param_1);

  if ((iVar7 == 0) && (psVar9 = (short *)(&DAT_800862e8 + uVar19 * 2), *psVar9 == 0))
  {
	// Get data from missile or warpball
	// driver -> trackerInstFollowingMe -> object -> flags ??
    if ((*(ushort *)(*(int *)(*(int *)(param_1 + 0x4a4) + 0x30) + 0x16) & 0x10) != 0)
    goto LAB_8004fe8c;
    sVar18 = 0xc;
  }
  else {
    if (
			(
				//if 27th bit of Actions Flag set is on (means ?)
				((*(uint *)(param_1 + 0x2c8) & 0x4000000) != 0) &&

				// driver -> trackerInstFollowingMe
				(iVar7 == *(int *)(param_1 + 0x4a4))
			) ||
			(psVar9 = (short *)(&DAT_800862e8 + uVar19 * 2), *psVar9 != 0)
		) goto LAB_8004fe8c;

    //turn on 27th bit of Actions Flag set (means ?)
    *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) | 0x4000000;
    sVar18 = 8;
  }
  *psVar9 = sVar18;
LAB_8004fe8c:
  iVar17 = uVar19 * 2;

  // set pointer of the missile or warpball chasing the player
  *(int *)(param_1 + 0x4a4) = iVar7;

  psVar9 = (short *)(&DAT_800862e8 + iVar17);
  if (*psVar9 != 0) {
    *psVar9 = *psVar9 + -1;
  }

						// something with X and Y position
  local_30 = CONCAT22(*(undefined2 *)(*(int *)(param_1 + 0x1c) + 0x48),
                      *(undefined2 *)(*(int *)(param_1 + 0x1c) + 0x44));

						// something with Z position
  local_2c = local_2c & 0xffff0000 | (uint)*(ushort *)(*(int *)(param_1 + 0x1c) + 0x4c);

  // camera110 ViewProj
  r0 = (MATRIX *)(PTR_DAT_8008d2ac + uVar19 * 0x110 + 0x168 + 0x28);
  gte_SetRotMatrix(r0);
  gte_SetTransMatrix(r0);
  
  // ldv0
  // put driver pos on GTE
  setCopReg(2,in_zero,local_30);
  setCopReg(2,in_at,local_2c);

  // RTPS - Perspective Transformation (single)
  copFunction(2,0x180001);

  // stsxy
  // get driver screenspace pos
  uVar3 = getCopReg(2,0xe);
  uVar16 = 0xff;

  // if no missile or warpball is chasing this player
  if (*(int *)(param_1 + 0x4a4) == 0) {
    sVar18 = *(short *)(&DAT_800862f0 + iVar17);
  }

  // if a missile or warpball is chasing this player
  else
  {
	// get distance between missile and player

    // uVar8 = sqrt(param_1 * 2 ^ param_2)
    uVar8 = FUN_80059070(*(undefined4 *)(*(int *)(*(int *)(param_1 + 0x4a4) + 0x30) + 0x28),0);

    uVar8 = uVar8 / 0x32;
    sVar18 = (short)uVar8;
    *(short *)(&DAT_800862f0 + iVar17) = sVar18;

	// beeping gets faster as missile gets closer
	// iVar10 is beeping rate (higher is less beeps),
	// and uVar8 is distance to player

	// slowest rate, once every 0x1e frames,
	// if missile is more than 0xc9 units away
    uVar10 = 0x1e;

	if (
			// if missile is closer than 0xc9 units
			(uVar8 < 0xc9) &&


			(
				// apply beep once every 5 frames if
				// missile is less than 100 units away
				uVar10 = 5,

				// if missile is more than 100 units
				// and less than 0xc9 units away
				100 < uVar8
			)
		)
	{
	  // beep once every 10 frames
      uVar10 = 10;
    }

	// if the variable was somehow not set
	if (uVar10 == 0)
	{
	  // kill the game
      trap(0x1c00);
    }

    uVar16 = 0xff;

	// play the beeping on certain frames
    if (*(uint *)(PTR_DAT_8008d2ac + 0x1cec) % uVar10 == 0) {

	  // If game is not paused
      if ((*(uint *)PTR_DAT_8008d2ac & 0xf) == 0)
	  {
		// OtherFX_Play "homing in" sound
        FUN_80028468(0x56,1);
      }

      uVar16 = 0xffffff;
    }

	// driver -> threadTracking -> instance -> model -> modelID == WarpBall
    if (*(short *)(*(int *)(*(int *)(*(int *)(param_1 + 0x4a4) + 0x34) + 0x18) + 0x10) == 0x36)
	{
	  	// driver -> threadTracking -> object -> pathNodeStart -> pathNodeIndex?
      iVar20 = ((uint)*(ushort *)(*(int *)(*(int *)(*(int *)(param_1 + 0x4a4) + 0x30) + 0x3c) + 6) -

				// LEV -> path [driver -> pathIndex] -> pathNodeIndex (whaaaat)?
               (uint)*(ushort *)
                      ((uint)*(byte *)(param_1 + 0x495) * 0xc +
                       *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c) + 6)) * 8;

	  // if warpball is further in the lap than the driver,
	  // and warpball needs to go around the track
      if (iVar20 < 0)
	  {
		// add to distance between warpball and driver
        iVar20 = iVar20 + (uint)*(ushort *)
                                 (*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c) + 6) * 8;
      }

	  // type of object following driver is a warpball
      *(undefined2 *)(&DAT_800862f8 + uVar19 * 2) = 1;
    }

	// if this is not a warpball
	else
	{
	  // type of object is missile, or nothing?
      *(undefined2 *)(&DAT_800862f8 + uVar19 * 2) = 0;
    }
  }
  iVar7 = 0;
  
  // driver screenspace x and y
  sStack38 = (short)((uint)uVar3 >> 0x10);
  local_28 = (short)uVar3;

  // check distance
  if (iVar20 < 16000)
  {
    sVar6 = sVar18 + (sVar2 >> 8);
    sVar5 = (short)((int)sVar1 * 7 >> 0xc);
    do {
      sVar15 = 1;
      if (iVar7 == 0) {
        sVar15 = -1;
      }

	  // gGT->backBuffer
      iVar20 = *(int *)(PTR_DAT_8008d2ac + 0x10);

	  // PrimMem curr
      puVar12 = *(uint **)(iVar20 + 0x80);

	  puVar14 = (uint *)0x0;

	  // if curr < near-end
	  if (puVar12 <= *(uint **)(iVar20 + 0x84))
	  {
		// increment curr
        *(uint **)(iVar20 + 0x80) = puVar12 + 7;
        puVar14 = puVar12;
      }
      if (puVar14 == (uint *)0x0) {
        return;
      }

	  // if tracking object is warpball
      if (*(short *)(&DAT_800862f8 + uVar19 * 2) == 1) 
	  {
		// polyG3 + rgb
		uVar10 = 0x309c6900;
        
		uVar8 = 0x30ffff00;
      }

	  // if tracking object is missile
      else 
	  {
		// polyG3 + rgb
        uVar10 = 0x3000699c;
		
        uVar8 = 0x3000ffff;
      }

      puVar14[3] = 0x30ffffff;
      puVar14[1] = uVar10;
      puVar14[5] = uVar8;

      sVar4 = sVar15 * sVar6;
      *(short *)(puVar14 + 6) = local_28 + sVar4;
      *(short *)((int)puVar14 + 0x1a) = sStack38 + -0xc;
      *(short *)(puVar14 + 4) = local_28 + sVar15 * sVar18;
      *(short *)((int)puVar14 + 0x12) = sStack38 + -0xc;
      *(short *)(puVar14 + 2) = local_28 + sVar4;
      puVar11 = PTR_DAT_8008d2ac;
      *(short *)((int)puVar14 + 10) = sStack38 - (sVar5 + 0xc);

	  // pointer to OTMem (25c-168=0xf4)
      puVar12 = *(uint **)(puVar11 + uVar19 * 0x110 + 0x25c);

      *puVar14 = *puVar12 | 0x6000000;
      *puVar12 = (uint)puVar14 & 0xffffff;

	  // gGT->backBuffer
      iVar20 = *(int *)(PTR_DAT_8008d2ac + 0x10);

	  // PrimMem curr
      puVar12 = *(uint **)(iVar20 + 0x80);

      puVar14 = (uint *)0x0;

	  // if curr < near-End
	  if (puVar12 <= *(uint **)(iVar20 + 0x84))
	  {
		// increment curr
        *(uint **)(iVar20 + 0x80) = puVar12 + 7;
        puVar14 = puVar12;
      }
      if (puVar14 == (uint *)0x0) {
        return;
      }

	  // if tracking object is warpball
      if (*(short *)(&DAT_800862f8 + uVar19 * 2) == 1) {
        uVar13 = 0x305b5b00;
		
		// polyG3 + rgb
        uVar10 = 0x30322b01;
		
        uVar8 = 0x30ffbb00;
      }

	  // if tracking object is missile
      else {
        uVar13 = 0x30005b5b;
		
		// polyG3 + rgb
        uVar10 = 0x30012b32;
		
        uVar8 = 0x3000bbff;
      }

      puVar14[3] = uVar13;
      puVar14[1] = uVar10;
      puVar14[5] = uVar8;

      sVar4 = sVar15 * sVar6;
      *(short *)(puVar14 + 6) = local_28 + sVar4;
      *(short *)((int)puVar14 + 0x1a) = sStack38 + sVar5 + -0xc;
      *(short *)(puVar14 + 4) = local_28 + sVar15 * sVar18;
      *(short *)((int)puVar14 + 0x12) = sStack38 + -0xc;
      iVar7 = iVar7 + 1;
      *(short *)(puVar14 + 2) = local_28 + sVar4;
      puVar11 = PTR_DAT_8008d2ac;
      *(short *)((int)puVar14 + 10) = sStack38 + -0xc;

	  // pointer to OTMem (25c-168=0xf4)
      puVar12 = *(uint **)(puVar11 + uVar19 * 0x110 + 0x25c);

      *puVar14 = *puVar12 | 0x6000000;
      *puVar12 = (uint)puVar14 & 0xffffff;
    } while (iVar7 < 2);
  }

  // DrawTrackerTargetBackground
  FUN_8004e660(

			   // missile lock-on icon
			   *(undefined4 *)(PTR_DAT_8008d2ac + 0x1fa0),

			   (int)local_28 - ((int)sVar2 >> 7),
               (int)sStack38 - ((int)sVar1 * 0xf >> 0xb),

			   // pointer to PrimMem struct
			   *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

				// pointer to OTMem (25c-168=0xf4)
			   *(undefined4 *)(PTR_DAT_8008d2ac + uVar19 * 0x110 + 0x25c),1,(int)sVar2,(int)sVar1,
               uVar16);
  return;
}


// Draw the "st", "nd", "rd" suffix after "1st, 2nd, 3rd, etc"
void FUN_8005045c(short param_1,short param_2,int param_3,short param_4)

{
  int iVar1;

  // If you're not in Battle Mode
  if ((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0) {
    // Get the rank you're in (1st, 2nd, 3rd, etc)
	iVar1 = (int)*(short *)(param_3 + 0x482);
  }

  // If you are in Battle Mode
  else
  {
							// Battle Team of Player
    iVar1 = *(int *)(PTR_DAT_8008d2ac + *(int *)(param_3 + 0x4e8) * 4 + 0x1da8);
  }

  // Draw the suffix of your position
  // 1st "st"
  // 2nd "nd"
  // 3rd "rd"
  // 4th "th"
  // etc
  FUN_80022878(*(undefined4 *)((int)*(short *)(&DAT_8008643c + iVar1 * 2) * 4 + DAT_8008d878),
               (int)param_1,(int)param_2,1,(int)param_4);

  // If pointer to instance of "Big Number" is valid
  if (*(int *)(param_3 + 0x498) != 0)
  {
	// Set [something] to position in race + 0x100
    *(int *)(*(int *)(param_3 + 0x498) + 0x4c) = (int)*(short *)(param_3 + 0x482) + 0x100;
  }
  return;
}


// Draw which lap the racer is on
void FUN_80050528(short param_1,int param_2,undefined4 param_3,int param_4)

{
  char *pcVar1;
  undefined4 uVar2;
  short sVar3;
  undefined4 local_38;
  char acStack48 [24];

  // get current lap number, then add 1
  // Draw Lap 0 as 1
  // Draw Lap 1 as 2
  // Draw Lap 2 as 3, etc
  sVar3 = (ushort)*(byte *)(param_4 + 0x44) + 1;

  // if your current lap is more than the number of laps in the race
  if ((int)(char)PTR_DAT_8008d2ac[0x1d33] < (int)((uint)*(byte *)(param_4 + 0x44) + 1))
  {
	// set current lap to the max number of laps in the race (3, 5, 7)
    sVar3 = (short)(char)PTR_DAT_8008d2ac[0x1d33];
  }

  // if number of screens is less than 3
  if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 3)
  {
	// DAT_8008d878 + 0x60
	// LAP
    FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x60),(int)param_1,(int)(short)param_2,2,0x4001);

	// s__d__d_8008d514
	// %d/%d

	// sVar3
	// current lap

	// (int)(char)PTR_DAT_8008d2ac[0x1d33]
	// number of laps in a race

	// turn it into a string
    sprintf(acStack48,s__d__d_8008d514,(int)sVar3,(int)(char)PTR_DAT_8008d2ac[0x1d33]);

	// copy a pointer to the string
    pcVar1 = acStack48;

	// set the Y value to the top of the string
    uVar2 = 1;

	// set the color
    local_38 = 0x4001;
  }

  // if number of screens is 3 or 4
  else
  {
	// set pointer to string
    pcVar1 = &DAT_8008d51c;

	// height of text
    uVar2 = 2;

	// convert current lap number to ascii
    DAT_8008d51c = (char)sVar3 + '0';

	// color
    local_38 = 1;

	// convert number of laps to ascii
    DAT_8008d51e = PTR_DAT_8008d2ac[0x1d33] + '0';
  }

  // draw string
  FUN_80022878(pcVar1,(int)param_1,(param_2 + 8) * 0x10000 >> 0x10,uVar2,local_38);
  return;
}


// Draw how many points or lifes the player has in battle
void FUN_80050654(int param_1,int param_2,int param_3)

{
  short sVar1;
  undefined4 local_40;
  undefined4 uVar2;
  int iVar3;
  char acStack48 [32];

  // DAT_8008644c has 16 shorts, each short is color + alignment
  // First 4 shorts show how text is drawn for 4 players in 1P Mode
  // Next  4 shorts show how text is drawn for 4 players in 2P Mode
  // Then 3P mode, then 4P mode

  // Set color of your string
  sVar1 = *(short *)(&DAT_8008644c +
                    (uint)*(byte *)(param_3 + 0x4a) * 2 +

					// number of screens - 1
                    ((uint)(byte)PTR_DAT_8008d2ac[0x1ca8] - 1) * 8);


  // If you dont have a point limit (battle)
  if ((*(uint *)PTR_DAT_8008d2ac & 0x4000) == 0)
  {
	// if you dont have a life limit (battle)
    if ((*(uint *)PTR_DAT_8008d2ac & 0x8000) == 0)
	{
      return;
    }

	// if you have a life limit (battle)

	// add life variable to string
    sprintf(acStack48,&DAT_8008d520,*(undefined4 *)(param_3 + 0x4e4));

	// Draw the string
    FUN_80022878(acStack48,(param_1 + 0x25) * 0x10000 >> 0x10,(param_2 + 4) * 0x10000 >> 0x10,2,
                 (int)sVar1);

	// pointer to backbuffer
	iVar3 = *(int *)(PTR_DAT_8008d2ac + 0x10);

	// pointer to OT memory
    local_40 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c);

	// pointer to lives icon
    uVar2 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x20fc);
  }


  // If you have a point limit (battle)
  else
  {
	// add point variable to string
    sprintf(acStack48,&DAT_8008d520,

								// Battle Team of Player -> points on this team
            *(undefined4 *)(PTR_DAT_8008d2ac + *(int *)(param_3 + 0x4e8) * 4 + 0x1d90));

	// Draw the string
	FUN_80022878(acStack48,(param_1 + 0x25) * 0x10000 >> 0x10,(param_2 + 4) * 0x10000 >> 0x10,2,
                 (int)sVar1);

	// pointer to backBuffer
    iVar3 = *(int *)(PTR_DAT_8008d2ac + 0x10);

	// pointer to OT memory
    local_40 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c);

	// pointer to points icon
    uVar2 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x2100);
  }

  // DecalHUD_DrawPolyFT4
  FUN_80022db0(

	// pointer to icon
	uVar2,

	(int)(short)param_1,
	(int)(short)param_2,

	// gGT->backBuffer->primMem
	iVar3 + 0x74,

	// pointer to OT mem
	local_40,

	1,0x1000);

  return;
}


// Draw weapon and wumpa fruit in HUD
void FUN_800507e0(short param_1,short param_2,short param_3,int param_4)

{
  uint uVar1;
  int iVar2;
  undefined4 uVar3;
  int iVar4;
  short local_20;
  short local_1e;

  // If you are not shuffling through weapon roulette
  if (*(char *)(param_4 + 0x36) != '\x10')
  {
	// If you do have "no weapon icon"
    if (*(char *)(param_4 + 0x36) == '\x0f') {
      return;
    }

	// If you have a weapon that is ready to use

    iVar4 = (uint)*(byte *)(param_4 + 0x36) + 5;

	// Get the ascii character to represent the quantity
	// of weapon that you have (3 missiles)
    DAT_8008d524 = *(char *)(param_4 + 0x37) + '0';

	if (
			(
				(
					// If your weapon is a mask
					(*(byte *)(param_4 + 0x36) == 7) &&
					(
						// Player / AI structure + 0x4a shows driver index (0-7)

													// character ID
						uVar1 = SEXT24((short)(&DAT_80086e84)[*(byte *)(param_4 + 0x4a)]),

						// if not Crash
						uVar1 != 0
					)
				) &&

				// if not Coco
				(uVar1 != 3)
			) &&

			(
				(
					// if not Polar
					uVar1 != 6 &&

					// If not Pura (7, same as mask weaponID)
					// This is some insane compiler optimization
					(uVar1 != (uint)*(byte *)(param_4 + 0x36))
				)
			)
		)
	{
	  // This is a bad guy, change icon to Uka
      iVar4 = 0x32;
    }

	// if 9 < amount of wumpa fruit
	// if you have 10 wumpa fruit
    if (('\t' < *(char *)(param_4 + 0x30)) &&

		// If your weapon is less than, or equal to, 6
       (((uint)*(byte *)(param_4 + 0x36) - 3 < 2 || (*(byte *)(param_4 + 0x36) == 6))))
	{
      iVar4 = (uint)*(byte *)(param_4 + 0x36) + 0x11;
    }
    if ((*(short *)(param_4 + 0x3c) != 0) && ((*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 1) == 0)) {
      return;
    }

	// If this weapon has a quantity (3 missiles)
    if (*(char *)(param_4 + 0x37) != '\0')
	{
	  // Draw the number near the weapon icon to show how many
      FUN_80022878(&DAT_8008d524,(int)param_1,(int)param_2,2,4);
    }

	// pointer to back buffer
    iVar2 = *(int *)(PTR_DAT_8008d2ac + 0x10);

	// pointer to OT memory
    uVar3 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c);

    iVar4 = iVar4 << 2;
    goto LAB_80050abc;
  }
  iVar4 = 0;
  local_20 = param_1;
  local_1e = param_2;

  // If game is not paused
  if ((*(uint *)PTR_DAT_8008d2ac & 0xf) == 0) {

	// If you're not in Battle Mode
    if ((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0) {
      iVar4 = rand();
      iVar4 = iVar4 + ((iVar4 / 6 + (iVar4 >> 0x1f) >> 1) - (iVar4 >> 0x1f)) * -0xc;
      if (iVar4 == 5) goto LAB_800508ec;
    }
    else {
      iVar4 = rand();
      iVar4 = iVar4 % 0xe;
      if (iVar4 == 5) {
LAB_800508ec:
        iVar4 = 0;
      }
      else {
        if (iVar4 == 8) {
          iVar4 = 1;
        }
        else {
          if (iVar4 == 9) {
            iVar4 = 3;
          }
        }
      }
    }
  }

  // if timer is not finished
  if (*(int *)(param_4 + 0x4b0) != 0)
  {
	// 4b4 and 4b6 are WindowStartPos(x,y) from Camera110, inside Driver
    FUN_8004ec18(&local_20,(int)*(short *)(param_4 + 0x4b4),(int)*(short *)(param_4 + 0x4b6),
                 (int)param_1,(int)param_2,*(undefined4 *)(param_4 + 0x4b0),5);

	// subtract one from timer
    *(int *)(param_4 + 0x4b0) = *(int *)(param_4 + 0x4b0) + -1;
  }

  // pointer to back buffer
  iVar2 = *(int *)(PTR_DAT_8008d2ac + 0x10);

  // pointer to OT memory
  uVar3 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c);

  iVar4 = (iVar4 + 5) * 4;
  param_1 = local_20;
  param_2 = local_1e;
LAB_80050abc:

  FUN_80022ec4(
				// pointer to icon, from array of icon pointers
				*(undefined4 *)(PTR_DAT_8008d2ac + iVar4 + 0x1eec),

				(int)param_1,(int)param_2,

				// PrimMem
				iVar2 + 0x74,

				// OTMem
				uVar3,

				1,(int)param_3,1);
  return;
}


// Draw_JuicedUp_Shine
void FUN_80050af8(short param_1,short param_2,short param_3,int param_4)

{
  int iVar1;
  int iVar2;

  // reduce frame timer until it hits zero (unused?)
  if (*(int *)(param_4 + 0x4e0) != 0) {
    *(int *)(param_4 + 0x4e0) = *(int *)(param_4 + 0x4e0) + -1;
  }

  iVar2 = (int)param_3;

  // wumpaShineTheta (given to sine)
  DAT_8008d990 = DAT_8008d990 + 0x100;

  iVar1 = iVar2 * 0xd000 >> 0x10;

  // WeaponBackground_DrawShine
  FUN_8004e37c(
				// Weapon Roulette background (shine)
				*(undefined4 *)(PTR_DAT_8008d2ac + 0x1fb0),

				(int)param_1,(int)param_2,

				// pointer to PrimMem struct
				*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

				// pointer to OTMem (25c-168=0xf4)
				*(undefined4 *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_4 + 0x4a) * 0x110 + 0x25c),

				2,iVar2,iVar1,0xff0000);

  // WeaponBackground_DrawShine
  FUN_8004e37c(
				// Weapon Roulette background (shine)
				*(undefined4 *)(PTR_DAT_8008d2ac + 0x1fb0),

				(int)param_1,(int)param_2,

				// pointer to PrimMem struct
				*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

				// pointer to OTMem (25c-168=0xf4)
				*(undefined4 *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_4 + 0x4a) * 0x110 + 0x25c),

				3,iVar2,iVar1,0xff0000);
  return;
}


// DrawNumWumpa
void FUN_80050c20(int param_1,int param_2,int param_3)

{
  char cVar1;
  int iVar2;
  short sVar3;
  short sVar4;
  char acStack40 [16];

  sVar3 = (short)param_1;
  sVar4 = (short)param_2;

  // if number of screens is less than 3
  if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 3)
  {
	// Draw 'x' before drawing number of wumpa
    FUN_80022878(&DAT_8008d528,(int)sVar3,(param_2 + 4) * 0x10000 >> 0x10,2,0);

	// DAT_8008d510
	// %d

	// convert amount of wumpa to string
    sprintf(acStack40,&DAT_8008d510,(int)*(char *)(param_3 + 0x30));

	// draw string
	FUN_80022878(acStack40,(param_1 + 0xd) * 0x10000 >> 0x10,(int)sVar4,1,0);

  }

  // if number of screens is 3 or 4
  else
  {
	// amount of wumpa
    cVar1 = *(char *)(param_3 + 0x30);

	// amount of wumpa / 10
    iVar2 = ((int)cVar1 / 10) * 0x1000000 >> 0x18;

	// In 3P or 4P, we dont have enough time to
	// render strings, so we render individual
	// number icons 0-9

	// Draw the 10s place icon of wumpa fruit
	// DecalHUD_DrawPolyGT4
	FUN_80023054(*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x2128) + iVar2 * 4 + 0x14),

				 // Dimensions
				 (int)sVar3,
                 (int)sVar4,

				 // pointer to PrimMem struct
				 *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

				 // pointer to OT memory
                 *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				 // color data
				 *(undefined4 *)PTR_DAT_80081d70,
                 *(undefined4 *)(PTR_DAT_80081d70 + 4),
				 *(undefined4 *)(PTR_DAT_80081d70 + 8),
                 *(undefined4 *)(PTR_DAT_80081d70 + 0xc),

				 0,0x1000);

	// 0-9 - 10*0
	// 10 - 10*1

	// Draw the 1s place icon of wumpa fruit
	// DecalHUD_DrawPolyGT4
	FUN_80023054(*(undefined4 *)
                  (*(int *)(PTR_DAT_8008d2ac + 0x2128) + ((int)cVar1 + iVar2 * -10) * 4 + 0x14),

				 (int)sVar3 + 0xc,
				 (int)sVar4,

				 // pointer to PrimMem struct
				 *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

				 // pointer to OT memory
                 *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				 // color data
				 *(undefined4 *)PTR_DAT_80081d70,
                 *(undefined4 *)(PTR_DAT_80081d70 + 4),
				 *(undefined4 *)(PTR_DAT_80081d70 + 8),
                 *(undefined4 *)(PTR_DAT_80081d70 + 0xc),

				 0,0x1000);
  }
  return;
}

// DrawNumTimebox
void FUN_80050e6c(int param_1,int param_2,int param_3)

{
  char acStack32 [16];

  // Draw 'x' before drawing number of time crates
  FUN_80022878(&DAT_8008d528,(param_1 + 0x14) * 0x10000 >> 0x10,(param_2 + -10) * 0x10000 >> 0x10,2,
               0);

  // Generate message for screen
  sprintf(acStack32,"%2.02d/%ld",

			// Number of Time Crates collected
			(int)*(char *)(param_3 + 0x32),

			// Number of Total Crates collected
			*(undefined4 *)(PTR_DAT_8008d2ac + 0x1e2c));

  // Draw the string
  FUN_80022878(acStack32,(param_1 + 0x21) * 0x10000 >> 0x10,(param_2 + -0xe) * 0x10000 >> 0x10,1,0);
  return;
}


// DrawNumRelic
void FUN_80050f18(int param_1,int param_2)

{
  // number of relics
  int iVar1;

  // buffer for sprintf string
  char acStack32 [16];

  // Draw 'x' string before drawing number of relics
  FUN_80022878(&DAT_8008d528,(int)(short)param_1,(param_2 + 4) * 0x10000 >> 0x10,2,0);

  // get number of relics
  iVar1 = *(int *)(PTR_DAT_8008d2ac + 0x1e34);

  // If you're playing animation to increment number of relics while
  // returning to the podium after earning the relic
  if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x1000000) != 0)
  {
	// subtract one from the number of relics, then
	// after the animation is done, it will show the proper number
    iVar1 = iVar1 + -1;
  }

  // DAT_8008d520
  // %ld
  // convert number of relics to a string
  sprintf(acStack32,&DAT_8008d520,iVar1);

  // draw number of relics
  FUN_80022878(acStack32,(param_1 + 0xd) * 0x10000 >> 0x10,(int)(short)param_2,1,0);
  return;
}


// DrawNumKey
void FUN_80050fc4(int param_1,int param_2)

{
  // number of keys
  int iVar1;

  // buffer for sprintf
  char acStack32 [16];

  // Draw 'x' character before drawing number of keys
  FUN_80022878(&DAT_8008d528,(int)(short)param_1,(param_2 + 4) * 0x10000 >> 0x10,2,0);

  // get number of keys
  iVar1 = *(int *)(PTR_DAT_8008d2ac + 0x1e38);

  // if you just returned to podium after earning a key, and playing
  // animation for the key counter to be incremented
  if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x2000000) != 0)
  {
	// decrease key count by one until animation ends
    iVar1 = iVar1 + -1;
  }

  // DAT_8008d520
  // %ld
  // turn number of keys into a string
  sprintf(acStack32,&DAT_8008d520,iVar1);

  // draw string for number of keys
  FUN_80022878(acStack32,(param_1 + 0xd) * 0x10000 >> 0x10,(int)(short)param_2,1,0);
  return;
}


// DrawNumTrophy
void FUN_80051070(int param_1,int param_2)

{
  // number of trophies
  int iVar1;

  // buffer for sprintf
  char acStack32 [16];

  // Draw 'x' before the number of trophies
  FUN_80022878(&DAT_8008d528,(int)(short)param_1,(param_2 + 4) * 0x10000 >> 0x10,2,0);

  // number of trophies in adventure
  iVar1 = *(int *)(PTR_DAT_8008d2ac + 0x1e30);

  // If you're on the podium after winning a trophy
  if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x4000000) != 0)
  {
	// subtract a trophy, until the animation that shows
	// the trophy count incrementing is done
    iVar1 = iVar1 + -1;
  }

  // DAT_8008d520
  // %ld
  // Add trophy count to string
  sprintf(acStack32,&DAT_8008d520,iVar1);

  // Draw String
  FUN_80022878(acStack32,(param_1 + 0xd) * 0x10000 >> 0x10,(int)(short)param_2,1,0);
  return;
}


// DrawNumCrystal
void FUN_8005111c(int param_1,int param_2,int param_3)

{
  char acStack32 [16];

  // Draw 'x' before drawing the number of crystals
  FUN_80022878(&DAT_8008d528,(int)(short)param_1,(param_2 + 4) * 0x10000 >> 0x10,2,0);

  // Generate message for screen
  sprintf(acStack32,"%2.02d/%ld",

			// amount of crystals you have
			(int)*(char *)(param_3 + 0x31),

			// Number of crystals you need to win
          *(undefined4 *)(PTR_DAT_8008d2ac + 0x1e28));

  // Draw the string
  FUN_80022878(acStack32,(param_1 + 0xd) * 0x10000 >> 0x10,(int)(short)param_2,1,0);
  return;
}


// draw spedometer needle
void FUN_800511c0(short param_1,short param_2,int param_3)

{
  undefined *puVar1;
  short sVar2;
  int iVar3;
  int iVar4;
  uint *puVar5;
  int iVar6;
  int iVar7;
  undefined4 uVar8;
  int iVar9;
  uint *puVar10;
  undefined4 local_28;

  iVar9 = (uint)*(ushort *)(param_3 + 0x42e) << 0x10;
  iVar6 = iVar9 >> 0x10;
  iVar3 = iVar6 + *(short *)(param_3 + 0x432) >> 8;
  iVar4 = (uint)*(ushort *)(param_3 + 0x36e) << 0x10;
  iVar7 = 0;
  iVar9 = iVar9 >> 0x18;
  if (iVar6 < iVar4 >> 0x10) {
    local_28 = 0x700;
    uVar8 = 0x980;
    iVar7 = (iVar9 * 0x1a5e0) / 64000;
  }
  else {
    local_28 = 0x980;
    uVar8 = 0xd90;
    iVar3 = iVar9;
  }

  // Map value from [oldMin, oldMax] to [newMin, newMax]
  // inverting newMin and newMax will give an inverse range mapping
  sVar2 = FUN_80058f9c(((iVar4 >> 0x18) * 0x1a5e0) / 64000,iVar7,(iVar3 * 0x1a5e0) / 64000,uVar8,
                       local_28);

  // gGT->backBuffer
  iVar7 = *(int *)(PTR_DAT_8008d2ac + 0x10);

  // PrimMem ptrCurrent
  puVar5 = *(uint **)(iVar7 + 0x80);

  puVar10 = (uint *)0x0;

  // if there is room for more
  if (puVar5 <= *(uint **)(iVar7 + 0x84))
  {
	// increment prim pointer
    *(uint **)(iVar7 + 0x80) = puVar5 + 7;
    puVar10 = puVar5;
  }

  if (puVar10 != (uint *)0x0) {
    iVar3 = (int)sVar2;
    iVar4 = iVar3 + 0x400;
    puVar10[1] = 0x30005b5b;
    puVar10[3] = 0x30012b32;
    puVar10[5] = 0x3000bbff;

	// Sine(angle)
	iVar7 = FUN_8003d184(iVar4);

	*(short *)(puVar10 + 6) = param_1 + (short)(iVar7 * 3 >> 0xb) + 0x41;

	// Cosine(angle)
	iVar7 = FUN_8003d1c0(iVar4);

	iVar7 = ((iVar7 << 2) >> 0xb) * 0x140;
    if (iVar7 < 0) {
      iVar7 = iVar7 + 0x1ff;
    }
    *(short *)((int)puVar10 + 0x1a) = param_2 + (short)(iVar7 >> 9) + 0x29;

	// Sine(angle)
	iVar7 = FUN_8003d184(iVar3);

	*(short *)(puVar10 + 4) = param_1 - ((short)(iVar7 * 3 >> 0xb) + -0x41);

	// Cosine(angle)
	iVar7 = FUN_8003d1c0(iVar3);

	iVar7 = (iVar7 * 3 >> 0xb) * 0x140;
    if (iVar7 < 0) {
      iVar7 = iVar7 + 0x1ff;
    }
    *(short *)((int)puVar10 + 0x12) = param_2 - ((short)(iVar7 >> 9) + -0x29);

	// Sine(angle)
	iVar7 = FUN_8003d184(iVar3);

	*(short *)(puVar10 + 2) = param_1 + (short)(iVar7 * 0x1e >> 0xb) + 0x41;

	// Cosine(angle)
	iVar7 = FUN_8003d1c0(iVar3);

	puVar1 = PTR_DAT_8008d2ac;
    iVar7 = (iVar7 * 0x1e >> 0xb) * 0x140;
    if (iVar7 < 0) {
      iVar7 = iVar7 + 0x1ff;
    }
    *(short *)((int)puVar10 + 10) = param_2 + (short)(iVar7 >> 9) + 0x29;

	// pointer to OT memory
    puVar5 = *(uint **)(puVar1 + 0x147c);

    *puVar10 = *puVar5 | 0x6000000;
    *puVar5 = (uint)puVar10 & 0xffffff;

	// gGT->backBuffer
    iVar7 = *(int *)(PTR_DAT_8008d2ac + 0x10);

	// PrimMem ptrCurrent
    puVar5 = *(uint **)(iVar7 + 0x80);

	puVar10 = (uint *)0x0;

	// if there is room for more
	if (puVar5 <= *(uint **)(iVar7 + 0x84))
	{
	  // increment prim pointer
      *(uint **)(iVar7 + 0x80) = puVar5 + 7;
      puVar10 = puVar5;
    }

    if (puVar10 != (uint *)0x0) {
      puVar10[1] = 0x30ffffff;
      puVar10[3] = 0x3000699c;
      puVar10[5] = 0x3000ffff;

	  // Sine(angle)
	  iVar7 = FUN_8003d184(iVar4);

	  *(short *)(puVar10 + 6) = param_1 - ((short)(iVar7 * 3 >> 0xb) + -0x41);

	  // Cosine(angle)
	  iVar7 = FUN_8003d1c0(iVar4);

	  iVar7 = ((iVar7 << 2) >> 0xb) * 0x140;
      if (iVar7 < 0) {
        iVar7 = iVar7 + 0x1ff;
      }
      *(short *)((int)puVar10 + 0x1a) = param_2 - ((short)(iVar7 >> 9) + -0x29);

	  // Sine(angle)
	  iVar7 = FUN_8003d184(iVar3);

	  *(short *)(puVar10 + 4) = param_1 - ((short)(iVar7 * 3 >> 0xb) + -0x41);

	  // Cosine(angle)
	  iVar7 = FUN_8003d1c0(iVar3);

	  iVar7 = (iVar7 * 3 >> 0xb) * 0x140;
      if (iVar7 < 0) {
        iVar7 = iVar7 + 0x1ff;
      }
      *(short *)((int)puVar10 + 0x12) = param_2 - ((short)(iVar7 >> 9) + -0x29);

	  // Sine(angle)
	  iVar7 = FUN_8003d184(iVar3);

	  *(short *)(puVar10 + 2) = param_1 + (short)(iVar7 * 0x1e >> 0xb) + 0x41;

	  // Cosine(angle)
	  iVar7 = FUN_8003d1c0(iVar3);

	  puVar1 = PTR_DAT_8008d2ac;
      iVar7 = (iVar7 * 0x1e >> 0xb) * 0x140;
      if (iVar7 < 0) {
        iVar7 = iVar7 + 0x1ff;
      }
      *(short *)((int)puVar10 + 10) = param_2 + (short)(iVar7 >> 9) + 0x29;

	  // pointer to OT memory
      puVar5 = *(uint **)(puVar1 + 0x147c);

      *puVar10 = *puVar5 | 0x6000000;
      *puVar5 = (uint)puVar10 & 0xffffff;
    }
  }
  return;
}


// speedometer background
void FUN_800516ac(void)

{
  ushort *puVar1;
  ushort uVar2;
  short sVar3;
  undefined *puVar4;
  uint uVar5;
  uint *puVar6;
  uint uVar7;
  uint *puVar8;
  int iVar9;
  int iVar10;
  ushort *puVar11;
  int iVar12;
  int iVar13;

  puVar11 = &DAT_800864a4;
  iVar10 = 1;
  iVar9 = 0;
  do {
    iVar13 = iVar9 + 2;

	// CTR_Box_DrawWirePrims
    FUN_80021500((int)(((uint)*puVar11 + 0x1e0) * 0x10000) >> 0x10,
                 (int)(((uint)puVar11[1] + 0xbe) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_800864a4)[iVar10 * 2] + 0x1e0) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_800864a6)[iVar10 * 2] + 0xbe) * 0x10000) >> 0x10,0xff,
                 0xff,0xff,

				 // pointer to OT memory
				 *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				 // pointer to PrimMem struct
                 *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

    uVar2 = *puVar11;
    puVar1 = puVar11 + 1;
    puVar11 = puVar11 + 4;

	// CTR_Box_DrawWirePrims
    FUN_80021500((int)(((uint)uVar2 + 0x1e1) * 0x10000) >> 0x10,
                 (int)(((uint)*puVar1 + 0xbf) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_800864a4)[iVar10 * 2] + 0x1e1) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_800864a6)[iVar10 * 2] + 0xbf) * 0x10000) >> 0x10,0,0,0,

				 // pointer to OT memory
				 *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				 // pointer to PrimMem struct
				 *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74
                );
    iVar10 = iVar9 + 3;
    iVar9 = iVar13;
  } while (iVar13 < 0xe);
  iVar9 = 0;
  do {
    iVar12 = iVar9 + 2;

	// CTR_Box_DrawWirePrims
    FUN_80021500((int)(((uint)(ushort)(&DAT_8008646c)[iVar9 * 2] + 0x1e0) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646e)[iVar9 * 2] + 0xbe) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646c)[iVar12 * 2] + 0x1e0) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646e)[iVar12 * 2] + 0xbe) * 0x10000) >> 0x10,0xff,
                 0xff,0xff,

				 // pointer to OT memory
				 *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				 // pointer to PrimMem struct
                 *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

    iVar13 = iVar9 + 1;
    iVar10 = iVar9 + 3;

	// CTR_Box_DrawWirePrims
    FUN_80021500((int)(((uint)(ushort)(&DAT_8008646c)[iVar13 * 2] + 0x1e0) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646e)[iVar13 * 2] + 0xbe) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646c)[iVar10 * 2] + 0x1e0) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646e)[iVar10 * 2] + 0xbe) * 0x10000) >> 0x10,0xff,
                 0xff,0xff,

				 // pointer to OT memory
				 *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				 // pointer to PrimMem struct
                 *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

	// CTR_Box_DrawWirePrims
    FUN_80021500((int)(((uint)(ushort)(&DAT_8008646c)[iVar9 * 2] + 0x1e1) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646e)[iVar9 * 2] + 0xbf) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646c)[iVar12 * 2] + 0x1e1) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646e)[iVar12 * 2] + 0xbf) * 0x10000) >> 0x10,0,0,0,

				 // pointer to OT memory
				 *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				 // pointer to PrimMem struct
				 *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

	// CTR_Box_DrawWirePrims
    FUN_80021500((int)(((uint)(ushort)(&DAT_8008646c)[iVar13 * 2] + 0x1e1) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646e)[iVar13 * 2] + 0xbf) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646c)[iVar10 * 2] + 0x1e1) * 0x10000) >> 0x10,
                 (int)(((uint)(ushort)(&DAT_8008646e)[iVar10 * 2] + 0xbf) * 0x10000) >> 0x10,0,0,0,

				 // pointer to OT memory
				 *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				 // pointer to PrimMem struct
				 *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

	// backDB
    iVar10 = *(int *)(PTR_DAT_8008d2ac + 0x10);

    puVar6 = *(uint **)(iVar10 + 0x80);
    puVar8 = (uint *)0x0;
    if (puVar6 <= *(uint **)(iVar10 + 0x84)) {
      *(uint **)(iVar10 + 0x80) = puVar6 + 9;
      puVar8 = puVar6;
    }
    if (puVar8 == (uint *)0x0) {
      return;
    }
    uVar5 = 0xb500;
    uVar7 = uVar5;
    if ((2 < iVar9) && (uVar7 = 0xd1ff, 4 < iVar9)) {
      uVar5 = 0xd1ff;
      if (iVar9 < 7) {
        uVar7 = 0xdb;
      }
      else {
        uVar5 = 0xdb;
        uVar7 = uVar5;
      }
    }
    puVar8[1] = uVar5 | 0x38000000;
    puVar8[3] = uVar5 | 0x38000000;
    puVar8[5] = uVar7 | 0x38000000;
    puVar8[7] = uVar7 | 0x38000000;
    iVar10 = iVar9 + 2;
    *(short *)(puVar8 + 2) = (&DAT_8008646c)[iVar9 * 2] + 0x1e0;
    *(short *)((int)puVar8 + 10) = (&DAT_8008646e)[iVar9 * 2] + 0xbe;
    *(short *)(puVar8 + 4) = (&DAT_8008646c)[(iVar9 + 1) * 2] + 0x1e0;
    *(short *)((int)puVar8 + 0x12) = (&DAT_8008646e)[(iVar9 + 1) * 2] + 0xbe;
    *(short *)(puVar8 + 6) = (&DAT_8008646c)[iVar10 * 2] + 0x1e0;
    *(short *)((int)puVar8 + 0x1a) = (&DAT_8008646e)[iVar10 * 2] + 0xbe;
    *(short *)(puVar8 + 8) = (&DAT_8008646c)[(iVar9 + 3) * 2] + 0x1e0;
    puVar4 = PTR_DAT_8008d2ac;
    *(short *)((int)puVar8 + 0x22) = (&DAT_8008646e)[(iVar9 + 3) * 2] + 0xbe;

	// pointer to OT memory
	puVar6 = *(uint **)(puVar4 + 0x147c);

	*puVar8 = *puVar6 | 0x8000000;
    *puVar6 = (uint)puVar8 & 0xffffff;
    iVar9 = iVar10;
  } while (iVar10 < 0xc);
  iVar13 = 0;
  iVar10 = 0xc;
  iVar9 = 4;
  while( true )
  {
	// gGT->backbuffer
    iVar12 = *(int *)(PTR_DAT_8008d2ac + 0x10);

	// PrimMem ptrCurrent
	puVar6 = *(uint **)(iVar12 + 0x80);

    puVar8 = (uint *)0x0;

	// if there is room for more
	if (puVar6 <= *(uint **)(iVar12 + 0x84))
	{
	  // increment primitive pointer
      *(uint **)(iVar12 + 0x80) = puVar6 + 9;
      puVar8 = puVar6;
    }
    if (puVar8 == (uint *)0x0) break;
    *(short *)(puVar8 + 4) = *(short *)((int)&DAT_8008646c + iVar9) + 0x1e0;
    *(short *)((int)puVar8 + 0x12) = *(short *)((int)&DAT_8008646e + iVar9) + 0xbe;
    *(short *)(puVar8 + 6) = *(short *)((int)&DAT_8008646c + iVar10) + 0x1e0;
    iVar9 = iVar9 + 8;
    *(short *)((int)puVar8 + 0x1a) = *(short *)((int)&DAT_8008646e + iVar10) + 0xbe;
    iVar13 = iVar13 + 2;
    *(short *)(puVar8 + 8) = DAT_800864a0 + 0x1e0;
    sVar3 = DAT_80086472;
    *(undefined *)((int)puVar8 + 3) = 8;
    *(undefined *)((int)puVar8 + 0xf) = 0x32;
    *(undefined *)(puVar8 + 5) = 0;
    *(undefined *)((int)puVar8 + 0x15) = 0;
    *(undefined *)((int)puVar8 + 0x16) = 0;
    *(undefined *)(puVar8 + 3) = 0;
    *(undefined *)((int)puVar8 + 0xd) = 0;
    *(undefined *)((int)puVar8 + 0xe) = 0;
    *(undefined *)(puVar8 + 7) = 0;
    *(undefined *)((int)puVar8 + 0x1d) = 0;
    *(undefined *)((int)puVar8 + 0x1e) = 0;
    puVar4 = PTR_DAT_8008d2ac;
    puVar8[1] = 0xe1000a00;
    puVar8[2] = 0;
    *(short *)((int)puVar8 + 0x22) = sVar3 + 0xbe;

	// pointer to OT memory
    puVar6 = *(uint **)(puVar4 + 0x147c);

	iVar10 = iVar10 + 8;
    *puVar8 = *puVar6 | 0x8000000;
    *puVar6 = (uint)puVar8 & 0xffffff;
    if (0xb < iVar13) {
      return;
    }
  }
  return;
}


//handles Jump meter and landing boosts
//param_1 is player struct pointer
void FUN_80051c64(int param_1)
{
  short sVar1;
  int iVar2;

  //if player is not in the air
  if ((*(uint *)(param_1 + 0x2c8) & 0x80000) == 0)
  {
    //if, in previous frame? player was not in the air either
    if ((*(uint *)(param_1 + 0x2cc) & 0x80000) == 0)
	{
      //if Jump meter Timer is done
      if (*(short *)(param_1 + 0x48) == 0) {
        //reset Jump meter
        *(undefined2 *)(param_1 + 0x46) = 0;
      }
      //if Jump meter Timer is not done
      else
      {
        //iVar2 = Jump meter Timer - ~32ms
        iVar2 = (uint)*(ushort *)(param_1 + 0x48) - (uint)*(ushort *)(PTR_DAT_8008d2ac + 0x1d04);
        //reduce Jump meter Timer by ~32ms
        *(undefined2 *)(param_1 + 0x48) = (short)iVar2;
        //if Jump meter Timer goes negative
        if (iVar2 * 0x10000 < 0) {
          //prevent Jump meter Timer from going negative
          *(undefined2 *)(param_1 + 0x48) = 0;
        }
      }
    }
    //if, in previous frame? player was in the air
    else
	{
      //iVar2 = Jump meter
      iVar2 = (int)*(short *)(param_1 + 0x46);
      //if Jump meter > 0x150

	  // if jump is high enough to be significant
	  if (0x150 < iVar2) 
	  {
        // keep track of all jumps
        *(int *)(param_1 + 0x53c) = *(int *)(param_1 + 0x53c) + iVar2;
		
        iVar2 = (int)*(short *)(param_1 + 0x46);
      }

      // if highest jump is less than current jump
      if (*(short *)(param_1 + 0x550) < iVar2) 
	  {
        // save highest jump
        *(undefined2 *)(param_1 + 0x550) = *(undefined2 *)(param_1 + 0x46);
      }

      //sVar1 = Jump meter
      sVar1 = *(short *)(param_1 + 0x46);

	  //if Jump meter < 0x5A0
      if (sVar1 < 0x5a0)
	  {
        //if Jump meter < 0x3C0
        if (sVar1 < 0x3c0)
		{
          //if Jump meter > 0x27F
          if (0x27f < sVar1)
		  {
			// Turbo_Increment
            // add one second reserves
            FUN_8005abfc(param_1,0x3c0,2,0);
          }
        }

		//if Jump meter >= 0x3C0
        else
		{
		  // Turbo_Increment
          // add one second reserves, plus speed
          FUN_8005abfc(param_1,0x3c0,2,0x80);
        }
      }

      //if Jump meter >= 0x5A0
      else
	  {
		// Turbo_Increment
        // add one second reserves, plus speed
        FUN_8005abfc(param_1,0x3c0,2,0x100);
      }
    }
  }

  //if player is in the air
  else
  {
    //if (0x3FC of player struct > 0x480) and Jump meter < 0x481
    if ((0x480 < *(short *)(param_1 + 0x3fc)) && (*(short *)(param_1 + 0x46) < 0x481))
    {
      //Jump meter related operation

	  // Make driver talk
      FUN_8002cbe8(7,(int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)],0x10);
    }

    //Jump meter = 0x3FC
    *(short *)(param_1 + 0x46) = *(short *)(param_1 + 0x3fc);

	//if Jump meter > 0x960
    if (0x960 < *(short *)(param_1 + 0x3fc))
	{
      //prevent Jump meter from going over 0x960
      *(undefined2 *)(param_1 + 0x46) = 0x960;
    }
    //keep Jump meter Timer at 0x5A0.
    *(undefined2 *)(param_1 + 0x48) = 0x5a0;
  }
  return;
}


// Draw Jump Meter
void FUN_80051e24(short param_1,short param_2,int param_3)

{
  undefined *puVar1;
  uint uVar2;
  short sVar3;
  int iVar4;
  int iVar5;
  uint *puVar6;
  uint *puVar7;
  int iVar8;
  short sVar9;
  int iVar10;
  int iVar11;
  short local_48;
  short local_46;
  undefined2 local_44;
  undefined2 local_42;
  undefined auStack64 [8];
  short local_38;
  short local_36;
  undefined2 local_34;
  undefined2 local_32;
  undefined auStack48 [8];

  iVar5 = ((int)*(short *)(param_3 + 0x46) / 0x3c0) * 0x10000 >> 0x10;
  iVar4 = (int)*(short *)(param_3 + 0x46) + iVar5 * -0x3c0;
  iVar10 = ((iVar4 / 6 + (iVar4 >> 0x1f) >> 4) - (iVar4 >> 0x1f)) * 0x10000 >> 0x10;
  iVar11 = (int)param_1;
  iVar8 = (int)param_2 + -0x2b;

  // DebugFont_DrawNumbers
  FUN_80022318(iVar5,iVar11 + -0x10,iVar8);
  FUN_80022318(iVar10,iVar11 + -4,iVar8);
  FUN_80022318((((iVar4 + iVar10 * -0x60) * 100) / 0x3c0) * 0x10000 >> 0x10,iVar11 + 4,iVar8);

  sVar9 = param_1 + -0x14;
  sVar3 = param_2 + -0x2d;
  local_44 = 0x22;
  local_42 = 10;
  local_48 = sVar9;
  local_46 = sVar3;
  memset(auStack64,0,4);

  // CTR_Box_DrawWireBox
  FUN_80021594(&local_48,auStack64,

				// pointer to OT memory
				*(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

			   // pointer to PrimMem struct
			   *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

  // backDB
  iVar4 = *(int *)(PTR_DAT_8008d2ac + 0x10);

  // PrimMem ptrCurrent
  puVar6 = *(uint **)(iVar4 + 0x80);

  puVar7 = (uint *)0x0;

  // if there is room left for more
  if (puVar6 <= *(uint **)(iVar4 + 0x84))
  {
	// add primitives
    *(uint **)(iVar4 + 0x80) = puVar6 + 6;

    puVar7 = puVar6;
  }

  if (puVar7 != (uint *)0x0) {
    puVar7[1] = 0x28ffffff;
    puVar1 = PTR_DAT_8008d2ac;
    *(short *)(puVar7 + 3) = param_1 + 0xe;
    *(short *)(puVar7 + 5) = param_1 + 0xe;
    *(short *)(puVar7 + 2) = sVar9;
    *(short *)((int)puVar7 + 10) = sVar3;
    *(short *)((int)puVar7 + 0xe) = sVar3;
    *(short *)(puVar7 + 4) = sVar9;
    *(short *)((int)puVar7 + 0x12) = param_2 + -0x23;
    *(short *)((int)puVar7 + 0x16) = param_2 + -0x23;

	// pointer to OT memory
    puVar6 = *(uint **)(puVar1 + 0x147c);

    *puVar7 = *puVar6 | 0x5000000;
    *puVar6 = (uint)puVar7 & 0xffffff;
    local_36 = param_2 + -0x26;
    local_34 = 0xc;
    local_32 = 0x26;
    local_38 = param_1;
    memset(auStack48,0,4);

	// CTR_Box_DrawWireBox
    FUN_80021594(&local_38,auStack48,

				// pointer to OT memory
				*(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				// pointer to PrimMem struct
				*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

	// BackDB
	iVar4 = *(int *)(PTR_DAT_8008d2ac + 0x10);

    puVar6 = *(uint **)(iVar4 + 0x80);
    puVar7 = (uint *)0x0;
    if (puVar6 <= *(uint **)(iVar4 + 0x84)) {
      *(uint **)(iVar4 + 0x80) = puVar6 + 6;
      puVar7 = puVar6;
    }
    if (puVar7 != (uint *)0x0) {
      sVar3 = *(short *)(param_3 + 0x46);
      sVar9 = *(short *)(param_3 + 0x46);
      uVar2 = 0x28ff0000;
      if (0x27f < sVar3) {
        if (sVar3 < 0x3c0) {
          uVar2 = 0x2800ff00;
        }
        else {
          if (sVar3 < 0x5a0) {
            uVar2 = 0x2800ffff;
          }
          else {
            uVar2 = 0x280000ff;
          }
        }
      }
      puVar7[1] = uVar2;
      iVar4 = (int)sVar9 * 0x26;
      sVar9 = param_1 + 0xc;
      *(short *)(puVar7 + 2) = param_1;
      *(short *)(puVar7 + 3) = sVar9;
      *(short *)(puVar7 + 4) = param_1;
      *(short *)((int)puVar7 + 0x12) = param_2;
      *(short *)(puVar7 + 5) = sVar9;
      *(short *)((int)puVar7 + 0x16) = param_2;
      puVar1 = PTR_DAT_8008d2ac;
      sVar3 = param_2 - ((short)((ulonglong)((longlong)iVar4 * 0x1b4e81b5) >> 0x28) -
                        (short)(iVar4 >> 0x1f));
      *(short *)((int)puVar7 + 10) = sVar3;
      *(short *)((int)puVar7 + 0xe) = sVar3;

	  // pointer to OT memory
      puVar6 = *(uint **)(puVar1 + 0x147c);

	  *puVar7 = *puVar6 | 0x5000000;
      *puVar6 = (uint)puVar7 & 0xffffff;

	  // gGT->backBuffer
      iVar4 = *(int *)(PTR_DAT_8008d2ac + 0x10);

	  // primMem ptrCurrent
      puVar6 = *(uint **)(iVar4 + 0x80);
      puVar7 = (uint *)0x0;

	  // If there is room to add more
      if (puVar6 <= *(uint **)(iVar4 + 0x84))
	  {
		// Add more primitives
        *(uint **)(iVar4 + 0x80) = puVar6 + 6;
        puVar7 = puVar6;
      }
      if (puVar7 != (uint *)0x0) {
        puVar7[1] = 0x28808080;
        puVar1 = PTR_DAT_8008d2ac;
        *(short *)(puVar7 + 2) = param_1;
        *(short *)((int)puVar7 + 10) = param_2 + -0x26;
        *(short *)(puVar7 + 3) = sVar9;
        *(short *)((int)puVar7 + 0xe) = param_2 + -0x26;
        *(short *)(puVar7 + 4) = param_1;
        *(short *)((int)puVar7 + 0x12) = param_2;
        *(short *)(puVar7 + 5) = sVar9;
        *(short *)((int)puVar7 + 0x16) = param_2;

		// pointer to OT memory
        puVar6 = *(uint **)(puVar1 + 0x147c);

        *puVar7 = *puVar6 | 0x5000000;
        *puVar6 = (uint)puVar7 & 0xffffff;
      }
    }
  }
  return;
}


// Draw powerslide meter
void FUN_80052250(short param_1,short param_2,int param_3)

{
  undefined *puVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint *puVar5;
  uint *puVar6;
  short sVar7;
  short sVar8;
  short local_30;
  short local_2e;
  undefined2 local_2c;
  short local_2a;
  undefined auStack40 [8];

  sVar8 = 0;

  // height of bar in 1P or 2P
  sVar7 = 7;

  // if number of screens is more than 2 (3P or 4P)
  if (2 < (byte)PTR_DAT_8008d2ac[0x1ca8])
  {
	// Make the bar shorter
    sVar7 = 3;
  }

  // if powerslide meter is not zero
  if ((int)*(short *)(param_3 + 0x3dc) != 0)
  {
	// current room remaining
    iVar4 = (int)*(short *)(param_3 + 0x3dc) * 0x31;

	// max amount of room in turbo
    iVar3 = (uint)*(byte *)(param_3 + 0x476) << 5;

	// max turbo meter size must be more than zero
    if (*(byte *)(param_3 + 0x476) == 0) {
      trap(0x1c00);
    }
    if ((iVar3 == -1) && (iVar4 == -0x80000000)) {
      trap(0x1800);
    }

	// length of rectangle is currentRoom / maxRoom
    sVar8 = 0x31 - (short)(iVar4 / iVar3);
  }
  local_30 = param_1 + -0x31;
  local_2e = param_2 - sVar7;
  local_2c = 0x31;
  local_2a = sVar7;
  memset(auStack40,0,4);

  // CTR_Box_DrawWireBox
  FUN_80021594(&local_30,auStack40,

				// pointer to OT memory
				*(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				// pointer to PrimMem struct
				*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

  // BackDB
  iVar4 = *(int *)(PTR_DAT_8008d2ac + 0x10);

  // backDB->primMem.curr
  puVar6 = *(uint **)(iVar4 + 0x80);

  puVar5 = (uint *)0x0;

  // if there is room remaining to draw
  if (puVar6 <= *(uint **)(iVar4 + 0x84))
  {
	// increment "curr" for next draw after powerslide meter
    *(uint **)(iVar4 + 0x80) = puVar6 + 6;

	// set pointer for where to draw powerslide meter primMem
    puVar5 = puVar6;
  }

  // if we are definitely drawing the powerslide meter
  if (puVar5 != (uint *)0x0)
  {
	// if remaining room is more than the "low warning"
    if ((int)((uint)*(byte *)(param_3 + 0x477) << 5) < (int)*(short *)(param_3 + 0x3dc))
	{
	  // set color to green
      uVar2 = 0x2800ff00;
    }

	// if room remaining is lower than "low warning"
    else
	{
	  // set color to red
      uVar2 = 0x280000ff;
    }

    puVar5[1] = uVar2;
    puVar1 = PTR_DAT_8008d2ac;
    sVar7 = param_2 - sVar7;
    *(short *)(puVar5 + 2) = param_1 - sVar8;
    *(short *)((int)puVar5 + 10) = sVar7;
    *(short *)(puVar5 + 3) = param_1;
    *(short *)((int)puVar5 + 0xe) = sVar7;
    *(short *)((int)puVar5 + 0x12) = param_2;
    *(short *)(puVar5 + 5) = param_1;
    *(short *)((int)puVar5 + 0x16) = param_2;
    *(short *)(puVar5 + 4) = param_1 - sVar8;

	// pointer to OT memory
    puVar6 = *(uint **)(puVar1 + 0x147c);

    *puVar5 = *puVar6 | 0x5000000;
    *puVar6 = (uint)puVar5 & 0xffffff;
    iVar4 = *(int *)(PTR_DAT_8008d2ac + 0x10);
    puVar6 = *(uint **)(iVar4 + 0x80);
    puVar5 = (uint *)0x0;
    if (puVar6 <= *(uint **)(iVar4 + 0x84)) {
      *(uint **)(iVar4 + 0x80) = puVar6 + 6;
      puVar5 = puVar6;
    }
    if (puVar5 != (uint *)0x0) {
      puVar5[1] = 0x28808080;
      puVar1 = PTR_DAT_8008d2ac;
      *(short *)(puVar5 + 2) = param_1 + -0x31;
      *(short *)((int)puVar5 + 10) = sVar7;
      *(short *)(puVar5 + 3) = param_1;
      *(short *)((int)puVar5 + 0xe) = sVar7;
      *(short *)((int)puVar5 + 0x12) = param_2;
      *(short *)(puVar5 + 5) = param_1;
      *(short *)((int)puVar5 + 0x16) = param_2;
      *(short *)(puVar5 + 4) = param_1 + -0x31;

	  // pointer to OT memory
      puVar6 = *(uint **)(puVar1 + 0x147c);

	  *puVar5 = *puVar6 | 0x5000000;
      *puVar6 = (uint)puVar5 & 0xffffff;
    }
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

// Draw player icons on left side of screen
// in Arcade mode and Boss mode, and draws
// icons in multiplayer on the midY axis (and warpball)

// DrawHUD_DriverIcons
void FUN_800524c4(void)

{
  ushort uVar1;
  bool bVar2;
  int iVar3;
  int iVar4;
  undefined *puVar5;
  undefined4 uVar6;
  uint uVar7;
  short *psVar8;
  undefined2 *puVar9;
  short sVar10;
  ushort uVar11;
  int iVar12;
  short *psVar13;
  int iVar14;
  int iVar15;
  ushort *puVar16;
  short *psVar17;
  ushort uVar18;
  undefined4 local_50;
  undefined4 local_48;
  short local_44;
  short local_40;
  short local_3e;
  short local_3c;
  undefined4 local_38;
  short local_34;
  uint local_30;
  uint local_2c;

  // if number of screens is 1
  if (PTR_DAT_8008d2ac[0x1ca8] == '\x01')
  {
	// Number of racers that have finished race
    sVar10 = 0;

	// loop counter
    iVar14 = 0;

    puVar9 = &DAT_800862b8;
    psVar8 = &DAT_800862d8;

	// incremented when looping through player structures
    puVar5 = PTR_DAT_8008d2ac;

	// iVar14 = 0; iVar14 < 8; iVar14++
    do {
      if (*psVar8 == 0)
	  {
		// player structure + 0x482 is your rank in the race
		// 0 = 1st place, 1 = 2nd place, 2 = 3rd place, etc
        *puVar9 = *(undefined2 *)(*(int *)(puVar5 + 0x24ec) + 0x482);
      }

	  // if player structure pointer is not nullptr
      if ((*(int *)(puVar5 + 0x24ec) != 0) &&

        //if racer finished the race
        ((*(uint *)(*(int *)(puVar5 + 0x24ec) + 0x2c8) & 0x2000000) != 0))
	  {
		// count how many racers have finished
        sVar10 = sVar10 + 1;
      }

	  // increment pointer for next player structure
      puVar5 = puVar5 + 4;
      puVar9 = puVar9 + 1;

	  // increment loop counter
      iVar14 = iVar14 + 1;

      psVar8 = psVar8 + 1;
    } while (iVar14 < 8);

	// In a normal arcade race, there are 4 icons
	// on the left side of the screen, for characters
	// in the top 4 places
    iVar14 = 4;

	// If you're in a Boss Race
	// 0x80000000
    if (*(int *)PTR_DAT_8008d2ac < 0)
	{
	  // There are only 2 icons that show position
      iVar14 = 2;
    }

	// start drawing the icons
    iVar15 = 0;

	// If there are icons you want to draw,
	// in this function it will 100% happen
    if (iVar14 != 0)
	{
	  // height to draw rank (this bitshifts later)
      iVar12 = 0x380000;

	  // first racer finished the race if
	  // the number of racers that finished
	  // is more than zero
      bVar2 = 0 < (int)sVar10;

	  // for iVar15 = 0; iVar15 < iVar14; iVar15++
      do
	  {
		// make the text white by default
        uVar6 = 4;

		// if racer has finished the race
        if (bVar2)
		{
		  // make the text red
          uVar6 = 3;
        }

		// convert binary value of iVar15 to ascii
		// by adding '1'... '1', '2', '3', '4'
        DAT_8008d524 = (char)iVar15 + '1';

		// Draw the ranking string
		// white if driver is racing, red if they finished
        FUN_80022878(&DAT_8008d524,0x34,iVar12 >> 0x10,2,uVar6);

		// add to Y, which mekes it lower on screen
        iVar12 = iVar12 + 0x1b0000;

		// increment loop counter
        iVar15 = iVar15 + 1;

		// check if the next racer finished race,
		// before their iteration starts. Willl
		// be true if index is less than num racers finished
        bVar2 = iVar15 < (int)sVar10;

      } while (iVar15 < iVar14);
    }

    iVar14 = 0;

	// these two arrays are compared when animating
	// icons to move up and down the board

	// rank of driver index (drawn on left)
    psVar17 = &DAT_800862c8;

	// rank of driver index (absolute)
    psVar8 = &DAT_800862b8;

	iVar15 = 0;

	// for iVar14 = 0; iVar14 < 8; iVar14++
    do
	{
	  // This is combined with 0x24ec to get the
	  // pointer to the structure of every driver
      puVar5 = PTR_DAT_8008d2ac + iVar14 * 4;

      if (
			// if player structure pointer is not nullptr
			(*(int *)(puVar5 + 0x24ec) != 0) &&

			// if you haven't gotten to the last driver
			((int)*psVar8 + 1 < 9)
		  )
	  {
		// player structure + [some offset]
        iVar12 = *(int *)(*(int *)(puVar5 + 0x24ec) + 0x4ac);

        if (iVar12 < 1) {

		  // if icon should be turning green
		  if (iVar12 < 0) {

            local_30._0_2_ =							// player structure + [some offset]
                 CONCAT11(~(((char)*(undefined4 *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) + '\x1e') *
                           '\x04'),((char)iVar12 + '\x1e') * '\x04');
            local_30._0_3_ =							// player structure + [some offset]
                 CONCAT12(((char)*(undefined4 *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) + '\x1e') *
                          '\x04',(undefined2)local_30);
            local_30 = (uint)(uint3)local_30;

			// timer is negative,
			// add to timer, making it closer to zero
            *(int *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) =
                 *(int *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) + 1;
          }

		  // if icon should have no effect
		  // (less than 1, not less than zero, must equal zero)
          else
		  {
			// make icon white
            local_30 = 0x808080;
          }
        }

		// if icon should be turning red
        else {
          local_30._0_2_ =									// player structure + [some offset]
               CONCAT11(('\x1e' - (char)*(undefined4 *)(*(int *)(puVar5 + 0x24ec) + 0x4ac)) * '\x04'
                        ,~(('\x1e' - (char)iVar12) * '\x04'));
          local_30._0_3_ =									// player structure + [some offset]
               CONCAT12(('\x1e' - (char)*(undefined4 *)(*(int *)(puVar5 + 0x24ec) + 0x4ac)) * '\x04'
                        ,(undefined2)local_30);
          local_30 = (uint)(uint3)local_30;

		  // timer is positive,
		  // decrement to get closer to zero
          *(int *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) =
               *(int *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) + -1;
        }

        psVar13 = (short *)((int)&DAT_800862d8 + iVar15);

		if (*psVar13 == 0) {

		  // get absolute pos-rank of driver
		  iVar12 = (int)*psVar8;

		  // if that's the same as the pos-rank
		  // shown on the left of the screen
		  // (if rank is not animated to move up or down)
          if (iVar12 == (int)*psVar17)
		  {
			// if you are in the top four positions
            if (iVar12 + 1 < 5) {

			  // Draw character icon
              FUN_8004e8d8(
							// MetaDataCharacters -> iconID
							*(undefined4 *)
                            (PTR_DAT_8008d2ac +
                            (int)*(short *)(&DAT_80086d8c +
                                           (int)*(short *)((int)&DAT_80086e84 + iVar15) * 0x10) * 4
                            + 0x1eec),

							0x14,iVar12 * 0x1b + 0x39,

							// pointer to PrimMem struct
                           *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

						   // pointer to OT memory
                           *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

						   1,0x1000,local_30);

			  *psVar17 = *psVar8;
            }
            goto LAB_800528cc;
          }
        }

		// at this point, icon must be moving up or down
		// on the list of top-ranking drivers

		// get position of icon based on a circular motion to move
		// the driver up or down in the ranks (left of screen in Arcade or Boss race)
        FUN_8004eaa8(
						&local_50,
						(int)*(short *)((int)&DAT_800862c8 + iVar15),
						(int)*(short *)((int)&DAT_800862b8 + iVar15)
					);

		// Draw character icon
        FUN_8004e8d8(
					// MetaDataCharacters -> iconID
					*(undefined4 *)
                      (PTR_DAT_8008d2ac +
                      (int)*(short *)(&DAT_80086d8c +
                                     (int)*(short *)((int)&DAT_80086e84 + iVar15) * 0x10) * 4 +
                      0x1eec),(int)(short)local_50,(int)local_50._2_2_,

					  // pointer to PrimMem struct
                     *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

					 // pointer to OT memory
                     *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

					 1,0x1000,local_30);

        sVar10 = *psVar13;
        *psVar13 = sVar10 + 1;
        if (4 < (short)(sVar10 + 1)) {
          *psVar13 = 0;
          *(short *)((int)&DAT_800862c8 + iVar15) = *(short *)((int)&DAT_800862b8 + iVar15);
        }
      }
LAB_800528cc:
      psVar17 = psVar17 + 1;
      psVar8 = psVar8 + 1;

	  // increment loop counter
      iVar14 = iVar14 + 1;

      iVar15 = iVar15 + 2;
    } while (iVar14 < 8);
  }

  // if this is multiplayer
  else {

	// loop counter
    iVar14 = 0;

	// number of screens  +  number of AIs
    if ((uint)(byte)PTR_DAT_8008d2ac[0x1ca8] + (uint)(byte)PTR_DAT_8008d2ac[0x1cab] != 0) {
      puVar16 = &DAT_800862d8;
      iVar12 = 0;
      iVar15 = 0;

	  // for iVar14 = 0; iVar14 < numScreens+numAI; iVar14++
	  do
	  {
		// puVar5 increases by 4 for each iteration

		// combined with 0x24ec to get every pointer to every driver
        puVar5 = PTR_DAT_8008d2ac + iVar15;

		// player structure + [some offset]
        iVar3 = *(int *)(*(int *)(puVar5 + 0x24ec) + 0x4ac);

        if (iVar3 < 1) {
          if (iVar3 < 0) {
            local_2c._0_2_ =							// player structure + [some offset]
                 CONCAT11(~(((char)*(undefined4 *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) + '\x1e') *
                           '\x04'),((char)iVar3 + '\x1e') * '\x04');

            local_2c._0_3_ =							// player structure + [some offset]
                 CONCAT12(((char)*(undefined4 *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) + '\x1e') *
                          '\x04',(undefined2)local_2c);
            local_2c = (uint)(uint3)local_2c;

			// player structure + [some offset]
            *(int *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) =
                 *(int *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) + 1;
          }
          else {
            local_2c = 0x808080;
          }
        }
        else {
          local_2c._0_2_ =									// player structure + [some offset]
               CONCAT11(('\x1e' - (char)*(undefined4 *)(*(int *)(puVar5 + 0x24ec) + 0x4ac)) * '\x04'
                        ,~(('\x1e' - (char)iVar3) * '\x04'));

          local_2c._0_3_ =									// player structure + [some offset]
               CONCAT12(('\x1e' - (char)*(undefined4 *)(*(int *)(puVar5 + 0x24ec) + 0x4ac)) * '\x04'
                        ,(undefined2)local_2c);
          local_2c = (uint)(uint3)local_2c;

		  // player structure + [some offset]
          *(int *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) =
               *(int *)(*(int *)(puVar5 + 0x24ec) + 0x4ac) + -1;
        }
        local_50 = local_2c;
        uVar1 = *puVar16;

        if (
				  //if racer is in first lap and
				  (*(char *)(*(int *)(PTR_DAT_8008d2ac + iVar15 + 0x24ec) + 0x44) == '\0') &&
				  //racer crossed the startline backwards
          //this is when race starts and you're behind the finish line
				  ((*(uint *)(*(int *)(PTR_DAT_8008d2ac + iVar15 + 0x24ec) + 0x2c8) & 0x1000000) != 0)
		    )
        {
LAB_80052b00:
		  // icon posX is zero,
		  // dont go to end of lap on the graph
          uVar18 = 0;
        }
        else 
		{
		  // length of track
          iVar3 = (uint)*(ushort *)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c) + 6) * 8;

		  // icon posX = track length - driver->distanceToFinish
          iVar4 = iVar3 - *(int *)(*(int *)(PTR_DAT_8008d2ac + iVar15 + 0x24ec) + 0x488);
		  
		  // divide track length by 0x1d1 (approx screen width)
          iVar3 = iVar3 / 0x1d1;
		  
		  // divide distanceToFinish by screen width
          _uVar18 = iVar4 / iVar3;
          uVar18 = (ushort)_uVar18;
		  
          if (iVar3 == 0) {
            trap(0x1c00);
          }
          if ((iVar3 == -1) && (iVar4 == -0x80000000)) {
            trap(0x1800);
          }
          if (_uVar18 << 0x10 < 0) goto LAB_80052b00;
        }
		
		// posX
        iVar4 = (int)(short)uVar18;
        iVar3 = iVar4 - (short)uVar1;
        
		if (iVar3 < 0) {
          iVar3 = -iVar3;
        }
        uVar7 = iVar3 / 0xe;
        if ((uVar7 & 0xffff) == 0) {
          uVar7 = 1;
        }
        iVar3 = uVar1 + uVar7;
        uVar11 = (ushort)iVar3;
        if ((short)uVar1 < iVar4) {
          bVar2 = iVar4 < iVar3 * 0x10000 >> 0x10;
        }
        else {
          iVar3 = uVar1 - uVar7;
          uVar11 = (ushort)iVar3;
          bVar2 = iVar3 * 0x10000 >> 0x10 < iVar4;
        }
        if (bVar2) {
          uVar11 = uVar18;
        }
        iVar3 = (int)(short)uVar18 - (int)(short)uVar11;
        if (iVar3 < 0) {
          iVar3 = -iVar3;
        }
		
		// 400 = 0x191
        if (400 < iVar3) 
		{
          uVar11 = uVar18;
        }
        
		psVar8 = (short *)((int)&DAT_80086e84 + iVar12);
        iVar12 = iVar12 + 2;
        iVar15 = iVar15 + 4;

		// character icon
		// DecalHUD_DrawPolyGT4
        FUN_80023054(*(undefined4 *)
                      (PTR_DAT_8008d2ac +
                      (int)*(short *)(&DAT_80086d8c + (int)*psVar8 * 0x10) * 4 + 0x1eec),

					 // positionX
					 (int)(short)uVar11 + 5,
					 
					 // midpointY
					 0x66,

					 // pointer to PrimMem struct
					 *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

					 // pointer to OT memory
                     *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

					 // color data
					 local_2c,local_2c,local_2c,local_2c,

					 1,0x9d8);

        puVar5 = PTR_DAT_8008d2ac;

		// increment loop counter
        iVar14 = iVar14 + 1;

        *puVar16 = uVar11;
        puVar16 = puVar16 + 1;

		// iVar14 < numScreens + number of AIs
      } while (iVar14 < (int)((uint)(byte)puVar5[0x1ca8] + (uint)(byte)puVar5[0x1cab]));
    }

	// pointer to first Tracking thread
    iVar14 = *(int *)(PTR_DAT_8008d2ac + 0x1ba4);

	// loop through all "Tracking" objects, AKA WarpBalls
    while (iVar14 != 0)
	{
	  // Get Instance from Thread
      iVar15 = *(int *)(iVar14 + 0x34);

	  // Instance -> Model -> ModelID == warpball
      if (*(short *)(*(int *)(iVar15 + 0x18) + 0x10) == 0x36)
	  {
		// pointer to path data
        iVar3 = *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c);

        iVar12 = 0;

        if ((*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x148) - 1U < 0xff) &&

			// path index = warpballInst->thread->object->pathNode - lev->startNode
           (iVar4 = (int)(short)((*(int *)(*(int *)(*(int *)(iVar15 + 0x6c) + 0x30) + 0x3c) - iVar3)
                                 * -0x55555555 >> 2),

								 // if path index is valid
								 -1 < iVar4))
		{
          psVar17 = (short *)(iVar3 + (uint)*(byte *)(iVar3 + iVar4 * 0xc + 8) * 0xc);
          local_40 = *(short *)(iVar15 + 0x44);
          local_3e = *(short *)(iVar15 + 0x48);
          local_3c = *(short *)(iVar15 + 0x4c);
          psVar8 = (short *)(iVar3 + (uint)*(byte *)(psVar17 + 4) * 0xc);
          local_38 = CONCAT22(psVar17[1] - psVar8[1],*psVar17 - *psVar8);
          local_34 = psVar17[2] - psVar8[2];

		  // MATH_VectorNormalize
		  FUN_8003d378(&local_38);

		  local_48 = CONCAT22(local_3e - psVar17[1],local_40 - *psVar17);
          local_44 = local_3c - psVar17[2];
          setCopControlWord(2,0,local_38);
          setCopControlWord(2,0x800,(int)local_34);
          setCopReg(2,0,local_48);
          setCopReg(2,0x800,(int)local_44);

		  copFunction(2,0x406012);

		  iVar15 = getCopReg(2,0xc800);
          uVar1 = *(ushort *)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c) + 6);
          iVar3 = (uint)(ushort)psVar17[3] * 8 + (iVar15 >> 0xc);
          iVar15 = (uint)uVar1 << 3;
          iVar12 = iVar3 % iVar15;
          if (uVar1 == 0) {
            trap(0x1c00);
          }
          if ((iVar15 == -1) && (iVar3 == -0x80000000)) {
            trap(0x1800);
          }
        }
        if (iVar12 != 0) {
          iVar15 = (uint)*(ushort *)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c) + 6) * 8;
          iVar12 = iVar15 - iVar12;
          iVar15 = iVar15 / 0x1d1;
          if (iVar15 == 0) {
            trap(0x1c00);
          }
          if ((iVar15 == -1) && (iVar12 == -0x80000000)) {
            trap(0x1800);
          }
          FUN_80022ec4(
						// warpball icon
						*(undefined4 *)(PTR_DAT_8008d2ac + 0x1f24),

						(int)(short)(iVar12 / iVar15) + 5,
						0x66,

					   // pointer to PrimMem struct
					   *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

					   // pointer to OT memory
                       *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

					   1,0x8aa,1);
        }
      }

	  // go to next warp ball
	  // thread = thread->sibling
      iVar14 = *(int *)(iVar14 + 0x10);
    }
  }
  return;
}

// DrawHUD_Racing
void FUN_80052f98(void)

{
  short sVar1;
  short sVar2;
  bool bVar3;
  int iVar4;
  undefined4 local_80;
  undefined **ppuVar5;
  byte *pbVar6;
  int iVar7;
  undefined *puVar8;
  uint uVar9;
  undefined4 uVar10;
  uint *puVar11;
  undefined2 *puVar12;
  char *fmt;
  int iVar13;
  ushort *puVar14;
  uint *puVar15;
  int iVar16;
  short sVar17;
  ushort *puVar18;
  undefined4 local_7c;
  undefined4 local_78;
  undefined4 local_74;
  undefined4 local_70;
  int iVar19;
  short *psVar20;
  int iVar21;
  char cVar22;
  short local_60;
  short local_5e;
  short local_58;
  short local_56;
  char acStack80 [24];
  ushort local_38;
  short local_36;
  undefined2 local_30 [4];

  // Get pointer to array of HUD structs                number of screens - 1
  psVar20 = (short *)(&PTR_DAT_8008625c)[(uint)(byte)PTR_DAT_8008d2ac[0x1ca8] - 1];

  iVar21 = 0;

  // WeaponBackground_AnimateShine
  FUN_8004e0e0();

  // if time on clock is zero
  if (*(int *)(PTR_DAT_8008d2ac + 0x1d10) == 0) {

	// loop counter
    iVar7 = 0;

    puVar18 = &DAT_800862c8;
    puVar14 = &DAT_800862b8;
    puVar12 = &DAT_800862d8;

	// for iVar7 = 0; iVar7 < 8; iVar7++
    do {
      *puVar12 = 0;
      puVar12 = puVar12 + 1;
      pbVar6 = &DAT_8008d69c + iVar7;

	  // increment loop counter
      iVar7 = iVar7 + 1;

      *puVar14 = (ushort)*pbVar6;
      puVar14 = puVar14 + 1;
      *puVar18 = (ushort)*pbVar6;
      puVar18 = puVar18 + 1;
    } while (iVar7 < 8);
  }

  // If not drawing intro-race cutscene
  if ((*(uint *)PTR_DAT_8008d2ac & 0x40) == 0) {
    if ((PTR_DAT_8008d2ac[0x1d31] & 0x20) == 0) {

	  // If you press Triangle
      if ((*(uint *)(PTR_DAT_8008d2b0 + 0x14) & 0x40000) != 0)
	  {
		// if & 8, remove bit 8,
		// if !& 8, add bit 8,
		// toggle map and speedometer
        DAT_8008d000 = DAT_8008d000 ^ 8;
      }
    }
    else {
      PTR_DAT_8008d2ac[0x1d31] = PTR_DAT_8008d2ac[0x1d31] & 0xdf;
    }
  }

  // number of screens is 0
  if ((PTR_DAT_8008d2ac[0x1ca8] == '\0') &&

	// If this is an AI and not a human
    ((*(uint *)(*(int *)(PTR_DAT_8008d2ac + 0x24ec) + 0x2c8) & 0x100000) != 0))
  {
	// force draw speedometer, and not map, why?
    DAT_8008d000 = 8;
  }

  // LEV -> trial_data . numPointers
  if (**(int **)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x134) != 0)
  {
	// LEV -> trial_data . ptr_map
    iVar21 = (*(int **)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x134))[1];
  }

  // If you are not in Relic Race, and not in battle mode,
  // and not in time trial
  if ((*(uint *)PTR_DAT_8008d2ac & 0x4020020) == 0)
  {
	// DrawHUD_DriverIcons
    FUN_800524c4();
  }

  // pointer to first Player thread
  iVar7 = *(int *)(PTR_DAT_8008d2ac + 0x1b2c);

  cVar22 = '\0';
  if (iVar7 != 0)
  {
	// Loop through all player threads
    do
	{
	  // pointer to player structure
      iVar19 = *(int *)(iVar7 + 0x30);

	  if (
			// if player has not driven backwards very far,
			(*(int *)(iVar19 + 0x490) < 0x1f5)

			||

			// racer is not going the Wrong Way
			((*(uint *)(iVar19 + 0x2c8) & 0x100) == 0))
	  {
LAB_80053260:
	    // If game is not paused
	    if ((*(uint *)PTR_DAT_8008d2ac & 0xf) == 0)
	    {
	      //execute Jump meter and landing boost processes
	      FUN_80051c64(iVar19);
		}
      }

	  // if racer has travelled
	  // wrong way for too long
	  else
	  {
	    // If game is not paused
        if ((*(uint *)PTR_DAT_8008d2ac & 0xf) == 0)
		{
		  // Player / AI structure + 0x4a shows driver index (0-7)
		  // This is a pointer to each player's camera110 buffer
          puVar8 = PTR_DAT_8008d2ac + (uint)*(byte *)(iVar19 + 0x4a) * 0x110 + 0x168;

		  // if "Time on clock" last 0xXX byte is greater than 0x80 and less than 0xFF
		  if ((*(uint *)(PTR_DAT_8008d2ac + 0x1d10) & 0x80) != 0)
		  {
			// DAT_8008d878 + 0x74
			// WRONG WAY!
            FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x74),

						 // Midpoint between Start X and Size X
                         (int)(((uint)*(ushort *)(puVar8 + 0x1c) +
                         ((int)((uint)*(ushort *)(puVar8 + 0x20) << 0x10) >> 0x11)) * 0x10000) >> 0x10,

						 // Midpoint between Start Y and Size Y, except 0x1e higher
						 (int)(((uint)*(ushort *)(puVar8 + 0x1e) +
                         ((int)((uint)*(ushort *)(puVar8 + 0x22) << 0x10) >> 0x11) + -0x1e) * 0x10000) >> 0x10,

						 1,0xffff8000);
          }

		  // The text will not show if the last byte is more than 0x00 and less than 0x7F.
		  // This is what makes the text flicker, rather than drawing solid

          cVar22 = '\x01';
          goto LAB_80053260;
        }
      }

      if (
			// number of screens is less than 2 (1P mode)
			((byte)PTR_DAT_8008d2ac[0x1ca8] < 2) &&

			// if want to draw speedometer
			((DAT_8008d000 & 8) != 0)
		 )
	  {
		// draw spedometer needle
        FUN_800511c0((int)psVar20[0x24],(int)psVar20[0x25],iVar19);

		// draw jump meter
        FUN_80051e24((int)psVar20[0x18],(int)psVar20[0x19],iVar19);

		// Draw Powerslide Meter
        FUN_80052250((int)psVar20[0x20],(int)psVar20[0x21],iVar19);

		// draw background of spedometer
        FUN_800516ac((int)psVar20[0x24],(int)psVar20[0x25],iVar19);
      }

      //if racer hasn't finished the race
      if ((*(uint *)(iVar19 + 0x2c8) & 0x2000000) == 0) {

		// If you're not in Battle Mode
        if ((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0)
		{
		  // Draw powerslide meter
          FUN_80052250((int)psVar20[0x20],(int)psVar20[0x21],iVar19);
        }

		// If you are not in Time Trial or Relic Race
        if ((*(uint *)PTR_DAT_8008d2ac & 0x4020000) == 0)
		{
		  // DrawNumWumpa
          FUN_80050c20((int)psVar20[0x10],(int)psVar20[0x11],iVar19);
        }
      }

	  // If you're in a Relic Race
      if ((*(uint *)PTR_DAT_8008d2ac & 0x4000000) != 0)
	  {
		// DrawNumTimebox
        FUN_80050e6c((int)psVar20[0x4c],(int)psVar20[0x4d],iVar19);
      }

	  // If game is not paused
      if ((*(uint *)PTR_DAT_8008d2ac & 0xf) == 0)
	  {
        if (*(int *)(iVar19 + 0x4c0) != 0)
		{
          local_60 = psVar20[0xc];
          local_5e = psVar20[0xd];

		  // if cooldown between items is over
          if (*(int *)(iVar19 + 0x4b8) == 0)
		  {
			// deduct from number of queued items to pick up
            *(int *)(iVar19 + 0x4c0) = *(int *)(iVar19 + 0x4c0) + -1;

			// Check if 231 dll is loaded
            iVar4 = FUN_800348e8(&local_60);

			// If it is loaded
            if (
					(iVar4 != 0) &&

					// If you're not in Adventure Arena
					((*(uint *)PTR_DAT_8008d2ac & 0x100000) == 0)
				)
			{
			  // RB_Player_ModifyWumpa, +1
              FUN_800abefc(iVar19,1);
            }

			// OtherFX_Play to get wumpa fruit
            FUN_80028468(0x42,1);

			// initial timer value
            iVar4 = 5;

			// if timer is already running, set new timer value
            if (*(int *)(iVar19 + 0x4c0) != 0) goto LAB_80053498;
          }
          else {
            FUN_8004ec18(&local_60,(int)*(short *)(iVar19 + 0x4bc),(int)*(short *)(iVar19 + 0x4be),
                         (int)psVar20[0xc],(int)psVar20[0xd],*(undefined4 *)(iVar19 + 0x4b8),5);

			// subtract one from timer
			iVar4 = *(int *)(iVar19 + 0x4b8) + -1;

LAB_80053498:

			// set timer value
            *(int *)(iVar19 + 0x4b8) = iVar4;
          }

		  // "wumpaposter" icon group
		  // DecalHUD_DrawPolyFT4
          FUN_80022db0(*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x2140) + 0x14),(int)local_60,
                       (int)local_5e,

					   // pointer to PrimMem struct
					   *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

					   // pointer to OT memory
					   *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

					   0,(int)psVar20[3]);
        }
        iVar16 = DAT_8008d9cc;
        iVar13 = DAT_8008d9c8;
        iVar4 = DAT_8008d9c4;
        if (*(short *)(iVar19 + 0x4c4) != 0)
		{
		  // C-Letter
          if (*(short *)(iVar19 + 0x4c6) == 0x93)
		  {
			// make visible
            *(uint *)(DAT_8008d9cc + 0x28) = *(uint *)(DAT_8008d9cc + 0x28) & 0xffffff7f;

			local_58 = psVar20[0x48];
            iVar13 = iVar16;
LAB_80053584:
            local_56 = psVar20[0x49];
            iVar4 = iVar13;
          }

		  // not C-Letter
          else
		  {
			// not T-Letter
            if (*(short *)(iVar19 + 0x4c6) != 0x94)
			{
			  // R-Letter

			  // make visible
              *(uint *)(DAT_8008d9c8 + 0x28) = *(uint *)(DAT_8008d9c8 + 0x28) & 0xffffff7f;

			  local_58 = psVar20[0x48] + 0x3a;
              goto LAB_80053584;
            }

			// T-Letter

			// make visible
            *(uint *)(DAT_8008d9c4 + 0x28) = *(uint *)(DAT_8008d9c4 + 0x28) & 0xffffff7f;

			local_58 = psVar20[0x48] + 0x1d;
            local_56 = psVar20[0x49] + -1;
          }

		  // reduce frame counter
		  *(short *)(iVar19 + 0x4c4) = *(short *)(iVar19 + 0x4c4) + -1;

		  // 4c8 and 4ca are start position of animation

		  // Interpolate from start pos to end pos
          FUN_8004ec18(&local_58,(int)*(short *)(iVar19 + 0x4c8),(int)*(short *)(iVar19 + 0x4ca),
                       (int)local_58,(int)local_56,(int)*(short *)(iVar19 + 0x4c4),10);

		  // Convert X
		  local_80 = FUN_8004caa8((int)local_58,0x200);
          *(undefined4 *)(iVar4 + 0x44) = local_80;

		  // Convert Y
		  local_80 = FUN_8004cac8((int)local_56,0x200);
          *(undefined4 *)(iVar4 + 0x48) = local_80;

		  *(undefined4 *)(iVar4 + 0x4c) = 0x200;
        }
      }

	  // If you're not in a Relic Race
      if ((*(uint *)PTR_DAT_8008d2ac & 0x4000000) == 0)
	  {
		//if racer hasn't finished the race
        if ((*(uint *)(iVar19 + 0x2c8) & 0x2000000) == 0)
		{
		  // Draw weapon and number of wumpa fruit in HUD
          FUN_800507e0((int)*psVar20,(int)psVar20[1],(int)psVar20[3],iVar19);
        }
      }

	  // if you are in relic mode
      else
	  {
		// If you smashed a time crate, this variable is set to 10
        if (*(int *)(iVar19 + 0x4b0) != 0)
		{
		  // DAT_8008d530
		  // -%ld

		  // Make string with number of time crate
		  // print "-x" where x is the amount of seconds
          sprintf(acStack80,&DAT_8008d530,*(undefined4 *)(PTR_DAT_8008d2ac + 0x1e24));

		  // 4b4 and 4b6 are WindowStartPos(x,y) from Camera110, inside Driver
          FUN_8004ec18(&local_60,(int)*(short *)(iVar19 + 0x4b4),(int)*(short *)(iVar19 + 0x4b6),
                       0x14,8,*(undefined4 *)(iVar19 + 0x4b0),10);

		  // Decrease remaining number of frames for this to be on screen
          *(int *)(iVar19 + 0x4b0) = *(int *)(iVar19 + 0x4b0) + -1;

		  // Put string on the screen
		  // This happens for 10 frames
          FUN_80022878(acStack80,(int)local_60,(int)local_5e,1,1);
        }
      }

	  // if you're in battle mode, while not paused
	  // and you do not have a life limit
      if ((*(uint *)PTR_DAT_8008d2ac & 0x802f) == 0x20)
	  {
		// If the animation for adding points is over
        if (*(int *)(iVar19 + 0x4d0) == 0)
		{
		  // Delete the change that in score that was queued
          *(undefined4 *)(iVar19 + 0x4dc) = 0;
        }

		// if the animation is not done
        else
		{
          local_60 = psVar20[0x34] + 0x20;
          local_5e = psVar20[0x35];

		  // if you do not have life limit (battle)
          if ((*(uint *)PTR_DAT_8008d2ac & 0x8000) == 0)
		  {
			// This is only with point limit,
			// points can add or subtract

			// Get what should be added to your score
            iVar4 = *(int *)(iVar19 + 0x4dc);

			// Can't add 0, so it's +1 or -1

			// if you are losing points
			if (iVar4 < 1)
			{
			  // print a minus sign with your change in score

			  // -%d
              fmt = &DAT_8008d540;

			  // Get own absolute value of the change
			  if (iVar4 < 0)
			  {
				// Make a negative number positive
                iVar4 = -iVar4;
              }
            }

			else
			{
			  // print a plus sign with your change in score

			  // +%ld
              fmt = &DAT_8008d538;
            }
          }

		  // if you do have life limit (battle)
		  else
		  {
			// Life can only go down, not up

			// Get your change in score
            iVar4 = *(int *)(iVar19 + 0x4dc);

			// Print a minus sign in front of the number of lives you lose

			// -%ld
			fmt = &DAT_8008d530;
          }

		  // make the string that flies from the center of your screen to the corner
          sprintf((char *)&local_58,fmt,iVar4);

          FUN_8004ec18(&local_60,(int)*(short *)(iVar19 + 0x4d4),(int)*(short *)(iVar19 + 0x4d6),
                       (int)(((uint)(ushort)psVar20[0x34] + 0x20) * 0x10000) >> 0x10,
                       (int)(((uint)(ushort)psVar20[0x35] + 8) * 0x10000) >> 0x10,
                       *(undefined4 *)(iVar19 + 0x4d0),5);

			// subtract one from the number of frames that the animation lasts
          *(int *)(iVar19 + 0x4d0) = *(int *)(iVar19 + 0x4d0) + -1;

		  // print the string that shows the change in your score
          FUN_80022878(&local_58,(int)local_60,(int)local_5e,2,3);
        }
      }

	  // If you're not in Battle Mode
      if ((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0)
	  {
		    //if racer hasn't finished the race
        if ((*(uint *)(iVar19 + 0x2c8) & 0x2000000) == 0)
		{
		  // Draw which lap they are on (1/3, 2/3, 3/3, etc)
          FUN_80050528((int)psVar20[4],(int)psVar20[5],(int)psVar20[7],iVar19);
        }
      }

	  // if you're in battle mode
      else
	  {
		// Draw how many points or lifes the player has
        FUN_80050654((int)psVar20[0x34],(int)psVar20[0x35],iVar19);
      }

      if (
			// if you're in adventure mode or Arcade mode and
			((*(uint *)PTR_DAT_8008d2ac & 0x480000) != 0) &&

			//racer finished the race
			((*(uint *)(iVar19 + 0x2c8) & 0x2000000) != 0)
		  )
	  {
		// Player / AI structure + 0x4a shows driver index (0-7)

		// DLL 222
		// Display total time it took to finish race
        FUN_800a06f8((uint)*(byte *)(iVar19 + 0x4a),0);
      }
      uVar9 = *(uint *)PTR_DAT_8008d2ac;

	  // If you are in Relic Race, and not in battle mode,
	  // and not in time trial
      if ((uVar9 & 0x4020020) == 0)
	  {
        if (
				//if racer hasn't finished the race
				((*(uint *)(iVar19 + 0x2c8) & 0x2000000) == 0) ||
				(
					(
						// if number of screens is 2
						PTR_DAT_8008d2ac[0x1ca8] == '\x02' &&

						// AND

						// Not Arcade Mode (must be VS or Battle)
						((uVar9 & 0x400000) == 0)
					)
				)
			)
		{
          sVar17 = 0;
          sVar1 = psVar20[0x14];
          sVar2 = psVar20[0x15];
          uVar9 = 0;
        }
        else {

		  // if number of screens is less than 3
          if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 3) goto LAB_80053af4;
          sVar1 = psVar20[0x14];
          sVar2 = psVar20[0x15];
          bVar3 = (*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 1) == 0;
          sVar17 = (ushort)bVar3 << 2;
          uVar9 = ((uint)bVar3 << 0x12) >> 0x10;
        }

		// Draw the "st", "nd", "rd" suffix after "1st, 2nd, 3rd, etc"
        FUN_8005045c((int)sVar1,(int)sVar2,iVar19,uVar9);

		// if more than 2 players
        if (2 < (byte)PTR_DAT_8008d2ac[0x1ca8])
		{
		  // pointer to OT memory
          local_80 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c);

		  // position, from hud struct
          sVar1 = psVar20[8];
          sVar2 = psVar20[9];

		  // gGT->backBuffer
          iVar4 = *(int *)(PTR_DAT_8008d2ac + 0x10);

		  // Get Color Data
          ppuVar5 = &PTR_DAT_80081d70 + sVar17;

		  // Four colors, one for each corner
          local_7c = *(undefined4 *)*ppuVar5;
          local_78 = *(undefined4 *)(*ppuVar5 + 4);
          local_74 = *(undefined4 *)(*ppuVar5 + 8);
          local_70 = *(undefined4 *)(*ppuVar5 + 0xc);

		  // icon pointer
          uVar10 = *(undefined4 *)

                    (PTR_DAT_8008d2ac +

						// finishing rank of player
						((int)*(short *)(iVar19 + 0x482)

							// index of '1' icon
							+ 0x19)

								// index of icon pointer array
								* 4 + 0x1eec);
LAB_80053aec:

		  // DecalHUD_DrawPolyGT4
          FUN_80023054(
						// icon pointer
						uVar10,

						// position
						(int)sVar1,
						(int)sVar2,

						// gGT->backBuffer->primMem
						iVar4 + 0x74,

						// color data
						local_80,
						local_7c,
						local_78,
						local_74,
						local_70,

						0,0x1000);
        }
      }

	  // if you are in Relic Race, or Battle, or Time Trial
	  else
	  {
		// If you're in end-of-race and Battle
        if ((uVar9 & 0x200020) == 0x200020)
		{
          uVar9 = (uint)((*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 1) == 0);

		  // Draw the "st", "nd", "rd" suffix after "1st, 2nd, 3rd, etc"
          FUN_8005045c((int)psVar20[0x14],(int)psVar20[0x15],iVar19,uVar9 << 2);

          sVar1 = psVar20[8];
          sVar2 = psVar20[9];

		  // pointer to OT memory
          local_80 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c);

		  // gGT->backBuffer
          iVar4 = *(int *)(PTR_DAT_8008d2ac + 0x10);

		  // Get Color Data
          ppuVar5 = &PTR_DAT_80081d70 + uVar9 * 4;

		  // Four colors, one for each corner
          local_7c = *(undefined4 *)*ppuVar5;
          local_78 = *(undefined4 *)(*ppuVar5 + 4);
          local_74 = *(undefined4 *)(*ppuVar5 + 8);
          local_70 = *(undefined4 *)(*ppuVar5 + 0xc);

		  // pointer to icon
          uVar10 = *(undefined4 *)
                    (PTR_DAT_8008d2ac +

					// Battle Team of Player
                    (*(int *)(PTR_DAT_8008d2ac + *(int *)(iVar19 + 0x4e8)

					// Get finishing rank of player's team (0 for 1st place, 1 for 2nd, etc)
					* 4 + 0x1da8)

					// icon index of '1'
					+ 0x19)

					// index of icon array
					* 4 + 0x1eec);

          goto LAB_80053aec;
        }
      }
LAB_80053af4:

	  // UpdateTrackerTargets
	  // draw lock-on target for driver, if
	  // a missile or warpball is chasing them
      FUN_8004fd34(iVar19);

	  // If you're in Battle
      if ((*(uint *)PTR_DAT_8008d2ac & 0x20) != 0)
	  {
		// Draw arrows over the heads of other players (not AIs)
        FUN_8004f9d8(iVar19);
      }

      if (
			(
				// if 9 < number of wumpa fruit
				// if you have 10 wumpa fruit
				('\t' < *(char *)(iVar19 + 0x30)) &&

				//if racer hasn't finished the race
				((*(uint *)(iVar19 + 0x2c8) & 0x2000000) == 0)
			) &&
			(
				// draw shining background behind wumpa fruit
				FUN_80050af8((int)psVar20[0x30],(int)psVar20[0x31],(int)psVar20[0x33],iVar19),

				// If your weapon is not "no weapon"
				*(char *)(iVar19 + 0x36) != '\x0f')
			)
	  {
		// draw shining background behind weapon
        FUN_80050af8((int)psVar20[0x2c],(int)psVar20[0x2d],(int)psVar20[0x2f],iVar19);
      }

	  // go to next player
	  // thread = thread->sibling
      iVar7 = *(int *)(iVar7 + 0x10);

	  // next HUD structure
      psVar20 = psVar20 + 0x50;

    } while (iVar7 != 0);
  }

  // (if WrongWay_bool != ???)
  if (DAT_8008d9dc != cVar22) {

    // framesDrivingSameDirection = 0
    DAT_8008d9e4 = 0;

    // WrongWay_bool = ???
    DAT_8008d9dc = cVar22;
  }

  // framesDrivingSameDirection += 1
  DAT_8008d9e4 = DAT_8008d9e4 + 1;

  // if number of screens is 1
  if (PTR_DAT_8008d2ac[0x1ca8] == '\x01')
  {
	// pointer to player structure
    iVar19 = *(int *)(PTR_DAT_8008d2ac + 0x24ec);

	// DrawRaceClock (1P)
    FUN_8004edac(0x14,8,0,iVar19);

    iVar7 = 0;

	// If Turbo Counter Cheat is Enabled
    if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x8000000) != 0) {

	  // Get number of boosts
      sVar1 = *(short *)(iVar19 + 0x4e);

	  // If number of boosts is not zero
      if (sVar1 != 0)
	  {
		// Read pointer from address
        iVar7 = *(int *)(PTR_DAT_8008d2ac + 0x1be0);

        while ((
					// Pointer != nullptr
					iVar7 != 0 &&

					// Adds 0x30 to iVar7 pointer, gets value (new address) then adds 4.
					// If   [something]   != pointer that holds boost counter
					(*(int *)(*(int *)(iVar7 + 0x30) + 4) != iVar19)
			  ))
		{
		  // Increment pointer by 16
          iVar7 = *(int *)(iVar7 + 0x10);
        }

		// Get number of boosts
		sVar1 = *(short *)(iVar19 + 0x4e);
      }

	  // DAT_8008d2a8
	  // Position of counter
	  // 0 = offscreen
	  // 1 = just barely on screen
	  // ...
	  // 10 = clearly on screen

      if (
			// If number boosts is less than 3
			(sVar1 < 3) ||

			// If display counter is fully on screen
			(9 < DAT_8008d2a8)
		)
	  {
		// If pointer == nullptr
        if (iVar7 == 0) goto LAB_80053c98;
LAB_80053cac:

		// Set sVar1 to current display counter position
        sVar1 = DAT_8008d2a8;
        if (
			// If number boosts is less than 3
			(*(short *)(iVar19 + 0x4e) < 3) &&

			// If turbo counter is on screen
			(0 < DAT_8008d2a8)
			)
		{
LAB_80053cd4:

		  // Animate counter to move off screen
          sVar1 = DAT_8008d2a8 + -1;
        }
      }

	  // If you have more than 3 boosts, and
	  // display counter is not fully on screen
      else {

		// Animate counter to move onto screen
        sVar1 = DAT_8008d2a8 + 1;

		// If pointer == nullptr
        if (iVar7 == 0) {
LAB_80053c98:
		  // If counter is off screen
          if (DAT_8008d2a8 < 1)
		  {
			// set svar1 to display position
			// does the "else" get skipped?
			goto LAB_80053cac;
		  }

		  // If counter is on screen
		  // decrease boost counter,
		  // does the "else" get skipped?
          goto LAB_80053cd4;
        }
      }

	  // Set display position value
      DAT_8008d2a8 = sVar1;

	  // If display counter is on screen (fully or not fully)
      if ((int)DAT_8008d2a8 != 0)
	  {
		// Interpolate the turbo counter slide in from the right
        FUN_8004ecd4(&local_38,0x2c8,0x20,500,0x20,(int)DAT_8008d2a8,10);

		// The actual counter number will continue to
		// increase past 1000, but the on-screen text
		// will cap at 999

		// If you have less than 1000 boosts
        if (*(short *)(iVar19 + 0x4e) < 1000)
		{
		  // DAT_8008d54c
		  // %d

		  // build string for on-screen boost counter
          sprintf((char *)&local_60,&DAT_8008d54c);
        }

		// If you have more than 1000 boosts
        else
		{
		  // 8d544
		  // "999" <-- ascii string, not 2-byte value

		  // Cap the on-screen counter at 999
          sprintf((char *)&local_60,&DAT_8008d544);
        }

		// DAT_8008d878 + 0x92c
		// "Turbos"

		// DecalFont_GetLineWidth
        iVar7 = FUN_800224d0(*(undefined4 *)(DAT_8008d878 + 0x92c),1);

		// Draw the string
        FUN_80022878(&local_60,(int)(((uint)local_38 - iVar7) * 0x10000) >> 0x10,(int)local_36,1,
                     0x4022);

		// DAT_8008d550
		// %s

		// DAT_8008d878 + 0x92c
		// "Turbos"
        sprintf((char *)&local_60,&DAT_8008d550,*(undefined4 *)(DAT_8008d878 + 0x92c));

		// Draw the string
		FUN_80022878(&local_60,(int)(short)local_38,(int)local_36,1,0x4000);

        iVar7 = *(int *)(PTR_DAT_8008d2ac + 0x10);
        puVar11 = *(uint **)(iVar7 + 0x80);
        puVar15 = (uint *)0x0;
        if (puVar11 <= *(uint **)(iVar7 + 0x84)) {
          *(uint **)(iVar7 + 0x80) = puVar11 + 9;
          puVar15 = puVar11;
        }
        if (puVar15 == (uint *)0x0) {
          return;
        }
        puVar15[1] = 0x3800c8ff;
        puVar15[3] = 0x3800c8ff;
        puVar15[5] = 0x380000ff;
        puVar15[7] = 0x380000ff;
        *(ushort *)(puVar15 + 2) = local_38 - 0xaa;
        *(short *)((int)puVar15 + 10) = local_36 + 9;
        *(ushort *)(puVar15 + 4) = local_38 + 0x32;
        *(short *)((int)puVar15 + 0x12) = local_36 + 9;
        *(ushort *)(puVar15 + 6) = local_38 - 0x96;
        *(short *)((int)puVar15 + 0x1a) = local_36 + 0x12;
        *(ushort *)(puVar15 + 8) = local_38 + 0x32;
        puVar8 = PTR_DAT_8008d2ac;
        *(short *)((int)puVar15 + 0x22) = local_36 + 0x12;

		// pointer to OT memory
        puVar11 = *(uint **)(puVar8 + 0x147c);

        *puVar15 = *puVar11 | 0x8000000;
        *puVar11 = (uint)puVar15 & 0xffffff;
      }
    }
  }

  // if number of screens is not 1 (multiplayer)
  else {

	// if you have a time limit (battle)
    if ((*(uint *)PTR_DAT_8008d2ac & 0x10000) != 0)
	{
	  // draw countdown clock
      FUN_8004f894(0xd7,0x68,2);
    }
  }

  if (
		(
			(
				// if number of screens is 1
				(PTR_DAT_8008d2ac[0x1ca8] == '\x01') &&

				// if ptr_map is valid
				(iVar21 != 0)
			) &&
			(
				// if want to draw map, not speedometer
				(DAT_8008d000 & 8) == 0
			)
		) ||

		(
			(
				// if number of screens is 3
				PTR_DAT_8008d2ac[0x1ca8] == '\x03' &&

				// if ptr_map is valid
				(iVar21 != 0)
			)
		)
	)
	{
    local_30[0] = 0;

	// Map_DrawDrivers
    FUN_8004dd5c(iVar21,*(undefined4 *)(PTR_DAT_8008d2ac + 0x1b2c),local_30);

	// Map_DrawDrivers
    FUN_8004dd5c(iVar21,*(undefined4 *)(PTR_DAT_8008d2ac + 0x1b40),local_30);

	// Draw all ghosts on 2D map
    FUN_8004dee8(iVar21,*(undefined4 *)(PTR_DAT_8008d2ac + 0x1b54));

	// Draw all "Tracking" warpballs on 2D map
    FUN_8004dffc(iVar21,*(undefined4 *)(PTR_DAT_8008d2ac + 0x1ba4));

	// if ptr_map is valid
    if (iVar21 != 0) {

	  // If number of screens is 1
      if (PTR_DAT_8008d2ac[0x1ca8] == '\x01')
	  {
		// pointer to backBuffer
        iVar21 = *(int *)(PTR_DAT_8008d2ac + 0x10);

		// pointer to OT memory
		uVar10 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c);

		// posX
		local_80 = 500;

		// two halves of the map textures
        local_7c = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1ef8);
        local_78 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1efc);

		// posY
		local_74 = 0xc3;
      }

	  // if number of screens is not 1
      else
	  {
		// posX
        local_80 = 0x1b8;

		// if number of screens is not 3
        if (PTR_DAT_8008d2ac[0x1ca8] != '\x03') goto LAB_80054040;

		// This happens only if number of screens is 3
        // pointer to backBuffer
        iVar21 = *(int *)(PTR_DAT_8008d2ac + 0x10);

		// pointer to OT memory
        uVar10 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c);

		// two halves of the map textures
        local_7c = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1ef8);
        local_78 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1efc);

		// posY
        local_74 = 0xcd;
      }

	  // Draw the map
      FUN_8004d614(
					// top half and bottom half
					local_7c,local_78,

					// X and Y
					local_80,local_74,

					// Pointer to primary memory
					iVar21 + 0x74,

					// pointer to OT memory
					uVar10,

					// color, in this case white
                    1);
    }
  }
LAB_80054040:
  bVar3 = false;

  // loop counter
  iVar21 = 0;

  // if number of screens is not 0
  if (PTR_DAT_8008d2ac[0x1ca8] != '\0') {
    iVar19 = 0;
    iVar7 = 0;

	// for(int iVar21 = 0; iVar21 < numScreens; iVar21++)
    do
	{
	  // pointer to array of pointers for each driver (9900C, 99010, etc)
      iVar4 = *(int *)(PTR_DAT_8008d2ac + iVar7 + 0x24ec);

	  // pointer to each player's camera110 buffer
      puVar8 = PTR_DAT_8008d2ac + (uint)*(byte *)(iVar4 + 0x4a) * 0x110 + 0x168;

      if (
			(
				//if racer finished the race
				((*(uint *)(iVar4 + 0x2c8) & 0x2000000) != 0) &&

				// If you're not in Arcade or Time Trial
				((*(uint *)PTR_DAT_8008d2ac & 0x420000) == 0)
			) &&
			(
				(
					// cooldown is finished
					*(short *)(PTR_DAT_8008d2ac + 0x1d36) == 0 ||

					// cooldown has not progressed far,
					// so you still need to draw "Finished" and "Loser"
					(0x96 < *(short *)(PTR_DAT_8008d2ac + 0x1d36))
				)
			)
		)
	  {

        if (
				// player structure + 0x482 is your rank in the race
				// 0 = 1st place, 1 = 2nd place, 2 = 3rd place, etc

				// Basically, out of all human players, if you did not come in last
				((int)*(short *)(iVar4 + 0x482) < (int)((uint)(byte)PTR_DAT_8008d2ac[0x1ca8] - 1)) &&

				// If you're not in Battle Mode (winner of battle mode wont be in this function)
				((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0)
			)
		{

		  // Position is the same regardless of win or lose

		  // Midpoint between camera110 Start X and End X
          iVar13 = (uint)*(ushort *)(puVar8 + 0x1c) +
                   ((int)((uint)*(ushort *)(puVar8 + 0x20) << 0x10) >> 0x11);

		  // Midpoint between camera110 Start Y and End Y
          iVar16 = (uint)*(ushort *)(puVar8 + 0x1e) +
                   ((int)((uint)*(ushort *)(puVar8 + 0x22) << 0x10) >> 0x11);

		  // DAT_8008d878 + 0x78
		  // FINISHED!
		  local_80 = *(undefined4 *)(DAT_8008d878 + 0x78);
        }

		// If you came in last place, or you're in battle
        else
		{
		  // Position is the same regardless of win or lose

		  // Midpoint between camera110 Start X and End X
          iVar13 = (uint)*(ushort *)(puVar8 + 0x1c) +
                   ((int)((uint)*(ushort *)(puVar8 + 0x20) << 0x10) >> 0x11);

		  // Midpoint between camera110 Start Y and End Y
          iVar16 = (uint)*(ushort *)(puVar8 + 0x1e) +
                   ((int)((uint)*(ushort *)(puVar8 + 0x22) << 0x10) >> 0x11);

		  // A rom hack can change 0x50c to 0x78 so that
		  // the game is more polite, like Nitro Fueled

		  // DAT_8008d878 + 0x50c
		  // LOSER!
		  local_80 = *(undefined4 *)(DAT_8008d878 + 0x50c);
        }

		// In some cases, this cuts off bits, but sometimes
		// [number] * 0x10000 >> 0x10 = [number]

		FUN_80022878(local_80,iVar13 * 0x10000 >> 0x10,(iVar16 + -0x1e) * 0x10000 >> 0x10,1,
                     0xffff8000);

        if (
				// If you press Cross or Start
				((*(uint *)(PTR_DAT_8008d2b0 + iVar19 + 0x14) & 0x1010) != 0) &&

				// If you're in End-Of-Race menu
				((*(uint *)PTR_DAT_8008d2ac & 0x200000) != 0)
			)
		{
		  // make "Finished" and "Loser" disappear, start
		  // drawing the on-screen comments
          *(undefined2 *)(PTR_DAT_8008d2ac + 0x1d36) = 0x96;
        }
      }
      //if item roll is not done
      if (*(short *)(iVar4 + 0x3a) != 0) {
        bVar3 = true;
      }
      iVar19 = iVar19 + 0x50;

	  // increment the iteration counter
      iVar21 = iVar21 + 1;

      iVar7 = iVar7 + 4;

	  // for(int iVar21 = 0; iVar21 < numScreens; iVar21++)
    } while (iVar21 < (int)(uint)(byte)PTR_DAT_8008d2ac[0x1ca8]);
  }
  if (
		(
			// If game is not paused
			((*(uint *)PTR_DAT_8008d2ac & 0xf) == 0) &&
      //item roll is done
			(!bVar3)
		) &&

		// If you're drawing Weapon Roulette (randomizing)
		((*(uint *)PTR_DAT_8008d2ac & 0x800000) != 0)
	  )
  {
	// OtherFX_Stop2
	// stop weapon shuffle sound
    FUN_80028844(0x5d);

	// disable the randomizing effect in the HUD
    *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac & 0xff7fffff;
  }
  return;
}


// DrawHUD_AdvStrings
void FUN_80054298(void)
{
  undefined *puVar1;
  undefined4 uVar2;

  // get Player 1
  uVar2 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x24ec);

								// number of screens - 1
  puVar1 = (&PTR_DAT_8008625c)[(uint)(byte)PTR_DAT_8008d2ac[0x1ca8] - 1];

  // DrawNumRelic
  FUN_80050f18((int)(((uint)*(ushort *)(puVar1 + 0x70) + 0x10) * 0x10000) >> 0x10,
               (int)(((uint)*(ushort *)(puVar1 + 0x72) - 10) * 0x10000) >> 0x10,uVar2);

  // DrawNumKey
  FUN_80050fc4((int)(((uint)*(ushort *)(puVar1 + 0x78) + 0x10) * 0x10000) >> 0x10,
               (int)(((uint)*(ushort *)(puVar1 + 0x7a) - 10) * 0x10000) >> 0x10,uVar2);

  // DrawNumTrophy
  FUN_80051070((int)(((uint)*(ushort *)(puVar1 + 0x80) + 0x10) * 0x10000) >> 0x10,
               (int)(((uint)*(ushort *)(puVar1 + 0x82) - 10) * 0x10000) >> 0x10,uVar2);
  return;
}


// DrawHUD_CrystalChallenge
void FUN_8005435c(void)

{
  char cVar1;
  int iVar2;
  int iVar3;
  short *psVar4;
  int iVar5;
  short local_18;
  short local_16;

  //iVar3 = player 1 pointer struct
  iVar3 = *(int *)(PTR_DAT_8008d2ac + 0x24ec);

											// number of screens - 1
  psVar4 = (short *)(&PTR_DAT_8008625c)[(uint)(byte)PTR_DAT_8008d2ac[0x1ca8] - 1];

  // If game is not paused
  if ((*(uint *)PTR_DAT_8008d2ac & 0xf) == 0) {
    //execute Jump meter and landing boost processes
    FUN_80051c64(iVar3);
  }

  // draw speedometer needle
  FUN_800511c0((int)psVar4[0x24],(int)psVar4[0x25],iVar3);

  // draw jump meter
  FUN_80051e24((int)psVar4[0x18],(int)psVar4[0x19],iVar3);

  // Draw powerslide meter
  FUN_80052250((int)psVar4[0x20],(int)psVar4[0x21],iVar3);

  // draw background of speedometer
  FUN_800516ac((int)psVar4[0x24],(int)psVar4[0x25],iVar3);

  // DrawNumCrystal
  FUN_8005111c((int)(((uint)(ushort)psVar4[0x44] + 0x10) * 0x10000) >> 0x10,
               (int)(((uint)(ushort)psVar4[0x45] - 0x10) * 0x10000) >> 0x10,iVar3);

  // Draw weapon and number of wumpa fruit in HUD
  FUN_800507e0((int)*psVar4,(int)psVar4[1],(int)psVar4[3],iVar3);

  // DAT_8008d878 + 0x48
  // TIME
  FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x48),0x14,8,2,0);

  // "TIME" and the actual time are printed at the same
  // X-coordinate, so we know 0x14 is the X, which only
  // leaves the next parameter as the only possible value for
  // the Y-coordinate.

  // draw countdown clock
  FUN_8004f894(0x14,0x10,1);


  // If game is paused
  if ((*(uint *)PTR_DAT_8008d2ac & 0xf) != 0) {
    return;
  }

  // If (I think) "bool visible" is false
  if (*(int *)(iVar3 + 0x4c0) == 0)
  {
	// make invisible
    *(uint *)(DAT_8008d9bc + 0x28) = *(uint *)(DAT_8008d9bc + 0x28) | 0x80;
    goto LAB_800545e8;
  }
  local_18 = psVar4[0x44];
  local_16 = psVar4[0x45];

  // make visible
  *(uint *)(DAT_8008d9bc + 0x28) = *(uint *)(DAT_8008d9bc + 0x28) & 0xffffff7f;

  // if cooldown between grabbing items is over,
  // which also means item has moved to the hud icon
  if (*(int *)(iVar3 + 0x4b8) == 0) {

	// add one to your crystal count
    cVar1 = *(char *)(iVar3 + 0x31) + '\x01';
	*(char *)(iVar3 + 0x31) = cVar1;

	// deduct from number of queued items to pick up
    *(int *)(iVar3 + 0x4c0) = *(int *)(iVar3 + 0x4c0) + -1;

	// if you have enough crystals to win the race
    if (*(int *)(PTR_DAT_8008d2ac + 0x1e28) <= (int)cVar1)
	{
	  // Player_Freeze_Init
      *(undefined4 *)(iVar3 + 0x54) = 0x80062d04;

      //turn on 26th bit of Actions Flag set (means racer finished the race)
      *(uint *)(iVar3 + 0x2c8) = *(uint *)(iVar3 + 0x2c8) | 0x2000000;

	  // ToggleGameState_EndOfRace
      FUN_8003a3fc(0x42);
    }

	// OtherFX_Play
    FUN_80028468(0x42,1);

	// 5 frame cooldown
    iVar2 = 5;

    if (*(int *)(iVar3 + 0x4c0) != 0) goto LAB_8005456c;
  }

  // if cooldown is not done
  else
  {
	// interpolate position over course of 5 frames
    FUN_8004ec18(
					&local_18,
					(int)*(short *)(iVar3 + 0x4bc),
					(int)*(short *)(iVar3 + 0x4be),
					(int)psVar4[0x44],
					(int)psVar4[0x45],

					// cooldown (0-5)
					*(undefined4 *)(iVar3 + 0x4b8),

					// 5 frames total
					5
				);

	// reduce cooldown between getting each wumpa (or crystal)
	iVar2 = *(int *)(iVar3 + 0x4b8) + -1;

LAB_8005456c:

	// set new cooldown
    *(int *)(iVar3 + 0x4b8) = iVar2;
  }
  iVar2 = DAT_8008d9bc;
  iVar5 = ((int)local_18 + -0x100) * (int)psVar4[0x46];
  if (iVar5 < 0) {
    iVar5 = iVar5 + 0xff;
  }
  *(int *)(DAT_8008d9bc + 0x44) = iVar5 >> 8;
  iVar5 = ((int)local_16 + -0x6c) * (int)psVar4[0x46];
  if (iVar5 < 0) {
    iVar5 = iVar5 + 0xff;
  }
  *(int *)(iVar2 + 0x48) = iVar5 >> 8;
  *(int *)(iVar2 + 0x4c) = (int)psVar4[0x46];
LAB_800545e8:
  if (
		(
			// If game is not paused
			((*(uint *)PTR_DAT_8008d2ac & 0xf) == 0) &&

			// item roll is done
			(*(short *)(iVar3 + 0x3a) == 0)
		) &&

		// If you're drawing Weapon Roulette (randomizing)
		((*(uint *)PTR_DAT_8008d2ac & 0x800000) != 0)
	  )
  {
	// OtherFX_Stop2
	// stop weapon shuffle sound
    FUN_80028844(0x5d);

	// Disable the randomizing effect in the HUD
    *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac & 0xff7fffff;
  }
  return;
}

// DrawHUD_Wumpa3D_2P3P4P
// param1 is gGT
void FUN_8005465c(int param_1)

{
  char cVar1;
  ushort uVar2;
  undefined *puVar3;
  undefined uVar4;
  undefined *puVar5;
  int iVar6;
  void *p;
  short sVar7;
  short sVar8;
  undefined4 *puVar9;
  undefined4 local_28;
  undefined4 local_24;
  undefined4 local_20;
  undefined4 local_1c;

  local_28 = DAT_8008d554;
  local_24 = DAT_8008d558;
  local_20 = DAT_8008d55c;
  local_1c = DAT_8008d560;
  puVar9 = &local_28;

  // if number of screens is more than 2
  if (2 < (byte)PTR_DAT_8008d2ac[0x1ca8]) {
    puVar9 = &local_20;
  }

  if (DAT_8008d4b4 != 0)
  {
	// called once to draw all wumpas

	// Camera110_LinkOT_DecalMP
    FUN_80042974(
					*(undefined4 *)(DAT_8008d4b4 + 0xf8),

					// gGT->backBuffer
					*(undefined4 *)(PTR_DAT_8008d2ac + 0x10),

					// RECT
					puVar9,

					// ofsX
					((int)(short)*(ushort *)puVar9 +
                        ((int)((uint)*(ushort *)(puVar9 + 1) << 0x10) >> 0x11) + -0x100) * 0x10000
                        >> 0x10,

					// ofsY
					((int)(short)*(ushort *)((int)puVar9 + 2) +
					((int)((uint)*(ushort *)((int)puVar9 + 6) << 0x10) >> 0x11) + -0x6c) * 0x10000 >> 0x10,

					0,0,0,0,1
				);

    iVar6 = *(int *)(DAT_8008d4b4 + 0xf4);

    if ((iVar6 != 0) && (*(int *)(DAT_8008d4b4 + 0xf8) != 0))
	{
	  // CTR_CycleTex_2p3p4pWumpaHUD
      FUN_80021b94(*(int *)(param_1 + 0x25c) + 0xffc,iVar6,
                   (*(int *)(DAT_8008d4b4 + 0xf8) - iVar6 >> 2) + 1);
    }
  }

  // if there is more than 1 screen
  if (1 < *(byte *)(param_1 + 0x1ca8))
  {
	// get HUD position variables [numScreens - 1]
    puVar5 = (&PTR_DAT_8008625c)[(uint)*(byte *)(param_1 + 0x1ca8) - 1];

    iVar6 = 0;

	// if numScreens is not zero
	if (*(byte *)(param_1 + 0x1ca8) != 0)
	{
	  // for iVar6 = 0; iVar6 < numScreens; iVar6++
      do {
        if (
			//if racer hasn't finished the race
			((*(uint *)(*(int *)(PTR_DAT_8008d2ac + iVar6 * 4 + 0x24ec) + 0x2c8) & 0x2000000) == 0) &&


			// If you're not in End-Of-Race menu
			((*(uint *)PTR_DAT_8008d2ac & 0x200000) == 0)
			)
		{
          sVar7 = (
						// wumpaHudPosX
						*(short *)(puVar5 + 0x18) +

						// Camera110 rect.x
						*(short *)(DAT_8008d4b4 + 0x1c)
				  ) -
                  ((short)*(ushort *)(puVar9 + 1) >> 1);

          sVar8 = (
						// wumpaHudPosY
						*(short *)(puVar5 + 0x1a) +

						// Camera110 rect.y
						*(short *)(DAT_8008d4b4 + 0x1e)
				  ) -
                  ((short)*(ushort *)((int)puVar9 + 6) >> 1);

		  // backBuffer->primMem.curr
          p = *(void **)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80);

		  // psyq macro setPolyFT4
          // sets len and code
		  *(undefined *)((int)p + 3) = 9;
          *(undefined *)((int)p + 7) = 0x2c;
		  
		  // RGB
          *(undefined *)((int)p + 6) = 0x80;
          *(undefined *)((int)p + 5) = 0x80;
          *(undefined *)((int)p + 4) = 0x80;
		  
		  // xy0
          *(short *)((int)p + 8) = sVar7;
          *(short *)((int)p + 10) = sVar8;
		  
          uVar2 = *(ushort *)(puVar9 + 1);
		  
		  // xy1, xy2, xy3
          *(short *)((int)p + 0x12) = sVar8;
          *(short *)((int)p + 0x18) = sVar7;
          *(short *)((int)p + 0x10) = uVar2 + sVar7;
          *(short *)((int)p + 0x1a) = *(ushort *)((int)puVar9 + 6) + sVar8;
          *(short *)((int)p + 0x20) = *(ushort *)(puVar9 + 1) + sVar7;
          *(short *)((int)p + 0x22) = *(ushort *)((int)puVar9 + 6) + sVar8;
		  
		  // uv0
          *(byte *)((int)p + 0xc) = *(byte *)puVar9 & 0x3f;
          *(byte *)((int)p + 0xd) = *(byte *)((int)puVar9 + 2);
		  
          cVar1 = *(char *)((int)p + 0xd);
		  
		  // uv1
          *(char *)((int)p + 0x14) = *(char *)((int)p + 0xc) + *(byte *)(puVar9 + 1);
          *(char *)((int)p + 0x15) = cVar1;
          
		  // uv2
		  *(undefined *)((int)p + 0x1c) = *(undefined *)((int)p + 0xc);
		  *(char *)((int)p + 0x1d) = cVar1 + *(byte *)((int)puVar9 + 6);
          
		  // uv3
		  *(char *)((int)p + 0x24) = *(char *)((int)p + 0xc) + *(byte *)(puVar9 + 1);
          *(char *)((int)p + 0x25) = cVar1 + *(byte *)((int)puVar9 + 6);
          
		  puVar3 = PTR_DAT_8008d2ac;
		  
		  // tpage
          *(ushort *)((int)p + 0x16) =
               (short)(*(ushort *)((int)puVar9 + 2) & 0x100) >> 4 |
               (ushort)(((uint)*(ushort *)puVar9 & 0x3ff) >> 6) | 0x100 |
               (ushort)(((uint)*(ushort *)((int)puVar9 + 2) & 0x200) << 2);

		  // wumpaShineResult
          uVar4 = (undefined)DAT_8008d994;

		  // if 9 < number of wumpa
		  // if wumpa is 10
          if ('\t' < *(char *)(*(int *)(puVar3 + iVar6 * 4 + 0x24ec) + 0x30))
		  {
			// wumpaShineResult
            *(undefined *)((int)p + 6) = (undefined)DAT_8008d994;
            *(undefined *)((int)p + 5) = uVar4;
            *(undefined *)((int)p + 4) = uVar4;
          }

		  // backBuffer->primMem.curr
		  // move pointer after writing polygons
          *(int *)(*(int *)(param_1 + 0x10) + 0x80) =
          *(int *)(*(int *)(param_1 + 0x10) + 0x80) + 0x28;

		  // pointer to OT memory, and pointer to primitive
		  AddPrim(*(void **)(param_1 + 0x147c),p);
        }
        iVar6 = iVar6 + 1;
        puVar5 = puVar5 + 0xa0;
      } while (iVar6 < (int)(uint)*(byte *)(param_1 + 0x1ca8));
    }
  }
  return;
}

// EndOfRace_GetDriverQuipData
// param_1 driver object,
// param_2 offset,
// param_3 size
uint FUN_80054a08(int param_1,int param_2,int param_3)

{
  // if size is 2 bytes
  if (param_3 == 2)
  {
	// return a short
    return (int)*(short *)(param_1 + param_2);
  }

  // if size is 1 byte
  if (param_3 < 3) {
    if (param_3 == 1)
	{
	  // return a char
      return (uint)*(byte *)(param_1 + param_2);
    }
  }

  // if size is 4 bytes
  else {
    if (param_3 == 4)
	{
	  // return an int
      return *(undefined4 *)(param_1 + param_2);
    }

	// Sep3
	// printf("**error** invalid quip size %ld\n");

	// dictionary defines "quip" as "a witty remark"
  }
  return 0;
}


// EndOfRace_AssignOneComment
// param_1 - driver object
void FUN_80054a78(int param_1,uint *param_2,int param_3,undefined4 param_4)

{
  undefined *puVar1;
  undefined2 uVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;

  if (
		// if driver object exists
		(param_1 != 0) &&

		(((*(ushort *)((int)param_2 + 10) & 4) == 0 || (param_1 == param_3)))
	  )
  {
    uVar5 = *param_2;
    uVar4 = uVar5 + 8;
    if (uVar4 < param_2[1]) {
      do {
        if (
				(*(int *)(uVar5 + 4) < *(int *)(uVar4 + 4)) ||
				(
					(
						*(int *)(uVar4 + 4) == *(int *)(uVar5 + 4) &&
						(
							// random number
							iVar3 = FUN_8003ea28(),
							(iVar3 >> 3 & 0xffU) < 0x40
						)
					)
				)
			)
		{
          uVar5 = uVar4;
        }
        uVar4 = uVar4 + 8;
      } while (uVar4 < param_2[1]);
    }
    if (*(int *)(param_1 + 0x56c) != 0) {
      iVar3 = *(int *)(*(int *)(param_1 + 0x56c) + 4);
      if (*(int *)(uVar5 + 4) <= iVar3) {
        if (*(int *)(uVar5 + 4) != iVar3) {
          return;
        }

		// Get random number
        iVar3 = FUN_8003ea28();

        if (0x3f < (iVar3 >> 3 & 0xffU)) {
          return;
        }
      }
      iVar3 = *(int *)(param_1 + 0x56c);
      if ((iVar3 != 0) && (*(int *)(iVar3 + 4) < 0)) {
        *(int *)(iVar3 + 4) = -*(int *)(iVar3 + 4);
      }
    }
    if (0 < *(int *)(uVar5 + 4)) {
      *(int *)(uVar5 + 4) = -*(int *)(uVar5 + 4);
    }
    puVar1 = PTR_DAT_8008d2ac;
    *(uint *)(param_1 + 0x56c) = uVar5;
    *(undefined4 *)(param_1 + 0x570) = param_4;

	// 150 frames (5 seconds) for Battle
    uVar2 = 0x96;

	// if not battle mode (VS)
    if ((*(uint *)puVar1 & 0x20) == 0)
	{
	  // 300 frames (10 seconds) for VS
      uVar2 = 300;
    }

	// set cooldown after end of VS race
	*(undefined2 *)(puVar1 + 0x1d36) = uVar2;
  }
  return;
}


// EndOfRace_AssignAllComments
void FUN_80054bfc(void)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  int *piVar7;
  int iVar8;
  uint uVar9;
  undefined *puVar10;
  undefined **ppuVar11;
  int iVar12;
  undefined **ppuVar13;
  int iVar14;
  int iVar15;
  int iVar16;
  ushort *puVar17;
  uint uVar18;
  int iVar19;
  undefined **ppuVar20;
  int aiStack80 [8];
  undefined **local_30;
  int local_2c;

  local_2c = 0;

  // number of screens is more than 1
  if (1 < (byte)PTR_DAT_8008d2ac[0x1ca8]) {

	// If you're not in Battle Mode
    if ((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0)
	{
	  // pointer to array of LNG index for end-of-race comment
      ppuVar13 = (undefined **)0x8008664c; // &DAT_800864dc
      local_30 = (undefined **)&DAT_800869f4;
    }

	// if in battle
    else
	{
	  // pointer to array of LNG index for end-of-race comment
      ppuVar13 = &PTR_DAT_80086c0c; // 80086b64
      local_30 = (undefined **)&DAT_80086d2c;
    }

	// loop through all comments, and apply some 
	// kind of patch to each
    if (ppuVar13 < local_30) {
      ppuVar11 = ppuVar13 + 1;
      ppuVar20 = ppuVar13;
      do {
        puVar10 = *ppuVar20;
        if (puVar10 < *ppuVar11) {
          piVar7 = (int *)(puVar10 + 4);
          do {
            puVar10 = puVar10 + 8;
            *piVar7 = *piVar7 + 1;
            piVar7 = piVar7 + 2;
          } while (puVar10 < *ppuVar11);
        }
		
		// skip 0x18 bytes
        ppuVar20 = ppuVar20 + 6;
        ppuVar11 = ppuVar11 + 6;
		
      } while (ppuVar20 < local_30);
    }
    puVar10 = PTR_DAT_8008d2ac;

	// pointer to first Player thread
    iVar19 = *(int *)(PTR_DAT_8008d2ac + 0x1b2c);

    iVar2 = 0;
    iVar3 = 0;
    iVar4 = 0;

	// loop through all Player threads
    while (iVar19 != 0)
	{
	  // get Driver object from thread
      iVar14 = *(int *)(iVar19 + 0x30);

      *(undefined4 *)(iVar14 + 0x56c) = 0;

	  // If you dont have a point limit (battle)
      if ((*(uint *)puVar10 & 0x4000) == 0)
	  {
		// get number of lives in life limit (3,6,9)
        iVar8 = *(int *)(iVar14 + 0x4e4);
      }

	  // if you have point limit in (battle)
      else
	  {
		// Get number of points on this driver's team
        iVar8 = *(int *)(puVar10 + *(int *)(iVar14 + 0x4e8) * 4 + 0x1d90);
      }

      aiStack80[*(byte *)(iVar14 + 0x4a)] = iVar8;
      iVar16 = iVar4;
      if ((iVar8 <= iVar4) &&
         (bVar1 = iVar8 == iVar4, iVar8 = iVar4, iVar14 = iVar3, iVar16 = iVar2, bVar1)) {
        iVar14 = 0;
        iVar16 = iVar4;
      }

	  // thread = thread -> sibling
	  iVar19 = *(int *)(iVar19 + 0x10);

      iVar2 = iVar16;
      iVar3 = iVar14;
      iVar4 = iVar8;
    }
	
	// offset 0xA
    puVar17 = (ushort *)((int)ppuVar13 + 10);
	
    if (ppuVar13 < local_30) {
      do {
        uVar18 = 0;
        if (puVar17[-1] == 5) {
          uVar18 = 0x7fffffff;
        }
		
		// short*
		// 0xA + 1*2 = 0xC
        iVar19 = *(int *)(puVar17 + 1);
		
        if ((*puVar17 & 1) != 0)
		{
		  // get number of laps in the race
          iVar4 = (int)(char)PTR_DAT_8008d2ac[0x1d33];

		  // get absolute value
          if (iVar4 < 0) {
            iVar4 = -iVar4;
          }

          iVar19 = iVar19 * iVar4;
        }

		// pointer to first Player thread
        iVar14 = *(int *)(PTR_DAT_8008d2ac + 0x1b2c);

        iVar4 = 0;

		// loop through all Player threads
        while (iVar14 != 0)
		{
		  // get driver object from thread
          iVar15 = *(int *)(iVar14 + 0x30);

          iVar8 = iVar4;
          iVar16 = iVar19;
          uVar9 = uVar18;
		  
		  // short*
		  // 0xA + -1*2 = 0x8
          switch(puVar17[-1]) {
          case 0:
		  
		    // EndOfRace_GetDriverQuipData
            iVar6 = FUN_80054a08(iVar15,
								*(undefined4 *)(puVar17 + 3), // 0xA + 3*2 = 0x10 (driverOffset)
								*(undefined4 *)(puVar17 + 5)  // 0xA + 5*2 = 0x14
								);
            iVar8 = iVar15;
            iVar16 = iVar6;
            if (iVar6 <= iVar19) {
LAB_80054f44:
              iVar8 = iVar4;
              iVar16 = iVar19;
              if (iVar6 == iVar19) {
                iVar8 = 0;
              }
            }
            break;
          case 1:
			// EndOfRace_GetDriverQuipData
            iVar6 = FUN_80054a08(iVar15,
								*(undefined4 *)(puVar17 + 3), // 0xA + 3*2 = 0x10 (driverOffset)
								*(undefined4 *)(puVar17 + 5)  // 0xA + 5*2 = 0x14
								);
								
            if ((-1 < iVar6) && (iVar8 = iVar15, iVar16 = iVar6, iVar19 <= iVar6))
            goto LAB_80054f44;
            break;
          case 3:

			// loop counter
            iVar12 = 0;

            iVar6 = iVar15;

			// for iVar12 = 0; iVar12 < 8; iVar12++
			do {
              uVar9 = (uint)*(byte *)(iVar6 + 0x560);
              if (iVar19 < (int)(uVar9 - uVar18)) {
                local_2c = iVar12;
                iVar4 = iVar15;
                uVar18 = uVar9;
              }
              else {
                if ((-iVar19 < (int)(uVar9 - uVar18)) && (iVar4 = 0, (int)uVar18 < (int)uVar9)) {
                  uVar18 = uVar9;
                }
              }

			  // increment loop counter
              iVar12 = iVar12 + 1;

              iVar6 = iVar15 + iVar12;
              iVar8 = iVar4;
              uVar9 = uVar18;
            } while (iVar12 < 8);
            break;
          case 4:
			// EndOfRace_GetDriverQuipData
            uVar5 = FUN_80054a08(iVar15,
								*(undefined4 *)(puVar17 + 3), // 0xA + 3*2 = 0x10 (driverOffset)
								*(undefined4 *)(puVar17 + 5)  // 0xA + 5*2 = 0x14
								);
            iVar8 = iVar15;
            uVar9 = uVar5;
            if (((int)(uVar5 - uVar18) <= iVar19) &&
               (bVar1 = (int)uVar18 < (int)uVar5, iVar8 = iVar4, uVar9 = uVar18,
               -iVar19 < (int)(uVar5 - uVar18))) {
LAB_80054fd0:
              iVar8 = 0;
              uVar9 = uVar18;
              if (bVar1) {
                uVar9 = uVar5;
              }
            }
            break;
          case 5:
			// EndOfRace_GetDriverQuipData
            uVar5 = FUN_80054a08(iVar15,
								*(undefined4 *)(puVar17 + 3), // 0xA + 3*2 = 0x10 (driverOffset)
								*(undefined4 *)(puVar17 + 5)  // 0xA + 5*2 = 0x14
								);
								
            if (((-1 < (int)uVar5) &&
                (iVar8 = iVar15, uVar9 = uVar5, (int)(uVar18 - uVar5) <= iVar19)) &&
               (bVar1 = (int)uVar5 < (int)uVar18, iVar8 = iVar4, uVar9 = uVar18,
               -iVar19 < (int)(uVar18 - uVar5))) goto LAB_80054fd0;
            break;
          case 6:
			// EndOfRace_GetDriverQuipData
            uVar18 = FUN_80054a08(iVar15,
								*(undefined4 *)(puVar17 + 3), // 0xA + 3*2 = 0x10 (driverOffset)
								*(undefined4 *)(puVar17 + 5)  // 0xA + 5*2 = 0x14
								);
								
            if (uVar18 == (uint)*(byte *)(iVar15 + 0x559)) {
              iVar8 = iVar15;
            }
            break;
          case 7:
            if (iVar19 == 0) {
              if (iVar15 == iVar3) {
                iVar8 = iVar3;
              }
            }
            else {
              if (((iVar19 == 1) && (iVar2 != 0)) && (aiStack80[*(byte *)(iVar15 + 0x4a)] == iVar2))
              {
                iVar8 = iVar15;
              }
            }
            break;
          case 8:
			// EndOfRace_GetDriverQuipData
            iVar4 = FUN_80054a08(iVar15,
								*(undefined4 *)(puVar17 + 3), // 0xA + 3*2 = 0x10 (driverOffset)
								*(undefined4 *)(puVar17 + 5)  // 0xA + 5*2 = 0x14
								);
            if (iVar4 == iVar19) {
              iVar8 = iVar15;
            }
            break;
          case 9:
            if (*(int *)(iVar15 + 0x56c) == 0)
			{
			  // EndOfRace_AssignOneComment
              FUN_80054a78(iVar15,ppuVar13,iVar3,0);
            }
          }
          if ((iVar8 != 0) && ((*puVar17 & 0xc) != 0))
		  {
			// EndOfRace_AssignOneComment
            FUN_80054a78(iVar8,ppuVar13,iVar3,local_2c);
          }

		  // thread = thread -> sibling
          iVar14 = *(int *)(iVar14 + 0x10);

          iVar4 = iVar8;
          iVar19 = iVar16;
          uVar18 = uVar9;
        }

		// EndOfRace_AssignOneComment
        FUN_80054a78(iVar4,ppuVar13,iVar3,local_2c);

		// jump 0x18 bytes
        ppuVar13 = ppuVar13 + 6;
        puVar17 = puVar17 + 0xc;
		
      } while (ppuVar13 < local_30);
    }
  }
  return;
}


// EndOfRace_DrawAllComments
void FUN_800550f4(void)

{
  ushort uVar1;
  ushort uVar2;
  ushort uVar3;
  ushort uVar4;
  ushort *puVar5;
  char *pcVar6;
  int iVar7;
  ushort *puVar8;
  int iVar9;
  short sVar10;
  char acStack160 [128];

  // pointer to first Player thread
  iVar9 = *(int *)(PTR_DAT_8008d2ac + 0x1b2c);

  sVar10 = 0;

  // if thread exists
  if (iVar9 != 0)
  {
    puVar8 = (ushort *)(PTR_DAT_8008d2ac + 0x18a);

	// loop through all threads
    do
	{
	  // Dimensions of each player's camera110
	  // PosX, PosY, Width, Height
	  // (rewritten order for simplicity)
      uVar1 = puVar8[-3];
      uVar2 = puVar8[-2];
      uVar3 = puVar8[-1];
      uVar4 = *puVar8;

      iVar7 = *(int *)(iVar9 + 0x30);
      if ((((&DAT_8008d564)[sVar10] & 2) == 0) &&


         (
			// Player struct's Offset 0x56c holds which LNG string
			// will be this player's End-Of-Race comment,
			// 0 - PAUSED, 1 - RESTART, 21A - The Dominator, etc
			puVar5 = *(ushort **)(iVar7 + 0x56c),

			// make sure the string index is valid
			puVar5 != (ushort *)0x0
		 )
		)
	  {
        *(undefined4 *)(puVar5 + 2) = 0;

		// if this is only one comment
        if ((puVar5[1] & 1) == 0)
		{
		  // Print the string as a comment
          pcVar6 = *(char **)((uint)*puVar5 * 4 + DAT_8008d878);
        }

		// if the comment is conjoined
        else
		{
		  // Add two strings together
          sprintf(
			acStack160,

			// original end-of-race comment
			*(char **)((uint)*puVar5 * 4 + DAT_8008d878),

			// second part of comment
                  *(undefined4 *)
                   ((int)*(short *)(&DAT_80086d88 + *(int *)(iVar7 + 0x570) * 0x10) * 4 +
                   DAT_8008d878));

		  // Overwrite the stack pointer to print
          pcVar6 = acStack160;
        }

		// Draw the string with a box around it
        FUN_8004568c(
					// The string to print
					pcVar6,

					// X-position of camera110, plus 50% of width
					((int)(short)uVar1 + ((int)((uint)uVar3 << 0x10) >> 0x11)) * 0x10000 >> 0x10,

					// Y-position of camera110, plus 12% of height
                    ((int)(short)uVar2 + ((int)((uint)uVar4 << 0x10) >> 0x13)) * 0x10000 >> 0x10,

					0,3,0xffff8000,4);
      }

	  // increment loop counter
      sVar10 = sVar10 + 1;

	  // next player thread
      iVar9 = *(int *)(iVar9 + 0x10);

	  // Go to next camera110
      puVar8 = puVar8 + 0x88;

    } while (iVar9 != 0);
  }
  return;
}


// EndOfRace_Battle
void FUN_800552a4(void)

{
  byte bVar1;
  short sVar2;
  short sVar3;
  short sVar4;
  short sVar5;
  undefined4 *puVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  byte *pbVar10;
  int iVar11;
  undefined *puVar12;
  int iVar13;
  int iVar14;
  int local_78;
  undefined4 local_70;
  undefined4 local_6c;
  undefined4 local_68;
  undefined4 local_64;
  undefined4 local_60;
  undefined4 local_5c;
  char acStack88 [8];
  short local_50;
  short local_4e;
  undefined2 local_48;
  undefined2 local_46;
  undefined2 local_44;
  undefined2 local_42;
  short local_40;
  byte *local_38;
  char *local_34;
  int local_30;

  local_40 = 0;
  local_70 = 0x350055;
  local_6c = 0x3500aa;
  local_68 = 0x430055;
  local_64 = 0x4300aa;
  local_60 = DAT_8008d568;
  local_5c = DAT_8008d56c;

  // loop counter
  iVar13 = 0;

  // if number of screens is not 0
  if (PTR_DAT_8008d2ac[0x1ca8] != '\0')
  {
    local_34 = acStack88;
    iVar14 = 0;
    local_30 = 0;
    iVar7 = 0;

	// for(int iVar13 = 0; iVar13 < numScreens; iVar13++)
    do
	{
	  // flags, for which players have pressed X to continue
      pbVar10 = &DAT_8008d564 + iVar13;

	  // Pointer to each camera110 struct ???
	  puVar12 = PTR_DAT_8008d2ac + (iVar7 + iVar13) * 0x10 + 0x168;

	  // Pointer to each player (9900C, 99010, etc)
      iVar7 = *(int *)(PTR_DAT_8008d2ac + local_30 + 0x24ec);

	  // If Player has not pressed X to continue
	  // Draw comment, and battle stats
      if ((*pbVar10 & 2) == 0)
	  {
		// If you hit left or right on the D-Pad, or Analog Stick
        if (((*(uint *)(PTR_DAT_8008d2b0 + iVar14 + 0x14) & 4) != 0) ||
           ((*(uint *)(PTR_DAT_8008d2b0 + iVar14 + 0x14) & 8) != 0))
		{
		  // Flip the first bit
		  // If it is 1, make it 0
		  // If it is 0, make it 1
          *pbVar10 = *pbVar10 ^ 1;
        }

		// If player hit X (to blacken their screen to proceed to next menu)
        if (((*(uint *)(PTR_DAT_8008d2b0 + iVar14 + 0x14) & 0x1010) != 0) &&

			// if cooldown has gone down a bit,
			// This way you can't press X immediately
			// after seeing on-screen comments
           (*(short *)(PTR_DAT_8008d2ac + 0x1d36) < 0x78))
		{
		  // Flip the 2nd bit, change 0 to 2
          (&DAT_8008d564)[iVar13] = (&DAT_8008d564)[iVar13] ^ 2;
        }

		// If you want to see YOU HIT (assumed by default)
		// set string to YOU HIT
        iVar9 = 0x157;

		// If you want to see HIT YOU
        if (((&DAT_8008d564)[iVar13] & 1) != 0)
		{
		  // if you want to see who hit you
          iVar9 = 0x158;
        }

		// If you're in Battle Mode
        if ((*(uint *)PTR_DAT_8008d2ac & 0x20) != 0)
		{
          local_78 = -0x7ffc;

		  // ivar9 0x157: YOU HIT
		  // ivar9 0x158: HIT YOU
          FUN_80022878(*(undefined4 *)(iVar9 * 4 + DAT_8008d878),

						// Midpoint between camera110 Start X and End X
                       (int)(((uint)*(ushort *)(puVar12 + 0x1c) +
                       ((int)((uint)*(ushort *)(puVar12 + 0x20) << 0x10) >> 0x11)) * 0x10000) >> 0x10,

					   // Start Y + 0x23
					   (int)(((uint)*(ushort *)(puVar12 + 0x1e) + 0x23) * 0x10000) >> 0x10,

					   3,0xffff8004);

		  // loop counter
		  iVar9 = 0;

		  // if number of screens is not zero
          if (PTR_DAT_8008d2ac[0x1ca8] != '\0')
		  {
			// same as checking HIT YOU vs YOU HIT before
            local_38 = &DAT_8008d564 + iVar13;

            iVar11 = 1;

			// If you have 3 screens, you need 9 prints
			// If you have 4 screens, you need 16 prints

			// for (a in players)
				// for (b in players)
					// print a hit b
					// print b hit a

			// for(int iVar9 = 0; iVar9 < numScreens; iVar9++)
            do
			{
			  // Get Battle Team of player
              sVar4 = *(short *)(*(int *)(PTR_DAT_8008d2ac + iVar9 * 4 + 0x24ec) + 0x4e8);

			  // if not two screens
			  // use flags from registers
              puVar6 = &local_70;

			  // If number of screens is 2
              if (PTR_DAT_8008d2ac[0x1ca8] == '\x02')
			  {
				// use flags from ram, loaded to stack
                puVar6 = &local_60;
              }

              sVar5 = *(short *)(puVar6 + iVar9);
              local_50 = sVar5;
              local_4e = *(short *)((int)(puVar6 + iVar9) + 2);
              sVar2 = *(short *)(puVar12 + 0x1c);
              sVar3 = *(short *)(puVar12 + 0x1e);
              iVar8 = (int)local_4e;

			  // YOU HIT
			  // iVar13 hit iVar9
              if ((*local_38 & 1) == 0)
			  {
                bVar1 = *(byte *)(iVar7 + 0x50c);
              }

			  // HIT YOU
			  // iVar9 hit iVar13
              else
			  {
                bVar1 = *(byte *)(iVar7 + 0x560);
              }

              sprintf(acStack88,"p%d:%2.02d",

				// basically, iVar11 = iVar9 + 1
				// which is (1, 2, 3, 4)
				iVar11,

				// Amount of times this player hit you,
				// or amount of times you hit them
				(uint)bVar1,

				local_78);

              local_78 = (int)(short)(sVar4 + 0x18U | 0x8000);

              FUN_80022878(acStack88,

						   // midpoint between Start X and Size X
						   ((int)sVar2 + (int)sVar5) * 0x10000 >> 0x10,

						   // midpoint between Start Y and Size Y
                           (sVar3 + iVar8) * 0x10000 >> 0x10,

						   2);

              iVar7 = iVar7 + 1;

			  // loop counter
			  iVar9 = iVar9 + 1;

              iVar11 = iVar11 + 1;

								// number of screens
            } while (iVar9 < (int)(uint)(byte)PTR_DAT_8008d2ac[0x1ca8]);
          }
        }
      }

	  // If Player has pressed X to continue
      else
	  {
		// Stop drawing comment + battle stats

        memset(local_34,0,4);

		// rectangle parameters, screen dimensions
        local_48 = *(undefined2 *)(puVar12 + 0x1c);
        local_46 = *(undefined2 *)(puVar12 + 0x1e);
        local_44 = *(undefined2 *)(puVar12 + 0x20);
        local_42 = *(undefined2 *)(puVar12 + 0x22);

		// CTR_Box_DrawClearBox
        FUN_8002177c(&local_48,local_34,0,

						*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0),

						// pointer to PrimMem struct
						*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

		// If player presses Square, to go back to view End-Of-Race comment,
		// or in Battle mode this includes "Hit You / You Hit" screen
        if ((*(uint *)(PTR_DAT_8008d2b0 + iVar14 + 0x14) & 0x8000) != 0)
		{
		  // Flip 2nd bit back from 1 to 0
          *pbVar10 = *pbVar10 ^ 2;
        }

		// increment counter of players ready to continue
        local_40 = local_40 + 1;
      }

      iVar14 = iVar14 + 0x50;
      local_30 = local_30 + 4;

	  // loop counter
      iVar13 = iVar13 + 1;

      iVar7 = iVar13 * 0x10;

	  // for(int iVar13 = 0; iVar13 < numScreens; iVar13++)
	} while (iVar13 < (int)(uint)(byte)PTR_DAT_8008d2ac[0x1ca8]);
  }
  iVar13 = 3;

  // if number players ready to continue is equal to number of screens
  // Basically: If all players press X to continue
  if ((int)local_40 == (uint)(byte)PTR_DAT_8008d2ac[0x1ca8])
  {
	// Stop drawing 4 screens, draw 1 screen and options
    *(undefined2 *)(PTR_DAT_8008d2ac + 0x1d36) = 0;
    puVar12 = &DAT_8008d567;
    do {
      *puVar12 = 0;
      iVar13 = iVar13 + -1;
      puVar12 = puVar12 + -1;
    } while (-1 < iVar13);
  }
  return;
}


// Driver_Finalize_RaceClock
void FUN_8005572c(int param_1)

{
  byte bVar1;
  int iVar2;
  int iVar3;
  int iVar4;

  // If race timer is not supposed to stop for this racer
  if ((*(uint *)(param_1 + 0x2c8) & 0x40000) == 0)
  {
    iVar3 = *(int *)(param_1 + 0x514);

    // Stop time for this racer
    *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) | 0x40000;

	if (iVar3 != 0) {
      iVar2 = *(int *)(param_1 + 0x518) * 100;
      if (iVar3 == 0) {
        trap(0x1c00);
      }
      if ((iVar3 == -1) && (iVar2 == -0x80000000)) {
        trap(0x1800);
      }
      *(int *)(param_1 + 0x518) = iVar2 / iVar3;
    }
    if (*(byte *)(param_1 + 0x55c) < 4) {
      *(undefined4 *)(param_1 + 0x574) = 0xffffffff;
    }
    else {
      bVar1 = *(byte *)(param_1 + 0x55c);
      if (bVar1 == 0) {
        trap(0x1c00);
      }
      if (((uint)bVar1 == 0xffffffff) && ((uint)*(byte *)(param_1 + 0x559) == 0x80000)) {
        trap(0x1800);
      }
      *(int *)(param_1 + 0x574) = (int)((uint)*(byte *)(param_1 + 0x559) << 0xc) / (int)(uint)bVar1;
    }
    iVar4 = 0;
    iVar2 = 0;
    iVar3 = param_1;
    do {
      iVar2 = iVar2 + 1;
      iVar4 = iVar4 + (uint)*(byte *)(iVar3 + 0x560);
      iVar3 = param_1 + iVar2;
    } while (iVar2 < 8);
    *(int *)(param_1 + 0x57c) = iVar4;
    if (*(short *)(param_1 + 0x482) == 0) {
    	//*(undefined4 *)(param_1 + 0x578) = time racer has been in last place
      *(undefined4 *)(param_1 + 0x578) = *(undefined4 *)(param_1 + 0x528);
    }
  }
  return;
}


// Draw Title Bars
// You see this in 1P mode, right before traffic lights count down
void FUN_80055840(void)

{
  short sVar1;
  undefined *puVar2;
  int iVar3;
  uint uVar4;
  undefined *puVar5;
  char *pcVar6;
  short sVar7;
  undefined4 uVar8;
  uint uVar9;
  int iVar10;
  char acStack72 [24];
  undefined2 local_30;
  short local_2e;
  undefined2 local_2c;
  undefined2 local_2a;
  uint local_28 [2];

  puVar2 = PTR_DAT_8008d2ac;

  // by default, do not transition
  // title bars to off-screen
  iVar10 = 0;

  uVar4 = *(uint *)PTR_DAT_8008d2ac;

  // If you are not in a relic race
  if ((uVar4 & 0x4000000) == 0)
  {
	// BONUS ROUND
    uVar9 = 0xbe;

	// If you are not in Crystal challenge
    if ((uVar4 & 0x8000000) == 0) {

	  // If you are not in Adventure Cup
      if ((uVar4 & 0x10000000) == 0) {

		// If you are not in Arcade or VS cup
        if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x10) == 0) {

		  // ARCADE
		  uVar9 = 0x4e;

          if (
				// If you're in Arcade Mode
				((uVar4 & 0x400000) != 0) ||

				(
					// TIME TRIAL
					uVar9 = 0x4d,

					// if you are in time trial mode
					(uVar4 & 0x20000) != 0
				)
			  )	goto LAB_80055930;

		  if (-1 < (int)uVar4)
		  {
			// TROPHY RACE
            uVar9 = 0xb7;

			// If you're in a CTR Token Race
            if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 8) != 0)
			{
			  // CTR CHALLENGE
              uVar9 = 0x176;
            }
            goto LAB_80055930;
          }
          iVar3 = *(int *)(PTR_DAT_8008d2ac + 0x1eb8);
          puVar5 = &DAT_8008413c;
        }

		// If you are in Arcade or VS cup
		else {
		  // Get Cup ID
          iVar3 = *(int *)(PTR_DAT_8008d2ac + 0x1e58);
          puVar5 = &DAT_80086d38;
        }
      }

	  // If you are in Adventure Cup
	  else {
		// Get Cup ID
        iVar3 = *(int *)(PTR_DAT_8008d2ac + 0x1e58);
        puVar5 = &DAT_80086d2c;
      }

	  // Get the name of the cup
	  // Wumpa, Nitro, Crystal
	  // Red, Green, Purple, etc
      uVar9 = (uint)*(ushort *)(puVar5 + iVar3 * 2);
    }
  }

  // If you are in Relic Race
  else
  {
	// RELIC RACE
    uVar9 = 0xb8;
  }
LAB_80055930:

  // if fly-in animation is one second away from finishing
  if (*(short *)(PTR_DAT_8008d2ac + 0x1526) < 0x1f)
  {
	// use this to transition title bars to off-screen
    iVar10 = 0x1e - (uint)*(ushort *)(PTR_DAT_8008d2ac + 0x1526);
  }

  // CheckeredFlag_IsFullyOnScreen
  iVar3 = FUN_80043f1c();

  // if not
  if (iVar3 == 0)
  {
	// Draw big string
    uVar8 = 1;

	// used for transitioning bars to off-screen
    sVar1 = (short)iVar10;

	if (

		// If you are not in Adventure cup
		((*(uint *)PTR_DAT_8008d2ac & 0x10000000) == 0) &&

		// If you are not in Arcade or VS cup
		((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x10) == 0)
	)
	{
	  // X-value, not 0x100???
      iVar3 = (int)(((uint)*(ushort *)(puVar2 + 0x184) +
                    ((int)((uint)*(ushort *)(puVar2 + 0x188) << 0x10) >> 0x11)) * 0x10000) >> 0x10;

	  // string of top title bar
	  pcVar6 = *(char **)(((int)(uVar9 << 0x10) >> 0xe) + DAT_8008d878);

	  // Y-value that transitions title text to off-screen
      sVar7 = *(short *)(puVar2 + 0x186) - (sVar1 + -7);
    }

	// If you are in any cup of any kind
    else
	{
	  // Name of Cup

										  // uVar9 * 4
      FUN_80022878(*(undefined4 *)(((int)(uVar9 << 0x10) >> 0xe) + DAT_8008d878),
                   (int)(((uint)*(ushort *)(puVar2 + 0x184) +
                         ((int)((uint)*(ushort *)(puVar2 + 0x188) << 0x10) >> 0x11)) * 0x10000) >>
                   0x10,(int)((((uint)*(ushort *)(puVar2 + 0x186) - (iVar10 + -7)) + -6) * 0x10000)
                        >> 0x10,1,0xffff8000);

	  // Track 1/4, 2/4, 3/4, 4/4 in cup
      sprintf(acStack72,"%s %ld/4",

				// DAT_8008d878 + 0x5d4
				// TRACK
				*(undefined4 *)(DAT_8008d878 + 0x5d4),

				// Track Index (0, 1, 2, 3) + 1
				*(int *)(PTR_DAT_8008d2ac + 0x1e5c) + 1);

	  // string of top title bar
	  pcVar6 = acStack72;

	  // X-value, centered
      iVar3 = 0x100;

	  // Draw small string
      uVar8 = 2;

	  // Y-value that transitions title text to off-screen
      sVar7 = (*(short *)(puVar2 + 0x186) - (short)(iVar10 + -7)) + 0xb;
    }

	// Print top title text "Arcade, Time Trial, etc"
    FUN_80022878(pcVar6,iVar3,(int)sVar7,uVar8,0xffff8000);

	// Print the name of the level
	// Crash Cove, Roos Tubes, etc
    FUN_80022878(*(undefined4 *)

					// 83a88 = 110
					// 8d878 + 110*4 -> Dingo Canyon

																// Level ID
                  ((int)*(short *)(&DAT_80083a88 + *(int *)(PTR_DAT_8008d2ac + 0x1a10) * 0x18) * 4 +
                  DAT_8008d878),

                 (int)(((uint)*(ushort *)(puVar2 + 0x184) +
                       ((int)((uint)*(ushort *)(puVar2 + 0x188) << 0x10) >> 0x11)) * 0x10000) >>
                 0x10,(int)(((uint)*(ushort *)(puVar2 + 0x186) + (uint)*(ushort *)(puVar2 + 0x18a) +
                            iVar10 + -0x17) * 0x10000) >> 0x10,1,0xffff8000);

	// color of rectangle that touches Black title bar
	local_28[0] = DAT_8008d438;

	// dimensions of window, two-pixels tall
    local_30 = *(undefined2 *)(puVar2 + 0x184);
    local_2e = *(short *)(puVar2 + 0x186) - (sVar1 + -0x1c);
    local_2c = *(undefined2 *)(puVar2 + 0x188);
    local_2a = 2;

	// Draw tiny rectangle near big black title bar (first)
	// CTR_Box_DrawSolidBox
    FUN_80021894(&local_30,local_28,

					*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0),

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

	// dimensions of window, two-pixels tall
	local_30 = *(undefined2 *)(puVar2 + 0x184);
    local_2e = *(short *)(puVar2 + 0x186) + *(short *)(puVar2 + 0x18a) + sVar1 + -0x1e;
    local_2c = *(undefined2 *)(puVar2 + 0x188);
    local_2a = 2;

	// Draw tiny rectangle near big black title bar (second)
	// CTR_Box_DrawSolidBox
    FUN_80021894(&local_30,local_28,

					*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0),

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

	// clear RGB, keep alpha (which is zero anyway)
    local_28[0] = local_28[0] & 0xff000000;

	// dimensions of window, 30-pixels tall
    local_30 = *(undefined2 *)(puVar2 + 0x184);
    local_2e = *(short *)(puVar2 + 0x186) - sVar1;
    local_2c = *(undefined2 *)(puVar2 + 0x188);
    local_2a = 0x1e;

	// draw big black title bar (first)
	// CTR_Box_DrawSolidBox
    FUN_80021894(&local_30,local_28,

					*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0),

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);

	// dimensions of window, 30-pixels tall
    local_30 = *(undefined2 *)(puVar2 + 0x184);
    local_2e = *(short *)(puVar2 + 0x186) + *(short *)(puVar2 + 0x18a) + sVar1 + -0x1e;
    local_2c = *(undefined2 *)(puVar2 + 0x188);
    local_2a = 0x1e;

	// draw big black title bar (second)
	// CTR_Box_DrawSolidBox
    FUN_80021894(&local_30,local_28,

					*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0),

					// pointer to PrimMem struct
					*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74);
  }
  return;
}


// MenuBoxFuncPtr_GenericEndOfRace
void FUN_80055c90(int param_1)

{
  short sVar1;
  undefined *puVar2;
  uint uVar3;
  int iVar4;
  undefined4 *puVar5;
  undefined4 *puVar6;
  undefined4 *puVar7;
  ushort uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  undefined4 uVar11;

  puVar2 = PTR_DAT_8008d2ac;
  if (*(short *)(param_1 + 0x1e) == 0) {

	if (-1 < (int)*(short *)(param_1 + 0x1a))
	{
      if (*(short *)((int)*(short *)(param_1 + 0x1a) * 6 + *(int *)(param_1 + 0xc)) != 9) {

		// make MenuBox invisible
		FUN_800469c8();
      }
      DAT_8008d52c = 0;
      DAT_8008d570 = 1;

	  // rows[rowSelected].titleLngID
      sVar1 = *(short *)((int)*(short *)(param_1 + 0x1a) * 6 + *(int *)(param_1 + 0xc));

	  // if "Change Level"
      if (sVar1 == 6)
	  {
		// Erase ghost of previous race from RAM
        FUN_80028410();

		// go back to track selection
        DAT_8008d97c = 2;
      }

	  // if not "Change Level"
      else
	  {
        if (sVar1 < 7)
		{
		  // If "Retry"
          if (sVar1 == 4)
		  {
			// Turn off HUD
            PTR_DAT_8008d2ac[0x1d31] = PTR_DAT_8008d2ac[0x1d31] & 0xfe;

			// CheckeredFlag_IsFullyOffScreen
			iVar4 = FUN_80043f28();

            if (iVar4 == 1)
			{
			  // checkered flag, begin transition on-screen
              FUN_80043fb0(1);
            }

            DAT_8008d0f8 = -5;

			// howl_StopAudio
			// clear backup,
			// keep music,
			// destroy "most" fx, let menu fx play to end
            FUN_8002c8a8(1,0,0);

            if ((*(uint *)(PTR_DAT_8008d2ac + 0x1d44) & 1) == 0) {
              return;
            }

			// bool playGhostDuringRace
            DAT_8008d958 = 1;

            puVar5 = DAT_8008fbf4 + 0xf80;

			// Ghost recording buffer
			puVar6 = DAT_8008fbf4;

			// Ghost replay buffer (to watch while you drive)
            puVar7 = DAT_8008d754;


            if ((((uint)DAT_8008fbf4 | (uint)DAT_8008d754) & 3) == 0)
			{
			  // Copy ghost recording buffer
              do {
                uVar9 = puVar6[1];
                uVar10 = puVar6[2];
                uVar11 = puVar6[3];
                *puVar7 = *puVar6;
                puVar7[1] = uVar9;
                puVar7[2] = uVar10;
                puVar7[3] = uVar11;
                puVar6 = puVar6 + 4;
                puVar7 = puVar7 + 4;
              } while (puVar6 != puVar5);
            }

			// The contents of this "else" are identical to the "if" above,
			// you can tell by copying the contents and searching with CTRL + F

            else
			{
			  // copy ghost recording buffer
              do {
                uVar9 = puVar6[1];
                uVar10 = puVar6[2];
                uVar11 = puVar6[3];
                *puVar7 = *puVar6;
                puVar7[1] = uVar9;
                puVar7[2] = uVar10;
                puVar7[3] = uVar11;
                puVar6 = puVar6 + 4;
                puVar7 = puVar7 + 4;
              } while (puVar6 != puVar5);
            }

			// Make P2 the character that is saved in the
			// header of the ghost that you will see in the race
            DAT_80086e86 = *(undefined2 *)((int)DAT_8008d754 + 6);

			// no ghosts are drawing
            DAT_8008d740 = 0;

            return;
          }

		  if (sVar1 < 5)
		  {
			// If not "Quit"
            if (sVar1 != 3) {
              DAT_8008d52c = 0;
              DAT_8008d570 = 1;
              return;
            }

			// If "Quit"...

			// Erase ghost of previous race from RAM
            FUN_80028410();

			// go back to main menu
            DAT_8008d97c = 0;

			// load LEV of main menu
            FUN_8003cfc0(0x27);
            return;
          }

		  // Erase ghost of previous race from RAM
          FUN_80028410();

		  // go to character selection
          DAT_8008d97c = 1;
        }
        else
		{
		  // If not "Change Setup"
          if (sVar1 != 10)
		  {
            if (sVar1 < 0xb)
			{
			  // If not "Save Ghost"
              if (sVar1 != 9)
			  {
				// ???

                DAT_8008d52c = 0;
                DAT_8008d570 = 1;
                return;
              }

			  // If it is "Save Ghost"

              DAT_8008d52c = 0x3f9;

			  // Set Load/Save to Ghost mode
              FUN_80048e2c(0x31);

			  // Change active MenuBox to GhostSelection
              DAT_8008d924 = &DAT_80085bb4;
              return;
            }

			// If "Exit To Map" chosen
            if (sVar1 == 0xd)
			{
			  // when loading is done, add flag for "In Adventure Arena"
              DAT_8008d100 = DAT_8008d100 | 0x100000;

			  // when loading is done, remove flag for "CTR Challenge"
              DAT_8008d10c = DAT_8008d10c | 8;

			  // If you are in Adventure cup
              if ((*(uint *)PTR_DAT_8008d2ac & 0x10000000) != 0)
			  {
				// when loading is done, remove flags for
				// adventure cup, relic race, and crystal challenge
                DAT_8008d104 = DAT_8008d104 | 0x1c000000;

				// load Gemstone valley LEV
                FUN_8003cfc0(0x19);
                return;
              }

			  // when loading is done,
			  // remove relic race, and crystal challenge
              uVar3 = DAT_8008d104 | 0xc000000;

			  // If you're in a Boss Race
			  // 0x80000000
              if ((int)*(uint *)PTR_DAT_8008d2ac < 0)
			  {
			    // when loading is done,
			    // add flag to spawn near boss door
                DAT_8008d108 = DAT_8008d108 | 1;

			    // when loading is done, remove flags for
			    // boss race, relic race, and crystal challenge
				uVar3 = DAT_8008d104 | 0x8c000000;
              }

			  // set flags that you want removed after
			  // the loading is finished
              DAT_8008d104 = uVar3;

			  // Load LEV in Track Selection
              FUN_8003cfc0((int)*(short *)(PTR_DAT_8008d2ac + 0x1eb4));
              return;
            }

			// If not "Press X to continue"
			// how would that be in a menu?
            if (sVar1 != 0xc9) {
              DAT_8008d52c = 0;
              DAT_8008d570 = 1;
              return;
            }

            DAT_8008d4bc = DAT_8008d4bc | 1;
            DAT_8008d52c = 0;
            DAT_8008d570 = 1;
            return;
          }

		  // go to battle setup screen
          DAT_8008d97c = 3;
        }
      }

	  // when loading is done
	  // add flag for "in menus"
      DAT_8008d100 = DAT_8008d100 | 0x2000;

	  // load LEV of main menu
      FUN_8003cfc0(0x27);
    }
  }
  else {
    uVar8 = *(ushort *)(param_1 + 0x14) & 0xfeff;
    *(ushort *)(param_1 + 0x14) = uVar8;

	// if more than 2 screens
    if (2 < (byte)puVar2[0x1ca8]) {
      *(ushort *)(param_1 + 0x14) = uVar8 | 0x100;
    }
  }
  return;
}


// CupStandings_FinalizeCupRanks
void FUN_8005607c(void)

{
  undefined *puVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  int *piVar5;
  int iVar6;
  short sVar7;
  short sVar8;
  int iVar9;

  puVar1 = PTR_DAT_8008d2ac;
  iVar9 = -1;

  // number of screens + number of AIs
  uVar3 = (uint)(byte)PTR_DAT_8008d2ac[0x1ca8] + (uint)(byte)PTR_DAT_8008d2ac[0x1cab];
  sVar8 = 0;

  // if there are more than four drivers
  if (4 < uVar3) {
    uVar3 = 4;
  }

  iVar6 = 1;

  // if there is more than one driver
  if (1 < uVar3) {
    sVar8 = 0;
    do {
      iVar2 = iVar6 << 0x10;
      iVar6 = iVar6 + 1;

	  // something related to cup ranks
      if (*(int *)(PTR_DAT_8008d2ac + *(int *)((int)&DAT_80086d44 + (iVar2 >> 0xe)) * 4 + 0x1e60) !=
          *(int *)(PTR_DAT_8008d2ac + DAT_80086d44 * 4 + 0x1e60)) break;

      sVar8 = sVar8 + 1;
    } while (iVar6 * 0x10000 >> 0x10 < (int)uVar3);
  }

  iVar6 = 0;
  if (0 < (int)sVar8 + 1) {
    do {
      sVar7 = 99;
      iVar4 = (int)(short)iVar6;
      iVar2 = iVar6;
      while (iVar4 < (int)sVar8 + 1)
	  {
		// something related to cup rank, and driver->rank (track rank)
        if (*(short *)(*(int *)(puVar1 + *(int *)((int)&DAT_80086d44 + ((iVar2 << 0x10) >> 0xe))
										* 4 + 0x24ec) + 0x482) < sVar7)
		{
          iVar9 = iVar2;

		  // something related to cup rank, and driver->rank (track rank)
          sVar7 = *(short *)(*(int *)(puVar1 + *(int *)((int)&DAT_80086d44 +
										((iVar2 << 0x10) >> 0xe)) * 4 + 0x24ec) + 0x482);
        }
        iVar2 = iVar2 + 1;
        iVar4 = iVar2 * 0x10000 >> 0x10;
      }
      iVar2 = iVar6 << 0x10;
      iVar6 = iVar6 + 1;
      piVar5 = (int *)((int)&DAT_80086d44 + (iVar2 >> 0xe));
      sVar7 = *(short *)piVar5;
      *piVar5 = (int)(short)iVar9;

	  // set cup rank
      (&DAT_80086d44)[(int)(short)iVar9] = (int)sVar7;

    } while (iVar6 * 0x10000 >> 0x10 < (int)sVar8 + 1);
  }
  return;
}



void FUN_80056220(void)

{
  undefined *puVar1;
  int iVar2;
  uint uVar3;
  undefined *puVar4;
  uint uVar5;
  short sVar6;
  uint uVar7;
  int iVar8;
  short sVar9;

  puVar1 = PTR_DAT_8008d2ac;
  uVar5 = 0;

  //        number of AIs          +        number of screens
  iVar2 = (uint)(byte)PTR_DAT_8008d2ac[0x1cab] + (uint)(byte)PTR_DAT_8008d2ac[0x1ca8];

  // for(int iVar8 = 0; iVar8  < totalNumCharacters; iVar8++)
  // Draw all multiplayer icons???

  iVar8 = 0;
  if (iVar2 != 0) {
    do
	{
	  // set highest numPoints value to zero
      sVar9 = 0;

	  // set driver index of highest score to zero
      uVar7 = 0xffffffff;

      sVar6 = -1;
      uVar3 = iVar2 - 1;
      if (-1 < (int)uVar3) {
        puVar4 = puVar1 + uVar3 * 4;
        do {
          if (
				// if number of points held by this player
				// is more than the biggest number found yet
				((int)sVar9 <= *(int *)(puVar4 + 0x1e60)) &&
             (((int)(uVar5 & 0xff) >> (uVar3 & 0x1f) & 1U) == 0))
		  {
			// set new highest score found
            sVar9 = *(short *)(puVar4 + 0x1e60);

            if ((int)(short)uVar7 != 0xffffffff)
			{
              uVar5 = uVar5 & ~(1 << ((int)(short)uVar7 & 0x1fU));
            }
            uVar5 = uVar5 | 1 << (uVar3 & 0x1f);

			// set ID of driver with highest score
            uVar7 = uVar3;
          }

		  // copy ID of driver with highest score
          sVar6 = (short)uVar7;

          uVar3 = uVar3 - 1;
          puVar4 = puVar4 + -4;
        } while (-1 < (int)uVar3);
      }

	  // Update cup rank of each player
      (&DAT_80086d44)[iVar8] = (int)sVar6;

      iVar8 = iVar8 + 1;
    } while (iVar8 < iVar2);
  }
  return;
}


// CupStandings_UpdateAndDraw
void FUN_800562fc(void)

{
  short sVar1;
  ushort uVar2;
  bool bVar3;
  undefined *puVar4;
  short sVar5;
  int local_8c;
  uint uVar6;
  int local_90;
  short sVar7;
  uint uVar8;
  undefined4 uVar9;
  int iVar10;
  char *fmt;
  undefined *puVar11;
  int iVar12;
  int *piVar13;
  undefined4 uVar14;
  int iVar15;
  undefined4 *puVar16;
  int iVar17;
  short sVar18;
  ushort local_80;
  ushort local_7e;
  undefined2 local_7c;
  undefined2 local_7a;
  char acStack120 [8];
  char acStack112 [24];
  ushort local_58;
  ushort local_56;
  undefined4 local_50;
  undefined2 local_4c;
  undefined4 local_48;
  undefined2 local_44;
  undefined4 local_40;
  undefined2 local_3c;
  short local_38;
  short local_30;

  puVar4 = PTR_DAT_8008d2ac;

  // number of screens        +         number of AIs
  iVar17 = (uint)(byte)PTR_DAT_8008d2ac[0x1ca8] + (uint)(byte)PTR_DAT_8008d2ac[0x1cab];

  if (
		(
			// If you are in Arcade or VS cup
			((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x10) != 0) &&

			// if number of screens is not 1
			// if this is a multiplayer game
			(PTR_DAT_8008d2ac[0x1ca8] != 1)
		) &&

		(
			// CheckeredFlag_IsFullyOffScreen
			local_8c = FUN_80043f28(),
			local_8c == 1
		)
	)
  {
	// checkered flag, begin transition on-screen
    FUN_80043fb0(1);
  }

  // CheckeredFlag_IsFullyOnScreen
  local_8c = FUN_80043f1c();

  if (
		// if it is
		(local_8c != 0) &&

		// if number of screens is not 1
		// if this is a multiplayer game
		(PTR_DAT_8008d2ac[0x1ca8] != '\x01')
	  )
  {
	// enable checkered flag
    FUN_80044088(1);
  }

  // CheckeredFlag_IsFullyOnScreen
  local_8c = FUN_80043f1c();

  if (
		// if not
		(local_8c == 0) &&

		// if number of screens is not 1
		// if this is a multiplayer game
		(PTR_DAT_8008d2ac[0x1ca8] != '\x01')
	 )
  {
    return;
  }

  // CheckeredFlag_IsFullyOnScreen
  local_8c = FUN_80043f1c();

  puVar11 = PTR_DAT_8008d2ac;

  if (
		// if fully on screen
		(local_8c != 0) ||

		// If number of screens is 1
		(PTR_DAT_8008d2ac[0x1ca8] == '\x01')
	  )
  {
    // if flag is fully on screen, and this is multiplayer
    if (PTR_DAT_8008d2ac[0x1ca8] != '\x01')
	{
	  // disable loading screen,
	  // set amount of confetti to zero
      uVar6 = *(uint *)(PTR_DAT_8008d2ac + 0x256c);
      *(undefined2 *)(PTR_DAT_8008d2ac + 0x1b04) = 0;
      *(undefined2 *)(puVar11 + 0x1b06) = 0;
      *(uint *)(puVar11 + 0x256c) = uVar6 & 0x1000;
    }

    if ((DAT_8008d52c < 0xf0) || (((DAT_8008d4bc & 8) != 0 && (DAT_8008d52c < 400)))) {
      DAT_8008d52c = DAT_8008d52c + 1;
    }
  }

  if (
		(DAT_8008d52c < 0x3c) &&

		// If you press Cross or Circle
		((DAT_8008d950 & 0x50) != 0)
	 )
  {
    DAT_8008d52c = 0x3c;

	// Save the number of drivers
	//               number of screens                 +         number of AIs
    DAT_8008d570 = (ushort)(byte)PTR_DAT_8008d2ac[0x1ca8] + (ushort)(byte)PTR_DAT_8008d2ac[0x1cab];

	// clear controller input (for menus)
	FUN_80046404();
  }
  if ((DAT_8008d4bc & 4) == 0) {
    local_38 = -0x32;
    local_30 = 0x1e;
  }
  else {
    local_38 = 0x1e;
    local_30 = -0x32;
  }
  if (DAT_8008d52c < 0xf1) {
    uVar9 = 0xffffff6a;
    uVar14 = 0x100;
    local_90 = 0x1e;
    iVar12 = (int)local_38;
    local_8c = DAT_8008d52c;
  }
  else {
    uVar9 = 0x100;
    iVar12 = 0x1e;
    uVar14 = 0x296;
    local_90 = (int)local_30;
    local_8c = DAT_8008d52c + -0xf0;
  }

  // Interpolate variables from the previous "if-statement"
  FUN_8004ecd4(&local_58,uVar9,iVar12,uVar14,local_90,local_8c,0x14);

  if ((DAT_8008d4bc & 4) == 0) {
												// Level ID
    sVar18 = *(short *)(&DAT_80083a88 + *(int *)(PTR_DAT_8008d2ac + 0x1a10) * 0x18);
  }
  else
  {
	// If this is the last track in a cup
    if (*(int *)(PTR_DAT_8008d2ac + 0x1e5c) == 3)
	{
	  // DAT_8008d878 + 0x8b8
	  // FINAL
      uVar9 = *(undefined4 *)(DAT_8008d878 + 0x8b8);
      goto LAB_80056678;
    }

	// If you are not in Arcade or VS cup
    if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x10) == 0)
	{
	  // adv cup name LNG index
      puVar11 = &DAT_80084114;

	  // each is 8 bytes apart
      local_8c = *(int *)(PTR_DAT_8008d2ac + 0x1e58) << 3;
    }

	// If you are not in Arcade or VS cup
    else
	{
	  // arcade cup name LNG index
      puVar11 = &DAT_80084148;

	  // each is 0x12 (18) bytes apart
	  local_8c = *(int *)(PTR_DAT_8008d2ac + 0x1e58) * 0x12;
    }

	// get final lang index
    sVar18 = *(short *)(puVar11 + local_8c);
  }

  // get pointer to name from lng
  uVar9 = *(undefined4 *)((int)sVar18 * 4 + DAT_8008d878);

LAB_80056678:

  // title text
  FUN_80022878(uVar9,(int)(short)local_58,(int)(((uint)local_56 - 0x11) * 0x10000) >> 0x10,1,
               0xffff8000);

  // DAT_8008d878 + 0x328
  // STANDINGS
  FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x328),(int)(short)local_58,(int)(short)local_56,1,
               0xffff8000);

  // TRACK 1/4, 2/4, 3/4, 4/4
  sprintf(acStack112,"%s %ld/4",

			// DAT_8008d878 + 0x5d4
			// TRACK
			*(undefined4 *)(DAT_8008d878 + 0x5d4),

			// Track Index (0, 1, 2, 3) + 1
			*(int *)(PTR_DAT_8008d2ac + 0x1e5c) + 1);

  FUN_80022878(acStack112,(int)(short)local_58,(int)(((uint)local_56 + 0x11) * 0x10000) >> 0x10,2,
               0xffff8000);
  if ((DAT_8008d52c == (DAT_8008d52c / 10) * 10) && (DAT_8008d570 < iVar17)) {
    DAT_8008d570 = DAT_8008d570 + 1;
  }
  local_8c = 0;
  if (0 < DAT_8008d570) {
    local_90 = 0;
    sVar18 = 0;
    do {
      sVar5 = (short)local_8c;

	  // If you are in Purple Gem Cup
      if (*(int *)(PTR_DAT_8008d2ac + 0x1e58) == 4) {
        if (local_8c < 5) {
          uVar9 = 0x60;
          sVar7 = *(short *)(puVar4 + 0x13a4);
          sVar5 = (short)(((int)*(short *)(puVar4 + 0x13a8) + -0x20) / 5) * sVar5 + 0x10;
          goto LAB_800568d4;
        }
        sVar7 = 0;
        uVar9 = 0;
      }

	  // If this is not Purple Gem Cup
      else {

		//           number of screens      +       number of AIs
        // Basically, if you're in 2P Arcade
		if ((uint)(byte)PTR_DAT_8008d2ac[0x1ca8] + (uint)(byte)PTR_DAT_8008d2ac[0x1cab] == 6) {
          uVar9 = 0x42;
          if (local_8c < 3) {
            sVar7 = *(short *)(puVar4 + 0x13a4);
            sVar5 = (short)((int)*(short *)(puVar4 + 0x13a8) + -0x80 >> 2) * sVar5 + 0x20;
          }
          else {
            sVar1 = *(short *)(puVar4 + 0x13a8);
            sVar5 = sVar5 + -2;
LAB_800568b8:
            uVar9 = 0x79;
            sVar7 = *(short *)(puVar4 + 0x13a4);
            sVar5 = (short)((int)sVar1 + -0x80 >> 2) * sVar5 + 0x60;
          }
        }

		// If you are not in 2P Arcade
        else {

		  // If number of AIs is zero
          if (PTR_DAT_8008d2ac[0x1cab] == 0) {
            uVar9 = 0x6c;
            sVar7 = *(short *)(puVar4 + 0x13a4) +
                    (short)(((int)*(short *)(puVar4 + 0x13a8) + iVar17 * -0x5a + 0xc) / 2) + sVar18;
            goto LAB_800568d8;
          }
          uVar9 = 0x42;
          if (3 < local_8c) {
            sVar1 = *(short *)(puVar4 + 0x13a8);
            sVar5 = sVar5 + -4;
            goto LAB_800568b8;
          }
          sVar7 = *(short *)(puVar4 + 0x13a4);
          sVar5 = (short)((int)*(short *)(puVar4 + 0x13a8) + -0x80 >> 2) * sVar5 + 0x20;
        }
LAB_800568d4:
        sVar7 = sVar7 + sVar5;
      }
LAB_800568d8:
      if (DAT_8008d52c < 0xf1) {
        iVar10 = 0x296;
        iVar15 = (int)sVar7;
        iVar12 = DAT_8008d52c + (local_90 + local_8c) * -2;
      }
      else {
        iVar10 = (int)sVar7;
        iVar15 = -0x96;
        iVar12 = DAT_8008d52c + -0xf0;
      }

	  // Interpolate fly-in variables over 0x14 frames
      FUN_8004ecd4(&local_58,iVar10,uVar9,iVar15,uVar9,iVar12,0x14);

	  // DAT_8008d510
	  // %d
      sprintf(acStack120,&DAT_8008d510,local_8c + 1);

	  FUN_80022878(acStack120,(int)(((uint)local_58 + 0x20) * 0x10000) >> 0x10,
                   (int)(((uint)local_56 - 1) * 0x10000) >> 0x10,2,3);

	  // If this is the first screen of cup standings,
	  // where you see just amount of points added
	  if ((DAT_8008d4bc & 4) == 0)
	  {
		// get driver in order of race rank (for one track)
        iVar12 = *(int *)(PTR_DAT_8008d2ac + local_90 + 0x250c);
      }

	  // if this is not the first page,
	  // so now you see total points of drivers
	  else
	  {
		// get driver in order of cup rank (for collection of tracks)
        iVar12 = *(int *)(PTR_DAT_8008d2ac + *(int *)((int)&DAT_80086d44 + local_90) * 4 + 0x24ec);
      }

	  // Draw character icon
      FUN_8004e8d8(*(undefined4 *)
                    (PTR_DAT_8008d2ac +
                    ((int)((uint)*(ushort *)
                                  (&DAT_80086d8c +

								  // Player / AI structure + 0x4a shows driver index (0-7)

													// character ID
                                  (int)(short)(&DAT_80086e84)[*(byte *)(iVar12 + 0x4a)] * 0x10) <<
                          0x10) >> 0xe) + 0x1eec),(int)(short)local_58,(int)(short)local_56,

					// pointer to PrimMem struct
                   *(int *)(PTR_DAT_8008d2ac + 0x10) + 0x74,

				   // pointer to OT memory
                   *(undefined4 *)(PTR_DAT_8008d2ac + 0x147c),

				   1,0x1000,0x808080);

	  // If this is the first screen of cup standings,
	  // where you see just amount of points added
	  if ((DAT_8008d4bc & 4) == 0)
	  {
		// If number of AIs is zero
        if (PTR_DAT_8008d2ac[0x1cab] == '\0') {

		  // amount of points to add is based on how
		  // many players are in the race, and race position
						// number of screens - [unknown]
          iVar12 = (uint)(byte)PTR_DAT_8008d2ac[0x1ca8] - (local_8c + 1);
        }

		// if there are AIs
        else
		{
		  // amount of points to add is based on array
		  // 9, 6, 3, 1, 0, 0, 0, 0
          iVar12 = *(int *)((int)&DAT_80086d64 + local_90);
        }
        fmt = &DAT_8008d574;
      }

	  // if this is not the first page,
	  // so now you see total points of drivers
      else
	  {
		// The amount of points that each player has, in a cup
        iVar12 = *(int *)(PTR_DAT_8008d2ac + *(int *)((int)&DAT_80086d44 + local_90) * 4 + 0x1e60);

		// "%ld"
        fmt = &DAT_8008d520;
      }
      local_90 = local_90 + 4;

	  // make a string to draw, based on above variables
      sprintf(acStack120,fmt,iVar12);

	  sVar18 = sVar18 + 0x5a;

	  // draw string for number of points
      FUN_80022878(acStack120,(int)(((uint)local_58 + 0x2d) * 0x10000) >> 0x10,
                   (int)(((uint)local_56 + 6) * 0x10000) >> 0x10,1,1);

      local_8c = local_8c + 1;
    } while (local_8c < DAT_8008d570);
  }

  // If this is the first screen of cup standings,
  // where you see just amount of points added
  if ((DAT_8008d4bc & 4) == 0)
  {
	// fly-in interpolation
    FUN_8004ecd4(&local_58,0xfffffff6,(int)local_38,0xfffffff6,9,DAT_8008d52c,0x14);
  }

  // if it's not...
  else {
    if (DAT_8008d52c < 0xf1) {
      local_58 = 0xfff6;
      local_56 = 9;
    }
    else
	{
	  // fly-in interpolation
      FUN_8004ecd4(&local_58,0xfffffff6,9,0xfffffff6,(int)local_30,DAT_8008d52c + -0xf0,0x14);
    }
  }
  local_7c = 0x214;
  local_7a = 0x32;
  local_80 = local_58;
  local_7e = local_56;

  // Draw 2D Menu rectangle background
  FUN_800457b0(&local_80,4,*(undefined4 *)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0xa0));

  puVar4 = PTR_DAT_8008d2ac;

  // Timer
  if (DAT_8008d52c < 0x10f) {
    if (
			(
				// Timer
				(0x3b < DAT_8008d52c) &&

				// If you are not in overall Cup standings
				((DAT_8008d4bc & 8) == 0)
			) &&
			(
				// DAT_8008d878 + 0x324
				// PRESS * TO CONTINUE
				FUN_80022878(*(undefined4 *)(DAT_8008d878 + 0x324),0x100,0xbe,1,0xffff8000),

				// If you press Cross or Circle
				(DAT_8008d950 & 0x50) != 0)
			)
	{
	  // Timer
      DAT_8008d52c = 0xf0;

	  // Proceed from Track standings to overall Cup standings,
	  // where you see how many points each driver has overall
      DAT_8008d4bc = DAT_8008d4bc | 8;

	  // clear controller input (for menus)
      FUN_80046404();
    }
  }
  else {
    DAT_8008d570 = 1;
    DAT_8008d52c = 0;
    uVar6 = DAT_8008d4bc & 0xfffffff6;
    uVar8 = DAT_8008d4bc & 4;

	// Proceed from end-of-race menu to Track Standings,
	// where you see how many points are added just for this race
    DAT_8008d4bc = uVar6 | 4;

	// If the "4" flag was not enabled till just now,
	// If this is the first frame of Track Standings
    if (uVar8 == 0)
	{
	  // Add points awarded from Track Standings to Cup Standings

	  // If number of AIs is zero (VS cup)
      if (PTR_DAT_8008d2ac[0x1cab] == '\0')
	  {
		// Loop counter
        iVar17 = 0;

		// if number of screens != 0
        if (PTR_DAT_8008d2ac[0x1ca8] != '\0')
		{
          local_8c = 0;

		  // for iVar17 = 0; iVar17 < numScreens; iVar17++
          do
		  {
			// Increment Loop counter
			// iVar17 = rank... 1 for 1st place, 2 for 2nd, etc
            iVar17 = iVar17 + 1;

			// the amount of points this player has in the cup
            *(uint *)(puVar4 + (uint)*(byte *)(*(int *)(puVar4 + local_8c + 0x250c) + 0x4a) * 4 + 0x1e60) =
            *(uint *)(puVar4 + (uint)*(byte *)(*(int *)(puVar4 + local_8c + 0x250c) + 0x4a) * 4 + 0x1e60) +

			// Incremented by

			// numScreens - rank
			((uint)(byte)puVar4[0x1ca8] - iVar17);

            local_8c = iVar17 * 4;

          } while (iVar17 < (int)(uint)(byte)puVar4[0x1ca8]);
        }
      }

	  // If there are AIs (Arcade cup)
	  else
	  {
		// Loop counter
        iVar17 = 0;

		// Array of ints that holds the amount of
		// points that should be awarded for each position
		// {9, 6, 3, 1, 0, 0, 0, 0}
        piVar13 = &DAT_80086d64;

        puVar11 = PTR_DAT_8008d2ac;

		// wont break when you have 6 drivers
		// in 2P Arcade Cup

		// for iVar17 = 0; iVar17 < 8; iVar17++
        do
		{
		  // get value at this array index
          local_8c = *piVar13;

		  // increment int pointer, jump 4 bytes to next array index
          piVar13 = piVar13 + 1;

		  // increment loop counter
          iVar17 = iVar17 + 1;

		  // the amount of points this player has in the cup
          *(int *)(puVar4 + (uint)*(byte *)(*(int *)(puVar11 + 0x250c) + 0x4a) * 4 + 0x1e60) =
          *(int *)(puVar4 + (uint)*(byte *)(*(int *)(puVar11 + 0x250c) + 0x4a) * 4 + 0x1e60) +

		  // Incremented by

		  // The amount of points that should be awarded to each position
		  local_8c;

		  // increment pointer to next player
          puVar11 = puVar11 + 4;

        } while (iVar17 < 8);

      }

	  // update cup rank of all drivers
      FUN_80056220();
    }

	// If this is not the first frame of track standings
	else
	{
      DAT_8008d4bc = uVar6;

	  // enable drawing HUD
	  PTR_DAT_8008d2ac[0x1d31] = PTR_DAT_8008d2ac[0x1d31] | 1;

	  // Disable types of HUD that are not needed for gameplay,
	  // This includes Cup rankings, which is a flag in this byte
      PTR_DAT_8008d2ac[0x1d31] = PTR_DAT_8008d2ac[0x1d31] & 0xfb;

	  puVar4 = PTR_DAT_8008d2ac;
      DAT_8008d4bc = DAT_8008d4bc & 0xfffffffb;

	  // Increment Track Number by 1 (0-3 in the cup)
      iVar17 = *(int *)(PTR_DAT_8008d2ac + 0x1e5c) + 1;
      *(int *)(PTR_DAT_8008d2ac + 0x1e5c) = iVar17;

	  // If this is not the last race in the cup
      if (iVar17 < 4)
	  {
		// If this is an Adventure Cup
        if ((*(uint *)(puVar4 + 8) & 0x10) == 0)
		{
		  // Load the next LEV, given cup ID (0-3) and track index of cup (0-3)
          FUN_8003cfc0((int)*(short *)(&DAT_800840a4 + iVar17 * 4 + *(int *)(puVar4 + 0x1e58) * 0x10
                                      ));
        }

		// If this is not an Adventure Cup
        else
		{
		  // Load the next LEV, given cup ID (0-3) and track index of cup (0-3)
          FUN_8003cfc0((int)*(short *)(&DAT_8008414a + iVar17 * 4 + *(int *)(puVar4 + 0x1e58) * 0x12
                                      ));
        }
      }

	  // If this was the last race in the cup
	  // If the cup is over
      else {
        iVar17 = 0;

		// If this is an Adventure Cup
        if ((*(uint *)(puVar4 + 8) & 0x10) == 0)
		{
		  // Array with the ranking of each player
          piVar13 = &DAT_80086d44;

		  // Set Level ID
          *(int *)(puVar4 + 0x1a10) = *(int *)(puVar4 + 0x1e58) + 100;

		  // Set Track Index of Cup to 0, for the start of the next cup
          *(undefined4 *)(puVar4 + 0x1e5c) = 0;

		  // when loading is done,
		  // remove flag for adventure cup
          DAT_8008d104 = DAT_8008d104 | 0x10000000;

          puVar11 = puVar4;

		  // Loop through 8 drivers, clear all data for next cup

		  // for iVar17 = 0; iVar17 < 8; iVar17++
          do {

			// If driver is not nullptr
            if (*(int *)(puVar4 + *piVar13 * 4 + 0x24ec) != 0)
			{
			  // Set final ranking of each player
              *(undefined2 *)(*(int *)(puVar4 + *piVar13 * 4 + 0x24ec) + 0x482) = (short)iVar17;
            }

			// set driver's cup score to zero
            *(undefined4 *)(puVar11 + 0x1e60) = 0;

			// increment offset into cup rankings array
			puVar11 = puVar11 + 4;

			// increment loop counter
            iVar17 = iVar17 + 1;

			// increment offset into player array
            piVar13 = piVar13 + 1;

		  } while (iVar17 < 8);

		  // Tawna_Init
          FUN_80041c84(PTR_DAT_8008d2ac);

          puVar4 = PTR_DAT_8008d2ac;

		  // If player 1 won the cup
          if (DAT_80086d44 == (uint)*(byte *)(*(int *)(PTR_DAT_8008d2ac + 0x24ec) + 0x4a))
		  {
			// bit offst 0x6a is where the gems start in the bits of Adventure Progress

			// If this cup has never been beaten before (if you dont have the gem)
			// 0x8fba4 is where the adventure profile (currently loaded) begins
            if (((uint)(&DAT_8008fba4)[(int)(*(int *)(PTR_DAT_8008d2ac + 0x1e58) + 0x6aU) >> 5] >>
                 (*(int *)(PTR_DAT_8008d2ac + 0x1e58) + 0x6aU & 0x1f) & 1) == 0)
			{
			  // Set podium reward model to Gem
              *(undefined2 *)(PTR_DAT_8008d2ac + 0x2572) = 0x5f;

			  // bit offset of non-adventure progress to unlock character,
			  // plus cupID
              uVar6 = *(int *)(puVar4 + 0x1e58) + 7;

			  // get index of integer array for this bit
			  iVar17 = (int)uVar6 >> 5;

			  // 4 bytes of rewards (characters + tracks)
			  // This unlocks Roo, Papu, Joe, Pinstripe, or Fake Crash
              (&DAT_8008e6ec)[iVar17] = (&DAT_8008e6ec)[iVar17] | 1 << (uVar6 & 0x1f);

			  // bit offset of adventure progress to unlock gem
			  // plus cupID
              uVar6 = *(int *)(puVar4 + 0x1e58) + 0x6a;

			  // 0x8fba4 is where the adventure profile (currently loaded) begins
			  // Unlocks one of the gems
              (&DAT_8008fba4)[(int)uVar6 >> 5] =
                   (&DAT_8008fba4)[(int)uVar6 >> 5] | 1 << (uVar6 & 0x1f);
            }

									// track index 0,1,2,3
			// reset counter for number of times you lost cup, to zero
            (&DAT_8008fbe6)[*(int *)(PTR_DAT_8008d2ac + 0x1e5c)] = 0;
          }

		  // If player 1 did not win the cup
          else
		  {
								// track index 0,1,2,3
            iVar17 = *(int *)(PTR_DAT_8008d2ac + 0x1e5c);

			// if you lost the cup less than 10 times
            if ((char)(&DAT_8008fbe6)[iVar17] < '\n')
			{
			  // increase number of times you lost the cup
              (&DAT_8008fbe6)[iVar17] = (&DAT_8008fbe6)[iVar17] + '\x01';
            }
          }

		  // Level ID for Gemstone Valley (podiums)
          FUN_8003cfc0(0x19);
        }

		// If this is not an Adventure Cup
		else
		{
		  // Set Track Index of Cup to 0, for the start of the next cup
          *(undefined4 *)(puVar4 + 0x1e5c) = 0;

		  // CupStandings_FinalizeCupRanks
          FUN_8005607c();

          puVar4 = PTR_DAT_8008d2ac;
          iVar17 = 0;

		  // Array with the final ranking of each player
          piVar13 = &DAT_80086d44;

          puVar11 = PTR_DAT_8008d2ac;

		  // for iVar17 = 0; iVar17 < 8; iVar17++
          do
		  {
			// If driver is not nullptr
            if (*(int *)(puVar4 + *piVar13 * 4 + 0x24ec) != 0)
			{
				// Set final ranking of each player
              *(undefined2 *)(*(int *)(puVar4 + *piVar13 * 4 + 0x24ec) + 0x482) = (short)iVar17;
            }

			// set driver's cup score to zero
            *(undefined4 *)(puVar11 + 0x1e60) = 0;

			// increment offset into cup rankings array
            puVar11 = puVar11 + 4;

			// increment loop counter
            iVar17 = iVar17 + 1;

			// increment offset into player array
            piVar13 = piVar13 + 1;

          } while (iVar17 < 8);

		  // Tawna_Init
          FUN_80041c84(PTR_DAT_8008d2ac);

          puVar4 = PTR_DAT_8008d2ac;

		  // If Player 1 or Player 2 won the cup
          if (((*(short *)(*(int *)(PTR_DAT_8008d2ac + 0x24ec) + 0x482) == 0) ||
              (*(short *)(*(int *)(PTR_DAT_8008d2ac + 0x24f0) + 0x482) == 0)) &&

			 // If you're in Arcade Mode
             ((*(uint *)PTR_DAT_8008d2ac & 0x400000) != 0))
		  {
			// If P1 or P2 lost the cup, or if this was VS mode,
			// then nothing would unlock

			// You deserve to have something unlocked.
            bVar3 = true;

			// If Arcade difficulty is "Easy"
            if (*(int *)(PTR_DAT_8008d2ac + 0x1ebc) == 0x50)
			{
              iVar17 = 0;
            }

			// if difficulty is not easy
            else
			{
			  // If Arcade difficulty is "Hard"
              iVar17 = 2;

			  // If Arcade difficulty is "Medium"
              if (*(int *)(PTR_DAT_8008d2ac + 0x1ebc) == 0xa0) {
                iVar17 = 1;
              }
            }

			// Bit index of cup completion (curr),
			// one index per difficulty
			// [0] (easy) = 0xC
			// [1] (medium) = 0x10
			// [2] (hard) = 0x14
            local_50 = DAT_8008d578;
            local_4c = DAT_8008d57c;

			// Bit index of cup completion (prev),
			// one index per difficulty
			// [0] (easy) = 0xC
			// [1] (medium) = 0x10
			// [2] (hard) = 0x14
            local_48 = DAT_8008d580;
            local_44 = DAT_8008d584;

			// Bit index of Battle Track Unlock
			// [0] (easy) = 0xC
			// [1] (medium) = 0x10
			// [2] (hard) = 0x14
            local_40 = DAT_8008d588;
            local_3c = DAT_8008d58c;

			// get base index
            puVar16 = (undefined4 *)((int)&local_50 + iVar17 * 2);

			// add cupID to bit
			uVar6 = (int)*(short *)puVar16 + *(int *)(PTR_DAT_8008d2ac + 0x1e58);

			// byte index
			local_8c = (int)uVar6 >> 5;

			// Save record that this cup, on this difficulty, was won
            (&DAT_8008e6ec)[local_8c] = (&DAT_8008e6ec)[local_8c] | 1 << (uVar6 & 0x1f);

			// bit index of cup completion on this difficulty (prior to now)
            uVar6 = (int)*(short *)((int)&local_48 + iVar17 * 2) + *(int *)(puVar4 + 0x1e58);

			// If this cup was not previuosly beaten on this difficulty,
			// and this is the first time the cup was won
            if (((uint)(&DAT_8008e6ec)[(int)uVar6 >> 5] >> (uVar6 & 0x1f) & 1) == 0)
			{
			  // loop counter
              local_8c = 0;

			  // gGT->0x8 | 0x1000,
			  // lets 233 know to prompt the Save Game box
              *(uint *)(puVar4 + 8) = *(uint *)(puVar4 + 8) | 0x1000;

              puVar4 = PTR_DAT_8008d2ac;

			  // bit index of cup completion (curr)
              uVar8 = SEXT24(*(short *)puVar16);
              uVar6 = uVar8;

			  // loop through all 4 cups to see if they've all
			  // been beaten on the current cup difficulty

			  // for local_8c = 0; local_8c < 4; local_8c++
              do
			  {
				// increment loop counter
                local_8c = local_8c + 1;

			    // if any of four cups on this difficulty was not won
                if (((uint)(&DAT_8008e6ec)[(int)uVar6 >> 5] >> (uVar6 & 0x1f) & 1) == 0)
				{
				  // you dont deserve to unlock a battle map
                  bVar3 = false;
                  break;
                }
                uVar6 = uVar8 + local_8c;
              } while (local_8c < 4);

			  // If P1 or P2 won an Arcade Cup, and if you haven't unlocked
			  // a battle map for this difficulty, and if you've beaten all
			  // four Arcade cups on this difficulty
              if (bVar3)
			  {
				// Get bit index of battle map unlock
                uVar2 = *(ushort *)((int)&local_40 + iVar17 * 2);
                iVar17 = (int)((uint)uVar2 << 0x10) >> 0x15;

			    // Unlock a Battle Map (Parking Lot, North Bowl, Parking Lot)
                (&DAT_8008e6ec)[iVar17] = (&DAT_8008e6ec)[iVar17] | 1 << (uVar2 & 0x1f);

				// gGT -> 0x8 | 0x2000
				// battle map is now unlocked (233 overlay)
                *(uint *)(puVar4 + 8) = *(uint *)(puVar4 + 8) | 0x2000;
              }
            }
          }

		  // Set podium's reward model to "Empty"
          *(undefined2 *)(PTR_DAT_8008d2ac + 0x2572) = 0x38;

		  // Level ID for Gemstone Valley (podiums)
          FUN_8003cfc0(0x19);
        }
      }
    }
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

// SpecularLight_Spinning2D
// instance, ptr rot[6], cop registers
void FUN_800572d0(int param_1,undefined4 param_2,SVECTOR *param_3)

{
  undefined *puVar1;
  int iVar2;
  undefined4 uVar3;
  undefined *puVar4;
  undefined auStack104 [16];
  undefined auStack88 [72];

  puVar4 = auStack104;

  // ConvertRotToMatrix_Transpose
  FUN_8006c378(auStack88, param_2);

  gte_ldv0(param_3);
  gte_rtv0();
  uVar3 = gte_stMAC1();
  *(undefined4 *)(puVar4 + 0x30) = uVar3;
  uVar3 = gte_stMAC2();
  *(undefined4 *)(puVar4 + 0x34) = uVar3;
  uVar3 = gte_stMAC3();
  *(undefined4 *)(puVar4 + 0x38) = uVar3;
  *(undefined *)(param_1 + 0x53) = puVar4[0x30];
  *(undefined4 *)(param_1 + 0x58) = *(undefined4 *)(puVar4 + 0x38);
  *(undefined2 *)(puVar4 + 0x50) = 0;
  *(undefined2 *)(puVar4 + 0x52) = 0;
  *(undefined2 *)(puVar4 + 0x54) = 0x1000;
  gte_ldv0((SVECTOR *)(puVar4 + 0x50));
  gte_rtv0();
  uVar3 = gte_stMAC1();
  *(undefined4 *)(puVar4 + 0x40) = uVar3;
  uVar3 = gte_stMAC2();
  *(undefined4 *)(puVar4 + 0x44) = uVar3;
  uVar3 = gte_stMAC3();
  *(undefined4 *)(puVar4 + 0x48) = uVar3;
  *(short *)(puVar4 + 0x50) = *(short *)(puVar4 + 0x30) + *(short *)(puVar4 + 0x40);
  *(short *)(puVar4 + 0x52) = *(short *)(puVar4 + 0x34) + *(short *)(puVar4 + 0x44);
  *(short *)(puVar4 + 0x54) = *(short *)(puVar4 + 0x38) + *(short *)(puVar4 + 0x48);

  // MATH_VectorNormalize
  FUN_8003d378();

  puVar1 = PTR_DAT_8008d2ac;
  iVar2 = 0;

  // if number of screens != 0
  if (PTR_DAT_8008d2ac[0x1ca8] != '\0')
  {
	// each InstDrawPerPlayer
	// for iVar2 = 0; iVar2 < numScreens; iVar2++
    do 
	{
	  // write specular values,
	  // increment loop index
      *(undefined2 *)(param_1 + 0xf4) = *(undefined2 *)(puVar4 + 0x50);
      *(undefined2 *)(param_1 + 0xf6) = *(undefined2 *)(puVar4 + 0x52);
      iVar2 = iVar2 + 1;
      *(undefined2 *)(param_1 + 0xf8) = *(undefined2 *)(puVar4 + 0x54);
	
	  // next InstDrawPerPlayer
      param_1 = param_1 + 0x88;
    
	} while (iVar2 < (int)(uint)(byte)puVar1[0x1ca8]);
  }
  return;
}


// WARNING: Could not reconcile some variable overlaps


// SpecularLight_Spinning3D
// param_1 MATRIX
// param_2 vec3s rotation
void FUN_8005741c(int param_1,undefined4 param_2,SVECTOR *param_3)

{
  short *psVar1;
  undefined4 uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  SVECTOR *r0;
  MATRIX *r0_00;
  undefined *puVar8;
  undefined auStack136 [16];
  MATRIX aMStack120 [2];
  SVECTOR local_38 [2];
  undefined *puVar2;

  puVar8 = auStack136;

  // ConvertRotToMatrix_Transpose
  FUN_8006c378(aMStack120, param_2);

  iVar4 = 0;

  // if number of screens is not zero
  if (PTR_DAT_8008d2ac[0x1ca8] != '\0')
  {
    r0_00 = aMStack120;
    r0 = local_38;

	// offset of 8008d2ac for camera110 buffers
	iVar7 = 0x168;

	// offset in camera110 buffer array (0 for p1, 0x110 for p2, etc)
    iVar6 = 0;

    puVar2 = PTR_DAT_8008d2ac;
    iVar5 = param_1;

	// for iVar6 = 0; iVar6 < numScreens; iVar6++
    do
	{
	  // pointer to start of camera110 buffer array
      psVar1 = (short *)(puVar2 + iVar7);

	  // Genius idea from Naughty Dog:
	  // Transpose-View + Vec3-Inverted = Inverse-Transpose-View + Vec3.

	  // camera110 offset 0x68, CameraMatrix
      gte_SetLightMatrix((MATRIX *)((int)psVar1 + iVar6 + 0x68));

	  // param_3 = inverted specular light vector 
      gte_ldv0(param_3);
	  
      gte_llv0();
	  
	  // generate stack-matrix from result
      uVar3 = gte_stMAC1();
      *(undefined4 *)(puVar8 + 0x30) = uVar3;
      uVar3 = gte_stMAC2();
      *(undefined4 *)(puVar8 + 0x34) = uVar3;
      uVar3 = gte_stMAC3();
      *(undefined4 *)(puVar8 + 0x38) = uVar3;
      *(undefined2 *)(puVar8 + 0x58) = *(undefined2 *)(puVar8 + 0x30);
      *(undefined2 *)(puVar8 + 0x5a) = *(undefined2 *)(puVar8 + 0x34);
      *(undefined2 *)(puVar8 + 0x5c) = *(undefined2 *)(puVar8 + 0x38);

	  gte_SetLightMatrix(r0_00);

	  gte_ldv0((SVECTOR *)(puVar8 + 0x58));
      gte_llv0();
      uVar3 = gte_stMAC1();
      *(undefined4 *)(puVar8 + 0x30) = uVar3;
      uVar3 = gte_stMAC2();
      *(undefined4 *)(puVar8 + 0x34) = uVar3;
      uVar3 = gte_stMAC3();
      *(undefined4 *)(puVar8 + 0x38) = uVar3;
      *(undefined *)(iVar5 + 0x53) = puVar8[0x30];
      *(uint *)(iVar5 + 0x58) = (uint)*(ushort *)(puVar8 + 0x38);
      *(short *)(puVar8 + 0x50) = *(short *)(iVar5 + 0x44) - *psVar1;
      *(short *)(puVar8 + 0x52) = *(short *)(iVar5 + 0x48) - psVar1[1];
      *(short *)(puVar8 + 0x54) = *(short *)(iVar5 + 0x4c) - psVar1[2];

	  // MATH_VectorNormalize
	  FUN_8003d378(r0);

      gte_SetLightMatrix(r0_00);

	  gte_ldv0(r0);
      gte_llv0();
      uVar3 = gte_stMAC1();
      *(undefined4 *)(puVar8 + 0x40) = uVar3;
      uVar3 = gte_stMAC2();
      *(undefined4 *)(puVar8 + 0x44) = uVar3;
      uVar3 = gte_stMAC3();
      *(undefined4 *)(puVar8 + 0x48) = uVar3;
      *(short *)(puVar8 + 0x50) = *(short *)(puVar8 + 0x30) + *(short *)(puVar8 + 0x40);
      *(short *)(puVar8 + 0x52) = *(short *)(puVar8 + 0x34) + *(short *)(puVar8 + 0x44);
      *(short *)(puVar8 + 0x54) = *(short *)(puVar8 + 0x38) + *(short *)(puVar8 + 0x48);

	  // MATH_VectorNormalize
	  FUN_8003d378(r0);

      puVar2 = PTR_DAT_8008d2ac;

	  // next camera110
	  iVar7 = iVar7 + 0x110;

	  *(undefined2 *)(param_1 + 0xf4) = *(undefined2 *)(puVar8 + 0x50);

	  // next camera110
	  iVar6 = iVar6 + 0x110;

      *(undefined2 *)(param_1 + 0xf6) = *(undefined2 *)(puVar8 + 0x52);

	  // next loop index
	  iVar4 = iVar4 + 1;

	  *(undefined2 *)(param_1 + 0xf8) = *(undefined2 *)(puVar8 + 0x54);
	
	  // next InstDrawPerPlayer
      param_1 = param_1 + 0x88;
    
	} while (iVar4 < (int)(uint)(byte)puVar2[0x1ca8]);
  }
  return;
}


// SpecularLight_Motionless3D
// used on flamejet
// param_1 - instance
// param_2 - inst->instDef->rot[3]
// param_3 - specLightDir
void FUN_800576b8(int param_1,undefined4 param_2,SVECTOR *param_3)

{
  short *psVar1;
  undefined4 uVar3;
  int iVar4;
  int iVar5;
  SVECTOR *r0;
  int iVar6;
  undefined *puVar7;
  undefined auStack112 [16];
  MATRIX aMStack96 [2];
  undefined *puVar2;

  puVar7 = auStack112;

  // ConvertRotToMatrix_Transpose
  FUN_8006c378(aMStack96, param_2);

  gte_SetLightMatrix(aMStack96);
  gte_ldv0(param_3);
  gte_llv0();
  uVar3 = gte_stMAC1();
  *(undefined4 *)(puVar7 + 0x30) = uVar3;
  uVar3 = gte_stMAC2();
  *(undefined4 *)(puVar7 + 0x34) = uVar3;
  uVar3 = gte_stMAC3();
  *(undefined4 *)(puVar7 + 0x38) = uVar3;
  *(undefined *)(param_1 + 0x53) = puVar7[0x30];
  puVar2 = PTR_DAT_8008d2ac;
  *(uint *)(param_1 + 0x58) = (uint)*(ushort *)(puVar7 + 0x38);
  iVar4 = 0;

  // if number of screens is not zero
  if (puVar2[0x1ca8] != '\0')
  {
    r0 = (SVECTOR *)(puVar7 + 0x50);
    iVar5 = 0x168;
    iVar6 = param_1;

	// for iVar3 = 0; iVar3 < numScreens; iVar3++
    do
	{
	  // pointer to camera110 buffer
      psVar1 = (short *)(puVar2 + iVar5);

	  // direction vector from object to camera
      *(short *)(puVar7 + 0x50) = *(short *)(iVar6 + 0x44) - *psVar1;
      *(short *)(puVar7 + 0x52) = *(short *)(iVar6 + 0x48) - psVar1[1];
      *(short *)(puVar7 + 0x54) = *(short *)(iVar6 + 0x4c) - psVar1[2];

	  // MATH_VectorNormalize
      FUN_8003d378(r0);

      gte_ldv0(r0);
      gte_llv0();
      uVar3 = gte_stMAC1();
      *(undefined4 *)(puVar7 + 0x40) = uVar3;
      uVar3 = gte_stMAC2();
      *(undefined4 *)(puVar7 + 0x44) = uVar3;
      uVar3 = gte_stMAC3();
      *(undefined4 *)(puVar7 + 0x48) = uVar3;

	  // ???
      *(short *)(puVar7 + 0x50) = *(short *)(puVar7 + 0x30) + *(short *)(puVar7 + 0x40);
      *(short *)(puVar7 + 0x52) = *(short *)(puVar7 + 0x34) + *(short *)(puVar7 + 0x44);
      *(short *)(puVar7 + 0x54) = *(short *)(puVar7 + 0x38) + *(short *)(puVar7 + 0x48);

	  // MATH_VectorNormalize
	  FUN_8003d378(r0);

      puVar2 = PTR_DAT_8008d2ac;
      *(undefined2 *)(param_1 + 0xf4) = *(undefined2 *)(puVar7 + 0x50);

	  // increment offset to next camera110 buffer
	  iVar5 = iVar5 + 0x110;

	  *(undefined2 *)(param_1 + 0xf6) = *(undefined2 *)(puVar7 + 0x52);

	  // loop index
      iVar4 = iVar4 + 1;

      *(undefined2 *)(param_1 + 0xf8) = *(undefined2 *)(puVar7 + 0x54);

	  // next InstDrawPerPlayer
	  param_1 = param_1 + 0x88;

	} while (iVar4 < (int)(uint)(byte)puVar2[0x1ca8]);
  }
  return;
}


// BakeMathGTE
// called once during init, not related to spec light,
// NOP will distort the following driver animations into squishing:
// crashing, boosting, jumping, blasted
void FUN_80057884(undefined *param_1)

{
  int iVar1;
  MATRIX *r0;
  undefined *puVar2;
  VECTOR *r0_00;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  int iVar6;
  undefined **ppuVar7;
  undefined2 *puVar8;
  int iVar9;
  int *piVar10;
  int iVar11;
  uint uVar12;
  undefined *puVar13;
  undefined auStack128 [16];
  uint local_70;
  undefined4 local_6c;
  uint local_68;
  undefined4 local_64;
  undefined2 local_60;
  undefined auStack80 [32];
  VECTOR local_30;

  puVar13 = auStack128;

  // DAT_80087f28 is a constant for how many frames are in "blasted" anim

  // if function has not run
  if (DAT_8008d590 == '\0')
  {
	// remember the function has run
    DAT_8008d590 = '\x01';

    iVar11 = 0;

	// if blasted frame count exists
    if (0 < DAT_80087f28)
	{

	  iVar9 = 0;

	  do
	  {
        puVar2 = PTR_DAT_80087f24;

		iVar6 = iVar11 << 0xd;

		// fail-safe to alert debugger
        if (DAT_80087f28 == 0) trap(0x1c00);
        if ((DAT_80087f28 == -1) && (iVar6 == -0x80000000)) trap(0x1800);

        *(short *)(PTR_DAT_80087f24 + iVar11 * 0x20 + 0xc) = (short)(iVar6 / DAT_80087f28);

		// fail-safe to alert debugger
		if (DAT_80087f28 == 0) trap(0x1c00);
        if ((DAT_80087f28 == -1) && (iVar9 == -0x80000000)) trap(0x1800);

        iVar1 = FUN_8003d184(iVar9 / DAT_80087f28);
        *(short *)(puVar2 + iVar11 * 0x20 + 8) = (short)(-iVar1 / 7);

		// fail-safe to alert debugger
        if (DAT_80087f28 == 0) trap(0x1c00);
        if ((DAT_80087f28 == -1) && (iVar6 == -0x80000000)) trap(0x1800);

        iVar1 = FUN_8003d184(iVar6 / DAT_80087f28);
        *(short *)(puVar2 + iVar11 * 0x20 + 0x10) = (short)((iVar1 * 6) / 0x28) + 0x1000;

		// fail-safe to alert debugger
        if (DAT_80087f28 == 0) trap(0x1c00);
        if ((DAT_80087f28 == -1) && (iVar6 == -0x80000000)) trap(0x1800);

        iVar1 = FUN_8003d184(iVar6 / DAT_80087f28);
        *(short *)(puVar2 + iVar11 * 0x20 + 0x14) = (short)((iVar1 * 6) / 0x28) + 0x1000;
        param_1 = (undefined *)(iVar6 / DAT_80087f28);

		// fail-safe to alert debugger
        if (DAT_80087f28 == 0) trap(0x1c00);
        if ((DAT_80087f28 == -1) && (iVar6 == -0x80000000)) trap(0x1800);

        iVar6 = FUN_8003d184(param_1);

        if (iVar6 < 0) {
          iVar6 = iVar6 + 3;
        }

		*(short *)(puVar2 + iVar11 * 0x20 + 0x10) = (short)(iVar6 >> 2) + 0x1000;

		// next index
		iVar11 = iVar11 + 1;

        iVar9 = iVar9 + 0x3000;

      } while (iVar11 < DAT_80087f28);
    }

    uVar12 = 0;

	// start of pointer table
	piVar10 = &DAT_80087ef4;

    local_70 = 0;
    local_6c = 0;
    local_68 = 0;
    local_64 = 0;
    local_60 = 0;
    do {
      if (((piVar10[1] != 0) && (*piVar10 != 0)) && (iVar11 = 0, 0 < piVar10[1])) {
        do {
          iVar9 = *piVar10 + iVar11 * 0x20;

		   // convert 3 rotation shorts into rotation matrix
          FUN_8006c2a4(auStack80,iVar9 + 8);

          local_70 = local_70 & 0xffff0000 | (uint)*(ushort *)(iVar9 + 0x10);
          local_68 = local_68 & 0xffff0000 | (uint)*(ushort *)(iVar9 + 0x12);
          local_60 = *(undefined2 *)(iVar9 + 0x14);
          FUN_8006c3b0(iVar9 + 8,&local_70,auStack80);
          iVar11 = iVar11 + 1;
          param_1 = auStack80;
        } while (iVar11 < piVar10[1]);
      }
      uVar12 = uVar12 + 1;
      piVar10 = piVar10 + 2;
    } while (uVar12 < 0x14);
    ppuVar7 = &PTR_DAT_80087f24;
    iVar11 = 0;
    if (0 < DAT_80087f28) {
      uVar5 = 0x2000;
      r0_00 = &local_30;
      uVar4 = 0xe0000000;
      uVar3 = 0;
      do {
        puVar2 = *ppuVar7;
        *(undefined4 *)(puVar13 + 0x50) = 0;
        *(undefined4 *)(puVar13 + 0x54) = uVar5;
        *(undefined4 *)(puVar13 + 0x58) = 0;
        puVar8 = (undefined2 *)(puVar2 + iVar11 * 0x20);
        r0 = (MATRIX *)(puVar8 + 4);
        gte_SetRotMatrix(r0);
        gte_SetTransVector(r0_00);
        gte_ldVXY0(uVar4);
        gte_ldVZ0(uVar3);
        gte_rt();
        read_mt(r0,puVar2,param_1);
        *puVar8 = (short)r0;
        puVar8[1] = (short)puVar2;
        puVar8[2] = (short)param_1;
        iVar11 = iVar11 + 1;
      } while (iVar11 < (int)ppuVar7[1]);
    }
  }
  return;
}


// get pointer to Scrub MetaData
int FUN_80057c44(uint param_1)

{
  int iVar1;

  iVar1 = param_1 << 4;
  if (6 < param_1) {
    iVar1 = 0;
  }
  return (int)&PTR_s_SOLID_80087f94 + iVar1;
}


// get pointer to terrain MetaData
int FUN_80057c68(uint param_1)

{
  int iVar1;

  iVar1 = param_1 << 6;
  if (0x14 < param_1) {
    iVar1 = 0;
  }
  return (int)&PTR_s_asphalt_800884cc + iVar1;
}


// Driver_TeleportSelf
void FUN_80057c8c(int param_1,uint param_2,int param_3)

{
  byte bVar1;
  short sVar2;
  bool bVar3;
  undefined *puVar4;
  undefined uVar5;
  undefined2 uVar6;
  undefined4 uVar7;
  code *pcVar8;
  int iVar9;
  undefined *puVar10;
  uint uVar11;
  int *piVar12;
  ushort uVar13;
  int iVar14;
  int *piVar15;
  undefined2 *puVar16;
  short local_40;
  short local_3e;
  short local_3c;
  short local_38;
  short local_36;
  short local_34;
  short local_30;
  short local_2e;
  short local_2c;

  puVar4 = PTR_DAT_8008d2ac;
  puVar16 = (undefined2 *)0x0;
  bVar3 = false;
  
  // by default, dont spawn by a hub door
  piVar15 = (int *)0x0;

  // Check LEV data for nullptr
  if (*(int **)(PTR_DAT_8008d2ac + 0x160) == (int *)0x0) {
    return;
  }
  if (**(int **)(PTR_DAT_8008d2ac + 0x160) == 0) {
    return;
  }

  // ground and wall quadblock flags
  DAT_1f80012c = 0x3000;

  DAT_1f800130 = 0;
  
  // low-LOD collision (2 triangles)
  DAT_1f80012a = 0;

  // if number of screens is less than 3
  if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 3) 
  {
	// high-LOD collision (8 triangles)
    DAT_1f80012a = 2;
  }
  
  DAT_1f800134 = **(undefined4 **)(PTR_DAT_8008d2ac + 0x160);
  *(uint *)(PTR_DAT_8008d2ac + 8) = *(uint *)(PTR_DAT_8008d2ac + 8) & 0xffffbfff;
  puVar10 = PTR_DAT_8008d2ac;

  // if you are mask grabbed
  if ((param_2 & 1) == 0)
  {
	// Ordinary player position
    local_38 = (short)((uint)*(undefined4 *)(param_1 + 0x2d4) >> 8);
    local_36 = (short)((uint)*(undefined4 *)(param_1 + 0x2d8) >> 8) + 0x80;
    local_34 = (short)((uint)*(undefined4 *)(param_1 + 0x2dc) >> 8);
  }

  // if you are spawning into the world for the first time,
  // could be startline, or adv hub spawn in several places
  else
  {
	// spawn in front of hub door, beach-to-gemstone
    if (
			// If you are at podium after winning a Key
			(*(short *)(puVar4 + 0x2572) == 99) &&

			// If you have one boss key
			(*(int *)(puVar4 + 0x1e38) == 1)
		)
	{
      // lev number instDef
	  iVar9 = *(int *)(*(int *)(puVar4 + 0x160) + 0xc);
	  
	  // lev instDefs
      piVar15 = *(int **)(*(int *)(puVar4 + 0x160) + 0x10);
      
	  iVar14 = 0;
	  
	  // if there are instDefs
      if (0 < iVar9) 
	  {
		// waste of addition
        piVar12 = piVar15 + 3;
        
		// loop through instDefs
		do 
		{
		  // if door is found
          if (
				(
					(
						// InstDef+0xC+0xC (modelID) == 0x7a (STATIC_DOOR)
						(*(short *)(piVar12 + 0xc) == 0x7a) && 
						
						// if name == "door"
						(*piVar15 == 0x726f6f64)
					) &&
              
					// InstDef+0xC-0x8 (name) == "#5"
					(piVar12[-2] == 0x3523)
				) && 
				
				// last 8 bytes of 16-byte name, all zeros
				((piVar12[-1] == 0 && (*piVar12 == 0)))
			 
			 // then leave loop
			 ) break;
			  
		  // next InstDef
          piVar12 = piVar12 + 0x10;
          
		  // loop counter
		  iVar14 = iVar14 + 1;
		  
		  // next InstDef (0x10*4)
          piVar15 = piVar15 + 0x10;
        
		} while (iVar14 < iVar9);
		
		// if the hub door was found, because not all instDefs were checked, then go to spawn
        if (iVar14 < *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0xc)) goto code_r0x80057f18;
      }
	  
	  // no InstDef found with "door" title,
	  // so spawn outside boss door instead
      piVar15 = (int *)0x0;
    }

	// If you not at hub-door after beating Roo
    else
	{
	  // if you are at podium for winning a trophy
      if (*(short *)(PTR_DAT_8008d2ac + 0x2572) == 0x62)
	  {
		// By default, you have all 4 trophies on a hub,
		// but we are about to determine if that's true
        bVar3 = true;

		// loop counter
        iVar14 = 0;
								// Level ID
        iVar9 = (*(int *)(PTR_DAT_8008d2ac + 0x1a10) + -0x1a) * 8;

		// for iVar14 = 0; iVar14 < 4; iVar14++
		do
		{
		  // increment loop counter
          iVar14 = iVar14 + 1;

		  // 0x8fba4 is where the adventure profile (currently loaded) begins

		  // if you do not have a trophy on this track
          if (((uint)(&DAT_8008fba4)[(int)((int)*(short *)(&DAT_800840f4 + iVar9) + 6U) >> 5] >>
               ((int)*(short *)(&DAT_800840f4 + iVar9) + 6U & 0x1f) & 1) == 0)
		  {
			// record that not all 4 trophies are collected on this hub
            bVar3 = false;
            break;
          }
          iVar9 = iVar9 + 2;
        } while (iVar14 < 4);

		// if you have all 4 trophies on a hub
        if ((bVar3) &&

			// 0x8fba4 is where the adventure profile (currently loaded) begins
													// Level ID
           (((uint)(&DAT_8008fba4)[(int)(*(int *)(PTR_DAT_8008d2ac + 0x1a10) + 0x44U) >> 5] >>
             (*(int *)(PTR_DAT_8008d2ac + 0x1a10) + 0x44U & 0x1f) & 1) != 0)) {

		  // dont spawn outside boss garage
		  bVar3 = false;
        }
      }
    }
code_r0x80057f18:

	// if you just exited boss race
    if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 1) != 0)
	{
	  // spawn outside boss door
      bVar3 = true;
    }

	// if not spawning at hub door
    if (piVar15 == (int *)0x0)
	{
	  // if you want to spawn outside boss door
      if (bVar3)
	  {
		// position outside boss door
        local_38 = *(short *)(*(int *)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x144) + 0xc) +
                             0xc);
        local_36 = *(short *)(*(int *)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x144) + 0xc) +
                             0xe) + 0x80;
        local_34 = *(short *)(*(int *)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x144) + 0xc) +
                             0x10);
      }

	  // If spawning anywhere else
      else {

		 // If you're not in Adventure Arena,
		 // Therefore, if spawning at startline of race track
        if ((*(uint *)PTR_DAT_8008d2ac & 0x100000) == 0) {
LAB_80058158:
		  // get index where driver should spawn (0-7)
          bVar1 = (&DAT_8008d69c)[*(byte *)(param_1 + 0x4a)];

          // racer crossed the start line backwards,
		  // so lap doesn't count when race starts
          *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) | 0x1000000;

		  // set distToFinish_checkpoint = level -> distSpawnToFinish
          *(int *)(param_1 + 0x48c) =
               (uint)*(ushort *)(*(int *)(*(int *)(puVar10 + 0x160) + 0x14c) + 6) << 3;

		  // convert spawn index to byte index,
		  // each spawn position is 3 ints (x,y,z)
          iVar9 = (uint)bVar1 * 0xc;

		  // get position where each of the 8 drivers should spawn, from LEV
          local_38 = *(short *)(*(int *)(puVar10 + 0x160) + iVar9 + 0x6c);
          local_36 = *(short *)(*(int *)(puVar10 + 0x160) + iVar9 + 0x6e) + 0x80;
          local_34 = *(short *)(*(int *)(puVar10 + 0x160) + iVar9 + 0x70);
        }

		// if you are in adventure arena
        else
		{
		  // if no podium reward
          if (*(short *)(PTR_DAT_8008d2ac + 0x2572) == 0) {

			// ivar9 = level you were in previously
            iVar9 = *(int *)(PTR_DAT_8008d2ac + 0x1eb4);

			// if you just came from any of these...
            if (

				// main menu, or adv character garage
				((iVar9 == 0x27) || (iVar9 == 0x28)) ||

			   // nowhere?, or cutscene?
			   ((iVar9 == -1 || ((iVar9 == 0x40 || (iVar9 - 0x2cU < 0x14)))))) goto LAB_80058158;

			// get position where driver should spawn on map,
			// outside warppad they previously entered

			// AH_WarpPad_GetSpawnPosRot
			puVar16 = (undefined2 *)FUN_800abafc(&local_30);
            local_38 = local_30;
            local_36 = local_2e + 0x80;
            local_34 = local_2c;
          }

		  // if you have a podium reward
          else
		  {
			// spawn on the podium in the adv hub
            local_38 = **(short **)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x144) + 0xc);
            local_36 = *(short *)(*(int *)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x144) +
                                          0xc) + 2) + 0x80;
            local_34 = *(short *)(*(int *)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x144) +
                                          0xc) + 4);
          }
        }
      }
    }
    
	// if spawning at hub door
	else 
	{
	  // do trigonometry to take hub door 
		
      *(uint *)(PTR_DAT_8008d2ac + 8) = *(uint *)(PTR_DAT_8008d2ac + 8) | 0x4000;

	  // Cosine(angle)
	  // instDef rotY
	  iVar9 = FUN_8003d1c0((int)*(short *)(piVar15 + 0xe));

	  // Cosine(angle)
	  // instDef rotY+400 (perpendicular)
	  iVar14 = FUN_8003d1c0((int)*(short *)(piVar15 + 0xe) + 0x400);

	  // posX = 
			// instDef posX + (where door starts)
			// doorLengthX + (to get to midpoint between two doors)
			// perpendicularX (to spawn away from door)
	  local_38 = *(short *)(piVar15 + 0xc) + (short)(iVar9 * 800 >> 0xc) +
                 (short)((iVar14 << 9) >> 0xc);
				 
	  // posY = instDef posY + random height offset
      local_36 = *(short *)((int)piVar15 + 0x32) + 0x17a;

	  // Sine(angle)
	  // instDef rotY
	  iVar9 = FUN_8003d184((int)*(short *)(piVar15 + 0xe));

	  // Sine(angle)
	  // instDef rotY+400 (perpendicular)
      iVar14 = FUN_8003d184((int)*(short *)(piVar15 + 0xe) + 0x400);

	  // posZ = 
			// instDef posZ + (where door starts)
			// doorLengthZ + (to get to midpoint between two doors)
			// perpendicularZ (to spawn away from door)
	  local_34 = *(short *)(piVar15 + 0xd) + (short)(iVar9 * 800 >> 0xc) +
                 (short)((iVar14 << 9) >> 0xc);
    }
  }
  local_40 = local_38;
  local_3c = local_34;
  local_3e = local_36 + -0x100;

  // search BSP
  FUN_8001eb0c(&local_40,&local_38,&DAT_1f800108,0);

  // if collision was not found
  if (DAT_1f800146 == 0) {
    *(undefined2 *)(param_1 + 0x370) = 0;
    *(undefined2 *)(param_1 + 0x372) = 0x1000;
    *(undefined2 *)(param_1 + 0x374) = 0;
  }

  // if it was found
  else {
    *(undefined2 *)(param_1 + 0x370) = DAT_1f800178;
    *(undefined2 *)(param_1 + 0x372) = DAT_1f80017a;
    *(undefined2 *)(param_1 + 0x374) = DAT_1f80017c;
    *(undefined4 *)(param_1 + 0x354) = DAT_1f800188;
  }

  // loop counter
  iVar14 = 0;

  // backup AxisAngle
  *(undefined2 *)(param_1 + 0x360) = *(undefined2 *)(param_1 + 0x370);
  *(undefined2 *)(param_1 + 0x368) = *(undefined2 *)(param_1 + 0x370);
  *(undefined2 *)(param_1 + 0x362) = *(undefined2 *)(param_1 + 0x372);
  *(undefined2 *)(param_1 + 0x36a) = *(undefined2 *)(param_1 + 0x372);
  *(undefined2 *)(param_1 + 0x364) = *(undefined2 *)(param_1 + 0x374);
  *(undefined2 *)(param_1 + 0x36c) = *(undefined2 *)(param_1 + 0x374);
  
  iVar9 = param_1;

  // for iVar14 = 0; iVar14 < 1; iVar14++
  do
  {
	// backup of backup of AxisAngle
    *(undefined2 *)(iVar9 + 0x378) = *(undefined2 *)(param_1 + 0x368);
    *(undefined2 *)(iVar9 + 0x37a) = *(undefined2 *)(param_1 + 0x36a);
	iVar14 = iVar14 + 1; // increment loop counter
	*(undefined2 *)(iVar9 + 0x37c) = *(undefined2 *)(param_1 + 0x36c);
    
	iVar9 = iVar9 + 8;
  
  } while (iVar14 < 1);

  // player structure X, Y, Z
  *(int *)(param_1 + 0x2d4) = (int)(short)DAT_1f800124 << 8;
  *(int *)(param_1 + 0x2d8) = (DAT_1f800124._2_2_ + param_3) * 0x100;
  *(int *)(param_1 + 0x2dc) = (int)((uint)DAT_1f800128 << 0x10) >> 8;

  // duplicate of coordinate variables
  *(undefined4 *)(param_1 + 0x2e4) = *(undefined4 *)(param_1 + 0x2d8);
  *(undefined4 *)(param_1 + 0x2e0) = *(undefined4 *)(param_1 + 0x2d4);
  *(undefined4 *)(param_1 + 0x2e8) = *(undefined4 *)(param_1 + 0x2dc);

  // save quadblock height
  *(int *)(param_1 + 0x2d0) = (int)DAT_1f800124._2_2_ << 8;

  puVar4 = PTR_DAT_8008d2ac;

  // if you are spawning into the world for the first time,
  // could be startline, or adv hub spawn in several places
  if ((param_2 & 1) != 0)
  {
    if (piVar15 == (int *)0x0)
	{
	  // if spawning outside boss door
      if (bVar3)
	  {
		// get desired rotation of driver when leaving portal, or spawning at startline
        uVar13 = *(short *)(*(int *)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x144) + 0xc) +
                           0x14) + 0x400U & 0xfff;

        *(ushort *)(param_1 + 0x2ee) = uVar13;

		// if just finished a boss race
        if ((*(uint *)(puVar4 + 8) & 1) != 0) {

		  // Level ID is citadel city
          if (*(int *)(puVar4 + 0x1a10) == 0x1d)
		  {
			// rotate 90 degrees to the right,
			// so you dont have a wall in your face
            uVar13 = uVar13 + 0x400;
          }

		  // if not...
          else
		  {
			// Level ID == 25
			// Level ID == GemStone Valley
            if ((*(int *)(puVar4 + 0x1a10) == 0x19) &&

				// If you just exited hot air skyway,
				// just finished pinstripe boss,
				// spawned by oxide's door
				(*(int *)(puVar4 + 0x1eb4) == 7)
			   )
			{
			  // use default rotation, face oxide's door
              *(ushort *)(param_1 + 0x2ee) = uVar13;

              goto LAB_80058438;
            }

			// If driver spawned to any other boss,
			// for any other reason

			// rotate 180 degrees, facing away from boss door
            uVar13 = *(short *)(param_1 + 0x2ee) + 0x800;
          }

		  // bitwise AND, do not go over 0x1000 (360 degrees)
          *(ushort *)(param_1 + 0x2ee) = uVar13 & 0xfff;
        }
LAB_80058438:
        *(uint *)(PTR_DAT_8008d2ac + 8) = *(uint *)(PTR_DAT_8008d2ac + 8) & 0xfffffffc;
      }

	  // if not outside boss door
	  else {

		// If you're not in Adventure Arena
        if ((*(uint *)PTR_DAT_8008d2ac & 0x100000) == 0)
		{
LAB_800584f8:

		  // position index on starting line
          iVar9 = (uint)(byte)(&DAT_8008d69c)[*(byte *)(param_1 + 0x4a)] * 0xc;

		  // rotation data of all 8 drivers on starting line
          *(undefined2 *)(param_1 + 0x2ec) =
               *(undefined2 *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + iVar9 + 0x72);
          sVar2 = *(short *)(*(int *)(puVar4 + 0x160) + iVar9 + 0x74);
          *(short *)(param_1 + 0x2ee) = sVar2;
          uVar6 = *(undefined2 *)(*(int *)(puVar4 + 0x160) + iVar9 + 0x76);
        }

		// if on adv hub
        else
		{
		  // podium reward
          if (*(short *)(PTR_DAT_8008d2ac + 0x2572) != 0)
		  {
			// set rotation, expecting driver to spawn on podium
            *(ushort *)(param_1 + 0x2ee) =
                 *(ushort *)
                  (*(int *)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x144) + 0xc) + 8) & 0xfff
            ;
            goto LAB_80058568;
          }


          if (
				(
					// If you just came from the main menu
					(*(int *)(PTR_DAT_8008d2ac + 0x1eb4) == 0x27) ||

					// If you just came from "nothing"
					(*(int *)(PTR_DAT_8008d2ac + 0x1eb4) == -1)

				// if WarpPad_ReturnToMap failed to find a matching portal
				) || (puVar16 == (undefined2 *)0x0))

		  // skip
		  goto LAB_800584f8;

		  // rotation data from spawning near hub warppad,
		  // after leaving a race or event
          *(undefined2 *)(param_1 + 0x2ec) = *puVar16;
          sVar2 = puVar16[1];
          *(short *)(param_1 + 0x2ee) = sVar2;
          uVar6 = puVar16[2];
        }
        *(ushort *)(param_1 + 0x2ee) = sVar2 + 0x400U & 0xfff;
        *(undefined2 *)(param_1 + 0x2f0) = uVar6;
      }
    }
    else {
      *(ushort *)(param_1 + 0x2ee) = *(short *)(piVar15 + 0xe) + 0x800U & 0xfff;
      *(uint *)(puVar4 + 8) = *(uint *)(puVar4 + 8) & 0xfffffffc;
    }
  }
LAB_80058568:

  // set speed to zero
  *(undefined2 *)(param_1 + 0x38c) = 0;

  *(undefined2 *)(param_1 + 0x38e) = 0;
  *(undefined2 *)(param_1 + 0x390) = 0;
  *(undefined2 *)(param_1 + 0x392) = 0;
  *(undefined2 *)(param_1 + 0x3b2) = 0;
  *(undefined2 *)(param_1 + 0x39a) = *(undefined2 *)(param_1 + 0x2ee);
  *(undefined2 *)(param_1 + 0x2f4) = *(undefined2 *)(param_1 + 0x2ec);
  *(undefined2 *)(param_1 + 0x2f6) = *(undefined2 *)(param_1 + 0x2ee);
  *(undefined2 *)(param_1 + 0x2f8) = *(undefined2 *)(param_1 + 0x2f0);

  if (
		(piVar15 != (int *)0x0) &&

		// if spawning into world (not mask grab)
		((param_2 & 1) != 0)
	 )
  {
	// spawn with speed (what? when does that ever happen?)
    *(undefined2 *)(param_1 + 0x38c) = 0xa00;
  }

  // set animation to zero
  *(undefined *)(*(int *)(param_1 + 0x1c) + 0x52) = 0;

  // get number of frames in animation
  uVar7 = FUN_8005b0f4(*(undefined4 *)(param_1 + 0x1c),0);

  // Instance_GetStartFrame
  uVar6 = FUN_8005b0c4(0,uVar7);

  // Animation frame
  *(undefined2 *)(*(int *)(param_1 + 0x1c) + 0x54) = uVar6;

  // Set Scale (x, y, z)
  *(undefined2 *)(*(int *)(param_1 + 0x1c) + 0x1c) = 0xccc;
  *(undefined2 *)(*(int *)(param_1 + 0x1c) + 0x1e) = 0xccc;
  *(undefined2 *)(*(int *)(param_1 + 0x1c) + 0x20) = 0xccc;

  *(undefined *)(param_1 + 0x4c) = 0;
  *(undefined *)(param_1 + 0x4d) = 0;
  *(undefined2 *)(param_1 + 0x3fc) = 0;
  *(undefined2 *)(param_1 + 0x46) = 0;
  *(undefined2 *)(param_1 + 0x48) = 0;
  *(undefined2 *)(param_1 + 0x3c6) = 0;
  *(undefined2 *)(param_1 + 0x3d2) = 0;
  *(undefined2 *)(param_1 + 0x3c8) = 0;
  *(undefined2 *)(param_1 + 0x2f2) = 0;
  *(undefined2 *)(param_1 + 0x2fa) = 0;
  *(undefined *)(param_1 + 0x4ff) = 0;
  *(undefined2 *)(param_1 + 0x40c) = 0;
  *(undefined4 *)(param_1 + 0x350) = 0;
  *(undefined4 *)(param_1 + 0x490) = 0;
  *(undefined2 *)(param_1 + 0xc) = 0;
  *(undefined *)(param_1 + 0x4fe) = 0;

  //turn off 7th and 20th bits of Actions Flag set (means ? (7) and racer is not in the air (20))
  *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) & 0xfff7ffbf;
  if ((param_2 & 2) == 0) {
    return;
  }
  iVar9 = 0xc;

  // driver -> instane -> thread -> modelIndex == "player" of any kind
  if (*(short *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x44) == 0x18)
  {
	// This erases all driver funcPtrs, 12 funcPtrs, 0x30 bytes total,
	// it is the strangest way to do it, but that's what it does

	// pointer = driver + 0x30
    iVar14 = param_1 + 0x30;

	// erase 12 (0xC) function pointers from
	// driver struct, 0x54 - 0x84 (0x30 bytes),
	// but erase them backwards
    do {
      *(undefined4 *)(iVar14 + 0x54) = 0;
      iVar9 = iVar9 + -1;
      iVar14 = iVar14 + -4;
    } while (-1 < iVar9);

	// CAM_StartOfRace
    FUN_80018d20(PTR_DAT_8008d2ac + (uint)*(byte *)(param_1 + 0x4a) * 0xdc + 0x1498);

    puVar4 = PTR_DAT_8008d2ac;

	// if you are not in cutscene and not in main menu
    if ((*(uint *)PTR_DAT_8008d2ac & 0x20002000) == 0) {
      puVar10 = (undefined *)0x0;
    }

	// if you are in cutscene or main menu
    else
	{
	  // 0x80058c44 is an empty function that does nothing
      puVar10 = &FUN_80058c44;
    }

	// driver -> instance -> thread -> funcPerFrame = puVar10
    *(undefined **)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x2c) = puVar10;


	// If you're not in Adventure Arena
	if ((*(uint *)puVar4 & 0x100000) == 0)
	{
	  // Player_EngineRevving_Init
      pcVar8 = FUN_80067f4c;
    }

	// If you're in Adventure Arena
    else
	{
	  // Player_Driving_Init
      pcVar8 = FUN_80062b74;
    }

	// set OnInit function
    *(code **)(param_1 + 0x54) = pcVar8;
  }

  // lapIndex = 0
  *(undefined *)(param_1 + 0x44) = 0;

  // numWumpa = 0
  *(undefined *)(param_1 + 0x30) = 0;

  puVar4 = PTR_DAT_8008d2ac;

  // lapTime = 0
  *(undefined4 *)(param_1 + 0x40) = 0;

  // no lap progress
  *(undefined4 *)(param_1 + 0x488) = 0;

  //turn off 21th and 26th flags of Actions Flag set
  //(means ? (21) and racer hasn't finished the race)
  *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) & 0xfdefffff;

  // If unlimited wumpa cheat is enabled
  if ((*(uint *)(puVar4 + 8) & 0x200) != 0)
  {
	// Set wumpa to 99
    *(undefined *)(param_1 + 0x30) = 99;
  }

  //set Held item to none
  *(undefined *)(param_1 + 0x36) = 0xf;

  //set Held item Quantity to 0
  *(undefined *)(param_1 + 0x37) = 0;

  puVar4 = PTR_DAT_8008d2ac;

  // collected zero C-T-R letters
  *(undefined4 *)(param_1 + 0x4cc) = 0;

  // cheat flags
  uVar11 = *(uint *)(puVar4 + 8);

  // set weaponID to mask
  uVar5 = 7;

  // if unlimited masks is disabled
  if ((uVar11 & 0x400) == 0)
  {
	// if unlimited turbos is disabled
    if ((uVar11 & 0x800) == 0)
	{
	  // set weaponID to bomb
      uVar5 = 1;

	  // if infinite bombs is disabled
      if ((uVar11 & 0x400000) == 0) goto LAB_800587cc;

	  goto LAB_800587c0;
    }

	// set weaponID to turbo
    *(undefined *)(param_1 + 0x36) = 0;
  }
  else
  {
LAB_800587c0:
	// set weaponID
    *(undefined *)(param_1 + 0x36) = uVar5;
  }

  //set Held item Quantity to 9 (Cheat related)
  *(undefined *)(param_1 + 0x37) = 9;

LAB_800587cc:
  puVar4 = PTR_DAT_8008d2ac;

  // set driver's life limit to the global life limit
  *(undefined4 *)(param_1 + 0x4e4) = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1d88);

  if (
		// If Permanent Invisibility Cheat is Enabled
		((*(uint *)(puVar4 + 8) & 0x8000) != 0) &&

		// Player / AI structure + 0x4a shows driver index (0-7)

		// driver ID must be less than number of screens,
		// which makes the cheat apply to players and not AIs
		(*(byte *)(param_1 + 0x4a) < (byte)puVar4[0x1ca8]))
  {
	// instance flags
    *(uint *)(*(int *)(param_1 + 0x1c) + 0x28) =
         *(uint *)(*(int *)(param_1 + 0x1c) + 0x28) & 0xfff8ffff;

	// instance flags
    *(uint *)(*(int *)(param_1 + 0x1c) + 0x28) =
         *(uint *)(*(int *)(param_1 + 0x1c) + 0x28) | 0x60000;

	// invisible timer
    *(undefined4 *)(param_1 + 0x28) = 0x2d00;
  }


  // If Super Engine Cheat is enabled
  if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x10000) != 0) {
    *(undefined2 *)(param_1 + 0x38) = 0x2d00;
  }
  return;
}


// Driver_TeleportAll
void FUN_80058898(undefined4 param_1,uint param_2)

{
  // pointer to player address
  int iVar1;

  // iteration counter
  int iVar2;
  iVar2 = 0;

  do
  {
	// address of player structure, idk which
    iVar1 = *(int *)(PTR_DAT_8008d2ac + ((iVar2 << 0x10) >> 0xe) + 0x24ec);

	// if player structure is not nullptr
    if (iVar1 != 0)
	{
	  // driver -> instance -> thread -> modelIndex == "robotcar" of any kind
      if (*(short *)(*(int *)(*(int *)(iVar1 + 0x1c) + 0x6c) + 0x44) == 0x3f)
	  {
		// BOTS_GotoStartingLine
        FUN_8001702c();
      }
      else
	  {
		// Driver_TeleportSelf (startline)
        FUN_80057c8c(iVar1,param_2 | 1,0);
      }
    }

	// increment loop iteration counter
    iVar2 = iVar2 + 1;

  } while (iVar2 * 0x10000 >> 0x10 < 8);
  return;
}


// Driver_SearchModelByString
int * FUN_80058948(int *param_1)

{
  int *piVar1;
  int **ppiVar2;
  int *piVar3;
  int iVar4;

  piVar3 = (int *)0x0;

  // loop counter
  iVar4 = 0;

  // array to character models loaded,
  // maximum of 4, used in VS mode
  ppiVar2 = (int **)&DAT_80083a10;

  // for iVar4 = 0; iVar4 < 3; iVar4++
  do {

	// dereference model pointer
    piVar1 = *ppiVar2;

	// if model pointer exists,
	// check first 16 bytes of model
	// for a matching string
    if (
			(
				(
					// if model pointer exists
					(piVar1 != (int *)0x0) &&

					// 0-3
					(*piVar1 == *param_1)
				) &&

				// 4-7
				(piVar1[1] == param_1[1])
			) &&
			(
				(
					// 8-11
					piVar1[2] == param_1[2] &&

					// 12-15
					(piVar1[3] == param_1[3])
				)
			)
		)
	{
	  // character found, return pointer
      return piVar1;
    }

	// loop counter
    iVar4 = iVar4 + 1;

	// pointer to next model
    ppiVar2 = ppiVar2 + 1;

  } while (iVar4 < 3);

  if (
		// if PLYROBJECTLIST is not nullptr
		(DAT_8008d870 != (int **)0x0) &&

		// make sure elements of PLYROBJECTLIST are valid
		(piVar3 = *DAT_8008d870, piVar3 != (int *)0x0)

		)
  {
	// PLYROBJECTLIST, used for arcade (6-8 players)
    ppiVar2 = DAT_8008d870;

	// loop until all strings are checked (until current is not nullptr)
    do
	{
	  // if model pointer exists,
	  // check first 16 bytes of model
	  // for a matching string
	  if (
			(
				(
					// if model exists
					(*piVar3 == *param_1) &&

					// 0-3
					(piVar3[1] == param_1[1])
				) &&

				// 4-7
				(piVar3[2] == param_1[2])
			) &&

			// 8-11
			(piVar3[3] == param_1[3])
		 )
	  {
	    // character found, return pointer
        return piVar3;
      }

	  // increment pointer
      ppiVar2 = ppiVar2 + 1;

	  // set to pointer
      piVar3 = *ppiVar2;

    } while (piVar3 != (int *)0x0);
  }
  return piVar3;
}



// Driver_SetConsts(driver*), based on driver class
void FUN_80058a60(int param_1)
{

  uint uVar1;
  int iVar2;
  uint uVar3;
  int iVar4;

  // loop counter
  uVar3 = 0;

  // array of structure indexes
  // 0x80088A0C
  iVar4 = -0x7ff775f4;

  // 0x1c * loop counter
  iVar2 = 0;

  // for uVar3 = 0; uVar3 < 0x41 (65); uVar3++
  do {

	// Get the size of the variable
    uVar1 = *(uint *)(iVar4 + 8);

	// If variable size == 2 bytes
    if (uVar1 == 2) {

      // *(2 bytes *) (driver + metaPhys[i]->driverOffset) =
      *(undefined2 *)(param_1 + *(int *)(iVar4 + 4)) =

         // *(2 bytes *) (metaPhys[i]->value[meta[charID].engineID])
        *(undefined2 *)(&DAT_80088a18 + *(int *)(&DAT_80086d90 + (int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)] * 0x10) * 4 + iVar2);
    }

    // if variable size != 2 bytes
    else {

      // if variable size < 3 bytes
      if (uVar1 < 3) {


		    // If variable size == 1 byte
        if (uVar1 == 1) {

          // *(1 byte *) (driver + metaPhys[i]->driverOffset) =
          *(undefined *)(param_1 + *(int *)(iVar4 + 4)) =

            // *(byte *) (metaPhys[i]->value[meta[charID].engineID])
            (&DAT_80088a18)[*(int *)(&DAT_80086d90 + (int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)] * 0x10) * 4 + iVar2];
        }

		/*
		Sep3
		else
			printf("**error** invalid phys size \'%s\' %ld\n",*puVar3,puVar3[2]);
		*/

      }

      // if variable size >= 3 bytes
      else {

        // if variable size == 4 bytes
        if (uVar1 == 4) {

          // *(4 bytes *) (driver + metaPhys[i]->driverOffset) =
          *(undefined4 *)(param_1 + *(int *)(iVar4 + 4)) =

            // *(4 bytes *) (metaPhys[i]->value[meta[charID].engineID])
            *(undefined4 *) (&DAT_80088a18 + *(int *)(&DAT_80086d90 + (int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)] * 0x10) * 4 + iVar2);
        }
      }
    }

	// array of structure indexes += 0x1C
	iVar4 = iVar4 + 0x1c;

	// loop counter
	uVar3 = uVar3 + 1;

	iVar2 = iVar2 + 0x1c;

  } while (uVar3 < 0x41);

  return;
}

// Init_EngineAudio_AllPlayers
void FUN_80058ba4(void)

{
  uint uVar1;
  int iVar2;

  // pointer to first Player thread
  iVar2 = *(int *)(PTR_DAT_8008d2ac + 0x1b2c);

  // while pointer is valid
  while (iVar2 != 0)
  {
	// Player / AI structure + 0x4a shows driver index (0-7)

	// thread -> driver -> driverID
    uVar1 = (uint)*(byte *)(*(int *)(iVar2 + 0x30) + 0x4a);

	// Initialize car engine sound
    FUN_80028880(

		// engineID from metadata, given characterID
		*(int *)(&DAT_80086d90 + (int)(short)(&DAT_80086e84)[uVar1] * 0x10) * 4 + uVar1 &
        0xffff,0x8080);

	// go to next Player in linked list
	iVar2 = *(int *)(iVar2 + 0x10);
  }
  return;
}

#if 0
// intentionally left empty, not a ghidra fail,
// This is inside "#if 0" because it is not
// a function on it's own, it is a pointer to
// the last 8 bytes of the previous function
void FUN_80058c44()
{
	return;
}
#endif


// initialize driver tires
void FUN_80058c4c(int param_1)

{
  undefined *puVar1;
  int iVar2;
  int *piVar3;

  puVar1 = PTR_DAT_8008d2ac;

  // thread -> driver object
  piVar3 = *(int **)(param_1 + 0x30);

  // IconGroup* tireAnim
  iVar2 = *(int *)(PTR_DAT_8008d2ac + 0x2114);

  // wheel scale
  *(undefined2 *)(piVar3 + 1) = 0xccc;

  // wheelSprites = tireAnim->icons
  *piVar3 = iVar2 + 0x14;

  if (
		// Player / AI structure + 0x4a shows driver index (0-7)

		// if character ID is oxide
		((&DAT_80086e84)[*(byte *)((int)piVar3 + 0x4a)] == 0xf) &&

		// Level ID != 39
		// Not in Main Menu
		(*(int *)(puVar1 + 0x1a10) != 0x27)
     )
  {
    *(undefined2 *)(piVar3 + 1) = 0;
  }

  piVar3[2] = 0x2e808080;
  *(undefined2 *)(piVar3 + 0xef) = 0xa00;

  // item held to 0xF (nothing)
  *(undefined *)((int)piVar3 + 0x36) = 0xf;

  // related to engine sound
  *(undefined *)((int)piVar3 + 0x47b) = 2;

  *(undefined2 *)((int)piVar3 + 0x362) = 0x1000;
  *(undefined2 *)((int)piVar3 + 0x36a) = 0x1000;
  *(undefined2 *)((int)piVar3 + 0x412) = 0x600;
  *(undefined2 *)((int)piVar3 + 0x3e6) = 10000;

  // terrain meta
  iVar2 = FUN_80057c68(10);
  piVar3[0xd6] = iVar2;

  // get number of lives in battle
  iVar2 = *(int *)(PTR_DAT_8008d2ac + 0x1d80);

  // 0x4e8
  // team in battle mode
  piVar3[0x13a] = (uint)*(byte *)((int)piVar3 + 0x4a);

  *(undefined2 *)(piVar3 + 0x13c) = 0xffff;
  *(undefined2 *)(piVar3 + 0x13d) = 0xffff;

  // 0x4e4
  // player lives in battle mode
  piVar3[0x139] = iVar2;

  return;
}

// Init NonGhost Driver
// param1 is thread
// param2 is driverID (0-7)
void FUN_80058d2c(int param_1,int param_2)

{
  short sVar1;
  undefined *puVar2;
  undefined4 uVar3;
  int iVar4;
  int iVar5;

  // model index = DYNAMIC_PLAYER,
  // AI will override this right after
  // the end of the function
  *(undefined2 *)(param_1 + 0x44) = 0x18;

  // unknown thread variables?
  *(undefined2 *)(param_1 + 0x42) = 0x40;
  *(undefined4 *)(param_1 + 0x38) = 0x1000;
  *(undefined2 *)(param_1 + 0x3e) = 0x40;

  // get pointer to game config
  puVar2 = PTR_DAT_8008d2ac;

  // unknown thread variables?
  *(undefined2 *)(param_1 + 0x3c) = 0;
  *(undefined2 *)(param_1 + 0x40) = 0;

  // get object from thread
  iVar5 = *(int *)(param_1 + 0x30);

  // by default, get ID of first character
  sVar1 = DAT_80086e84;

  // if you are not in the main menu
  if ((*(uint *)puVar2 & 0x2000) == 0)
  {
	// get ID of character, given param2
    sVar1 = (&DAT_80086e84)[param_2];
  }

  // Driver_SearchModelByString
  uVar3 = FUN_80058948((&PTR_s_crash_80086d84)[(int)sVar1 * 4]);

  // INSTANCE_Birth3D -- ptrModel, name, thread
  uVar3 = FUN_8003086c(uVar3,uVar3,param_1);

  // get pointer to game config
  puVar2 = PTR_DAT_8008d2ac;

  // give instance to thread
  *(undefined4 *)(param_1 + 0x34) = uVar3;

  // Ptr Model "Wake"
  iVar4 = *(int *)(puVar2 + 0x226c);

  // if "Wake" exists
  if (iVar4 != 0)
  {
	// INSTANCE_Birth3D -- ptrModel, name, thread
    iVar4 = FUN_8003086c(iVar4,iVar4,0);

	// pointer to "Wake" instance
    *(int *)(iVar5 + 0x4f8) = iVar4;

	// instance flags
	if (iVar4 != 0)
	{
	  // make invisible, set to anim 1
      *(uint *)(iVar4 + 0x28) = *(uint *)(iVar4 + 0x28) | 0x90;
    }

	// sep 3
	// else
    // player %d wake create failed
  }

  /*
  sep 3
  else
  printf("wake not in level\n");
  */

  // get instance from thread
  iVar4 = *(int *)(param_1 + 0x34);

  // if driverID is less than number of screens,
  // "If driver belongs to human player"
  if (param_2 < (int)(uint)(byte)PTR_DAT_8008d2ac[0x1ca8])
  {
	// thread flag
    *(uint *)(iVar4 + 0x28) = *(uint *)(iVar4 + 0x28) | 0x4000000;
  }

  // give driverID to driver
  *(undefined *)(iVar5 + 0x4a) = (char)param_2;

  // give instance to driver
  *(int *)(iVar5 + 0x1c) = iVar4;

  // initialize tire data
  FUN_80058c4c(param_1);

  // Driver_SetConsts(driver*), based on driver class
  FUN_80058a60(iVar5);

  // if you are not in cutscene and not in main menu
  if ((*(uint *)PTR_DAT_8008d2ac & 0x20002000) != 0)
  {
	// funcPerFrame
	// 0x80058c44 is an empty function that does nothing
    *(undefined4 *)(param_1 + 0x2c) = 0x80058c44;

	// make invisible
    *(uint *)(iVar4 + 0x28) = *(uint *)(iVar4 + 0x28) | 0x80;
  }
  return;
}

// Init_Player
struct Driver* FUN_80058ec0(int param_1)

{
  char cVar1;
  int iVar2;
  struct Driver* iVar3;

  // s_player_8008d614
  // "player"

  // THREAD_BirthWithObject
  // 0x62c = size
  // 0 = no relation to param4
  // 0x100 flag = LargeStackPool
  // 0 = player thread bucket
  iVar2 = FUN_8004205c(0x62c0100,0,s_player_8008d614,0);

  // Get player pointer from the thread
  iVar3 = *(int *)(iVar2 + 0x30);

  // player Driver is 0x62C bytes large
  memset(iVar3,0,0x62c);

  // Init NonGhost Driver
  FUN_80058d2c(iVar2,param_1);

  // Get Team that player chose from Battle Setup menu
  cVar1 = PTR_DAT_8008d2ac[param_1 + 0x1da4];

  // Player_Driving_Init
  *(undefined4 *)(iVar3 + 0x54) = 0x80062b74;

  // Battle Team that the player is on
  *(int *)(iVar3 + 0x4e8) = (int)cVar1;

  return iVar3;
}


// param1 is current rotation
// param2 is speed of rotation
// param3 is desired rotation
// Rotation Interpolation
int FUN_80058f54(int param_1,int param_2,int param_3)

{
  int iVar1;
  int iVar2;

  // if desired rotation is less than current
  if (param_3 < param_1)
  {
	// subtract current by a rate of "speed"
    iVar2 = param_1 - param_2;

	// if new rotation is less than desired
    if (param_1 - param_2 < param_3)
	{
	  // Just use desired rotation
      return param_3;
    }
  }

  // if desired rotation is not less than current
  else
  {
	// make a copy of current
    iVar1 = param_1;
    if (
		// desired <= current,
		// we know desired is not less than current,
		// so this really checks if it is current
		(param_3 <= param_1) ||
		(
			// copy desired
			iVar2 = param_3,

			// add to rotation at rate of "speed"
			iVar1 = param_1 + param_2,

			// if new rotation overshoots desired,
			// probably should say >=
			param_1 + param_2 <= param_3)
		)
	{
	  // if current = desired
	  // if current is overshot past desired

	  // current = desired
      iVar2 = iVar1;
    }
  }

  // return new current
  return iVar2;
}


// Map value from [oldMin, oldMax] to [newMin, newMax]
// inverting newMin and newMax will give an inverse range mapping
int FUN_80058f9c(int param_1,int param_2,int param_3,int param_4,int param_5)
{
  int iVar1;

  // if value is lessor equal than oldMin, return newMin
  if (param_1 <= param_2) {
    return param_4;
  }

  // if value is less than old Max
  if (param_1 < param_3)
  {

	// distance from old min, multiplied by new range
    iVar1 = (param_1 - param_2) * (param_5 - param_4);

	// get range of first min and max
    param_3 = param_3 - param_2;

	// if min === max, crash
	if (param_3 == 0) {
      trap(0x1c00);
    }

	// if min is less than max, crash
    if ((param_3 == -1) && (iVar1 == -0x80000000)) {
      trap(0x1800);
    }

	// new min, plus [...] / old range
    return param_4 + iVar1 / param_3;
  }

  // return new max
  return param_5;
}


// Player_Steer_GetAngularVelocity
undefined4
FUN_8005900c(int param_1,int param_2,int param_3,undefined4 param_4,undefined4 param_5,
            undefined4 param_6)

{
  if (param_1 < param_2) {

    // Map value from [oldMin, oldMax] to [newMin, newMax]
    // inverting newMin and newMax will give an inverse range mapping
    param_6 = FUN_80058f9c(param_1,0,param_2,param_5,param_6);
  }
  else {
    if (param_2 + param_3 < param_1) {

      // Map value from [oldMin, oldMax] to [newMin, newMax]
      // inverting newMin and newMax will give an inverse range mapping
      param_6 = FUN_80058f9c(param_1,param_2 + param_3,param_4,param_6,0);
    }
  }
  return param_6;
}


// if you're interested in learning about the algorithm:
// https://en.wikipedia.org/wiki/Integer_square_root#Digit-by-digit_algorithm

// f(n, i) = sqrt(n * 2^i)
// FastSqrt(n, i)
uint FUN_80059070(uint param_1,uint param_2)
/*
  f(n, 0) will always output the sqrt(n)

  the idea for this function is to first computer the length of the square root in numbers of bits,
  and then test each bit and see if it belongs to the square root. if so, keep the bit, otherwise discard.
*/


{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;

  // result
  uVar5 = 0;

  // uVar4 = x + 1
  uVar4 = 1;

  // last_approximation = 0
  uVar6 = 0;

  uVar3 = 1 << (param_2 & 0x1f);

  /* what this is doing is picking the least x that 4^x >= n
    notice that:
      4^x = n
      log_4(n) = x
      log_2(n) / log_2(4) = x
      log_2(n) / 2 = x
      x = log_2(sqrt(n))

      in order words, x is the length in bits of the square root of n
  */
  while ((uVar3 < param_1 && (uVar3 << 2 != 0))) {
    uVar4 = uVar4 + 1;
    uVar3 = uVar3 << 2;
  }

  // uVar1 = 2 ^ x
  uVar1 = 1 << (uVar4 + (param_2 - 1) & 0x1f);

  // while 4^x != 0
  while (uVar3 != 0) {

    // current_approximation = result << x + 1
    uVar2 = uVar5 << (uVar4 & 0x1f);

    if ((int)uVar4 < 0) {
      uVar2 = uVar5 >> (-uVar4 & 0x1f);
    }

    // current_approximation = (result << x + 1) + last_approximation + current_bit_squared
    uVar2 = uVar2 + uVar6 + uVar3;

    // if current_approximation <= n
    if (uVar2 <= param_1) {

      // result += current_bit
      uVar5 = uVar5 + uVar1;

      // last_approximation = current_approximation
      uVar6 = uVar2;
    }

    // current_bit /= 2
    uVar1 = uVar1 >> 1;

    // current_bit_squared /= 4
    uVar3 = uVar3 >> 2;

    // (x + 1) -= 1
    uVar4 = uVar4 - 1;
  }
  return uVar5;
}


// SpawnParticle_Exhaust
int FUN_80059100(int param_1,int *param_2,int *param_3)

{
  int iVar1;
  undefined *puVar2;
  int iVar3;

  if (
		// if driver is not using invisibility powerup
		(*(int *)(param_1 + 0x28) == 0) &&

		// if driver -> instSelf -> instFlags & INVISIBLE is false
		((*(uint *)(*(int *)(param_1 + 0x1c) + 0x28) & 0x80) == 0)
	 )
  {
	// If you're in 1P mode
	// high LOD exhaust
    puVar2 = (undefined *)0x80089224;

	// if number of screens is less than 3
    if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 3) {

	  // if number of screens is more than 1
      if (1 < (byte)PTR_DAT_8008d2ac[0x1ca8]) {

		// really only happens if number of screens is 2
		// med LOD exhaust
        puVar2 = (undefined *)0x80089344;
      }
    }

	// if number of screens is 3 or 4
    else
	{
	  // low LOD exhaust
      puVar2 = &DAT_80089464;
    }

	// driver -> instance -> thread -> modelIndex == "robotcar" of any kind
    if (*(short *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x44) == 0x3f)
	{
	  // low LOD exhaust
      puVar2 = &DAT_80089464;
    }
    iVar3 = 1;

	// driver -> instance -> flags
    if (((*(uint *)(*(int *)(param_1 + 0x1c) + 0x28) & 0x2000) != 0) &&
       ((param_2[1] - param_3[1]) + *(int *)(param_1 + 0x2d8) < 0x100))
	{
      iVar3 = 7;

	  // exhaust when you're underwater,
	  // which makes bubbles comes out
      puVar2 = &DAT_80089128;
    }

	// Create instance in particle pool
    iVar1 = FUN_80040308(0,*(undefined4 *)(PTR_DAT_8008d2ac + iVar3 * 4 + 0x2114),puVar2);

	// if particle exists
    if (iVar1 != 0)
	{
	  // posX
      *(int *)(iVar1 + 0x24) = *(int *)(iVar1 + 0x24) + (*param_2 - *param_3);

	  // velX
	  *(undefined2 *)(iVar1 + 0x28) = *(undefined2 *)param_3;

	  // posY
	  *(int *)(iVar1 + 0x2c) = *(int *)(iVar1 + 0x2c) + (param_2[1] - param_3[1]);

	  // velY
	  *(undefined2 *)(iVar1 + 0x30) = *(undefined2 *)(param_3 + 1);

	  // posZ
      *(int *)(iVar1 + 0x34) = *(int *)(iVar1 + 0x34) + (param_2[2] - param_3[2]);

	  // velZ
	  *(undefined2 *)(iVar1 + 0x38) = *(undefined2 *)(param_3 + 2);

	  *(undefined *)(iVar1 + 0x18) = *(undefined *)(*(int *)(param_1 + 0x1c) + 0x50);

	  // driver->instSelf
      *(undefined4 *)(iVar1 + 0x20) = *(undefined4 *)(param_1 + 0x1c);

	  if (iVar3 == 7)
	  {
		// Particle_FuncPtr_ExhaustUnderwater
        *(undefined4 *)(iVar1 + 0x1c) = 0x8003ee20;
      }

	  // if engine revving
	  if (*(char *)(param_1 + 0x376) == '\x04')
	  {
        if (*(char *)(param_1 + 0x4fe) != '\x01') {
          return iVar1;
        }
      }

	  // if not engine revving
	  else {
        if ((int)*(short *)(param_1 + 0x3dc) < 0x81) {
          return iVar1;
        }
        if ((int)(((uint)*(byte *)(param_1 + 0x477) + 2) * 0x20) < (int)*(short *)(param_1 + 0x3dc))
        {
          return iVar1;
        }
      }
      *(ushort *)(iVar1 + 0x12) = *(ushort *)(iVar1 + 0x12) & 0xff9f | 0x40;
    }
  }
  else {
    iVar1 = 0;
  }
  return iVar1;
}


// SpawnParticle_Sparks_Ground
void FUN_80059344(int param_1,undefined4 param_2)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  int iVar11;
  int iVar12;
  int iVar13;

  setCopReg(2,0,0);
  setCopReg(2,0x800,0xffffe800);

  // rtv0     cop2 $0486012  v0 * rotmatrix
  copFunction(2,0x486012);

  iVar4 = getCopReg(2,0xc800);
  iVar5 = getCopReg(2,0xd000);
  iVar6 = getCopReg(2,0xd800);
  setCopReg(2,0,0x1800);
  setCopReg(2,0x800,0);

  // rtv0     cop2 $0486012  v0 * rotmatrix
  copFunction(2,0x486012);

  iVar13 = getCopReg(2,0xc800);
  iVar12 = getCopReg(2,0xd000);
  iVar11 = getCopReg(2,0xd800);
  setCopReg(2,0,0);
  setCopReg(2,0x800,0xfffffe00);

  // rtv0     cop2 $0486012  v0 * rotmatrix
  copFunction(2,0x486012);

  uVar10 = getCopReg(2,0xc800);
  uVar9 = getCopReg(2,0xd000);
  uVar8 = getCopReg(2,0xd800);
  iVar7 = 10;
  do
  {
	// Create instance in particle pool
    iVar1 = FUN_80040308(0,*(undefined4 *)(PTR_DAT_8008d2ac + 0x2114),param_2);

    if (iVar1 != 0)
	{
	  // RNG
      uVar2 = FUN_8006c684(PTR_DAT_8008d2ac + 0x252c);
      uVar3 = uVar2 & 0x7ff;
      if ((uVar2 & 1) != 0) {
        uVar3 = -uVar3;
      }

	  // velocity variables
      *(short *)(iVar1 + 0x28) =
           *(short *)(iVar1 + 0x28) + (short)uVar10 + (short)((int)(uVar3 * iVar13) >> 0xc);
      *(short *)(iVar1 + 0x30) =
           *(short *)(iVar1 + 0x30) + (short)uVar9 + (short)((int)(uVar3 * iVar12) >> 0xc);
      *(short *)(iVar1 + 0x38) =
           *(short *)(iVar1 + 0x38) + (short)uVar8 + (short)((int)(uVar3 * iVar11) >> 0xc);

	  // position variables
	  *(int *)(iVar1 + 0x24) = *(int *)(iVar1 + 0x24) + iVar4 + *(short *)(iVar1 + 0x28);
      *(int *)(iVar1 + 0x2c) = *(int *)(iVar1 + 0x2c) + iVar5 + *(short *)(iVar1 + 0x30);
      *(int *)(iVar1 + 0x34) = *(int *)(iVar1 + 0x34) + iVar6 + *(short *)(iVar1 + 0x38);

	  // driver -> instSelf
      *(undefined4 *)(iVar1 + 0x20) = *(undefined4 *)(param_1 + 0x1c);

	  *(undefined *)(iVar1 + 0x18) = *(undefined *)(*(int *)(param_1 + 0x1c) + 0x50);
    }
    iVar7 = iVar7 + -1;
  } while (iVar7 != 0);
  return;
}


// SpawnParticle_Terrain_Ground
void FUN_80059558(int param_1,undefined4 param_2)

{
  int iVar1;
  int iVar2;
  undefined4 uVar3;
  int iVar4;
  int iVar5;
  undefined4 uVar6;
  int iVar7;
  undefined4 uVar8;

  //if racer is on the ground and not in accel prevention
  if (((*(uint *)(param_1 + 0x2c8) & 1) != 0) && ((*(uint *)(param_1 + 0x2c8) & 8) == 0)) {
    iVar1 = (int)*(short *)(param_1 + 0x39e);
    if (iVar1 < 0) {
      iVar1 = -iVar1;
    }
    if (iVar1 < 0x300) {
      iVar1 = (int)*(short *)(param_1 + 0x38e);
      if (iVar1 < 0) {
        iVar1 = -iVar1;
      }
      if (iVar1 < 0x300) {
        return;
      }
    }
    iVar1 = 2;
    if (*(char *)(param_1 + 0x376) == '\x02') {
      iVar1 = 4;
    }
    while (iVar1 != 0) {
      if (iVar1 == 3) {
        setCopReg(2,0,0xa001e);
        uVar3 = 0x28;
        setCopReg(2,0x800,0x28);
      }
      else {
        if (iVar1 < 4) {
          if (iVar1 == 2) {
            setCopReg(2,0,0xaffe2);
            uVar3 = 0xffffffec;
            setCopReg(2,0x800,0xffffffec);
          }
          else {
LAB_80059674:
            setCopReg(2,0,0xa001e);
            uVar3 = 0xffffffec;
            setCopReg(2,0x800,0xffffffec);
          }
        }
        else {
          if (iVar1 != 4) goto LAB_80059674;
          setCopReg(2,0,0xaffe2);
          uVar3 = 0x28;
          setCopReg(2,0x800,0x28);
        }
      }

	  // rtv0     cop2 $0486012  v0 * rotmatrix
      copFunction(2,0x486012);

	  iVar4 = getCopReg(2,0xc800);
      iVar5 = getCopReg(2,0xd000);
      iVar7 = getCopReg(2,0xd800);

	  // Create instance in particle pool
      iVar2 = FUN_80040308(0,*(undefined4 *)(PTR_DAT_8008d2ac + 0x2114),param_2,uVar3);

	  if (iVar2 != 0)
	  {
		// position variables
        *(int *)(iVar2 + 0x24) = *(int *)(iVar2 + 0x24) + iVar4 * 0x100;
        *(int *)(iVar2 + 0x2c) = *(int *)(iVar2 + 0x2c) + iVar5 * 0x100;
        *(int *)(iVar2 + 0x34) = *(int *)(iVar2 + 0x34) + iVar7 * 0x100;

		setCopReg(2,0,CONCAT22(*(undefined2 *)(iVar2 + 0x30),*(undefined2 *)(iVar2 + 0x28)));
        setCopReg(2,0x800,(uint)*(ushort *)(iVar2 + 0x38));

		// rtv0     cop2 $0486012  v0 * rotmatrix
		copFunction(2,0x486012);

		uVar3 = getCopReg(2,0xc800);
        uVar6 = getCopReg(2,0xd000);
        uVar8 = getCopReg(2,0xd800);
        *(undefined2 *)(iVar2 + 0x28) = (short)uVar3;
        *(undefined2 *)(iVar2 + 0x30) = (short)uVar6;
        *(undefined2 *)(iVar2 + 0x38) = (short)uVar8;

		// driver -> instSelf
		*(undefined4 *)(iVar2 + 0x20) = *(undefined4 *)(param_1 + 0x1c);

        *(undefined *)(iVar2 + 0x18) = *(undefined *)(*(int *)(param_1 + 0x1c) + 0x50);
      }
      iVar1 = iVar1 + -1;
    }
  }
  return;
}

// SpawnParticle_Sparks_Wall
// param_1 is driver struct
// param_2 is always 0x800896c8, particle data for sparks
void FUN_80059780(int param_1,undefined4 param_2)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  undefined4 uVar7;
  uint uVar8;
  undefined4 uVar9;
  uint uVar10;
  undefined4 uVar11;

  if (*(short *)(param_1 + 0x39e) == 0) {
    iVar1 = (int)*(short *)(param_1 + 0x38e);
    if (iVar1 < 0) {
      iVar1 = -iVar1;
    }
    if (0x200 < iVar1) goto LAB_800597d0;
  }
  else {
LAB_800597d0:

	// if time against wall is less than 15 seconds
    if (*(short *)(param_1 + 0x50) < 0x1c2)
	{
	  // both controller vibration
      FUN_80026440(param_1,8,0);
      FUN_800264c0(param_1,8,0x7f);

	  // increment time against wall
	  *(short *)(param_1 + 0x50) = *(short *)(param_1 + 0x50) + 1;

	  goto LAB_80059818;
    }
  }

  // reset time against wall to zero
  *(undefined2 *)(param_1 + 0x50) = 0;

LAB_80059818:
  if (*(short *)(param_1 + 0x38e) < 0x201) {
    if (-0x201 < *(short *)(param_1 + 0x38e)) {
      return;
    }
    setCopReg(2,0,0xa00de00);
    setCopReg(2,0x800,0xffffec00);
    setCopReg(2,0x1000,0xa002200);
    setCopReg(2,0x1800,0xffffec00);
  }
  else {
    setCopReg(2,0,0xa00de00);
    setCopReg(2,0x800,0x2800);
    setCopReg(2,0x1000,0xa002200);
    setCopReg(2,0x1800,0x2800);
  }

  // rtv0     cop2 $0486012  v0 * rotmatrix
  copFunction(2,0x486012);

  uVar6 = getCopReg(2,0xc800);
  uVar8 = getCopReg(2,0xd000);
  uVar10 = getCopReg(2,0xd800);

  // rtv1     cop2 $048E012  v1 * rotmatrix
  copFunction(2,0x48e012);

  // get result
  uVar3 = getCopReg(2,0xc800);
  uVar4 = getCopReg(2,0xd000);
  uVar5 = getCopReg(2,0xd800);
  
  setCopControlWord(2,0x4000,uVar6 & 0xffff | uVar8 << 0x10);
  setCopControlWord(2,0x4800,uVar10 & 0xffff | uVar3 << 0x10);
  setCopControlWord(2,0x5000,uVar4 & 0xffff | uVar5 << 0x10);
  
  // ldv0 vec3(driver->0x384) - vec3(driver->posCurr)
  setCopReg(2,0,(int)*(short *)(param_1 + 900) * 0x100 - *(int *)(param_1 + 0x2d4) & 0xffffU |
                ((int)*(short *)(param_1 + 0x386) * 0x100 - *(int *)(param_1 + 0x2d8)) * 0x10000);
  setCopReg(2,0x800,(int)*(short *)(param_1 + 0x388) * 0x100 - *(int *)(param_1 + 0x2dc));

  // llv0     cop2 $04A6012  v0 * light matrix
  copFunction(2,0x4a6012);

  iVar1 = getCopReg(2,0xc800);
  iVar2 = getCopReg(2,0xd000);
  if (iVar1 < iVar2) {
    uVar6 = uVar3;
    uVar8 = uVar4;
    uVar10 = uVar5;
  }

  // Create instance in particle pool
  iVar1 = FUN_80040308(0,*(undefined4 *)(PTR_DAT_8008d2ac + 0x2114),param_2);

  if (iVar1 != 0)
  {
	// position variables
    *(int *)(iVar1 + 0x24) = *(int *)(iVar1 + 0x24) + uVar6;
    *(int *)(iVar1 + 0x34) = *(int *)(iVar1 + 0x34) + uVar10;
    *(int *)(iVar1 + 0x2c) = *(int *)(iVar1 + 0x2c) + uVar8;

    setCopReg(2,0,CONCAT22(*(undefined2 *)(iVar1 + 0x30),*(undefined2 *)(iVar1 + 0x28)));
    setCopReg(2,0x800,(uint)*(ushort *)(iVar1 + 0x38));

	// rtv0     cop2 $0486012  v0 * rotmatrix
	copFunction(2,0x486012);

	uVar7 = getCopReg(2,0xc800);
    uVar9 = getCopReg(2,0xd000);
    uVar11 = getCopReg(2,0xd800);
	
    *(undefined2 *)(iVar1 + 0x28) = (short)uVar7;
    *(undefined2 *)(iVar1 + 0x30) = (short)uVar9;
    *(undefined2 *)(iVar1 + 0x38) = (short)uVar11;

	// driver -> instSelf
    *(undefined4 *)(iVar1 + 0x20) = *(undefined4 *)(param_1 + 0x1c);
  }
  return;
}


// SpawnParticle_DriverMain (calls all other SpawnParticle functions)
void FUN_80059a18(int param_1,int param_2)

{
  undefined uVar1;
  byte bVar2;
  short sVar3;
  short sVar4;
  short sVar5;
  short sVar6;
  short sVar7;
  short sVar8;
  short sVar9;
  short sVar10;
  short sVar11;
  short sVar12;
  ushort uVar13;
  int iVar14;
  int iVar15;
  uint uVar16;
  undefined4 uVar17;
  undefined2 uVar18;
  undefined4 uVar19;
  int iVar20;
  undefined4 uVar21;
  int iVar22;
  char cVar23;
  int iVar24;
  undefined4 local_50;
  undefined4 local_4c;
  undefined4 local_48;
  undefined4 local_40;
  undefined4 local_3c;
  undefined4 local_38;
  uint local_30;

  // driver -> terrain meta
  iVar22 = *(int *)(param_2 + 0x358);

  // get instance from thread
  iVar24 = *(int *)(param_1 + 0x34);

  // backup previous frame's skidmark flags, in the upper bits of itself
  *(int *)(param_2 + 0x2c4) = (*(uint *)(param_2 + 0x2c4) & 0xfffff) << 4;
  
  *(byte *)(param_2 + 0xc3) = *(char *)(param_2 + 0xc3) - 1U & 7;
  local_30 = *(uint *)(iVar22 + 4);
  sVar3 = *(short *)(iVar22 + 0x30);

  // thread -> modelIndex == "player" of any kind
  if (*(short *)(param_1 + 0x44) == 0x18) {
    iVar20 = -1;
    //if racer is on the ground and (?)
    if (((*(uint *)(param_2 + 0x2c8) & 1) != 0) && ((local_30 & 0x20) == 0)) {
      iVar20 = (int)*(short *)(iVar22 + 0x32);
    }
    iVar15 = (int)*(short *)(param_2 + 0x38e);
    if (iVar15 < 0) {
      iVar15 = -iVar15;
    }

    // Map value from [oldMin, oldMax] to [newMin, newMax]
    // inverting newMin and newMax will give an inverse range mapping
    iVar14 = FUN_80058f9c(iVar15,0,5000,0,200);

    iVar15 = (int)*(short *)(param_2 + 0x38e);
    if (iVar15 < 0) {
      iVar15 = -iVar15;
    }

    // Map value from [oldMin, oldMax] to [newMin, newMax]
    // inverting newMin and newMax will give an inverse range mapping
    iVar15 = FUN_80058f9c(iVar15,0,12000,0x6c,0xd2);

	// distortion
    uVar16 = iVar15 << 8;

	// if echo is required
    if ((*(uint *)(param_2 + 0x2c8) & 0x10000) != 0)
	{
	  // add echo
      uVar16 = uVar16 | 0x1000000;
    }

	// driver audio
    FUN_8002e690(param_2 + 0x304,iVar20,

		// volume
		iVar14 << 0x10 |

		// distortion
		uVar16 |

		// L/R
		0x80);

	// If this is human and not an AI
    if ((*(uint *)(param_2 + 0x2c8) & 0x100000) == 0)
	{
	  // get speedApprox
      iVar20 = (int)*(short *)(param_2 + 0x38e);

	  // absolute value
      if (iVar20 < 0) {
        iVar20 = -iVar20;
      }

	  // if speed high enough
      if (0x200 < iVar20)
	  {
		// both controller vibration
        FUN_80026440(param_2,(uint)*(byte *)(iVar22 + 0x2c),(uint)*(byte *)(iVar22 + 0x2d));
        FUN_80026540(param_2,(uint)*(byte *)(iVar22 + 0x2e),(uint)*(byte *)(iVar22 + 0x2f));
      }

      //if racer started touching the ground in this frame
      if ((*(uint *)(param_2 + 0x2c8) & 2) != 0) {
        iVar20 = (int)*(short *)(param_2 + 0x392);
        if (iVar20 < 0) {
          iVar20 = -iVar20;
        }

        if (0x1600 < iVar20)
		{
		  // controller vibration
          FUN_800264c0(param_2,3,0xff);
        }
      }
    }
  }

  // if number of screens is less than 2
  if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 2)
  {
    iVar20 = (int)*(short *)(param_2 + 0x38c);
    if (iVar20 < 0) {
      iVar20 = -iVar20;
    }
    if (
			// high speed
			(0x500 < iVar20) &&

			// current terrain
			(*(char *)(param_2 + 0xc2) == '\x0e')
		)
	{

	  // number of particles
	  iVar20 = 10;

	  //if racer didn't start touching the ground in this frame
      if ((*(uint *)(param_2 + 0x2c8) & 2) == 0)
	  {
		// Create instance in particle pool (land jump in mud)
        iVar20 = FUN_80040308(0,*(undefined4 *)(PTR_DAT_8008d2ac + 0x2148),&DAT_8008980c);

		if (iVar20 != 0) {
          *(undefined *)(iVar20 + 0x18) = *(undefined *)(*(int *)(param_2 + 0x1c) + 0x50);

		  // driver -> instSelf
          *(undefined4 *)(iVar20 + 0x20) = *(undefined4 *)(param_2 + 0x1c);

		  // driverID
          uVar1 = *(undefined *)(param_2 + 0x4a);

          *(int *)(iVar20 + 0x24) = *(int *)(iVar20 + 0x24) + (int)*(short *)(iVar20 + 0x28) * 0x10;

		  // driverID
		  *(undefined *)(iVar20 + 0x19) = uVar1;

          *(int *)(iVar20 + 0x34) = *(int *)(iVar20 + 0x34) + (int)*(short *)(iVar20 + 0x38) * 0x10;
          *(short *)(iVar20 + 0x2a) = *(short *)(iVar20 + 0x2a) - (*(short *)(iVar20 + 0x28) >> 4);
          *(short *)(iVar20 + 0x3a) = *(short *)(iVar20 + 0x3a) - (*(short *)(iVar20 + 0x38) >> 4);
        }
      }

      else
	  {
        do
		{
		  // Create instance in particle pool (mud)
          iVar15 = FUN_80040308(0,*(undefined4 *)(PTR_DAT_8008d2ac + 0x2148),&DAT_8008980c);
          if (iVar15 != 0) {
            *(undefined *)(iVar15 + 0x18) = *(undefined *)(*(int *)(param_2 + 0x1c) + 0x50);

			// driver -> instSelf
            *(undefined4 *)(iVar15 + 0x20) = *(undefined4 *)(param_2 + 0x1c);

            uVar1 = *(undefined *)(param_2 + 0x4a);
            *(int *)(iVar15 + 0x24) =
                 *(int *)(iVar15 + 0x24) + (int)*(short *)(iVar15 + 0x28) * 0x10;
            *(undefined *)(iVar15 + 0x19) = uVar1;
            *(int *)(iVar15 + 0x34) =
                 *(int *)(iVar15 + 0x34) + (int)*(short *)(iVar15 + 0x38) * 0x10;
            *(short *)(iVar15 + 0x2a) = *(short *)(iVar15 + 0x2a) - (*(short *)(iVar15 + 0x28) >> 4)
            ;
            *(short *)(iVar15 + 0x3a) = *(short *)(iVar15 + 0x3a) - (*(short *)(iVar15 + 0x38) >> 4)
            ;
          }

		  // loop count
          iVar20 = iVar20 + -1;

        } while (iVar20 != 0);
      }
    }

	// if number of screens is less than 2 (useless if?)
    if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 2)
	{
      //if racer started touching the ground in this frame
      if (((local_30 & 0x40) != 0) && ((*(uint *)(param_2 + 0x2c8) & 2) != 0)) {

		// get speedApprox
		iVar20 = (int)*(short *)(param_2 + 0x38e);

		// absolute value
		if (iVar20 < 0) {
          iVar20 = -iVar20;
        }

		// if speed is high enough
        if (0x600 < iVar20) {
          iVar20 = (int)*(short *)(param_2 + 0x392);
          if (iVar20 < 0) {
            iVar20 = -iVar20;
          }
          if (0x1600 < iVar20) 
		  {
			// instance -> matrix
			r0 = (MATRIX *)(iVar24 + 0x30);
			gte_SetRotMatrix(r0);
			gte_SetTransMatrix(r0);

			// SpawnParticle_Sparks_Ground
            FUN_80059344(param_2,&DAT_80089584);
          }
        }
      }

	  // if terrain  has particle data
      if (*(int *)(iVar22 + 0x18) != 0)
	  {
		// instance -> matrix
		r0 = (MATRIX *)(iVar24 + 0x30);
		gte_SetRotMatrix(r0);
		gte_SetTransMatrix(r0);

		// particles even frame
		iVar20 = *(int *)(iVar22 + 0x1c);

		// if data is invalid, or odd-number frame
        if ((iVar20 == 0) || ((*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 1) == 0))
		{
		  // particles odd frame
          iVar20 = *(int *)(iVar22 + 0x18);
        }

		// SpawnParticle_Terrain_Ground
		FUN_80059558(param_2,iVar20);
      }

      if (
			// if wall rubbing right now
			(*(short *)(param_2 + 0x3fe) == 0xf0) &&

			// if you are not being mask grabbed
			(*(char *)(param_2 + 0x376) != '\x05')
		  )
	  {
		// instance -> matrix
		r0 = (MATRIX *)(iVar24 + 0x30);
		gte_SetRotMatrix(r0);
		gte_SetTransMatrix(r0);

		// SpawnParticle_Sparks_Wall
		FUN_80059780(param_2,&DAT_800896c8);

		uVar21 = 0x14;

		// increase engine volume
        sVar12 = *(short *)(param_2 + 0x496) + 0x14;
        *(short *)(param_2 + 0x496) = sVar12;

		// max engine volume
        if (0xff < sVar12) {
          *(undefined2 *)(param_2 + 0x496) = 0xff;
        }
      }

	  // if being mask grabbed
      else
	  {
        if (*(short *)(param_2 + 0x3fe) == 0)
		{
		  // reset time against wall
          *(undefined2 *)(param_2 + 0x50) = 0;
        }

		// decrease engine volume
        uVar13 = *(short *)(param_2 + 0x496) - 0x14;
        *(ushort *)(param_2 + 0x496) = uVar13;

		// minimum engine volume
        if ((int)((uint)uVar13 << 0x10) < 0) {
          *(undefined2 *)(param_2 + 0x496) = 0;
        }

        uVar21 = 0x14;
        if (*(short *)(param_2 + 0x496) == 0) {
          uVar21 = 0xffffffff;
        }
      }

	  // thread -> modelIndex == "player" of any kind
      if (*(short *)(param_1 + 0x44) == 0x18)
	  {
		// volume
        uVar16 = (int)*(short *)(param_2 + 0x496) << 0x10;

		// if echo is not requierd
        if ((*(uint *)(param_2 + 0x2c8) & 0x10000) == 0)
		{
		  // volume, distortion, left/right
          uVar16 = uVar16 | 0x8080;
        }

		// if echo
        else
		{
		  // add echo, volume, distortion, left/right
          uVar16 = uVar16 | 0x1008080;
        }

		// driver audio
        FUN_8002e690(param_2 + 0x308,uVar21,uVar16);
      }
    }
  }
  if ((local_30 & 8) != 0)
  {
	// driver is drifting (0x1000)
	// driver is skidding (0x800)
    *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) | 0x1800;
  }
  bVar2 = *(byte *)(param_2 + 0x4c);
  if (bVar2 == 1) {
    //turn on 12th bit of Actions Flag set (means racer is leaving skid marks)
    *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) | 0x800;
LAB_8005a094:
    //turn off 13th bit of Actions Flag set (means racer is not drifting)
    *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) & 0xffffefff;
  }
  else {
    if ((bVar2 != 0) && (bVar2 < 4)) goto LAB_8005a094;
  }

  //if racer is not on the ground, not leaving skid marks on front or back tires
  if (((*(uint *)(param_2 + 0x2c8) & 1) == 0) || ((*(uint *)(param_2 + 0x2c8) & 0x1800) == 0)) {
LAB_8005a73c:

	// if driver sound exists
    if (*(int *)(param_2 + 0x300) != 0)
	{
	  // OtherFX_Stop1
      FUN_80028808();

	  // erase sound
      *(undefined4 *)(param_2 + 0x300) = 0;
    }
  }

  // if driver is on ground, and leaving skidmarks (or drift)
  else
  {
	// get speedApprox
    iVar22 = (int)*(short *)(param_2 + 0x38e);

	// absolute value
    if (iVar22 < 0) {
      iVar22 = -iVar22;
    }

	// if speed is low
    if (iVar22 < 0x201) goto LAB_8005a73c;

	// if speed is high

	// thread -> modelIndex == "player" of any kind
    if (*(short *)(param_1 + 0x44) == 0x18) {
      iVar20 = (int)*(char *)(param_2 + 0x4b);
      if (iVar20 < 0) {
        iVar20 = -iVar20;
      }

      // Map value from [oldMin, oldMax] to [newMin, newMax]
      // inverting newMin and newMax will give an inverse range mapping
      iVar15 = FUN_80058f9c(iVar22,2000,12000,0x14,0xaa);

	  // approxSpeed
      iVar22 = (int)*(short *)(param_2 + 0x38e);

	  // absolute value
      if (iVar22 < 0) {
        iVar22 = -iVar22;
      }

      // Map value from [oldMin, oldMax] to [newMin, newMax]
      // inverting newMin and newMax will give an inverse range mapping
      iVar22 = FUN_80058f9c(iVar22,2000,12000,0x92,0x78);

	  if (*(char *)(param_2 + 0x376) == '\x02') {
        iVar14 = (int)*(short *)(param_2 + 0x3d4);
        if (iVar14 < 0) {
          iVar14 = -iVar14;
        }
        iVar22 = iVar22 - iVar14;
        if (iVar22 < 0) {
          iVar22 = 0;
        }
      }
      iVar22 = iVar22 + iVar20;
      if (0x92 < iVar22) {
        iVar22 = 0x92;
      }

	  // distortion
      uVar16 = iVar22 << 8;

      // if echo is required
      if ((*(uint *)(param_2 + 0x2c8) & 0x10000) != 0)
	  {
		// add echo
        uVar16 = uVar16 | 0x1000000;
      }

	  FUN_8002e690(

			// driver audio
			param_2 + 0x300,

			(int)sVar3,

			// volume
			(iVar15 + (iVar20 >> 1)) * 0x10000 |

			// echo + distort
			uVar16 |

			// L/R with no safeguard
			0x80U - ((int)((uint)*(byte *)(param_2 + 0x4b) << 0x18) >> 0x1a));
    }
    if ((*(uint *)(iVar24 + 0x28) & 0x2000) == 0) {
      cVar23 = *(char *)(iVar24 + 0x50);
    }
    else {
      cVar23 = *(char *)(iVar24 + 0x51);
    }
    cVar23 = cVar23 + '\x02';

	// Cosine(angle)
    FUN_8003d1c0((int)*(short *)(param_2 + 0x396));

	// Sine(angle)
	iVar22 = FUN_8003d184((int)*(short *)(param_2 + 0x396));

	// Cosine(angle)
	iVar20 = FUN_8003d1c0((int)*(short *)(param_2 + 0x396));

	// Sine(angle)
	FUN_8003d184((int)*(short *)(param_2 + 0x396));

	// Cosine(angle)
	iVar15 = FUN_8003d1c0((int)*(short *)(param_2 + 0x396));

	// Sine(angle)
	FUN_8003d184((int)*(short *)(param_2 + 0x396));

	// Cosine(angle)
	FUN_8003d1c0((int)*(short *)(param_2 + 0x396));

	// Sine(angle)
	iVar14 = FUN_8003d184((int)*(short *)(param_2 + 0x396));

	// instance -> matrix
	r0 = (MATRIX *)(iVar24 + 0x30);
	gte_SetRotMatrix(r0);
	gte_SetTransMatrix(r0);
	
    sVar3 = (short)(iVar15 * 10 >> 0xc);
    sVar12 = (short)(iVar14 * -10 >> 0xc);
    sVar6 = (short)(iVar15 * 10 >> 0xd);
    sVar7 = (short)(iVar14 * -10 >> 0xd);
    sVar10 = (short)(iVar22 * 0xf >> 0xc);
    sVar11 = (short)(iVar20 * 0xf >> 0xc);
    sVar8 = (short)(iVar22 * 0xf >> 0xd);
    sVar9 = (short)(iVar20 * 0xf >> 0xd);
	
    // front wheel skids
    if ((*(uint *)(param_2 + 0x2c8) & 0x800) != 0) 
	{
	  // enable skidmarks for first tire
      *(uint *)(param_2 + 0x2c4) = *(uint *)(param_2 + 0x2c4) | 1;
      
	  // ldv0
	  setCopReg(2,0,0xffe2);
      setCopReg(2,0x800,0xffffffec);

	  // rtv0tr   cop2 $0480012  v0 * rotmatrix + tr vector
      copFunction(2,0x480012);

	  // get result
      uVar21 = getCopReg(2,0xc800);
      uVar19 = getCopReg(2,0xd000);
      uVar17 = getCopReg(2,0xd800);
	  
      sVar4 = (short)uVar21 - sVar8;
	  
	  // skidmark index (0-7)
      bVar2 = *(byte *)(param_2 + 0xc3);
	  
      sVar5 = (short)uVar17 - sVar9;
      iVar22 = param_2 + (uint)bVar2 * 0x40;
      
	  // store to skidmark buffer
	  *(short *)(iVar22 + 0xc4) = sVar4 + sVar3;
      *(short *)(iVar22 + 200) = sVar5 + sVar12;
      *(short *)(iVar22 + 0xcc) = sVar4 - sVar3;
	  
      uVar18 = (undefined2)uVar19;
      *(undefined2 *)(iVar22 + 0xc6) = uVar18;
      *(undefined2 *)(iVar22 + 0xce) = uVar18;
      *(short *)(iVar22 + 0xd0) = sVar5 - sVar12;
      *(char *)(iVar22 + 0xca) = cVar23;
      if ((local_30 & 8) == 0) {
        *(undefined *)(iVar22 + 0xcb) = 0;
      }
      else {
        *(undefined *)(iVar22 + 0xcb) = 1;
      }
	  
	  // previous skidmark index
      uVar16 = (uint)bVar2 - 1 & 7;
      iVar22 = param_2 + uVar16 * 0x40;
	  
	  // record skidmark buffer
      *(short *)(iVar22 + 0xc4) = sVar4 + sVar10 + sVar6;
      *(undefined2 *)(iVar22 + 0xc6) = uVar18;
      *(short *)(iVar22 + 200) = sVar5 + sVar11 + sVar7;
      *(short *)(iVar22 + 0xcc) = (sVar4 + sVar10) - sVar6;
      *(undefined2 *)(iVar22 + 0xce) = uVar18;
      *(short *)(iVar22 + 0xd0) = (sVar5 + sVar11) - sVar7;
      *(char *)(iVar22 + 0xca) = cVar23;
	  
      if ((local_30 & 8) == 0) {
        *(undefined *)(iVar22 + 0xcb) = 0;
      }
      else {
        *(undefined *)(iVar22 + 0xcb) = 1;
      }
	  
	  // enable skidmarks for second tire
      *(uint *)(param_2 + 0x2c4) = *(uint *)(param_2 + 0x2c4) | 2;
	  
	  // ldv0
      setCopReg(2,0,0x1e);
      setCopReg(2,0x800,0xffffffec);

	  // rtv0tr   cop2 $0480012  v0 * rotmatrix + tr vector
      copFunction(2,0x480012);

	  // get result
      uVar21 = getCopReg(2,0xc800);
      uVar19 = getCopReg(2,0xd000);
      uVar17 = getCopReg(2,0xd800);
	  
	  // next skidmark index
      uVar16 = uVar16 + 1 & 7;
      sVar4 = (short)uVar21 - sVar8;
      sVar5 = (short)uVar17 - sVar9;
      iVar22 = param_2 + uVar16 * 0x40;
	  
	  // skidmark data
      *(short *)(iVar22 + 0xd4) = sVar4 + sVar3;
      *(short *)(iVar22 + 0xd8) = sVar5 + sVar12;
      *(short *)(iVar22 + 0xdc) = sVar4 - sVar3;
      uVar18 = (undefined2)uVar19;
      *(undefined2 *)(iVar22 + 0xd6) = uVar18;
      *(undefined2 *)(iVar22 + 0xde) = uVar18;
      *(short *)(iVar22 + 0xe0) = sVar5 - sVar12;
      *(char *)(iVar22 + 0xda) = cVar23;
      if ((local_30 & 8) == 0) {
        *(undefined *)(iVar22 + 0xdb) = 0;
      }
      else {
        *(undefined *)(iVar22 + 0xdb) = 1;
      }
	  
	  // previous skidmark index
      iVar22 = param_2 + (uVar16 - 1 & 7) * 0x40;
	  
      *(short *)(iVar22 + 0xd4) = sVar4 + sVar10 + sVar6;
      *(undefined2 *)(iVar22 + 0xd6) = uVar18;
      *(short *)(iVar22 + 0xd8) = sVar5 + sVar11 + sVar7;
      *(short *)(iVar22 + 0xdc) = (sVar4 + sVar10) - sVar6;
      *(undefined2 *)(iVar22 + 0xde) = uVar18;
      *(short *)(iVar22 + 0xe0) = (sVar5 + sVar11) - sVar7;
      *(char *)(iVar22 + 0xda) = cVar23;
      if ((local_30 & 8) == 0) {
        *(undefined *)(iVar22 + 0xdb) = 0;
      }
      else {
        *(undefined *)(iVar22 + 0xdb) = 1;
      }
    }
	
    // back wheel skids
    if ((*(uint *)(param_2 + 0x2c8) & 0x1000) != 0) 
	{
	  // enable skidmarks for third tire
      *(uint *)(param_2 + 0x2c4) = *(uint *)(param_2 + 0x2c4) | 4;
      
	  // ldv0
	  setCopReg(2,0,0xffe2);
      setCopReg(2,0x800,0x28);

	  // rtv0tr   cop2 $0480012  v0 * rotmatrix + tr vector
      copFunction(2,0x480012);

      uVar21 = getCopReg(2,0xc800);
      uVar19 = getCopReg(2,0xd000);
      uVar17 = getCopReg(2,0xd800);
	  
      sVar4 = (short)uVar21 - sVar8;
      bVar2 = *(byte *)(param_2 + 0xc3);
      sVar5 = (short)uVar17 - sVar9;
      iVar22 = param_2 + (uint)bVar2 * 0x40;
      *(short *)(iVar22 + 0xe4) = sVar4 + sVar3;
      *(short *)(iVar22 + 0xe8) = sVar5 + sVar12;
      *(short *)(iVar22 + 0xec) = sVar4 - sVar3;
      uVar18 = (undefined2)uVar19;
      *(undefined2 *)(iVar22 + 0xe6) = uVar18;
      *(undefined2 *)(iVar22 + 0xee) = uVar18;
      *(short *)(iVar22 + 0xf0) = sVar5 - sVar12;
      *(char *)(iVar22 + 0xea) = cVar23;
      if ((local_30 & 8) == 0) {
        *(undefined *)(iVar22 + 0xeb) = 0;
      }
      else {
        *(undefined *)(iVar22 + 0xeb) = 1;
      }
	  
	  // next skidmark buffer
      uVar16 = (uint)bVar2 - 1 & 7;
      iVar22 = param_2 + uVar16 * 0x40;
	  
      *(short *)(iVar22 + 0xe4) = sVar4 + sVar10 + sVar6;
      *(undefined2 *)(iVar22 + 0xe6) = uVar18;
      *(short *)(iVar22 + 0xe8) = sVar5 + sVar11 + sVar7;
      *(short *)(iVar22 + 0xec) = (sVar4 + sVar10) - sVar6;
      *(undefined2 *)(iVar22 + 0xee) = uVar18;
      *(short *)(iVar22 + 0xf0) = (sVar5 + sVar11) - sVar7;
      *(char *)(iVar22 + 0xea) = cVar23;
      if ((local_30 & 8) == 0) {
        *(undefined *)(iVar22 + 0xeb) = 0;
      }
      else {
        *(undefined *)(iVar22 + 0xeb) = 1;
      }
	  
	  // enable skidmarks for fourth tire
      *(uint *)(param_2 + 0x2c4) = *(uint *)(param_2 + 0x2c4) | 8;
	  
	  // ldv0
      setCopReg(2,0,0x1e);
      setCopReg(2,0x800,0x28);

	  // rtv0tr   cop2 $0480012  v0 * rotmatrix + tr vector
      copFunction(2,0x480012);

	  uVar21 = getCopReg(2,0xc800);
      uVar19 = getCopReg(2,0xd000);
      uVar17 = getCopReg(2,0xd800);
	  
	  // next skidmark buffer
      uVar16 = uVar16 + 1 & 7;
	  
      sVar8 = (short)uVar21 - sVar8;
      sVar9 = (short)uVar17 - sVar9;
      iVar22 = param_2 + uVar16 * 0x40;
      *(short *)(iVar22 + 0xf4) = sVar8 + sVar3;
      *(short *)(iVar22 + 0xf8) = sVar9 + sVar12;
      *(short *)(iVar22 + 0xfc) = sVar8 - sVar3;
      uVar18 = (undefined2)uVar19;
      *(undefined2 *)(iVar22 + 0xf6) = uVar18;
      *(undefined2 *)(iVar22 + 0xfe) = uVar18;
      *(short *)(iVar22 + 0x100) = sVar9 - sVar12;
      *(char *)(iVar22 + 0xfa) = cVar23;
      if ((local_30 & 8) == 0) {
        *(undefined *)(iVar22 + 0xfb) = 0;
      }
      else {
        *(undefined *)(iVar22 + 0xfb) = 1;
      }
      iVar22 = param_2 + (uVar16 - 1 & 7) * 0x40;
      *(short *)(iVar22 + 0xf4) = sVar8 + sVar10 + sVar6;
      *(undefined2 *)(iVar22 + 0xf6) = uVar18;
      *(short *)(iVar22 + 0xf8) = sVar9 + sVar11 + sVar7;
      *(short *)(iVar22 + 0xfc) = (sVar8 + sVar10) - sVar6;
      *(undefined2 *)(iVar22 + 0xfe) = uVar18;
      *(short *)(iVar22 + 0x100) = (sVar9 + sVar11) - sVar7;
      *(char *)(iVar22 + 0xfa) = cVar23;
      if ((local_30 & 8) == 0) {
        *(undefined *)(iVar22 + 0xfb) = 0;
      }
      else {
        *(undefined *)(iVar22 + 0xfb) = 1;
      }
    }
  }

  // thread -> modelIndex == "robotcar" of any kind
  if (*(short *)(param_1 + 0x44) == 0x3f)
  {
    if (
			// put each driver on alternates frames of 4 (0,1,2,3)
			(*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 3) !=
			((uint)*(byte *)(param_2 + 0x4a) & 3)
		)

	goto LAB_8005a9d8;
	LAB_8005a858:

	if (*(char *)(param_2 + 0x381) != '\0') goto LAB_8005a868;
  }

  // else if "player"???
  else {
    if (
		(*(char *)(param_2 + 0x4fe) == '\x02') ||
		(
			(
				// If number of screens is more than 1
				// If this is a multiplayer game
				1 < (byte)PTR_DAT_8008d2ac[0x1ca8] &&
				(
					(
						(
							// If number of screens is not 2
							PTR_DAT_8008d2ac[0x1ca8] != 2 ||
							(
								// for 2P mode, make driver skids on alternating frames (0 or 1)
								(*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 1) != (uint)*(byte *)(param_2 + 0x4a)
							)
						) &&
						(
							// for 3P or 4P mode, make skids on alternating frames of 4 (0,1,2,3)
							(*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 3) != (uint)*(byte *)(param_2 + 0x4a))
						)
				)
			)
		)
	   )
    goto LAB_8005a9d8;
    if (*(char *)(param_2 + 0x381) == '\0') {
      if (
			(
				((int)*(short *)(param_2 + 0x3dc) < 0x81) ||

				(
					(int)(((uint)*(byte *)(param_2 + 0x477) + 2) * 0x20) <
					(int)*(short *)(param_2 + 0x3dc)
				)
			) &&

			(
				// THREAD_SearchForModel
				iVar22 = FUN_80042394(*(undefined4 *)(param_1 + 0x14),0x2c),

				// result found
				iVar22 != 0
			)
		 )
      goto LAB_8005a9d8;
      goto LAB_8005a858;
    }
LAB_8005a868:
    *(char *)(param_2 + 0x381) = *(char *)(param_2 + 0x381) + -1;
  }
  
  // gte_setRotMatrix
  setCopControlWord(2,0,*(undefined4 *)(iVar24 + 0x30));
  setCopControlWord(2,0x800,*(undefined4 *)(iVar24 + 0x34));
  setCopControlWord(2,0x1000,*(undefined4 *)(iVar24 + 0x38));
  setCopControlWord(2,0x1800,*(undefined4 *)(iVar24 + 0x3c));
  setCopControlWord(2,0x2000,*(undefined4 *)(iVar24 + 0x40));
  
  // ldv0
  setCopReg(2,0,0x4000000);
  setCopReg(2,0x800,0xfffffc00);

  // rtv0     cop2 $0486012  v0 * rotmatrix
  copFunction(2,0x486012);

  local_40 = getCopReg(2,0xc800);
  local_3c = getCopReg(2,0xd000);
  local_38 = getCopReg(2,0xd800);
  
  // ldv0
  setCopReg(2,0,(int)*(short *)(iVar24 + 0x1c) * 9 >> 3 & 0xffffU |
                ((int)*(short *)(iVar24 + 0x1e) * 7 >> 1) << 0x10);
  setCopReg(2,0x800,(int)*(short *)(iVar24 + 0x20) * -0x38 >> 4);

  // rtv0     cop2 $0486012  v0 * rotmatrix
  copFunction(2,0x486012);

  local_50 = getCopReg(2,0x19);
  local_4c = getCopReg(2,0x1a);
  local_48 = getCopReg(2,0x1b);

  // SpawnParticle_Exhaust
  FUN_80059100(param_2,&local_50,&local_40);

  // ldv0
  setCopReg(2,0,(int)*(short *)(iVar24 + 0x1c) * -0x12 >> 4 & 0xffffU |
                ((int)*(short *)(iVar24 + 0x1e) * 7 >> 1) << 0x10);
  setCopReg(2,0x800,(int)*(short *)(iVar24 + 0x20) * -0x38 >> 4);

  // rtv0     cop2 $0486012  v0 * rotmatrix
  copFunction(2,0x486012);

  local_50 = getCopReg(2,0x19);
  local_4c = getCopReg(2,0x1a);
  local_48 = getCopReg(2,0x1b);

  // SpawnParticle_Exhaust
  FUN_80059100(param_2,&local_50,&local_40);

LAB_8005a9d8:

  // if driver is burnt
  if (*(short *)(param_2 + 0x402) != 0)
  {
    *(undefined2 *)(param_2 + 0x508) = 0x1000;

	// set alpha to max (draws black)
    *(undefined2 *)(*(int *)(param_2 + 0x1c) + 0x22) = 0x1000;
  }

  // if driver is invisible
  if (*(int *)(param_2 + 0x28) != 0)
  {
	// set transparency to max
    *(undefined2 *)(iVar24 + 0x22) = 0x1000;
  }

  //if racer is not driving normally and not drifting
  if ((*(char *)(param_2 + 0x376) != '\0') && (*(char *)(param_2 + 0x376) != '\x02'))
  {
    //turn off 20th bit of Actions Flag set (means racer is not in the air)
    *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) & 0xfff7ffff;
  }

  //if racer is being mask grabbed or repositioned, or is on the ground
  if (((uint)*(byte *)(param_2 + 0x376) - 4 < 2) || ((*(uint *)(param_2 + 0x2c8) & 1) != 0))
  {
	// GAMEPAD_Vib_2
	FUN_800263fc(param_2,0x27,0);

	if (*(short *)(param_2 + 0x3d4) == 0) {
      return;
    }
    if ((*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 3) == 0) {
      uVar21 = 0x27;
    }
    else {
      uVar21 = 0xf0;
    }
    uVar17 = 0x100;
  }
  else {
    if (*(short *)(param_2 + 0x3fc) < 0x80) {
      uVar21 = 0x12;
      if ((*(char *)(param_2 + 0x4b) < '\0') || (uVar21 = 0x22, '\0' < *(char *)(param_2 + 0x4b)))
	  {
		// GAMEPAD_Vib_1
        FUN_800263a0(param_2,uVar21,0x20);
      }
    }
    uVar21 = 0;
    uVar17 = uVar21;
  }

  // GAMEPAD_Vib_2
  FUN_800263fc(param_2,uVar21,uVar17);

  return;
}


// param1 - driver
// param2 - speed cap
// Turbo_Audio
void FUN_8005ab24(int param_1,int param_2)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;

  // if turbo audio cooldown is not done
  if (*(short *)(param_1 + 0x3e0) != 0) {
    return;
  }

  // half volume
  iVar4 = 0x80;

  if (param_2 < 0x40)
  {
	// distort
    iVar3 = 0x94;
  }

  else
  {
	// 3/4 volume
    iVar4 = 0xc0;

	if (0x7f < param_2)
	{
	  // distort
      iVar3 = 0x6c;

	  // Make driver talk
      FUN_8002cbe8(0x10,(int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)],0x10);

	  // max volume
	  uVar2 = 0xff0000;

	  goto LAB_8005aba4;
    }

	// no distort
    iVar3 = 0x80;
  }

  // volume
  uVar2 = iVar4 << 0x10;

LAB_8005aba4:

  // distortion
  uVar1 = iVar3 << 8;

  // if echo is requierd
  if ((*(uint *)(param_1 + 0x2c8) & 0x10000) != 0)
  {
	// add echo
    uVar1 = uVar1 | 0x1000000;
  }

  // OtherFX_Play_LowLevel
  // 0xD = Turbo Boost Sound
  // 0x80 = balance L/R
  FUN_800284d0(0xd,1,uVar2 | uVar1 | 0x80);

  // turbo audio cooldown 0.24s
  *(undefined2 *)(param_1 + 0x3e0) = 0xf0;

  return;
}

// param1 - driver
// param2 - reserves to add
// param3 - add type
// param4 - fire level
// Turbo_Increment
void FUN_8005abfc(int param_1,int param_2,uint param_3,int param_4)

{
  char cVar1;
  short sVar2;
  undefined *puVar3;
  undefined uVar4;
  int iVar5;
  uint uVar6;
  int *piVar7;
  int iVar8;
  short sVar9;

  if (
		//if pointer is not null and
		((param_3 & 4) != 0) &&
		//racer is in accel prevention
		((*(uint *)(param_1 + 0x2c8) & 8) != 0)
	)
  {
    return;
  }

  if (
	// Player / AI structure + 0x4a shows driver index (0-7)

    // If this is the first driver (P1) and
		(*(char *)(param_1 + 0x4a) == '\0') &&

		// driver -> instance -> thread -> modelIndex == "player" of any kind
		(*(short *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x44) == 0x18)
	 )
  {
    // Add Reserves to ghost buffer
    FUN_8002838c(param_2,param_3,param_4);
  }

  //puVar3 = 0x96B20
  puVar3 = PTR_DAT_8008d2ac;
  //cVar1 = Kart state
  cVar1 = *(char *)(param_1 + 0x376);

  //if player is spinning, blasted, or mask grabbed, quit the function
  if (cVar1 == '\x03') {
    return;
  }
  if (cVar1 == '\x06') {
    return;
  }
  if (cVar1 == '\x05') {
    return;
  }

  //turn off 8th flag, turn on 22nd flag of actions flag set
  //means ? (!(8)) and racer just got an outside turbo (22)
  *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) & 0xffffff7f | 0x200000;

  // turbo thread bucket
  iVar5 = *(int *)(puVar3 + 0x1be0);

  // turbo thread bucket exists
  if (iVar5 != 0)
  {
    // check all turbo threads
    do
	{
      // if this turbo thread is owned by this driver
	  // turboThread->object->offset0x4 == driver
      if (*(int *)(*(int *)(iVar5 + 0x30) + 4) == param_1)
	  {
		  // quit, iVar5 is now this driver's turbo thread
		  break;
	  }

	  // next turbo thread in bucket
      iVar5 = *(int *)(iVar5 + 0x10);

    } while (iVar5 != 0);

    // if this driver's turbo thread was found
    if (iVar5 != 0)
	{
	  // get the turbo's object
      piVar7 = *(int **)(iVar5 + 0x30);

      // get the turbo's instance
      iVar8 = *(int *)(iVar5 + 0x34);

	  // thread flags
      *(uint *)(iVar5 + 0x1c) = *(uint *)(iVar5 + 0x1c) & 0xfffff7ff;

	  // manipulate how turbo draws, depending on Add Type flag
      if ((param_3 & 4) == 0)
	  {

        // turbo instance (1/2) attached to thread, edit instance draw flags
        *(uint *)(iVar8 + 0x28) = *(uint *)(iVar8 + 0x28) | 0x1000080;

        // turbo instance (2/2) in thread's object, edit instance draw flags
        *(uint *)(*piVar7 + 0x28) = *(uint *)(*piVar7 + 0x28) | 0x1000080;

        *(undefined2 *)((int)piVar7 + 0xe) = 0x60;

LAB_8005ad6c:

        //increase Turbo counter by 1
        *(short *)(param_1 + 0x4e) = *(short *)(param_1 + 0x4e) + 1;
      }

	  // if AddType is different
      else
	  {
        //if racer got an Outside turbo, add it to the Turbo counter
        if ((*(uint *)(param_1 + 0x2cc) & 0x200000) == 0) goto LAB_8005ad6c;
      }

      *(undefined *)(piVar7 + 3) = 0xff;
      *(undefined2 *)(iVar8 + 0x22) = 0;
      *(undefined2 *)(*piVar7 + 0x22) = 0;

      if (
			// driver -> instance -> thread -> modelIndex == "player" of any kind
			(*(short *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x44) == 0x18) &&
			(
				(
					//if racer is not getting an Outside turbo
					(*(uint *)(param_1 + 0x2c8) & 0x200000) == 0 ||

					//racer was not getting an Outside turbo previous frame
					((*(uint *)(param_1 + 0x2cc) & 0x200000) == 0)
				)
			)
		)
      {
        *(undefined *)((int)piVar7 + 0xd) = 0;

		// Turbo_Audio
        FUN_8005ab24(param_1,param_4);
      }

      // skip code, do not re-initialize turbo thread,
	  // because it already exists
      goto LAB_8005af38;
    }
  }

  // If the program reaches this point,
  // it means a boost was added to the driver,
  // and a thread does not already exist, so
  // a turbo thread is created

  //Turbo counter = 1
  *(undefined2 *)(param_1 + 0x4e) = 1;

  // definitely related to turbo display counter,
  // because it is in the HUD thread bucket...

  // s_turbo1_8008d61c
  // "turbo1"
  // 0x300 flag = SmallStackPool
  // 0x10 = HUD thread bucket
  iVar5 = FUN_800309a4(0x2c,s_turbo1_8008d61c,0x300,9,FUN_800693c8,0x10,0);

  // piVar7 = nullptr
  piVar7 = (int *)0x0;

  //if iVar5 != nullptr
  if (iVar5 != 0)
  {
    // turboInstance->thread->object
    piVar7 = *(int **)(*(int *)(iVar5 + 0x6c) + 0x30);

    // store Driver pointer inside Turbo object
    piVar7[1] = param_1;

    *(undefined2 *)((int)piVar7 + 0xe) = 0;

    // allow this thread to ignore all collisions
    *(uint *)(*(int *)(iVar5 + 0x6c) + 0x1c) = *(uint *)(*(int *)(iVar5 + 0x6c) + 0x1c) | 0x1000;

    if (

	  // driver -> instance -> thread -> modelIndex == "player" of any kind
      (*(short *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x44) == 0x18) &&
      (
		*(undefined *)((int)piVar7 + 0xd) = 0,

		//racer is not crashing
		*(char *)(param_1 + 0x376) != '\x01'
	  )
    )
    {
	  // Turbo_Audio
      FUN_8005ab24(param_1,param_4);
    }

    //puVar3 = 0x96B20
    puVar3 = PTR_DAT_8008d2ac;

	// turbo thread OnDestroy
    *(undefined4 *)(*(int *)(iVar5 + 0x6c) + 0x24) = 0x80069370;

    // s_turbo2_8008d624
    // "turbo2"

	// INSTANCE_Birth3D -- ptrModel, name, thread,
	// model 0x2c, first turbo_effect
    iVar8 = FUN_8003086c(*(undefined4 *)(puVar3 + 0x2210),
			s_turbo2_8008d624,

			// turbo thread
      *(undefined4 *)(iVar5 + 0x6c));

    //puVar3 = 0x96B20 (again)
    puVar3 = PTR_DAT_8008d2ac;

	// store pointer to 2nd turbo
	// inside Turbo object
    *piVar7 = iVar8;

    // if number of screens is not 1
    uVar6 = 0x1040000;

    // if number of screens is 1
    if (puVar3[0x1ca8] == '\x01')
	{
      uVar6 = 0x3040000;
    }

	// turbo (1/2) instance flag (attached to thread)
    *(uint *)(iVar5 + 0x28) =
	*(uint *)(iVar5 + 0x28) | uVar6 | 0x80;

	// turbo (2/2) instance flag (attached to object)
    *(uint *)(*piVar7 + 0x28) =
	*(uint *)(*piVar7 + 0x28) | uVar6 | 0x80;

    *(undefined2 *)(piVar7 + 2) = 0;
    if ((param_3 & 2) == 0) {
      uVar4 = 0xff;
    }
    else {
      uVar4 = 2;
    }
    *(undefined *)(piVar7 + 3) = uVar4;
  }

// This code only seem to run when you either are on a turbo pad/super turbo pad or you get any sort of boost
LAB_8005af38:

  // param_4 = multiplier that represents the level of fire of your boost
  // Constant values:
  // sacred fire speed cap = 0x1000
  // single turbo speed cap = 0x800

  // iVar5 = (param_4 * sacred fire speed cap) - (single turbo speed cap >> 8) + (single turbo speed cap)
  // iVar5 = ground speed cap represented by your multiplier

  iVar5 = (param_4 * ((int)*(short *)(param_1 + 0x432) - (int)*(short *)(param_1 + 0x430)) >> 8) +
          (int)*(short *)(param_1 + 0x430);

  if (
      (
		(
			// Reserves are equal to zero
			(*(short *)(param_1 + 0x3e2) == 0) ||

			// OR

			// Current ground speed cap is less than iVar5
			((int)*(short *)(param_1 + 0x3e4) < iVar5)
		) ||

		// OR

		(
			(
				// Current speed cap is greater than 0x1000
				(int)*(short *)(param_1 + 0x432) < (int)*(short *)(param_1 + 0x3e4) &&

				// AND

				// You are not on a super turbo pad
				((*(uint *)(param_1 + 0xbc) & 2) == 0)
			)
		)
	  ) &&

    // AND

	  (
		(
			// Current speed cap = iVar5
			*(undefined2 *)(param_1 + 0x3e4) = (short)iVar5,

			// Compare !=
			piVar7 != (int *)0x0 &&

			// AND

			(
				// Assignment
				iVar5 = (param_4 >> 6) + 5,

				// Assignment
				*(undefined2 *)((int)piVar7 + 10) = (short)iVar5,

				// Compoare <
				8 < iVar5 * 0x10000 >> 0x10
			)
		)
	  )
	 )
  {
    *(undefined2 *)((int)piVar7 + 10) = 8;
  }

  if ((param_3 & 8) != 0)
  {
    //turn on 14th bit of Actions Flag set (means racer is driving against a wall)
    *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) | 0x200;
  }

  sVar9 = (short)param_2;
  if ((param_3 & 1) == 0)
  {
    if ((param_3 & 0x10) == 0)
	{
	  // increase reserves BY param2
      *(short *)(param_1 + 0x3e2) = *(short *)(param_1 + 0x3e2) + sVar9;
    }
    else
	{
	  // increase reserves TO param2
      if (*(short *)(param_1 + 0x3e2) < param_2)
	  {
        *(short *)(param_1 + 0x3e2) = sVar9;
      }
    }
  }
  else {
    sVar2 = *(short *)(param_1 + 0x3de);
    if (*(short *)(param_1 + 0x3de) < param_2) {
      *(short *)(param_1 + 0x3de) = sVar9;
      *(short *)(param_1 + 0x3e2) = *(short *)(param_1 + 0x3e2) + (sVar9 - sVar2);
    }
  }

  // driver -> instance -> thread -> modelIndex == "player" of any kind
  if (*(short *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x44) == 0x18) {

	// CameraDC flag
    *(uint *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_1 + 0x4a) * 0xdc + 0x1508) =
         *(uint *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_1 + 0x4a) * 0xdc + 0x1508) | 0x80;

	// controller vibration
    FUN_800264c0(param_1,8,0x7f);
  }
  return;
}


// animation index, and number of frames
// 0 - midpoint (steering should start at midpoint)
// 1 - start
// 2 - start
// 3 - start
// 4 - end

// Instance_GetStartFrame
int FUN_8005b0c4(int param_1,int param_2)
{
  if (param_1 == 0) {
    return param_2 >> 1;
  }
  if (param_1 != 4) {
    return 0;
  }
  return param_2 + -1;
}


// get number of frames in animation
// param1 - instance
// param2 - animIndex
uint FUN_8005b0f4(int param_1,int param_2)
{
  int iVar1;

  // instance -> model
  iVar1 = *(int *)(param_1 + 0x18);

  // if model is valid, and if numHeaders is more than zero
  if ((((iVar1 != 0) && (0 < *(short *)(iVar1 + 0x12))) &&

	  // get header, check for nullptr
      (iVar1 = *(int *)(iVar1 + 0x14), iVar1 != 0)) &&

	  // animIndex < numAnimations in model
	  (param_2 < *(int *)(iVar1 + 0x34)))
  {
	// if pointer to animation data is valid
    if (*(int *)(iVar1 + 0x38) != 0)
	{
	  // get pointer to animation, given animIndex
      iVar1 = *(int *)(param_2 * 4 + *(int *)(iVar1 + 0x38));
      if (iVar1 != 0)
	  {
		// return number of animation frames
        return (uint)*(ushort *)(iVar1 + 0x10) & 0x7fff;
      }
      return 0;
    }
  }
  return 0;
}


// OnAnimate_Driving
// param1 = thread, param2 = driver
void FUN_8005b178(int param_1,int param_2)
{
  byte bVar1;
  undefined *puVar2;
  char cVar3;
  undefined2 uVar4;
  int iVar5;
  short sVar6;
  int iVar7;
  undefined4 uVar8;
  int iVar9;
  int iVar10;
  uint uVar11;

  // Get instance from thread
  iVar10 = *(int *)(param_1 + 0x34);

  // animation is drive forwards
  uVar11 = 0;

  //if you don't have a TNT over you and state of kart is not in a warp pad
  if ((*(int *)(param_2 + 0x18) == 0) && (*(char *)(param_2 + 0x376) != '\n'))
  {
    if (*(short *)(param_2 + 0x39e) < 0)
	{
      // check if you are driving backwards
	  // (0) forwards
	  // (1) backwards
      uVar11 = (uint)(*(short *)(param_2 + 0x38e) < 1);
    }
    if (((0x600 < *(short *)(param_2 + 0x390)) || (*(char *)(iVar10 + 0x52) == '\x03')) &&

	   // if player height is far from quadblock height
	   (0x8000 < *(int *)(param_2 + 0x2d8) - *(int *)(param_2 + 0x2d0)))
	{
	  // jumping animation
      uVar11 = 3;
    }
  }

  // get number of frames in animation
  iVar5 = FUN_8005b0f4(iVar10,(uint)*(byte *)(iVar10 + 0x52));

  // if animation has frames
  if (0 < iVar5)
  {
	// get animation frame currently
    bVar1 = *(byte *)(iVar10 + 0x52);

	// if animation changes
    if (uVar11 != (uint)bVar1)
	{
	  // if crashing animation
      if (bVar1 == 2)
	  {
		// get number of frames in animation
        iVar5 = FUN_8005b0f4(iVar10);

		// start on last frame
        iVar5 = iVar5 + -1;
      }

      else
	  {
		// Instance_GetStartFrame
        iVar5 = FUN_8005b0c4((uint)bVar1,iVar5);
      }

	  if ((int)*(short *)(iVar10 + 0x54) != iVar5) {
        if (*(char *)(iVar10 + 0x52) == '\0') {
          uVar8 = 6;
        }
        else {
          uVar8 = 2;
          if (*(char *)(iVar10 + 0x52) == '\x02') {
            uVar8 = 1;
            //kart emote frame = *(uchar *)(iVar10 + 0x54)
            *(undefined *)(param_2 + 0x4d) = *(undefined *)(iVar10 + 0x54);
          }
        }

		// Interpolate animation by speed
        uVar4 = FUN_80058f54((int)*(short *)(iVar10 + 0x54),uVar8,iVar5);
        *(undefined2 *)(iVar10 + 0x54) = uVar4;

        if (1 < (uint)*(byte *)(iVar10 + 0x52) - 2) {
          return;
        }

		// get animation frame from Instance
        cVar3 = *(char *)(iVar10 + 0x54);

        // Give it to driver
        *(char *)(param_2 + 0x4d) = cVar3;

		if (cVar3 != '\0') {
          return;
        }
        //kart animation Index
        *(undefined *)(param_2 + 0x4c) = 0;

        //kart animation frame
        *(undefined *)(param_2 + 0x4d) = 0;
        return;
      }

	  // get number of frames in animation
      iVar5 = FUN_8005b0f4(iVar10,uVar11);
      if (iVar5 < 1) {
        return;
      }

	  // set animation
      *(undefined *)(iVar10 + 0x52) = (char)uVar11;

	  // Instance_GetStartFrame
      uVar4 = FUN_8005b0c4(uVar11,iVar5);

	  // set animation frame
      *(undefined2 *)(iVar10 + 0x54) = uVar4;

	  // animation index
      *(undefined *)(param_2 + 0x4c) = 0;

	  // animation frame
	  *(undefined *)(param_2 + 0x4d) = 0;
    }
    //puVar2 = 0x96B20
    puVar2 = PTR_DAT_8008d2ac;

	if (uVar11 == 0)
	{
      iVar9 = iVar5 >> 1;

	  //if you don't have a TNT over you
      if (*(int *)(param_2 + 0x18) == 0)
	  {
        //sVar6 = time burnt left
        sVar6 = *(short *)(param_2 + 0x402);

		//if you're not burnt or your time burnt left is bigger than 0x1df
        if ((sVar6 == 0) || (0x1df < sVar6))
		{
		  //iVar9 = negative turning stat while braking
          iVar9 = -0x40;

		  //if you're not in accel prevention
          if ((*(uint *)(param_2 + 0x2c8) & 8) == 0) {
            //iVar7 = simplified turning state
            iVar7 = (int)*(char *)(param_2 + 0x4b);

			//uVar11 = character's turn stat
            uVar11 = (uint)*(byte *)(param_2 + 0x43a);

			//iVar9 = negative character's turn stat
            iVar9 = -uVar11;
          }
          //if you're braking or being mask grabbed
          else {
            //uVar11 = positive turning stat while braking
            uVar11 = 0x40;

			//iVar7 = amplified turning state
            iVar7 = (int)*(short *)(param_2 + 0xc0);
          }

          //seems like iVar9 gets set to 0 if you're turning, or to iVar5 - 1 if you're not
          // Map value from [oldMin, oldMax] to [newMin, newMax]
          // inverting newMin and newMax will give an inverse range mapping
          iVar9 = FUN_80058f9c(-iVar7,iVar9,uVar11,0,iVar5 + -1);
        }

        //if your time burnt left is between (0x0, 0x1df)
        else {
          iVar9 = (((int)(sVar6 >> 5) % 5) * 0x10000 >> 0xe) + -8 + iVar9;
          *(undefined2 *)(iVar10 + 0x54) = (short)iVar9;

		  // Create instance in particle pool
          iVar5 = FUN_80040308(0,*(undefined4 *)(puVar2 + 0x2118),&DAT_80089974);

          if (iVar5 != 0) {
            *(undefined *)(iVar5 + 0x18) = *(undefined *)(*(int *)(param_2 + 0x1c) + 0x50);

			// driver -> instSelf
            *(undefined4 *)(iVar5 + 0x20) = *(undefined4 *)(param_2 + 0x1c);

			// driverID
            *(undefined *)(iVar5 + 0x19) = *(undefined *)(param_2 + 0x4a);
          }
        }
      }
      sVar6 = *(short *)(iVar10 + 0x54);
    }
    else {
      if (uVar11 == 3)
	  {
		// Interpolate animation frame by speed
        uVar4 = FUN_80058f54((int)*(short *)(iVar10 + 0x54),1,iVar5 + -1);

		// set animation frame
        *(undefined2 *)(iVar10 + 0x54) = uVar4;

		    //if you're getting mask grabbed
        if (*(char *)(param_2 + 0x376) == '\x05') {
          return;
        }

    //player / AI structure + 0x4a shows driver index (0-7)

		    //get character ID
        sVar6 = (&DAT_80086e84)[*(byte *)(param_2 + 0x4a)];

		    //if this is penta
        if (sVar6 == 0xd) {
          sVar6 = 3;
        }

		    //if this is fake crash
        if (sVar6 == 0xe) {
          sVar6 = 0;
        }

		//cVar3 = (char)sVar6 + 0x7
        cVar3 = (char)sVar6 + '\a';

		    //if this is oxide
        if (sVar6 == 0xf) {
          //cVar3 = 0x7 (hex equivalent of ascii \a)
          cVar3 = '\a';
        }

		// set animation
        *(char *)(param_2 + 0x4c) = cVar3;

        // set animation frame
        *(undefined *)(param_2 + 0x4d) = *(undefined *)(iVar10 + 0x54);
        return;
      }
      iVar9 = iVar5 + -1;

	  // set animation frame
      sVar6 = *(short *)(iVar10 + 0x54);
    }

	// Interpolate rotation by speed
    uVar4 = FUN_80058f54((int)sVar6,1,iVar9);

	  // set animation frame
    *(undefined2 *)(iVar10 + 0x54) = uVar4;
    return;
  }
  return;
}

// OnAnimate_Spinning
// param1 = thread, param2 = driver
void FUN_8005b510(int param_1,int param_2)

{
  undefined2 uVar1;
  int iVar2;
  int iVar3;
  int iVar4;

  // get instance from thread
  iVar4 = *(int *)(param_1 + 0x34);

  // get number of frames in animation
  iVar2 = FUN_8005b0f4(iVar4,(uint)*(byte *)(iVar4 + 0x52));

  // if there are no frames
  if (iVar2 < 1)
  {
	// quit
    return;
  }

  // if animation is not zero
  if (*(byte *)(iVar4 + 0x52) != 0)
  {
	// Instance_GetStartFrame
    iVar3 = FUN_8005b0c4((uint)*(byte *)(iVar4 + 0x52),iVar2);

	// If animation is negative
    if ((uint)*(byte *)(iVar4 + 0x52) - 2 < 2)
	{
	  // reset animation id and frame
      *(undefined *)(param_2 + 0x4c) = 0;
      *(undefined *)(param_2 + 0x4d) = 0;
    }

    if ((int)*(short *)(iVar4 + 0x54) == iVar3)
	{
	  // get number of frames in animation
      iVar2 = FUN_8005b0f4(iVar4,0);
      if (iVar2 < 1) {
        return;
      }

	  // set animation
      *(undefined *)(iVar4 + 0x52) = 0;
    }
    if (*(char *)(iVar4 + 0x52) != '\0') goto LAB_8005b5d0;
  }
  iVar3 = 0;
  if (-1 < *(short *)(param_2 + 0x582)) {
    iVar3 = iVar2 + -1;
  }
LAB_8005b5d0:

  // Interpolate animation frame by speed
  uVar1 = FUN_80058f54((int)*(short *)(iVar4 + 0x54),4,iVar3);

  // set animation frame
  *(undefined2 *)(iVar4 + 0x54) = uVar1;

  return;
}

// OnAnimate_LastSpin
// param1 = thread, param2 = driver
void FUN_8005b5fc(int param_1,int param_2)

{
  short sVar1;
  undefined2 uVar2;
  int iVar3;
  int iVar4;
  int iVar5;

  // get instance from thread
  iVar5 = *(int *)(param_1 + 0x34);

  // if animation is zero
  if (*(char *)(iVar5 + 0x52) == '\0')
  {
	// get number of frames in animation
    iVar3 = FUN_8005b0f4(iVar5,0);

    if (0 < iVar3) {
      sVar1 = *(short *)(param_2 + 0x3c6);

	  // get animation frame
      iVar4 = (int)*(short *)(iVar5 + 0x54);

      if (0 < sVar1)
	  {
        if (*(short *)(param_2 + 0x3d2) < 0) {
          iVar4 = iVar3 + -1;
        }
        sVar1 = *(short *)(param_2 + 0x3c6);
      }

      if ((sVar1 < 0) && (0 < *(short *)(param_2 + 0x3d2))) {
        iVar4 = 0;
      }

	  // Interpolate animation frame by speed
      uVar2 = FUN_80058f54((int)*(short *)(iVar5 + 0x54),3,iVar4);

	  // set animation frame
      *(undefined2 *)(iVar5 + 0x54) = uVar2;
    }
  }
  else
  {
	// OnAnimate_Spinning
    FUN_8005b510();
  }
  return;
}


// without this, all shadows are solid rectangles
// Shadow_Subset
undefined4 FUN_8005b6b8(undefined4 *param_1,int param_2)

{
  int iVar1;

  // get pointer to icon
  iVar1 = *(int *)(PTR_DAT_8008d2ac + param_2 * 4 + 0x1eec);

  // if icon is valid
  if (iVar1 != 0) {
    *param_1 = *(undefined4 *)(iVar1 + 0x14);
    param_1[1] = *(uint *)(iVar1 + 0x18) & 0xff9fffff | 0x400000;
    *(undefined2 *)(param_1 + 2) = *(undefined2 *)(iVar1 + 0x1c);
    *(undefined2 *)((int)param_1 + 10) = *(undefined2 *)(iVar1 + 0x1e);
    return 1;
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Restarted to delay deadcode elimination for space: ram

//draws shadows
void FUN_8005b720(void)

{
  undefined *puVar1;
  char cVar2;
  ushort uVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  short sVar8;
  int iVar9;
  MATRIX *pMVar10;
  int iVar11;
  uint *puVar12;
  uint uVar13;
  short sVar14;
  undefined *puVar15;
  uint *puVar16;
  int iVar17;
  short sVar18;
  int iVar19;
  int iVar20;
  uint uVar21;
  MATRIX *r0;
  uint *puVar22;
  uint *puVar23;
  uint *puVar24;
  uint *puVar25;
  undefined2 *puVar26;
  SVECTOR *r0_00;
  undefined *puVar27;
  uint *puVar28;
  undefined auStack72 [32];
  
  puVar27 = auStack72;
  puVar23 = &DAT_1f800000;
  
  // without this, all shadows are solid rectangles
  iVar4 = FUN_8005b6b8(&DAT_1f800224,0);
  
  if (
		(
			(iVar4 != 0) && 
			(
				// without this, all shadows are solid rectangles
				iVar4 = FUN_8005b6b8(&DAT_1f800230,1), 
				iVar4 != 0
			)
		) &&
     
		(
			// backBuffer->primMem.curr
			puVar28 = *(uint **)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80),
		
			// if enough primMem remains to draw shadows
			puVar28 + 0x140 < *(uint **)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x84)
		)
	  ) 
  {
	// set transformation vector to (0,0,0)
    _DAT_1f800090 = 0;
    DAT_1f800094 = 0;
    DAT_1f800098 = 0;
    gte_SetTransVector((VECTOR *)&DAT_1f800090);
	
	// loop counter
    iVar4 = 0;
	
    puVar15 = (undefined *)((uint)puVar23 | 0xb6);
    uVar21 = (uint)puVar23 | 0xa4;
	
	// for iVar4 = 0; iVar4 < 8; iVar4++
    do 
	{
      uVar6 = uVar21;
      puVar1 = PTR_DAT_8008d2ac;
	  
	  // pointer to each player structure
      iVar11 = *(int *)(PTR_DAT_8008d2ac + iVar4 * 4 + 0x24ec);
	  
	  // if player pointer is invalid
      if (iVar11 == 0) {
        *(undefined4 *)(puVar15 + 2) = 0;
      }
	  
	  // if player pointer is valid
      else 
	  {
        *(int *)(puVar15 + 2) = iVar11;
        
		// get instance
		iVar19 = *(int *)(iVar11 + 0x1c);
        
		*(int *)(puVar15 + 6) = iVar19;
        
											// instance flags
		*(undefined2 *)(puVar15 + 0x14) = *(undefined2 *)(iVar19 + 0x28);
        
		// number of screens - 1
		iVar17 = (byte)puVar1[0x1ca8] - 1;
        
		// numPlayers > 0
		if (-1 < iVar17) 
		{
		  // InstDrawPerPlayer = Instance -> InstDrawPerPlayer[iVar17]
          iVar9 = iVar17 * 0x88 + iVar19;
          
		  // loop for all players
		  do 
		  {
			// flags?
            puVar1 = (undefined *)(iVar9 + 0xb8);
			
			// next InstDrawPerPlayer
            iVar9 = iVar9 + -0x88;
			
            iVar5 = uVar6 + iVar17;
            iVar17 = iVar17 + -1;
            *(undefined *)(iVar5 + 0x1c) = *puVar1;
          } while (-1 < iVar17);
        }
		
		// PlayerX, quadblockHeight+3, PlayerZ
        *(short *)(puVar15 + 0xe) = (short)((uint)*(undefined4 *)(iVar11 + 0x2d4) >> 8);
        *(short *)(puVar15 + 0x10) = (short)((uint)*(undefined4 *)(iVar11 + 0x2d0) >> 8) + 3;
        *(short *)(puVar15 + 0x12) = (short)((uint)*(undefined4 *)(iVar11 + 0x2dc) >> 8);
        
		if ((*(ushort *)(puVar15 + 0x14) & 0x2000) == 0) {
          cVar2 = *(char *)(iVar19 + 0x50);
        }
        else {
          cVar2 = *(char *)(iVar19 + 0x51);
        }
        puVar15[1] = cVar2 + '\x01';
      }
      *puVar15 = 0;
      puVar1 = PTR_DAT_8008d2ac;
	  
	  // increment loop iteration counter
      iVar4 = iVar4 + 1;
	  
      puVar15 = puVar15 + 0x28;
      uVar21 = uVar6 + 0x28;
    } while (iVar4 < 8);
    
	*(undefined4 *)(uVar6 + 0x3c) = 0;
	
	// number of screens - 1
    iVar4 = (byte)puVar1[0x1ca8] - 1;
	
	// loop through all player screens
    if (-1 < iVar4) 
	{
      iVar11 = -1;
      r0_00 = (SVECTOR *)(puVar23 + 0x12);
      uVar21 = 1;
	  
	  // camera110 offset 0x38
      puVar26 = (undefined2 *)(puVar1 + iVar4 * 0x110 + 0x1a0);
	  
      do {
        puVar23[0x90] = *(uint *)(puVar26 + -0x10);
        puVar23[0x8f] = *(uint *)(puVar26 + 0x5e);
		
		// screen dimensions
        gte_SetGeomOffset((int)((uint)(ushort)puVar26[-0xc] << 0x10) >> 0x11,
                          (int)((uint)(ushort)puVar26[-0xb] << 0x10) >> 0x11);
						  
		// distToScreen
        gte_ldH(puVar23[0x90]);
		
        puVar23[0x24] = *(uint *)(puVar26 + 0x22);
        puVar23[0x25] = *(uint *)(puVar26 + 0x24);
        puVar23[0x26] = *(uint *)(puVar26 + 0x26);
        puVar23[0x14] = *(uint *)(puVar26 + -8);
        puVar23[0x15] = *(uint *)(puVar26 + -6);
        puVar23[0x16] = *(uint *)(puVar26 + -4);
        uVar6 = *(uint *)(puVar26 + -2);
        *(undefined2 *)(puVar23 + 0x18) = *puVar26;
        puVar23[0x17] = uVar6;
		
        gte_SetRotMatrix((MATRIX *)(puVar23 + 0x14));
        
		puVar12 = puVar23 + 0x29;
        uVar6 = puVar23[0x2e];
        if (uVar6 != 0) {
          puVar22 = puVar23 + 0x2e;
          do {
            if (*(char *)((int)puVar22 + -2) != iVar11) {
              if ((*(ushort *)((int)puVar22 + 0x12) & 0x80) == 0) {
                if ((*(byte *)((int)puVar12 + iVar4 + 0x1c) & 0x40) != 0) {
                  uVar3 = *(ushort *)(puVar22 + 3);
                  *(short *)(puVar23 + 0x27) =
                       (short)((uint)uVar3 - (uint)*(ushort *)(puVar23 + 0x24)) * 4;
                  iVar9 = (int)(((uint)uVar3 - (uint)*(ushort *)(puVar23 + 0x24)) * 0x40000) >> 0x10
                  ;
                  iVar17 = (uint)*(ushort *)((int)puVar22 + 0xe) - (uint)*(ushort *)(puVar23 + 0x25)
                  ;
                  *(short *)((int)puVar23 + 0x9e) = (short)iVar17 * 4;
                  iVar19 = iVar17 * 0x40000 >> 0x10;
                  iVar17 = (int)(((uint)*(ushort *)(puVar22 + 4) - (uint)*(ushort *)(puVar23 + 0x26)
                                 ) * 0x40000) >> 0x10;
                  *(short *)(puVar23 + 0x28) =
                       (short)((uint)*(ushort *)(puVar22 + 4) - (uint)*(ushort *)(puVar23 + 0x26)) *
                       4;
                  uVar7 = (uint)((int)puVar23[0x90] < 0x101);
                  if ((uVar7 == 0) ||
                     ((((iVar9 < 0x1771 && (iVar19 < 0x1771)) &&
                       ((iVar17 < 0x1771 && ((-0x1771 < iVar9 && (-0x1771 < iVar19)))))) &&
                      (-0x1771 < iVar17)))) {
                    gte_ldv0((SVECTOR *)(puVar23 + 0x27));
                    gte_rtv0();
                    iVar5 = gte_stMAC3();
                    iVar5 = iVar5 >> 2;
                    if (-0x35 < iVar5) {
                      if (uVar7 == 0) {
                        uVar7 = 0x2e1f1f1f;
                      }
                      else {
                        if (iVar5 < 0x180) {
                          uVar7 = 0x1f;
                        }
                        else 
						{
						  // asm address 8005bb04,
						  // changing 0x200 to 0x800, increases
						  // the render distance of shadows
                          iVar5 = (0x200 - iVar5) * 0x1f;
						  
                          if (iVar5 < 0) {
                            iVar5 = iVar5 + 0x7f;
                          }
                          
						  uVar7 = iVar5 >> 7;
                          
						  // skip shadow draw
						  if ((int)uVar7 < 1) goto LAB_8005c0b8;
                        }
                        uVar7 = uVar7 | uVar7 << 8 | 0x2e000000 | uVar7 << 0x10;
                      }
                      puVar25 = puVar12;
                      if (*(char *)((int)puVar22 + -2) == '\0') 
					  {
						// player height, minus quadblock height
                        iVar17 = 0x100 - (*(int *)(uVar6 + 0x2d8) - *(int *)(uVar6 + 0x2d0) >> 8);
                        
						// if driver is too far from ground, skip shadow draw
						if ((iVar17 < 1) || (0x109 < iVar17)) goto LAB_8005bb94;
						
                        r0 = (MATRIX *)(puVar23 + 0x1c);
                        if (0x100 < iVar17) {
                          iVar17 = 0x100;
                        }
                        iVar19 = (int)*(short *)(uVar6 + 0x2ee);
                        *(int *)(puVar27 + 0x10) = iVar11;
                        *(uint *)(puVar27 + 0x14) = uVar21;
                        *(SVECTOR **)(puVar27 + 0x18) = r0_00;
                        pMVar10 = r0;
						
						// Rot_AxisAngle
                        FUN_8005f89c(r0,uVar6 + 0x370);
						
                        gte_SetLightMatrix(r0);
                        
						// loop counter
						uVar6 = 0;
						
                        iVar20 = iVar17 * 0x29 >> 6;
                        iVar5 = iVar17 * 0x34 >> 6;
                        *(short *)(puVar23 + 0x12) = (short)(iVar17 * 0x28 >> 6);
                        *(undefined2 *)((int)puVar23 + 0x4a) = 0;
                        *(undefined2 *)(puVar23 + 0x13) = 0;
                        r0_00 = *(SVECTOR **)(puVar27 + 0x18);
                        uVar21 = *(uint *)(puVar27 + 0x14);
                        iVar11 = *(int *)(puVar27 + 0x10);
                        puVar25 = puVar12;
						
						// for uVar6 = 0; uVar6 < 3; uVar6++
                        do 
						{
                          gte_ldv0(r0_00);
                          gte_llv0();
                          if (uVar6 == 0) {
                            *(undefined2 *)(puVar23 + 0x12) = 0;
                            *(short *)(puVar23 + 0x13) = (short)iVar20;
                          }
                          else if (uVar6 == uVar21) {
                            *(short *)(puVar23 + 0x13) = (short)iVar5;
                          }
                          read_mt(iVar9,iVar19,pMVar10);
                          *(short *)puVar12 = (short)iVar9;
                          *(short *)((int)puVar12 + 2) = (short)iVar19;
                          *(short *)(puVar12 + 1) = (short)pMVar10;
						  
						  // increment loop counter
                          uVar6 = uVar6 + 1;
						  
                          puVar12 = (uint *)((int)puVar12 + 6);
                        
						} while ((int)uVar6 < 3);
						
                        gte_SetRotMatrix((MATRIX *)(puVar23 + 0x14));
						
                        sVar8 = *(short *)(puVar23 + 0x27);
                        sVar14 = *(short *)((int)puVar23 + 0x9e);
                        sVar18 = *(short *)(puVar23 + 0x28);
                        *(char *)((int)puVar22 + -2) = (char)uVar21;
                        iVar9 = (int)sVar8;
                        iVar19 = (int)sVar14;
                        iVar17 = (int)sVar18;
                      }
                      sVar18 = (short)iVar9;
                      *(short *)(puVar23 + 0x83) = sVar18;
                      sVar14 = (short)iVar19;
                      *(short *)((int)puVar23 + 0x20e) = sVar14;
                      sVar8 = (short)iVar17;
                      *(short *)(puVar23 + 0x84) = sVar8;
                      *(short *)(puVar23 + 0x85) =
                           (sVar18 - *(short *)puVar25) - *(short *)((int)puVar22 + -0xe);
                      *(short *)((int)puVar23 + 0x216) =
                           (sVar14 - *(short *)((int)puVar22 + -0x12)) - *(short *)(puVar22 + -3);
                      *(short *)(puVar23 + 0x86) =
                           (sVar8 - *(short *)(puVar22 + -4)) - *(short *)((int)puVar22 + -10);
                      iVar5 = 0;
                      *(short *)(puVar23 + 0x87) = sVar18 - *(short *)((int)puVar22 + -0xe);
                      iVar20 = 0x24;
                      *(short *)((int)puVar23 + 0x21e) = sVar14 - *(short *)(puVar22 + -3);
                      *(short *)(puVar23 + 0x88) = sVar8 - *(short *)((int)puVar22 + -10);
                      puVar24 = puVar23;
                      do {
                        gte_ldv3c((SVECTOR *)(puVar24 + 0x83));
                        gte_rtpt();
                        sVar8 = (short)iVar9;
                        sVar14 = (short)iVar19;
                        sVar18 = (short)iVar17;
                        if (iVar5 == 0) {
                          *(short *)(puVar24 + 0x83) =
                               (*(short *)puVar25 + sVar8) - *(short *)((int)puVar22 + -0xe);
                          *(short *)((int)puVar24 + 0x20e) =
                               (*(short *)((int)puVar22 + -0x12) + sVar14) -
                               *(short *)(puVar22 + -3);
                          *(short *)(puVar24 + 0x84) =
                               (*(short *)(puVar22 + -4) + sVar18) - *(short *)((int)puVar22 + -10);
                          *(short *)(puVar24 + 0x85) = *(short *)puVar25 + sVar8;
                          *(short *)((int)puVar24 + 0x216) =
                               *(short *)((int)puVar22 + -0x12) + sVar14;
                          *(short *)(puVar24 + 0x86) = *(short *)(puVar22 + -4) + sVar18;
                          *(short *)(puVar24 + 0x87) =
                               *(short *)(puVar22 + -2) + *(short *)puVar25 + sVar8;
                          *(short *)((int)puVar24 + 0x21e) =
                               *(short *)((int)puVar22 + -6) +
                               *(short *)((int)puVar22 + -0x12) + sVar14;
                          *(short *)(puVar24 + 0x88) =
                               *(short *)(puVar22 + -1) + *(short *)(puVar22 + -4) + sVar18;
                        }
                        else if (iVar5 == 3) {
                          *(short *)(puVar24 + 0x83) = *(short *)(puVar22 + -2) + sVar8;
                          *(short *)((int)puVar24 + 0x20e) = *(short *)((int)puVar22 + -6) + sVar14;
                          *(short *)(puVar24 + 0x84) = *(short *)(puVar22 + -1) + sVar18;
                          *(short *)(puVar24 + 0x85) =
                               *(short *)(puVar22 + -2) + (sVar8 - *(short *)puVar25);
                          *(short *)((int)puVar24 + 0x216) =
                               *(short *)((int)puVar22 + -6) +
                               (sVar14 - *(short *)((int)puVar22 + -0x12));
                          *(short *)(puVar24 + 0x86) =
                               *(short *)(puVar22 + -1) + (sVar18 - *(short *)(puVar22 + -4));
                          *(short *)(puVar24 + 0x87) = sVar8 - *(short *)puVar25;
                          *(short *)((int)puVar24 + 0x21e) =
                               sVar14 - *(short *)((int)puVar22 + -0x12);
                          *(short *)(puVar24 + 0x88) = sVar18 - *(short *)(puVar22 + -4);
                        }
                        gte_stsxy3c((long *)puVar23);
                        gte_stsz3c((long *)((int)puVar24 + iVar20));
                        iVar20 = iVar20 + 0xc;
                        iVar5 = iVar5 + 3;
                        puVar23 = puVar23 + 3;
                      } while (iVar5 < 9);
                      uVar6 = 0;
                      puVar16 = puVar28 + 8;
                      do {
                        puVar23 = puVar24 + 0x89;
                        if ((uVar6 & 1) != 0) {
                          puVar23 = puVar24 + 0x8c;
                        }
                        puVar16[-7] = uVar7;
                        puVar16[-5] = *puVar23;
                        puVar16[-3] = puVar23[1];
                        *(undefined2 *)(puVar16 + -1) = *(undefined2 *)(puVar23 + 2);
                        *(undefined2 *)(puVar16 + 1) = *(undefined2 *)((int)puVar23 + 10);
                        if (uVar6 == uVar21) {
                          puVar16[-6] = puVar24[8];
                          puVar16[-4] = *puVar24;
                          puVar16[-2] = puVar24[7];
LAB_8005c044:
                          *puVar16 = puVar24[6];
                        }
                        else if ((int)uVar6 < 2) {
                          if (uVar6 == 0) {
                            puVar16[-6] = puVar24[8];
                            puVar16[-4] = *puVar24;
                            puVar16[-2] = puVar24[1];
                            *puVar16 = puVar24[2];
                          }
                        }
                        else if (uVar6 == 2) {
                          puVar16[-6] = puVar24[4];
                          puVar16[-4] = *puVar24;
                          puVar16[-2] = puVar24[3];
                          *puVar16 = puVar24[2];
                        }
                        else if (uVar6 == 3) {
                          puVar16[-6] = puVar24[4];
                          puVar16[-4] = *puVar24;
                          puVar16[-2] = puVar24[5];
                          goto LAB_8005c044;
                        }
                        iVar19 = ((int)puVar24[9] >> 8) + (int)*(char *)((int)puVar22 + -1);
                        iVar17 = iVar19;
                        if (iVar19 < 0) {
                          iVar17 = 0;
                        }
                        if (0x3ff < iVar19) {
                          iVar17 = 0x3ff;
                        }
                        puVar16 = puVar16 + 10;
                        uVar6 = uVar6 + 1;
                        uVar13 = (uint)puVar28 & 0xffffff;
                        puVar23 = (uint *)(puVar24[0x8f] + iVar17 * 4);
                        *puVar28 = *puVar23 | 0x9000000;
                        puVar28 = puVar28 + 10;
                        *puVar23 = uVar13;
                        puVar23 = puVar24;
                        puVar12 = puVar25;
                      } while ((int)uVar6 < 4);
                    }
                  }
                }
              }
              else {
LAB_8005bb94:
                *(char *)((int)puVar22 + -2) = (char)iVar11;
              }
            }
LAB_8005c0b8:
            puVar22 = puVar22 + 10;
            uVar6 = *puVar22;
            puVar12 = puVar12 + 10;
          } while (uVar6 != 0);
        }
        iVar4 = iVar4 + -1;
        puVar26 = puVar26 + -0x88;
      } while (-1 < iVar4);
    }
	
	// backBuffer->primMem.curr
    *(uint **)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80) = puVar28;
  }
  return;
}


// DrawSkidMarks_Subset1
void FUN_8005c120(uint *param_1,uint *param_2,int param_3,int param_4)

{
  undefined *puVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  uint *puVar5;
  uint *puVar6;

  puVar1 = PTR_DAT_8008d2ac;

  // gGT->backDB
  iVar3 = *(int *)(PTR_DAT_8008d2ac + 0x10);

  // primMem.curr
  puVar6 = *(uint **)(iVar3 + 0x80);

  // if there is room to draw
  if (puVar6 + 0xd <= *(uint **)(iVar3 + 0x84))
  {
    
	// primMem.curr += 0x34
	*(uint **)(iVar3 + 0x80) = puVar6 + 0xd;
	
    puVar6[1] = *(uint *)(param_4 + 0x1c);
    puVar6[4] = *(uint *)(param_4 + 0x1c);
    puVar6[7] = *(uint *)(param_4 + 0x20);
    puVar6[10] = *(uint *)(param_4 + 0x20);
    puVar6[2] = *param_1;
    puVar6[5] = param_1[1];
    puVar6[8] = *param_2;
    puVar6[0xb] = param_2[1];
	
	// gGT->0x1fa8 = gGT->0x1eec[0x2f*4] = skidmark
	
    puVar6[3] = *(uint *)(*(int *)(puVar1 + 0x1fa8) + 0x14);
    if ((*(uint *)(param_4 + 0x24) & 1) == 0) {
      uVar2 = *(uint *)(*(int *)(puVar1 + 0x1fa8) + 0x18);
      uVar4 = 0x400000;
    }
    else {
      uVar2 = *(uint *)(*(int *)(puVar1 + 0x1fa8) + 0x18);
      uVar4 = 0x600000;
    }
    puVar6[6] = uVar2 & 0xff9fffff | uVar4;
    puVar1 = PTR_DAT_8008d2ac;
    *(undefined2 *)(puVar6 + 9) = *(undefined2 *)(*(int *)(PTR_DAT_8008d2ac + 0x1fa8) + 0x1c);
    *(undefined2 *)(puVar6 + 0xc) = *(undefined2 *)(*(int *)(puVar1 + 0x1fa8) + 0x1e);
    puVar5 = (uint *)(*(int *)(*(int *)(param_4 + 0x18) + 0xf4) + (param_3 >> 6) * 4);
    *puVar6 = *puVar5 | 0xc000000;
    *puVar5 = (uint)puVar6 & 0xffffff;
  }
  return;
}


// DrawSkidMarks_Subset2
void FUN_8005c278(short *param_1,short *param_2,short *param_3,short *param_4)

{
  *param_1 = (*param_2 - param_1[0x5c]) * 4;
  param_1[1] = (param_2[1] - param_1[0x5e]) * 4;
  param_1[2] = (param_2[2] - param_1[0x60]) * 4;
  param_1[4] = (*param_3 - param_1[0x5c]) * 4;
  param_1[5] = (param_3[1] - param_1[0x5e]) * 4;
  param_1[6] = (param_3[2] - param_1[0x60]) * 4;
  param_1[8] = (*param_4 - param_1[0x5c]) * 4;
  param_1[9] = (param_4[1] - param_1[0x5e]) * 4;
  param_1[10] = (param_4[2] - param_1[0x60]) * 4;
  return;
}


// draws skidmarks
// param_1 - thread pointer (player or robot)
// param_2 - camera110 pointer
void FUN_8005c354(undefined4 param_1,int param_2)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  SVECTOR *pSVar6;
  SVECTOR *pSVar7;
  SVECTOR *r0;
  SVECTOR *pSVar8;
  SVECTOR *r0_00;
  uint uVar9;
  SVECTOR *pSVar10;
  undefined *puVar11;
  uint uVar12;
  undefined auStack64 [24];
  
  puVar11 = auStack64;
  
  // window dimensions
  gte_SetGeomOffset((int)((uint)*(ushort *)(param_2 + 0x20) << 0x10) >> 0x11,
                    (int)((uint)*(ushort *)(param_2 + 0x22) << 0x10) >> 0x11);
	
  // distance to screen	
  gte_ldH(*(undefined4 *)(param_2 + 0x18));
  
  r0 = (SVECTOR *)&DAT_1f800000;
  DAT_1f8000b8 = 0;
  DAT_1f8000bc = 0;
  DAT_1f8000c0 = 0;
  DAT_1f800018 = param_2;
  
  // camera110 offset 0x28, ViewProj
  gte_SetRotMatrix((MATRIX *)(param_2 + 0x28));
  gte_SetTransVector((VECTOR *)&DAT_1f8000b8);
  
  *(undefined4 *)(r0 + 0x17) = *(undefined4 *)(param_2 + 0x7c);
  *(undefined4 *)&r0[0x17].vz = *(undefined4 *)(param_2 + 0x80);
  *(undefined4 *)(r0 + 0x18) = *(undefined4 *)(param_2 + 0x84);
  
  // this is "somehow" param_1 (thread)
  iVar5 = *(int *)(puVar11 + 0x40);
  
  do {
    if (iVar5 == 0) {
      return;
    }
	
	// thread -> object
    iVar5 = *(int *)(*(int *)(puVar11 + 0x40) + 0x30);
	
    *(int *)(puVar11 + 0x10) = iVar5;
	
	// if skidmarks are enabled...
	// will be enabled for 7 frames after drift stops,
	// because of how the bit shifting works
    uVar9 = *(uint *)(iVar5 + 0x2c4);
	
	// if skidmarks are enabled
    if (0xf < uVar9) {
      uVar12 = 0;
      pSVar7 = r0 + 5;
      pSVar6 = r0 + 0xe;
      pSVar10 = (SVECTOR *)&r0[9].vz;
      uVar1 = *(byte *)(iVar5 + 0xc3) - 1 & 7;
      *(uint *)(puVar11 + 0x14) = uVar1;
      iVar5 = iVar5 + uVar1 * 0x40;
      iVar2 = (int)*(short *)(iVar5 + 0xc4) - *(int *)(r0 + 0x17);
      iVar4 = iVar2 * 4;
      iVar3 = iVar4;
      if (iVar4 < 0) {
        iVar3 = iVar2 * -4;
      }
      pSVar8 = (SVECTOR *)&r0[0x12].vz;
      if (iVar3 < 0x1771) {
        r0->vx = (short)iVar4;
        iVar2 = (int)*(short *)(iVar5 + 0xc6) - *(int *)&r0[0x17].vz;
        iVar4 = iVar2 * 4;
        iVar3 = iVar4;
        if (iVar4 < 0) {
          iVar3 = iVar2 * -4;
        }
        if (iVar3 < 0x1771) {
          r0->vy = (short)iVar4;
          iVar3 = (int)*(short *)(iVar5 + 200) - *(int *)(r0 + 0x18);
          iVar2 = iVar3 * 4;
          iVar5 = iVar2;
          if (iVar2 < 0) {
            iVar5 = iVar3 * -4;
          }
          if (iVar5 < 0x1771) {
            r0->vz = (short)iVar2;
            gte_ldv0(r0);
            gte_rtv0();
            iVar5 = gte_stMAC3();
            if (iVar5 >> 2 < 0x180) {
              uVar1 = 0x7f;
            }
            else {
              gte_ldLZCS((iVar5 >> 2) + -0x180);
              iVar5 = gte_stLZCR();
              uVar1 = 0x1a - iVar5;
              if ((int)uVar1 < 0) {
                uVar1 = 0;
              }
              uVar1 = 0x7f >> (uVar1 & 0x1f);
              if ((int)uVar1 < 0x10) goto LAB_8005c9dc;
            }
            *(uint *)&r0[3].vz = uVar1 | uVar1 << 8 | 0x3e000000 | uVar1 << 0x10;
            *(undefined4 *)(r0 + 4) = 0xffffffff;
            do {
              uVar1 = uVar9;
              r0_00 = pSVar7;
              pSVar7 = pSVar6;
              if (uVar1 == 0) break;
              if ((uVar1 & 0xf) != 0) 
			  {
                iVar3 = *(int *)(puVar11 + 0x14) * 0x40;
                iVar5 = *(int *)(puVar11 + 0x10) + iVar3 + 0xc4;
                
				FUN_8005c278(r0,iVar5,iVar5 + 8,iVar5 + 0x10);
                gte_ldv3c(r0);
                gte_rtpt();
				
                FUN_8005c278(r0,iVar5 + 0x18,iVar5 + 0x20,iVar5 + 0x28);
                gte_stsxy3c((long *)r0_00);
                gte_stsz3c((long *)pSVar7);
                gte_ldv3c(r0);
                gte_rtpt();
                
				FUN_8005c278(r0,iVar5 + 0x30,iVar5 + 0x38,iVar5);
                gte_stsxy3c((long *)&r0_00[1].vz);
                gte_stsz3c((long *)&pSVar7[1].vz);
                gte_ldv3c(r0);
                gte_rtpt();
                
				gte_stsxy3c((long *)(r0_00 + 3));
                gte_stsz3c((long *)(pSVar7 + 3));
                
				// skidmark primitive 1/4
				if (((((uVar1 & uVar12 & 1) != 0) && (0x20 < *(int *)pSVar7)) &&
                    (0x20 < *(int *)&pSVar7->vz)) &&
                   ((0x20 < *(int *)pSVar8 && (0x20 < *(int *)&pSVar8->vz)))) 
				{
                  iVar5 = *(int *)(puVar11 + 0x10);
                  *(uint *)&r0[4].vz = (uint)*(byte *)(iVar5 + iVar3 + 0xcb);
                  
				  // draw prim
				  FUN_8005c120(r0_00,pSVar10,
                               (*(int *)pSVar7 >> 2) + (uint)*(byte *)(iVar5 + iVar3 + 0xca) * 0x40,
                               r0);
                }
				
				// skidmark primitive 2/4
                if ((((uVar1 & uVar12 & 2) != 0) && (0x20 < *(int *)(pSVar7 + 1))) &&
                   ((0x20 < *(int *)&pSVar7[1].vz &&
                    ((0x20 < *(int *)(pSVar8 + 1) && (0x20 < *(int *)&pSVar8[1].vz)))))) 
				{
                  iVar5 = *(int *)(puVar11 + 0x14);
                  iVar3 = *(int *)(puVar11 + 0x10);
                  *(uint *)&r0[4].vz = (uint)*(byte *)(iVar3 + iVar5 * 0x40 + 0xdb);
                  
				  // draw prim
				  FUN_8005c120(r0_00 + 1,pSVar10 + 1,
                               (*(int *)(pSVar7 + 1) >> 2) +
                               (uint)*(byte *)(iVar3 + iVar5 * 0x40 + 0xda) * 0x40,r0);
                }
				
				// skidmark primitive 3/4
                if (((((uVar1 & uVar12 & 4) != 0) && (0x20 < *(int *)(pSVar7 + 2))) &&
                    (0x20 < *(int *)&pSVar7[2].vz)) &&
                   ((0x20 < *(int *)(pSVar8 + 2) && (0x20 < *(int *)&pSVar8[2].vz)))) 
				{
                  iVar5 = *(int *)(puVar11 + 0x14);
                  iVar3 = *(int *)(puVar11 + 0x10);
                  *(uint *)&r0[4].vz = (uint)*(byte *)(iVar3 + iVar5 * 0x40 + 0xeb);
                  
				  // draw prim
				  FUN_8005c120(r0_00 + 2,pSVar10 + 2,
                               (*(int *)(pSVar7 + 2) >> 2) +
                               (uint)*(byte *)(iVar3 + iVar5 * 0x40 + 0xea) * 0x40,r0);
                }
				
				// skidmark primitive 4/4
                if ((((uVar1 & uVar12 & 8) != 0) && (0x20 < *(int *)(pSVar7 + 3))) &&
                   ((0x20 < *(int *)&pSVar7[3].vz &&
                    ((0x20 < *(int *)(pSVar8 + 3) && (0x20 < *(int *)&pSVar8[3].vz)))))) 
				{
                  iVar5 = *(int *)(puVar11 + 0x14);
                  iVar3 = *(int *)(puVar11 + 0x10);
                  *(uint *)&r0[4].vz = (uint)*(byte *)(iVar3 + iVar5 * 0x40 + 0xfb);
				  
				  // draw prim
                  FUN_8005c120(r0_00 + 3,pSVar10 + 3,
                               (*(int *)(pSVar7 + 3) >> 2) +
                               (uint)*(byte *)(iVar3 + iVar5 * 0x40 + 0xfa) * 0x40,r0);
                }
              }
              *(uint *)(puVar11 + 0x14) = *(int *)(puVar11 + 0x14) + 1U & 7;
              if (*(int *)(r0 + 4) == -1) {
                *(undefined4 *)(r0 + 4) = *(undefined4 *)&r0[3].vz;
                uVar9 = uVar1;
                uVar1 = 0xf;
              }
              else {
                uVar9 = uVar1 >> 4;
                uVar12 = (int)(*(uint *)&r0[3].vz & 0xff) >> 1;
                *(undefined4 *)(r0 + 4) = *(undefined4 *)&r0[3].vz;
                *(uint *)&r0[3].vz = uVar12 | uVar12 << 8 | 0x3e000000 | uVar12 << 0x10;
              }
              pSVar6 = pSVar8;
              pSVar8 = pSVar7;
              pSVar7 = pSVar10;
              pSVar10 = r0_00;
              uVar12 = uVar1;
            } while (*(int *)(r0 + 4) != 0);
          }
        }
      }
    }
LAB_8005c9dc:

	// thread = thread -> next
    iVar5 = *(int *)(*(int *)(puVar11 + 0x40) + 0x10);
    *(int *)(puVar11 + 0x40) = iVar5;
	
  } while( true );
}


// Driver_UpdateLapProgress (param1=driver)
void FUN_8005ca24(int param_1)

{
  ushort uVar1;
  undefined *puVar2;
  undefined4 in_zero;
  undefined4 in_at;
  undefined4 uVar3;
  undefined4 uVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  short *psVar8;
  int iVar9;
  short *psVar10;
  ushort uVar11;
  int iVar12;
  undefined4 local_30;
  undefined4 local_20;
  uint local_1c;

  // if player structure is not nullptr
  if (param_1 != 0)
  {
    uVar11 = 0xffff;

	// If this is human and not an AI
    if ((*(uint *)(param_1 + 0x2c8) & 0x100000) == 0)
	{
	  // quadblock (last valid)
      iVar7 = *(int *)(param_1 + 0x354);

      if (
			// if quadblock exists
			(iVar7 != 0) &&

			// quadBlock -> respawnIndex is valid
			(*(char *)(iVar7 + 0x3e) != -1)
		 )
	  {
		// quadblock -> respawnIndex
        uVar11 = (ushort)*(byte *)(iVar7 + 0x3e);
      }
    }

	// If this is an AI
    else
	{
	  // duplicate of quadblock respawnIndex (AI-exclusive)
      uVar11 = (ushort)*(byte *)(param_1 + 0x60a);
    }

	// if level has respawn points
    if ((*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x148) - 1U < 0xff) &&

	   // respawnIndex is valid
	   (-1 < (int)(short)uVar11))
	{
	  // array of respawn points
      iVar7 = *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c);

	  // byte offset of respawn point from last-valid quadblock
      iVar12 = iVar7 + (int)(short)uVar11 * 0xc;

	  // pointer to desired respawn point
	  psVar10 = (short *)(iVar7 + (uint)*(byte *)(iVar12 + 8) * 0xc);

	  // Player X, Y, and Z
      uVar3 = *(undefined4 *)(param_1 + 0x2d4);
      uVar4 = *(undefined4 *)(param_1 + 0x2d8);
      uVar5 = *(uint *)(param_1 + 0x2dc);

      psVar8 = (short *)(iVar7 + (uint)*(byte *)(psVar10 + 4) * 0xc);
      local_20 = CONCAT22(psVar10[1] - psVar8[1],*psVar10 - *psVar8);
      local_1c = local_1c & 0xffff0000 | (uint)(ushort)(psVar10[2] - psVar8[2]);

	  // MATH_VectorNormalize
	  FUN_8003d378(&local_20);

	  puVar2 = PTR_DAT_8008d2ac;
      local_30 = CONCAT22((short)((uint)uVar4 >> 8) - psVar10[1],
                          (short)((uint)uVar3 >> 8) - *psVar10);
      setCopControlWord(2,0,local_30);
      setCopControlWord(2,0x800,(uVar5 >> 8 & 0xffff) - (uint)(ushort)psVar10[2] & 0xffff |
                                ((int)((uint)*(ushort *)(param_1 + 0x314) << 0x10) >> 0x15) << 0x10)
      ;
      setCopControlWord(2,0x1000,(int)((uint)*(ushort *)(param_1 + 0x31a) << 0x10) >> 0x15 & 0xffffU
                                 | ((int)((uint)*(ushort *)(param_1 + 800) << 0x10) >> 0x15) << 0x10
                       );
      setCopReg(2,in_zero,local_20);
      setCopReg(2,in_at,local_1c);

      copFunction(2,0x406012);

	  iVar7 = getCopReg(2,0xc800);
      iVar9 = getCopReg(2,0xd000);
      iVar6 = (uint)(ushort)psVar10[3] * 8 + (iVar7 >> 0xc);

	  // set new progress
      *(int *)(param_1 + 0x488) = iVar6;

	  uVar1 = *(ushort *)(*(int *)(*(int *)(puVar2 + 0x160) + 0x14c) + 6);
      iVar7 = (uint)uVar1 << 3;
      if (uVar1 == 0) {
        trap(0x1c00);
      }
      if ((iVar7 == -1) && (iVar6 == -0x80000000)) {
        trap(0x1800);
      }

	  // set new progress
      *(int *)(param_1 + 0x488) = iVar6 % iVar7;

	  if (iVar9 < 0x5a801) {
        //uVar5 = Actions Flag set with 9th bit off
        uVar5 = *(uint *)(param_1 + 0x2c8) & 0xfffffeff;
      }
      else {
        //uVar5 = Actions Flag set with 9th bit on
        uVar5 = *(uint *)(param_1 + 0x2c8) | 0x100;
      }

	  //manage 9th bit of Actions Flag set
      *(uint *)(param_1 + 0x2c8) = uVar5;

      //if 28th bit of Actions Flag set is on (means ?) and
      if (((*(uint *)(param_1 + 0x2c8) & 0x8000000) != 0) &&
         ((uint)*(byte *)(param_1 + 0x495) != (int)(short)uVar11))
	  {
		// save respawn index
        *(undefined *)(param_1 + 0x494) = (char)uVar11;

		//turn off 28th bit of Actions Flag set (means ?)
        *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) & 0xf7ffffff;
      }
      if (*(char *)(iVar12 + 9) != -1) {
        //turn on 28th bit of Actions Flag set (means ?)
        *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) | 0x8000000;
      }

	  // respawnIndex
      *(undefined *)(param_1 + 0x495) = (char)uVar11;
    }
  }
  return;
}


// param_1: &driver
// param_2: coordSpeeds
void FUN_8005cd1c(int param_1,int *param_2)

{
  undefined2 extraout_var;
  short extraout_var_00;
  short extraout_var_01;
  long x;
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;

  // x = sqrt(param_1 * 2 ^ param_2)
  x = FUN_80059070(*param_2 * *param_2 + param_2[2] * param_2[2], 0x10);

  // sqrt(param_1 * 2 ^ param_2)
  FUN_80059070(*param_2 * *param_2 + param_2[1] * param_2[1] + param_2[2] * param_2[2],0x10);

  // Ghidra missed this!
  // extraout_var = FUN_80059070(*param_2 * *param_2 + param_2[1] * param_2[1] + param_2[2] * param_2[2],0x10);
  // extraout_var = extraout_var << 0x8;

  *(undefined2 *)(param_1 + 0x38c) = extraout_var;
  x = ratan2(param_2[1] << 8,x);
  *(undefined2 *)(param_1 + 0x394) = (short)x;
  x = ratan2(*param_2,param_2[2]);
  *(undefined2 *)(param_1 + 0x396) = (short)x;
  iVar4 = *param_2 * (int)*(short *)(param_1 + 0x312) +
          param_2[1] * (int)*(short *)(param_1 + 0x318) +
          param_2[2] * (int)*(short *)(param_1 + 0x31e) >> 0xc;
  iVar1 = (int)*(short *)(param_1 + 0x312) * iVar4 >> 0xc;
  iVar2 = (int)*(short *)(param_1 + 0x318) * iVar4 >> 0xc;
  iVar3 = (int)*(short *)(param_1 + 0x31e) * iVar4 >> 0xc;

  // sqrt(param_1 * 2 ^ param_2)
  FUN_80059070(iVar1 * iVar1 + iVar2 * iVar2 + iVar3 * iVar3,0x10);

  // Ghidra missed this!
  // extraout_var_00 = FUN_80059070(iVar1 * iVar1 + iVar2 * iVar2 + iVar3 * iVar3,0x10);
  // extraout_var_00 = extraout_var_00 << 0x8;

  *(short *)(param_1 + 0x390) = extraout_var_00;
  if (iVar4 < 0) {
    *(short *)(param_1 + 0x390) = -extraout_var_00;
  }
  iVar1 = *param_2 - iVar1;
  iVar2 = param_2[1] - iVar2;
  iVar3 = param_2[2] - iVar3;

  // sqrt(param_1 * 2 ^ param_2)
  FUN_80059070(iVar1 * iVar1 + iVar2 * iVar2 + iVar3 * iVar3,0x10);

  // Ghidra missed this!
  // extraout_var_01 = FUN_80059070(iVar1 * iVar1 + iVar2 * iVar2 + iVar3 * iVar3,0x10);
  // extraout_var_01 = extraout_var_01 << 0x8;

  *(short *)(param_1 + 0x38e) = extraout_var_01;
  if (iVar1 * *(short *)(param_1 + 0x314) + iVar2 * *(short *)(param_1 + 0x31a) +
      iVar3 * *(short *)(param_1 + 800) < 0) {
    *(short *)(param_1 + 0x38e) = -extraout_var_01;
  }
  return;
}


// DriverCrash_BounceSelf
undefined4 FUN_8005cf64(short *param_1,int *param_2,int *param_3,int param_4)

{
  short sVar1;
  short sVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;

  iVar5 = param_2[1];
  iVar6 = param_2[2];
  iVar8 = (*param_3 - *param_2) * (int)*param_1 + (param_3[1] - iVar5) * (int)param_1[1] +
          (param_3[2] - iVar6) * (int)param_1[2] >> 0xc;
  if (param_4 == 0) {
    if (iVar8 < 0) goto LAB_8005cfdc;
  }
  else {
    if (0 < iVar8) {
LAB_8005cfdc:
      iVar7 = iVar8;
      if (iVar8 < 0) {
        iVar7 = -iVar8;
      }
      if (DAT_8008d9f4 < iVar7) {
        DAT_8008d9f4 = iVar7;
      }
      iVar7 = iVar8 * *param_1 >> 0x1f;
      sVar1 = param_1[1];
      sVar2 = param_1[2];
      iVar3 = iVar8 * sVar1 >> 0x1f;
      iVar4 = iVar8 * sVar2 >> 0x1f;
      *param_3 = ((*param_3 - *param_2) - (((iVar8 * *param_1) / 6 + iVar7 >> 9) - iVar7)) +
                 *param_2;
      iVar5 = ((param_3[1] - iVar5) - (((iVar8 * sVar1) / 6 + iVar3 >> 9) - iVar3)) + param_2[1];
      if ((param_3[1] < iVar5) && (0x3200 < iVar5)) {
        iVar5 = 0x3200;
      }
      param_3[1] = iVar5;
      param_3[2] = ((param_3[2] - iVar6) - (((iVar8 * sVar2) / 6 + iVar4 >> 9) - iVar4)) +
                   param_2[2];
      return 0;
    }
  }
  return 0;
}


// DriverCrash_AI
void FUN_8005d0d0(int param_1,int *param_2)

{
  int iVar1;
  int iVar2;

  DAT_8008d9ec = (ushort)*(byte *)(*(int *)(param_1 + 0x5a4) + 6) << 4;
  DAT_8008d9ee = (ushort)*(byte *)(*(int *)(param_1 + 0x5a4) + 7) << 4;
  DAT_8008d9f0 = (ushort)*(byte *)(*(int *)(param_1 + 0x5a4) + 8) << 4;

   // convert 3 rotation shorts into rotation matrix
  FUN_8006c2a4(&DAT_8009ae38,&DAT_8008d9ec);

  DAT_8009ae28 = (int)((uint)DAT_8009ae3c << 0x10) >> 0x14;
  DAT_8009ae2c = (int)((uint)DAT_8009ae42 << 0x10) >> 0x14;
  DAT_8009ae30 = (int)((uint)DAT_8009ae48 << 0x10) >> 0x14;
  iVar1 = DAT_8009ae28 * *param_2 + DAT_8009ae2c * param_2[1] + DAT_8009ae30 * param_2[2] >> 8;
  *(int *)(param_1 + 0x5d4) = iVar1;
  *(int *)(param_1 + 0x5d8) = *param_2 - (DAT_8009ae28 * iVar1 >> 8);
  iVar1 = DAT_8009ae30 * iVar1;
  iVar2 = param_2[2];
  *(uint *)(param_1 + 0x5b0) = *(uint *)(param_1 + 0x5b0) | 8;
  *(int *)(param_1 + 0x5e0) = iVar2 - (iVar1 >> 8);
  return;
}


//param_1 = driver pointer
//param_2 = driver pointer
int FUN_8005d218(int param_1,int param_2,int param_3,int param_4)
{
  int iVar1;

  //if driver (1) is not using mask weapon
  if ((*(uint *)(param_1 + 0x2c8) & 0x800000) == 0)
  {
	//if driver (2) is using mask weapon
    if ((*(uint *)(param_2 + 0x2c8) & 0x800000) != 0)
	{
      *(undefined *)(param_1 + 0x4ff) = 2;
      *(undefined *)(param_1 + 0x504) = 6;
      *(int *)(param_1 + 0x500) = param_2;

	  if (((param_3 != 0) && (*(char *)(param_1 + 0x376) != '\x06')) &&
         (*(int *)(param_1 + 0x24) == 0))
	  {
		// OtherFX_DriverCrashing
        FUN_8002e760(

			// if driver is supposed to echo
			(uint)*(ushort *)(param_1 + 0x2ca) & 1,

			0xff
		);

		// Make driver talk
        FUN_8002cbe8(1,(int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)],0x10);
      }
    }

	// if one driver has a bubble, and the other does not
	if ((*(int *)(param_2 + 0x14) != 0) && (*(int *)(param_1 + 0x14) == 0))
	{
		// driver -> bubbleInst -> thread -> object
      iVar1 = *(int *)(*(int *)(*(int *)(param_2 + 0x14) + 0x6c) + 0x30);

      *(ushort *)(iVar1 + 6) = *(ushort *)(iVar1 + 6) | 8;

	  // clear bubbleInst pointer
      *(undefined4 *)(param_2 + 0x14) = 0;

      *(undefined *)(param_1 + 0x4ff) = 2;
      *(undefined *)(param_1 + 0x504) = 0;
      *(int *)(param_1 + 0x500) = param_2;

	  if (
			(param_3 != 0) &&

			(
				(
					// if driver is not blasted
					*(char *)(param_1 + 0x376) != '\x06' &&

					// if driver is not invincible
					(*(int *)(param_1 + 0x24) == 0)
				)
			)
		 )
	  {
		// OtherFX_DriverCrashing
        FUN_8002e760(

			// if driver is supposed to echo
			(uint)*(ushort *)(param_1 + 0x2ca) & 1,

			0xff
		);

		if (param_4 != 0)
		{
		  // OtherFX_Play
          FUN_80028468(0x4f,1);
        }

		// Make driver talk
        FUN_8002cbe8(1,(int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)],0x10);
      }
    }

	//if (?) and racer (2) is not out of Reserves and
    if ((((0xa00 < DAT_8008d9f4) && (*(short *)(param_2 + 0x3e2) != 0)) &&
      //10th bit of Actions Flag set is on (means ?) and racer (1) is out of reserves
      ((*(uint *)(param_2 + 0x2c8) & 0x200) != 0)) && (*(short *)(param_1 + 0x3e2) == 0)) {
      *(undefined *)(param_2 + 0x366) = 2;
      *(undefined *)(param_1 + 0x4ff) = 3;
      *(undefined *)(param_1 + 0x504) = 5;
      *(int *)(param_1 + 0x500) = param_2;
    }
  }
  return param_3;
}

// DriverCrash_AnyTwoCars
// pass the thread, collision data, and driver->88 coordSpeed[] (x, y, z)
// calls Crash_AI and Crash_HumanToHuman
void FUN_8005d404(int param_1,int param_2,int *param_3)

{
  undefined2 uVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  undefined4 uVar9;
  uint uVar10;
  int local_48;
  int local_44;
  int local_40;
  int local_38;
  int local_34;
  int local_30;

  // fast sqrt
  iVar2 = FUN_8003d214(*(undefined4 *)(param_2 + 0xc),0);

  uVar1 = 0x1000;
  if (iVar2 == 0) {
    *(undefined2 *)(param_2 + 0x18) = 0;
    *(undefined2 *)(param_2 + 0x1a) = 0;
  }
  else 
  {
	// distX
    iVar8 = (int)*(short *)(param_2 + 0x10) << 0xc;
    
	// safety check
	if (iVar2 == 0) { trap(0x1c00); }
    if ((iVar2 == -1) && (iVar8 == -0x80000000)) { trap(0x1800); }
	
	// distY
    iVar5 = (int)*(short *)(param_2 + 0x12) << 0xc;
	
	// safety check
    if (iVar2 == 0) { trap(0x1c00); }
    if ((iVar2 == -1) && (iVar5 == -0x80000000)) { trap(0x1800); }
    
	// distZ
	iVar3 = (int)*(short *)(param_2 + 0x14) << 0xc;
    
	// safety check
	if (iVar2 == 0) { trap(0x1c00); }
    if ((iVar2 == -1) && (iVar3 == -0x80000000)) { trap(0x1800); }
	
	// hit direction vector,
	// divide each direction by distance
    uVar1 = (undefined2)(iVar3 / iVar2);
    *(undefined2 *)(param_2 + 0x18) = (short)(iVar8 / iVar2);
    *(undefined2 *)(param_2 + 0x1a) = (short)(iVar5 / iVar2);
  }
  
  // hit direction vector
  *(undefined2 *)(param_2 + 0x1c) = uVar1;
  
  // two driver objects
  iVar8 = *(int *)(*(int *)(param_2 + 8) + 0x30);
  iVar5 = *(int *)(param_1 + 0x30);

  // hit strength
  iVar2 = 
			(
				// driver1 radius
				(int)*(short *)(param_1 + 0x42) +
				
				// driver2 radius
				(int)*(short *)(*(int *)(*(int *)(iVar8 + 0x1c) + 0x6c) + 0x42)
			) 
			
			// minus distance between them
			- iVar2;

  // if hitStrength < 0, drivers dont collide,
  // if hitStrength == 0, drivers touch, but with no force
  // if hitStrength > 0, drivers touch with force
  
  // if drivers hit each other
  if (0 < iVar2)
  {
    DAT_8008d9f4 = 0;

	// If this is human and not AI
    if ((*(uint *)(iVar5 + 0x2c8) & 0x100000) == 0) {
      iVar3 = param_2 + 0x18;

	  // If this (other driver) is human and not AI
      if ((*(uint *)(iVar8 + 0x2c8) & 0x100000) == 0) {
        iVar7 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar6 = *param_3 * (int)*(short *)(iVar5 + 0x47c) +
                *(int *)(iVar8 + 0x88) * (int)*(short *)(iVar8 + 0x47c);
        local_38 = iVar6 / iVar7;
        if (iVar7 == 0) {
          trap(0x1c00);
        }
        if ((iVar7 == -1) && (iVar6 == -0x80000000)) {
          trap(0x1800);
        }
        iVar7 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar6 = param_3[1] * (int)*(short *)(iVar5 + 0x47c) +
                *(int *)(iVar8 + 0x8c) * (int)*(short *)(iVar8 + 0x47c);
        local_34 = iVar6 / iVar7;
        if (iVar7 == 0) {
          trap(0x1c00);
        }
        if ((iVar7 == -1) && (iVar6 == -0x80000000)) {
          trap(0x1800);
        }
        iVar7 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar6 = param_3[2] * (int)*(short *)(iVar5 + 0x47c) +
                *(int *)(iVar8 + 0x90) * (int)*(short *)(iVar8 + 0x47c);
        local_30 = iVar6 / iVar7;
        if (iVar7 == 0) {
          trap(0x1c00);
        }
        if ((iVar7 == -1) && (iVar6 == -0x80000000)) {
          trap(0x1800);
        }

		// DriverCrash_BounceSelf
        iVar6 = FUN_8005cf64(iVar3,&local_38,iVar8 + 0x88,1);

        if (iVar6 < 0) {
          DAT_8008d9f4 = 0;
        }

		// DriverCrash_BounceSelf
		iVar3 = FUN_8005cf64(iVar3,&local_38,param_3,0);

        if (0 < iVar3) {
          DAT_8008d9f4 = 0;
        }
        *param_3 = *param_3 + (*(short *)(param_2 + 0x18) * iVar2 >> 8);
        param_3[1] = param_3[1] + (*(short *)(param_2 + 0x1a) * iVar2 >> 8);
        param_3[2] = param_3[2] + (*(short *)(param_2 + 0x1c) * iVar2 >> 8);
		
		// deduct speed by (dirVec * hitStrength)
        *(int *)(iVar8 + 0x88) = *(int *)(iVar8 + 0x88) - (*(short *)(param_2 + 0x18) * iVar2 >> 8);
        *(int *)(iVar8 + 0x8c) = *(int *)(iVar8 + 0x8c) - (*(short *)(param_2 + 0x1a) * iVar2 >> 8);
        *(int *)(iVar8 + 0x90) = *(int *)(iVar8 + 0x90) - (*(short *)(param_2 + 0x1c) * iVar2 >> 8);
      }

	  // If this (other driver) is an AI
	  else {
        local_48 = *(int *)(iVar8 + 0x3a0) + *(int *)(iVar8 + 0x5d8);
        local_44 = *(int *)(iVar8 + 0x3a4) + *(int *)(iVar8 + 0x5dc);
        local_40 = *(int *)(iVar8 + 0x3a8) + *(int *)(iVar8 + 0x5e0);
        iVar7 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar6 = *param_3 * (int)*(short *)(iVar5 + 0x47c) +
                local_48 * (int)*(short *)(iVar8 + 0x47c);
        local_38 = iVar6 / iVar7;
        if (iVar7 == 0) {
          trap(0x1c00);
        }
        if ((iVar7 == -1) && (iVar6 == -0x80000000)) {
          trap(0x1800);
        }
        iVar7 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar6 = param_3[1] * (int)*(short *)(iVar5 + 0x47c) +
                local_44 * (int)*(short *)(iVar8 + 0x47c);
        local_34 = iVar6 / iVar7;
        if (iVar7 == 0) {
          trap(0x1c00);
        }
        if ((iVar7 == -1) && (iVar6 == -0x80000000)) {
          trap(0x1800);
        }
        iVar7 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar6 = param_3[2] * (int)*(short *)(iVar5 + 0x47c) +
                local_40 * (int)*(short *)(iVar8 + 0x47c);
        local_30 = iVar6 / iVar7;
        if (iVar7 == 0) {
          trap(0x1c00);
        }
        if ((iVar7 == -1) && (iVar6 == -0x80000000)) {
          trap(0x1800);
        }

		// DriverCrash_BounceSelf
        iVar6 = FUN_8005cf64(iVar3,&local_38,&local_48,1);

		if (iVar6 < 0) {
          DAT_8008d9f4 = 0;
        }

		// DriverCrash_BounceSelf
		iVar3 = FUN_8005cf64(iVar3,&local_38,param_3,0);

		if (0 < iVar3) {
          DAT_8008d9f4 = 0;
        }

		*param_3 = *param_3 + (*(short *)(param_2 + 0x18) * iVar2 >> 8);
        param_3[1] = param_3[1] + (*(short *)(param_2 + 0x1a) * iVar2 >> 8);
        param_3[2] = param_3[2] + (*(short *)(param_2 + 0x1c) * iVar2 >> 8);

        local_48 = local_48 - (*(short *)(param_2 + 0x18) * iVar2 >> 8);
        local_44 = local_44 - (*(short *)(param_2 + 0x1a) * iVar2 >> 8);
        local_40 = local_40 - (*(short *)(param_2 + 0x1c) * iVar2 >> 8);

		// DriverCrash_AI
        FUN_8005d0d0(iVar8,&local_48);
      }
      uVar10 = (uint)((uint)(*(int *)(PTR_DAT_8008d2ac + 0x1cf8) - DAT_8008d838) < 3) ^ 1;
      if (0x200 < DAT_8008d9f4)
	  {
		  // thread -> modelIndex == "player" of any kind
        if ((((*(short *)(param_1 + 0x44) == 0x18) ||

			// modelIndex == "player" of any kind
            (*(short *)(*(int *)(param_2 + 8) + 0x44) == 0x18)) &&

            // Map value from [oldMin, oldMax] to [newMin, newMax]
            // inverting newMin and newMax will give an inverse range mapping
            (uVar4 = FUN_80058f9c(DAT_8008d9f4,0,0x1900,0x3f,0xff), uVar10 != 0)) &&
             (
				// if both drivers are not blasted and not invincible
				((*(char *)(iVar5 + 0x376) != '\x06' && (*(int *)(iVar5 + 0x24) == 0)) &&
				((*(char *)(iVar8 + 0x376) != '\x06' && (*(int *)(iVar8 + 0x24) == 0))))
			  )
			)
		{
		  // OtherFX_DriverCrashing
          FUN_8002e760(

				// if driver is supposed to echo
				(uint)*(ushort *)(iVar5 + 0x2ca) & 1,

				uVar4
			);

		  DAT_8008d838 = *(int *)(PTR_DAT_8008d2ac + 0x1cf8);
          if (0xdc < uVar4)
		  {
			// Make driver talk
            FUN_8002cbe8(5,(int)(short)(&DAT_80086e84)[*(byte *)(iVar5 + 0x4a)],0x10);
          }
        }

		// both vibration related
		FUN_80026440(iVar8,8,0);
        FUN_800264c0(iVar8,8,0x7f);

        if (*(char *)(iVar8 + 0x4b) < '\x01') {
          uVar9 = 0x19;
        }
        else {
          uVar9 = 0x29;
        }

		// all three are vibration related
        FUN_800263a0(iVar8,uVar9,0x60);
        FUN_80026440(iVar5,8,0);
        FUN_800264c0(iVar5,8,0x7f);

        if (*(char *)(iVar5 + 0x4b) < '\x01') {
          uVar9 = 0x19;
        }
        else {
          uVar9 = 0x29;
        }

		// controller vibration
        FUN_800263a0(iVar5,uVar9,0x60);

		// flag used in 80062e04
		// Let both human drivers know, they are in a human-human collision
        *(uint *)(iVar5 + 0x2c8) = *(uint *)(iVar5 + 0x2c8) | 0x10000000;
        *(uint *)(iVar8 + 0x2c8) = *(uint *)(iVar8 + 0x2c8) | 0x10000000;
      }
      uVar9 = FUN_8005d218(iVar5,iVar8,uVar10,0);
      FUN_8005d218(iVar8,iVar5,uVar9,1);
    }

	// If this is an AI
	else
	{
	  // If this (other driver) is human and not AI
      if ((*(uint *)(iVar8 + 0x2c8) & 0x100000) == 0)
	  {
		// NOP makes player fail to move when hitting X
        FUN_8005e104(iVar8,&local_48);

        iVar6 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar3 = *param_3 * (int)*(short *)(iVar5 + 0x47c) +
                local_48 * (int)*(short *)(iVar8 + 0x47c);
        local_38 = iVar3 / iVar6;
        if (iVar6 == 0) {
          trap(0x1c00);
        }
        if ((iVar6 == -1) && (iVar3 == -0x80000000)) {
          trap(0x1800);
        }
        iVar6 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar3 = param_3[1] * (int)*(short *)(iVar5 + 0x47c) +
                local_44 * (int)*(short *)(iVar8 + 0x47c);
        local_34 = iVar3 / iVar6;
        if (iVar6 == 0) {
          trap(0x1c00);
        }
        if ((iVar6 == -1) && (iVar3 == -0x80000000)) {
          trap(0x1800);
        }
        iVar6 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar3 = param_3[2] * (int)*(short *)(iVar5 + 0x47c) +
                local_40 * (int)*(short *)(iVar8 + 0x47c);
        local_30 = iVar3 / iVar6;
        if (iVar6 == 0) {
          trap(0x1c00);
        }
        if ((iVar6 == -1) && (iVar3 == -0x80000000)) {
          trap(0x1800);
        }

		// DriverCrash_BounceSelf
        iVar3 = FUN_8005cf64(param_2 + 0x18,&local_38,&local_48,1);

		if (iVar3 < 0) {
          DAT_8008d9f4 = 0;
        }

		// DriverCrash_BounceSelf
		iVar3 = FUN_8005cf64(param_2 + 0x18,&local_38,param_3,0);

		if (0 < iVar3) {
          DAT_8008d9f4 = 0;
        }

		*param_3 = *param_3 + (*(short *)(param_2 + 0x18) * iVar2 >> 8);
        param_3[1] = param_3[1] + (*(short *)(param_2 + 0x1a) * iVar2 >> 8);
        param_3[2] = param_3[2] + (*(short *)(param_2 + 0x1c) * iVar2 >> 8);

		local_48 = local_48 - (*(short *)(param_2 + 0x18) * iVar2 >> 8);
        local_44 = local_44 - (*(short *)(param_2 + 0x1a) * iVar2 >> 8);
        local_40 = local_40 - (*(short *)(param_2 + 0x1c) * iVar2 >> 8);

		// DriverCrash_AI
        FUN_8005d0d0(iVar5,param_3);

        FUN_8005cd1c(iVar8,&local_48,0);
      }

	   // If this (other driver) is an AI
	  else {
        local_48 = *(int *)(iVar8 + 0x3a0) + *(int *)(iVar8 + 0x5d8);
        local_44 = *(int *)(iVar8 + 0x3a4) + *(int *)(iVar8 + 0x5dc);
        local_40 = *(int *)(iVar8 + 0x3a8) + *(int *)(iVar8 + 0x5e0);
        iVar6 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar3 = *param_3 * (int)*(short *)(iVar5 + 0x47c) +
                local_48 * (int)*(short *)(iVar8 + 0x47c);
        local_38 = iVar3 / iVar6;
        if (iVar6 == 0) {
          trap(0x1c00);
        }
        if ((iVar6 == -1) && (iVar3 == -0x80000000)) {
          trap(0x1800);
        }
        iVar6 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar3 = param_3[1] * (int)*(short *)(iVar5 + 0x47c) +
                local_44 * (int)*(short *)(iVar8 + 0x47c);
        local_34 = iVar3 / iVar6;
        if (iVar6 == 0) {
          trap(0x1c00);
        }
        if ((iVar6 == -1) && (iVar3 == -0x80000000)) {
          trap(0x1800);
        }
        iVar6 = (int)*(short *)(iVar5 + 0x47c) + (int)*(short *)(iVar8 + 0x47c);
        iVar3 = param_3[2] * (int)*(short *)(iVar5 + 0x47c) +
                local_40 * (int)*(short *)(iVar8 + 0x47c);
        local_30 = iVar3 / iVar6;
        if (iVar6 == 0) {
          trap(0x1c00);
        }
        if ((iVar6 == -1) && (iVar3 == -0x80000000)) {
          trap(0x1800);
        }

		// DriverCrash_BounceSelf
        iVar3 = FUN_8005cf64(param_2 + 0x18,&local_38,&local_48,1);

		if (iVar3 < 0) {
          DAT_8008d9f4 = 0;
        }

		// DriverCrash_BounceSelf
		iVar3 = FUN_8005cf64(param_2 + 0x18,&local_38,param_3,0);

		if (0 < iVar3) {
          DAT_8008d9f4 = 0;
        }

		*param_3 = *param_3 + (*(short *)(param_2 + 0x18) * iVar2 >> 8);
        param_3[1] = param_3[1] + (*(short *)(param_2 + 0x1a) * iVar2 >> 8);
        param_3[2] = param_3[2] + (*(short *)(param_2 + 0x1c) * iVar2 >> 8);

        local_48 = local_48 - (*(short *)(param_2 + 0x18) * iVar2 >> 8);
        local_44 = local_44 - (*(short *)(param_2 + 0x1a) * iVar2 >> 8);
        local_40 = local_40 - (*(short *)(param_2 + 0x1c) * iVar2 >> 8);

		// DriverCrash_AI (twice)
        FUN_8005d0d0(iVar8,&local_48);
        FUN_8005d0d0(iVar5,param_3);

		// pass pointer to two drivers,
		// this is AI-on-AI collision
        FUN_80016ec8(iVar5,iVar8);
      }
    }
  }
  return;
}

// hint : disabling this function stops player from moving, but you can still turn
// param_1 = &driver
// param_2 = &driver.coordSpeed
void FUN_8005e104(int param_1,int *param_2)

{
  short sVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  uint uVar6;

  // angle = axisRotationY
  uVar6 = SEXT24(*(short *)(param_1 + 0x394));

  // approximate trigonometry
  // sVar1 = sin(angle)
  sVar1 = (short)*(int *)(&DAT_800845a0 + (uVar6 & 0x3ff) * 4);
  // iVar5 = cos(angle)
  iVar5 = *(int *)(&DAT_800845a0 + (uVar6 & 0x3ff) * 4) >> 0x10;

  if ((uVar6 & 0x400) == 0) {
    iVar2 = (int)sVar1;
    if ((uVar6 & 0x800) != 0) {
      iVar3 = -iVar5;
      goto LAB_8005e15c;
    }
  }
  else {
    iVar3 = (int)sVar1;
    iVar2 = iVar5;
    if ((uVar6 & 0x800) == 0) {
      iVar5 = -iVar3;
    }
    else {
LAB_8005e15c:
      iVar2 = -iVar2;
      iVar5 = iVar3;
    }
  }

  // driver.coordSpeed[y] = (driver.speed * ???) >> 0xC
  param_2[1] = *(short *)(param_1 + 0x38c) * iVar2 >> 0xc;

  uVar6 = SEXT24(*(short *)(param_1 + 0x396));
  iVar2 = *(short *)(param_1 + 0x38c) * iVar5 >> 0xc;

  // approximate trigonometry
  iVar5 = *(int *)(&DAT_800845a0 + (uVar6 & 0x3ff) * 4) >> 0x10;
  sVar1 = (short)*(int *)(&DAT_800845a0 + (uVar6 & 0x3ff) * 4);

  if ((uVar6 & 0x400) == 0) {
    iVar3 = (int)sVar1;
    if ((uVar6 & 0x800) == 0) goto LAB_8005e1e8;
    iVar4 = -iVar5;
  }
  else {
    iVar4 = (int)sVar1;
    iVar3 = iVar5;
    if ((uVar6 & 0x800) == 0) {
      iVar5 = -iVar4;
      goto LAB_8005e1e8;
    }
  }
  iVar3 = -iVar3;
  iVar5 = iVar4;
LAB_8005e1e8:
  *param_2 = iVar2 * iVar3 >> 0xc;
  param_2[2] = iVar2 * iVar5 >> 0xc;
  return;
}


// OnGravity (for humans only)
// param1 - driver, param2 - coordSpeed
void FUN_8005e214(int param_1,VECTOR *param_2)

{
  char cVar1;
  undefined2 uVar2;
  int iVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  int iVar13;
  uint unaff_s3;
  uint unaff_s5;
  undefined *puVar14;
  int unaff_s8;
  int iVar15;
  int iVar16;
  undefined auStack72 [16];
  
  puVar14 = auStack72;
  
  // driver -> 0x310 matrix
  uVar8 = *(uint *)(param_1 + 0x310);
  uVar7 = *(uint *)(param_1 + 0x314);
  uVar10 = *(uint *)(param_1 + 0x318);
  uVar9 = *(uint *)(param_1 + 0x31c);
  
  // load matrix into GTE
  gte_ldR11R12(uVar8);
  gte_ldR13R21(uVar7);
  gte_ldR22R23(uVar10);
  gte_ldR31R32(uVar9);
  gte_ldR33((int)*(short *)(param_1 + 800)); // 0x320
  
  // transpose matrix
  gte_ldL11L12(uVar8 & 0xffff | uVar7 & 0xffff0000);
  uVar8 = uVar8 & 0xffff0000;
  gte_ldL13L21(uVar9 & 0xffff | uVar8);
  gte_ldL22L23(uVar10 & 0xffff | uVar9 & 0xffff0000);
  uVar7 = uVar7 & 0xffff | uVar10 & 0xffff0000;
  gte_ldL31L32(uVar7);
  gte_ldL33((int)*(short *)(param_1 + 800)); // 0x320
  
  // load vector from param_2
  gte_ldVXY0((uint)*(ushort *)&param_2->vx | param_2->vy << 0x10);
  gte_ldVZ0(param_2->vz);
  
  gte_llv0();
  
  read_mt(unaff_s5,unaff_s8,unaff_s3);
  
  // driver gravity constant
  iVar3 = -(int)*(short *)(param_1 + 0x416);

  // elapsed milliseconds per frame, ~32
  iVar5 = *(int *)(PTR_DAT_8008d2ac + 0x1d04);
  iVar6 = iVar5;
  
  // If the driver's under-quadblock has moon gravity
  if ((*(ushort *)(*(int *)(param_1 + 0x350) + 0x12) & 2) != 0) 
  {
	// 41% gravity (41 / 100)
    iVar6 = *(short *)(param_1 + 0x416) * -0x29;
    iVar3 = iVar6 >> 0x1f;
    iVar6 = iVar6 / 100 + iVar3;
    iVar3 = iVar6 - iVar3;
  }
  
  gte_ldVXY0((iVar3 * iVar5 >> 5) << 0x10);
  gte_ldVZ0(0);
  gte_llv0();
  read_mt(uVar7,uVar8,iVar6);
  
  if (((iVar6 < 0) && (0 < *(short *)(param_1 + 0x3b2))) ||
     ((0 < iVar6 && (*(short *)(param_1 + 0x3b2) < 0)))) {
    iVar6 = 0;
  }
  
  // driver flags
  uVar10 = *(uint *)(param_1 + 0x2c8);
  
  iVar3 = (int)*(short *)(param_1 + 0x38e);     // speed approximate magnitude
  uVar9 = (uint)*(short *)(param_1 + 0x39c);	// character rotation maybe?
  
  if ((((uVar10 & 8) != 0) || ((0 < (int)uVar9 && (iVar3 < 0)))) ||
     (((int)uVar9 < 0 && (0 < iVar3)))) {
    uVar7 = 0;
    iVar6 = 0;
  }
  iVar15 = unaff_s8 + uVar8;
  uVar11 = (int)*(short *)(param_1 + 0x39e) + (int)*(short *)(param_1 + 0x47e);
  uVar8 = unaff_s3 + iVar6;
  if (((int)uVar11 < (int)(unaff_s3 + iVar6)) && (uVar8 = unaff_s3, (int)unaff_s3 < (int)uVar11)) {
    uVar8 = uVar11;
  }
  uVar11 = (int)*(short *)(param_1 + 0x39e) - ((int)*(short *)(param_1 + 0x47e) >> 1);
  if (((int)uVar8 < (int)uVar11) && (uVar8 = unaff_s3, (int)uVar11 < (int)unaff_s3)) {
    uVar8 = uVar11;
  }
  uVar12 = (uint)*(short *)(param_1 + 0x480);
  uVar4 = *(uint *)(*(int *)(param_1 + 0x358) + 4);
  uVar11 = unaff_s5 + uVar7;
  if (((int)(unaff_s5 + uVar7) <= (int)uVar12) ||
     (uVar11 = uVar12, uVar7 = unaff_s5, (int)unaff_s5 < (int)uVar12)) {
    uVar7 = uVar11;
  }
  uVar12 = -uVar12;
  if (((int)uVar7 < (int)uVar12) && (uVar7 = unaff_s5, (int)uVar12 < (int)unaff_s5)) {
    uVar7 = uVar12;
  }
  iVar6 = (int)*(short *)(param_1 + 0x442);
  if (((iVar15 < 0) && ((uVar4 & 0x80) != 0)) && (iVar6 = 0x100, unaff_s8 < -0x100)) {
    unaff_s8 = -0x100;
  }
  if ((iVar15 <= iVar6) || (iVar15 = iVar6, iVar16 = unaff_s8, unaff_s8 < iVar6)) {
    iVar16 = iVar15;
  }
  iVar6 = -iVar6;
  if ((iVar16 < iVar6) && (iVar16 = unaff_s8, iVar6 < unaff_s8)) {
    iVar16 = iVar6;
  }
  
  // kart state
  cVar1 = *(char *)(param_1 + 0x376);
  
  // if mask grab
  if (cVar1 == '\x05') {
    uVar7 = 0;
    uVar8 = 0;
  }
  
  // if not mask grab
  else if (
			(
				((*(uint *)(param_1 + 0x2cc) & 1) != 0) || 
				
				// blasted
				(cVar1 == '\x06')
			) ||
			(
				(
					*(short *)(param_1 + 0x3c4) < *(short *)(param_1 + 0x38e) &&
					(*(int *)(*(int *)(param_1 + 0x35c) + 8) < 0x100)
				)
			)
		  ) 
  {
    if ((uVar10 & 8) == 0) {
      if (uVar9 == 0) {
        iVar15 = (int)*(short *)(param_1 + 0x41e);
        iVar6 = (int)*(short *)(param_1 + 0x420);
        if (*(short *)(param_1 + 0x50a) == 5) {
          iVar15 = (int)*(short *)(param_1 + 0x422) << 4;
          iVar6 = iVar15;
        }
      }
      else {
        iVar6 = iVar3;
        if (iVar3 < 0) {
          iVar6 = -iVar3;
        }
        if ((iVar6 < 0x301) ||
           ((((int)uVar9 < 1 || (-1 < iVar3)) && ((-1 < (int)uVar9 || (iVar3 < 1)))))) {
          if (cVar1 == '\x02') {
            iVar15 = (int)*(short *)(param_1 + 0x424);
            iVar6 = (int)*(short *)(param_1 + 0x426);
          }
          else {
            if (iVar3 < 0) {
              iVar3 = -iVar3;
            }
            iVar15 = (int)*(short *)(param_1 + 0x41a);
            iVar6 = (int)*(short *)(param_1 + 0x41c);
            if (0x300 < iVar3) {
              uVar11 = uVar9;
              if ((int)uVar9 < 0) {
                uVar11 = -uVar9;
              }
              if (iVar3 < (int)uVar11 >> 1) {
                uVar10 = uVar10 | 0x800;
              }
            }
          }
        }
        else {
          if (iVar3 < 0) {
            iVar3 = -iVar3;
          }
          iVar15 = (int)*(short *)(param_1 + 0x41a);
          iVar6 = (int)*(short *)(param_1 + 0x422);
          if (0x300 < iVar3) {
            uVar10 = uVar10 | 0x800;
          }
        }
      }
    }
    else {
      if (iVar3 < 0) {
        iVar3 = -iVar3;
      }
      if (0x300 < iVar3) {
        uVar10 = uVar10 | 0x800;
      }
      iVar3 = (uint)*(ushort *)(param_1 + 0x422) << 0x10;
      iVar15 = iVar3 >> 0x10;
      if (*(short *)(param_1 + 0x50a) == 5) {
        iVar15 = iVar15 << 4;
        iVar6 = iVar15;
      }
      else if (cVar1 == '\x06') {
        iVar15 = iVar15 * 3 >> 2;
        iVar6 = iVar15;
      }
      else {
        iVar6 = iVar15;
        if (cVar1 == '\x03') {
          iVar15 = iVar3 >> 0x11;
          iVar6 = iVar15;
        }
      }
    }
    iVar13 = *(int *)(*(int *)(param_1 + 0x358) + 0x20);
    iVar3 = iVar15 * iVar5 >> 5;
    iVar6 = iVar6 * iVar5 >> 5;
    if (iVar13 != 0x100) {
      iVar3 = iVar13 * iVar3 >> 8;
      iVar6 = iVar13 * iVar6 >> 8;
    }
    iVar15 = (int)*(short *)(param_1 + 0x414);
    if (iVar15 < 0) {
      uVar11 = uVar7;
      if (iVar15 == -0x140) {
        if ((int)uVar7 < 0) {
          uVar11 = -uVar7;
        }
        iVar3 = (int)uVar11 >> 1;
      }
      else {
        iVar3 = iVar3 + (iVar3 * *(short *)(param_1 + 0x444) >> 8);
        if (iVar3 < 0) {
          iVar3 = 0;
        }
        if ((int)uVar7 < 0) {
          uVar11 = -uVar7;
        }
      }
      if (0 < (int)uVar11) {
        uVar10 = uVar10 | 0x1800;
		
		  // controller vibration
        FUN_800264c0(param_1,4,0x7f);
        FUN_80026440(param_1,4,0);
      }
      iVar15 = iVar15 + iVar5;
      if (0 < iVar15) {
        iVar15 = 0;
      }
      *(short *)(param_1 + 0x414) = (short)iVar15;
    }
    else if (0 < iVar15) {
      iVar15 = iVar15 - iVar5;
      if (iVar15 < 0) {
        iVar15 = 0;
      }
      iVar3 = iVar3 + (iVar3 * *(short *)(param_1 + 0x444) >> 8);
      *(short *)(param_1 + 0x414) = (short)iVar15;
      if (iVar3 < 0) {
        iVar3 = 0;
      }
    }
    if (((uVar10 & 0x800000) == 0) && (iVar5 = (int)uVar7 >> 3, (uVar4 & 0x80) != 0)) {
      if (iVar5 < 0) {
        iVar5 = -iVar5;
      }
      if (iVar3 < iVar5) {
        iVar3 = iVar5;
      }
      if (((uVar8 == 0) || (uVar9 == 0)) || (-1 < (int)(uVar8 ^ uVar9))) {
        if ((((int)uVar9 <= (int)uVar8) || (0 < (int)uVar8)) &&
           (((int)uVar8 <= (int)uVar9 || ((int)uVar8 < 0)))) goto LAB_8005e8d8;
        iVar5 = uVar8 - uVar9;
        if (iVar5 < 0) {
          iVar5 = -iVar5;
        }
        iVar5 = iVar5 >> 1;
      }
      else {
        iVar5 = (int)uVar8 >> 1;
        if (iVar5 < 0) {
          iVar5 = -iVar5;
        }
      }
      if (iVar6 < iVar5) {
        iVar6 = iVar5;
      }
    }
LAB_8005e8d8:
    if (((uVar4 & 0x100) == 0) || (iVar5 = iVar3 * 3 >> 2, iVar3 = iVar6, iVar5 < iVar6)) {
      iVar5 = iVar3;
    }
	
	// Interpolate rotation by speed
    uVar7 = FUN_80058f54(uVar7,iVar5,0);
    uVar8 = FUN_80058f54(uVar8,iVar6,0);
  }
  
  gte_ldVXY0(uVar7 & 0xffff | iVar16 << 0x10);
  gte_ldVZ0(uVar8);
  gte_rtv0();
  gte_stlvnl(param_2);
  
  // set flag
  *(uint *)(param_1 + 0x2c8) = uVar10;
  
  // if driver is not in air
  if ((uVar10 & 0x80000) == 0) 
  {
    if ((*(char *)(param_1 + 0x449) != '\0') && (uVar8 != 0)) {
      uVar2 = 1;
      if ((int)uVar8 < 0) {
        uVar2 = 0xffff;
      }
      *(undefined2 *)(param_1 + 1000) = uVar2;
      *(undefined *)(param_1 + 0x449) = 0;
      goto LAB_8005e9d8;
    }
    if (*(int *)(puVar14 + 0x10) < 0) {
LAB_8005e9cc:
      if (-1 < (int)uVar8) {
        *(undefined2 *)(param_1 + 1000) = 1;
      }
      goto LAB_8005e9d8;
    }
    if ((int)uVar8 < 0) {
      *(undefined2 *)(param_1 + 1000) = 0xffff;
    }
    if (*(int *)(puVar14 + 0x10) < 1) goto LAB_8005e9cc;
LAB_8005e9e8:
    if ((int)uVar8 < 0) goto LAB_8005ea08;
    if (0 < *(int *)(puVar14 + 0x10)) {
      return;
    }
  }
  
  // if driver is in air
  else {
LAB_8005e9d8:
    if (-1 < *(int *)(puVar14 + 0x10)) goto LAB_8005e9e8;
  }
  if ((int)uVar8 < 1) {
    return;
  }
  
  // these variables are related to kart state 9,
  // why is this inside OnGravity?
  
LAB_8005ea08:


  // if driver has been "Driving" less than 0.64s
  if (*(short *)(param_1 + 0x408) != 0) 
  {
    *(short *)(param_1 + 0x40a) = *(short *)(param_1 + 0x40a) + 1;
  }

  // reset timer
  *(undefined2 *)(param_1 + 0x408) = 0x280;
  
  return;
}


// OnApplyForces
void FUN_8005ea60(undefined4 param_1,int param_2)

{
  undefined4 uVar1;
  int iVar2;

  // if speed is more than top speed
  if (0x6400 < *(short *)(param_2 + 0x38c))
  {
	// set top speed
    *(undefined2 *)(param_2 + 0x38c) = 0x6400;
  }

  gte_SetColorMatrix((MATRIX *)(param_2 + 0x330));
  gte_ldVXY0(0x190000);
  gte_ldVZ0(0);
  gte_lcv0();
  gte_stlvnl0((long *)(param_2 + 0x94));
  gte_stlvnl1((long *)(param_2 + 0x98));
  gte_stlvnl2((long *)(param_2 + 0x9c));

  // NOP makes player fail to move when hitting X
  FUN_8005e104(param_2,param_2 + 0x88,0);

  if (
		(
			(
				// if under-quadblock exists
				(*(int *)(param_2 + 0x350) != 0) &&

				// if quadblock terrain is mud
				(*(char *)(*(int *)(param_2 + 0x350) + 0x38) == '\x0e')
			)
			&&

			// if you have not sinked too far under the mud
			(-0x1000 < *(int *)(param_2 + 0x2d8))
		) &&

		(iVar2 = -0x1000 - *(int *)(param_2 + 0x2d8), *(int *)(param_2 + 0x8c) < iVar2)
	 )
  {
    *(int *)(param_2 + 0x8c) = iVar2;
  }

  // OnGravity
  FUN_8005e214(param_2,param_2 + 0x88);

  *(undefined4 *)(param_2 + 0xa4) = 0x10000000;
  *(undefined4 *)(param_2 + 0x360) = 0x10000000;

  // driver is not touching quadblock
  *(undefined4 *)(param_2 + 0xa0) = 0;

  *(undefined2 *)(param_2 + 0xa8) = 0;
  *(undefined2 *)(param_2 + 0x364) = 0;
  *(undefined2 *)(param_2 + 0xaa) = 0;

  *(int *)(param_2 + 0x88) = *(int *)(param_2 + 0x88) + (int)*(short *)(param_2 + 0x3cc);
  *(int *)(param_2 + 0x90) = *(int *)(param_2 + 0x90) + (int)*(short *)(param_2 + 0x3d0);
  *(int *)(param_2 + 0x8c) = *(int *)(param_2 + 0x8c) + (int)*(short *)(param_2 + 0x3ce);
  return;
}

// OnCollide
// handle collision with turbo pads and robotcars
void FUN_8005ebac(int param_1,int param_2)

{
  int iVar1;
  undefined4 uVar2;
  int iVar3;
  undefined4 uVar4;
  uint uVar5;
  undefined2 local_40;
  undefined2 local_3e;
  undefined2 local_3c;
  int local_38;
  int local_34;

  *(int *)(param_2 + 0x8c) = *(int *)(param_2 + 0x8c) - (int)*(short *)(param_2 + 0x3ce);
  *(int *)(param_2 + 0x88) = *(int *)(param_2 + 0x88) - (int)*(short *)(param_2 + 0x3cc);
  uVar5 = *(uint *)(param_2 + 0xbc);
  *(int *)(param_2 + 0x90) = *(int *)(param_2 + 0x90) - (int)*(short *)(param_2 + 0x3d0);

  if ((uVar5 & 0x4000) != 0) {
    *(ushort *)(param_2 + 0xaa) = *(ushort *)(param_2 + 0xaa) | 1;
  }

  // If this is not a super turbo pad
  if ((uVar5 & 2) == 0) {

	// If this is not an ordinary turbo pad
    if ((uVar5 & 1) == 0) goto LAB_8005ec70;

	// add one second reserves
    uVar2 = 0x3c0;

	// If Super Turbo Pads is enabled
    if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x100000) != 0)
	{
		// Skip a few lines
		goto LAB_8005ec50;
	}

	// set speed of turbo to normal speed
    uVar4 = 0x100;
  }

  // If this is a super turbo pad (only on some tracks)
  else {
LAB_8005ec50:

	// add 0.12s reserves
    uVar2 = 0x78;

	// Set speed of turbo to big speed
    uVar4 = 0x800;
  }

  // Turbo_Increment
  // add reserves and speed of turbo pad
  FUN_8005abfc(param_2,uVar2,5,uVar4);

LAB_8005ec70:
  if ((uVar5 & 0x8000) == 0)
  {
	// thread -> instance -> flags
	// instance is not in water or mud
    *(uint *)(*(int *)(param_1 + 0x34) + 0x28) =
         *(uint *)(*(int *)(param_1 + 0x34) + 0x28) & 0xffffdfff;
  }

  // if instance is in water or mud
  else
  {
	// thread -> instance
    iVar1 = *(int *)(param_1 + 0x34);

	// set vertical split height
	// (Y=0 for all water and mud)
    *(undefined2 *)(iVar1 + 0x56) = 0;

	// instance -> flags
	// split the instance
	*(uint *)(iVar1 + 0x28) = *(uint *)(iVar1 + 0x28) | 0x2000;
  }

  // if collision is not disabled for this thread
  if ((*(uint *)(param_1 + 0x1c) & 0x1000) == 0)
  {
	// 40, 3e, 3c, 38, 34, allocated in that order

	// position X and Y
    local_40 = (undefined2)((uint)*(undefined4 *)(param_2 + 0x2d4) >> 8);
    local_3e = (undefined2)((uint)*(undefined4 *)(param_2 + 0x2d8) >> 8);

	// distance between two objects
	local_34 = 0x7fffffff;

	// thread you collide with
	local_38 = 0;

	// position Z
    local_3c = (undefined2)((uint)*(undefined4 *)(param_2 + 0x2dc) >> 8);

	// check for collision with all sibling threads
	// THREAD_CollidePointWithBucket
    FUN_80042348(*(undefined4 *)(param_1 + 0x10),&local_40);

	// pointer to first robotcar thread
	// THREAD_CollidePointWithBucket
    FUN_80042348(*(undefined4 *)(PTR_DAT_8008d2ac + 0x1b40),&local_40);

	if (
			// if there was a collision
			(local_38 != 0) &&
			(
				// thread offset 0x42?
				iVar1 = (int)*(short *)(param_1 + 0x42) + (int)*(short *)(local_38 + 0x42),

				local_34 < iVar1 * iVar1
			)
	    )
	{
	  // pass the thread, collision data, and driver->88 is velocity?
      FUN_8005d404(param_1,&local_40,param_2 + 0x88);
    }
  }
  if ((*(ushort *)(param_2 + 0xaa) & 2) != 0) 
  {
    iVar3 = (*(int *)(param_2 + 0x2d4) >> 8) - (int)*(short *)(param_2 + 0xac);
    iVar1 = (*(int *)(param_2 + 0x2dc) >> 8) - (int)*(short *)(param_2 + 0xb0);
    
	if (
		*(short *)(param_2 + 0xb4) * iVar3 +
        (int)*(short *)(param_2 + 0xb6) * (((*(int *)(param_2 + 0x2d0) >> 8) - (int)*(short *)(param_2 + 0xae)) + 4) +
        *(short *)(param_2 + 0xb8) * iVar1 < 0) 
	{
	  // calculate speed vector
      *(int *)(param_2 + 0x88) = *(int *)(param_2 + 0x88) + iVar3 * 0x40;
      *(int *)(param_2 + 0x8c) = *(int *)(param_2 + 0x8c) + ((*(int *)(param_2 + 0x2d8) >> 8) - (int)*(short *)(param_2 + 0xae)) * 0x40;
      *(int *)(param_2 + 0x90) = *(int *)(param_2 + 0x90) + iVar1 * 0x40;
    }
  }
  return;
}

// OnRender -- move position to instance matrix
// param1 = thread, param2 = driver
void FUN_8005ee34(int param_1,int param_2)

{
  bool bVar1;
  undefined *puVar2;
  byte bVar3;
  undefined2 uVar4;
  short sVar5;
  int iVar6;
  undefined4 uVar7;
  int iVar8;
  int iVar9;
  MATRIX *pMVar10;
  int iVar11;
  int *piVar12;
  uint uVar13;
  MATRIX *r0;
  int iVar14;
  undefined uVar15;
  
  // get instance from thread
  iVar14 = *(int *)(param_1 + 0x34);
  
  // If you are not in a warp pad
  if (*(char *)(param_2 + 0x376) != '\n') 
  {
	// if you're being mask grabbed and you're not on the ground
    if ((*(char *)(param_2 + 0x376) == '\x05') && ((*(uint *)(param_2 + 0x2c8) & 1) == 0)) 
	{
	  // set Y scale
      *(short *)(iVar14 + 0x1e) = *(short *)(param_2 + 0x40c) + 0xccc;
	  
      iVar6 = *(short *)(param_2 + 0x40c) * 0x28;
      if (iVar6 < 0) {
        iVar6 = iVar6 + 0xff;
      }
	  
	  // X and Z
      iVar6 = 0xccc - (iVar6 >> 8);
      if (iVar6 < 0x400) {
        iVar6 = 0x400;
      }
	  
	  // Set X and Z scale
      *(short *)(iVar14 + 0x1c) = (short)iVar6;
      *(short *)(iVar14 + 0x20) = (short)iVar6;
    }
    else {
      sVar5 = *(short *)(param_2 + 0x390);
      iVar8 = (int)sVar5;
      iVar6 = -800;
      if ((*(uint *)(param_2 + 0x2c8) & 0x400) == 0) {
        iVar11 = (int)*(short *)(param_2 + 0x410) -
                 (*(short *)(param_2 + 0x410) * 9 + iVar8 * 7 >> 4);
        iVar6 = iVar11 * 4;
        iVar9 = iVar6;
        if (iVar6 < 0) {
          iVar9 = iVar11 * -4;
        }
        if (iVar9 < 0x960) {
          iVar6 = 0;
        }
		
		// if racer did not just touch ground this frame or last
        if (((*(uint *)(param_2 + 0x2c8) | *(uint *)(param_2 + 0x2cc)) & 2) == 0) {
          bVar1 = iVar6 < 0x321;
          if (iVar6 < -800) {
            iVar6 = -800;
            goto LAB_8005ef64;
          }
        }
		
		// if racer just touched ground this frame or last
        else {
          bVar1 = iVar6 < 0x321;
          if (iVar6 < -0x640) {
            iVar6 = -0x640;
LAB_8005ef64:
            bVar1 = iVar6 < 0x321;
          }
        }
        if (!bVar1) {
          iVar6 = 800;
        }
      }
	  
      //if Hazard Timer > 0 and Hazard Timer & 80 = 0 and (?)
      if (((0 < *(short *)(param_2 + 0xe)) && ((*(ushort *)(param_2 + 0xe) & 0x80) == 0)) &&
         (-800 < iVar6)) {
        iVar6 = -800;
      }
	  
	  // if racer is not on the ground
      if (((*(uint *)(param_2 + 0x2c8) & 1) == 0) && (iVar8 < 0)) 
	  {
        // Map value from [oldMin, oldMax] to [newMin, newMax]
        // inverting newMin and newMax will give an inverse range mapping
        iVar9 = FUN_80058f9c(-iVar8,0,0xa00,0x280);
		
        if (iVar6 < iVar9) {
          iVar6 = iVar9;
        }
        *(short *)(param_2 + 0x410) = sVar5;
      }
      if ((*(int *)(param_2 + 0x18) != 0) &&
         (iVar9 = (int)*(short *)(*(int *)(param_2 + 0x18) + 0x1e), iVar9 < 0x9c4)) {
        iVar6 = iVar6 + (iVar9 + -0x800) * 2;
      }
      iVar11 = (int)*(short *)(param_2 + 0x40c);
      iVar9 = iVar6;
      if (iVar6 < 0) {
        iVar9 = -iVar6;
      }
      if (iVar11 < 0) {
        iVar11 = -iVar11;
      }
      if (iVar11 < iVar9) {
        *(short *)(param_2 + 0x40c) = (short)iVar6;
      }
	  
	  // Interpolate rotation by speed
      uVar4 = FUN_80058f54((int)*(short *)(param_2 + 0x40c),300,0);
      *(undefined2 *)(param_2 + 0x40c) = uVar4;
	  
      *(short *)(param_2 + 0x410) = (short)(*(short *)(param_2 + 0x410) * 9 + iVar8 * 7 >> 4);
      
	  if (*(short *)(param_2 + 0x404) == 0) 
	  {
        if (*(short *)(iVar14 + 0x1e) == 0) 
		{
		  // driver -> instance -> thread -> modelIndex == "player" of any kind
          if (*(short *)(*(int *)(*(int *)(param_2 + 0x1c) + 0x6c) + 0x44) == 0x18) 
		  {
			// OtherFX_Play_Echo
			// 0x5b?
            FUN_80028494(0x5b,1,*(ushort *)(param_2 + 0x2ca) & 1);
          }
          *(short *)(iVar14 + 0x1e) = *(short *)(param_2 + 0x40c) + 0xccc;
          *(undefined *)(param_2 + 0x4c) = 5;
          *(undefined *)(param_2 + 0x4d) = 0;
        }
		
        else 
		{
		  // Interpolate scale by speed
          uVar4 = FUN_80058f54((int)*(short *)(iVar14 + 0x1e),0xa0,
                               *(short *)(param_2 + 0x40c) + 0xccc);
          *(undefined2 *)(iVar14 + 0x1e) = uVar4;
        }
      }
      else {
        *(undefined2 *)(iVar14 + 0x1e) = 0;
      }
      iVar6 = *(short *)(param_2 + 0x40c) * 0xa0;
      if (iVar6 < 0) {
        iVar6 = iVar6 + 0xff;
      }
	  
	  // Interpolate scale by speed
      uVar4 = FUN_80058f54((int)*(short *)(iVar14 + 0x1c),0xa0,0xccc - (iVar6 >> 8));
      *(undefined2 *)(iVar14 + 0x1c) = uVar4;
      iVar6 = *(short *)(param_2 + 0x40c) * 0xa0;
      if (iVar6 < 0) {
        iVar6 = iVar6 + 0xff;
      }
	  
	  // Interpolate rotation by speed
      uVar4 = FUN_80058f54((int)*(short *)(iVar14 + 0x20),0xa0,0xccc - (iVar6 >> 8));
      *(undefined2 *)(iVar14 + 0x20) = uVar4;
    }
  }
  
  // Rot_AxisAngle
  FUN_8005f89c(param_2 + 0x330,param_2 + 0x368,(int)*(short *)(param_2 + 0x2ee));
  
  if (((*(short *)(param_2 + 0x3e2) == 0) ||
      (*(short *)(param_2 + 0x39e) < *(short *)(param_2 + 0x42c))) ||
     ((*(uint *)(param_2 + 0x2c8) & 0x80) != 0)) {
    bVar3 = *(byte *)(param_2 + 0x4c);
    if (bVar3 != 0) {
      if (bVar3 == 2) {
        *(undefined *)(param_2 + 0x4c) = 3;
LAB_8005f398:
        *(undefined *)(param_2 + 0x4d) = 0;
      }
      else if (bVar3 < 3) {
        if (bVar3 == 1) {
          iVar6 = DAT_80087f00 + -1;
          if (iVar6 == 0) {
            trap(0x1c00);
          }
          if ((iVar6 == -1) && (*(byte *)(param_2 + 0x4d) == 0x800000)) {
            trap(0x1800);
          }
          iVar8 = 0x100 - (int)((uint)*(byte *)(param_2 + 0x4d) << 8) / iVar6;
          iVar6 = iVar8;
          if (iVar8 < 0) {
            iVar6 = 0;
          }
          if (0x100 < iVar8) {
            iVar6 = 0x100;
          }
          uVar15 = (undefined)((uint)(iVar6 * (DAT_80087f10 + -1)) >> 8);
          *(undefined *)(param_2 + 0x4c) = 3;
          goto LAB_8005f354;
        }
      }
      else if ((bVar3 == 3) &&
              (bVar3 = *(char *)(param_2 + 0x4d) + 1, *(byte *)(param_2 + 0x4d) = bVar3,
              DAT_80087f10 <= (int)(uint)bVar3)) {
        *(undefined *)(param_2 + 0x4c) = 0;
        goto LAB_8005f398;
      }
    }
LAB_8005f39c:
    bVar3 = *(byte *)(param_2 + 0x4c);
  }
  else {
    bVar3 = *(byte *)(param_2 + 0x4c);
    if (bVar3 == 1) {
      bVar3 = *(char *)(param_2 + 0x4d) + 1;
      *(byte *)(param_2 + 0x4d) = bVar3;
      if (DAT_80087f00 <= (int)(uint)bVar3) {
        *(undefined *)(param_2 + 0x4c) = 2;
        goto LAB_8005f398;
      }
      goto LAB_8005f39c;
    }
    if (1 < bVar3) {
      if ((bVar3 != 2) && (bVar3 == 3)) {
        iVar6 = DAT_80087f10 + -1;
        if (iVar6 == 0) {
          trap(0x1c00);
        }
        if ((iVar6 == -1) && (*(byte *)(param_2 + 0x4d) == 0x800000)) {
          trap(0x1800);
        }
        iVar8 = 0x100 - (int)((uint)*(byte *)(param_2 + 0x4d) << 8) / iVar6;
        iVar6 = iVar8;
        if (iVar8 < 0) {
          iVar6 = 0;
        }
        if (0x100 < iVar8) {
          iVar6 = 0x100;
        }
        uVar15 = (undefined)((uint)(iVar6 * (DAT_80087f00 + -1)) >> 8);
        *(undefined *)(param_2 + 0x4c) = 1;
LAB_8005f354:
        *(undefined *)(param_2 + 0x4d) = uVar15;
      }
      goto LAB_8005f39c;
    }
    if (bVar3 == 0) {
      *(undefined *)(param_2 + 0x4c) = 1;
      goto LAB_8005f398;
    }
  }
  if ((bVar3 == 5) &&
     (bVar3 = *(char *)(param_2 + 0x4d) + 1, *(byte *)(param_2 + 0x4d) = bVar3,
     DAT_80087f20 <= (int)(uint)bVar3)) {
    *(undefined *)(param_2 + 0x4c) = 0;
    *(undefined *)(param_2 + 0x4d) = 0;
  }
  
  // animation index
  if (*(byte *)(param_2 + 0x4c) == 0) 
  {
	// copy matrix from driver to instance?
    *(undefined4 *)(iVar14 + 0x30) = *(undefined4 *)(param_2 + 0x330);
    *(undefined4 *)(iVar14 + 0x34) = *(undefined4 *)(param_2 + 0x334);
    *(undefined4 *)(iVar14 + 0x38) = *(undefined4 *)(param_2 + 0x338);
    *(undefined4 *)(iVar14 + 0x3c) = *(undefined4 *)(param_2 + 0x33c);
    *(undefined2 *)(iVar14 + 0x40) = *(undefined2 *)(param_2 + 0x340);
	
	// position (xyz)
    *(int *)(iVar14 + 0x44) = *(int *)(param_2 + 0x2d4) >> 8;
    *(int *)(iVar14 + 0x48) = (*(int *)(param_2 + 0x2d8) >> 8) + (*(char *)(param_2 + 0x377) * 3 >> 3);
    iVar6 = *(int *)(param_2 + 0x2dc);
  }
  
  // different animation index
  else 
  {
	// driver -> 0x330 matrix
    r0 = (MATRIX *)(param_2 + 0x330);
    
	// data from pointer table (FUN_80057884)
	piVar12 = (int *)((&DAT_80087ef4)[(uint)*(byte *)(param_2 + 0x4c) * 2] +
                     (uint)*(byte *)(param_2 + 0x4d) * 0x20);
    
	pMVar10 = r0;
    
	// instance matrix and driver matrix
	FUN_8006c3b0(iVar14 + 0x30,r0,piVar12 + 2);
	
	// load matrix
    gte_SetRotMatrix(r0);
    
	// load vector
	iVar6 = *piVar12;
	gte_ldVXY0(iVar6);
    gte_ldVZ0((uint)*(ushort *)(piVar12 + 1));
    
	gte_rtv0();
	
	// x shares register with iVar6
	// y shares register with r0
	// z shares register with pMVar10
    read_mt(iVar6,r0,pMVar10);
    
	// position (xyz)
	*(int *)(iVar14 + 0x44) = *(int *)(param_2 + 0x2d4) + iVar6 >> 8;
    *(int *)(iVar14 + 0x48) = ((int)r0->m + *(int *)(param_2 + 0x2d8) >> 8) + (*(char *)(param_2 + 0x377) * 3 >> 3);
    iVar6 = (int)pMVar10->m + *(int *)(param_2 + 0x2dc);
  }
  
  // matrix -> 0x4C (posZ)
  *(int *)(iVar14 + 0x4c) = iVar6 >> 8;
  
  // if driver is squished
  if (*(short *)(param_2 + 0x404) != 0) 
  {
	// increment position by AngleAxis_NormalVec
    *(int *)(iVar14 + 0x44) = *(int *)(iVar14 + 0x44) + (*(short *)(param_2 + 0x368) * 0x13 >> 0xc);
    *(int *)(iVar14 + 0x48) = *(int *)(iVar14 + 0x48) + (*(short *)(param_2 + 0x36a) * 0x13 >> 0xc);
    *(int *)(iVar14 + 0x4c) = *(int *)(iVar14 + 0x4c) + (*(short *)(param_2 + 0x36c) * 0x13 >> 0xc);
  }
  
  iVar6 = *(int *)(iVar14 + 0x48);
  if (-1 < iVar6) {
code_r0x8005f834:
    if (0 < iVar6) {
      *(uint *)(iVar14 + 0x28) = *(uint *)(iVar14 + 0x28) & 0xffffdfff;
    }
	
	// ptrInstanceWake
    iVar14 = *(int *)(param_2 + 0x4f8);
    
	// if valid
	if (iVar14 != 0) 
	{
	  // make invisible
      *(uint *)(iVar14 + 0x28) = *(uint *)(iVar14 + 0x28) | 0x80;
	  
      *(undefined2 *)(param_2 + 0x4fc) = 0;
      *(undefined2 *)(iVar14 + 0x1c) = 0;
      *(undefined2 *)(iVar14 + 0x20) = *(undefined2 *)(param_2 + 0x4fc);
    }
    return;
  }
  
  // touching wall so???? or is it water?
  if ((iVar6 < -0x4f) || ((*(uint *)(iVar14 + 0x28) & 0x2000) == 0)) {
    iVar6 = *(int *)(iVar14 + 0x48);
    goto code_r0x8005f834;
  }
  iVar6 = *(int *)(param_2 + 0x4f8);
  if (iVar6 == 0) {
    return;
  }
  
  // make visible
  *(uint *)(iVar6 + 0x28) = *(uint *)(iVar6 + 0x28) & 0xffffff7f;
  
  // animation data
  *(char *)(iVar6 + 0x50) = *(char *)(iVar14 + 0x50) + '\x01';
  *(char *)(iVar6 + 0x51) = *(char *)(iVar14 + 0x51) + -1;
  
  // instance posX, posY, posZ
  uVar7 = *(undefined4 *)(iVar14 + 0x44);
  *(undefined4 *)(iVar6 + 0x48) = 0;
  *(undefined4 *)(iVar6 + 0x44) = uVar7;
  *(undefined4 *)(iVar6 + 0x4c) = *(undefined4 *)(iVar14 + 0x4c);
  
  // driver -> rotation
  uVar13 = (uint)*(short *)(param_2 + 0x39a);

  // approximate trigonometry

  // Sin(angle)
  sVar5 = (short)*(int *)(&DAT_800845a0 + (uVar13 & 0x3ff) * 4);

  // Cos(angle)
  iVar14 = *(int *)(&DAT_800845a0 + (uVar13 & 0x3ff) * 4) >> 0x10;

  // if (0 < angle < 90) or (180 < angle < 270)
  if ((uVar13 & 0x400) == 0) {
    iVar8 = (int)sVar5;
    if ((uVar13 & 0x800) == 0) goto LAB_8005f6a4;
    iVar9 = -iVar14;
  }

  // if (90 < angle < 180) or (270 < angle < 360)
  else {
    iVar9 = (int)sVar5;
    iVar8 = iVar14;
    if ((uVar13 & 0x800) == 0) {
      iVar14 = -iVar9;
      goto LAB_8005f6a4;
    }
  }
  iVar8 = -iVar8;
  iVar14 = iVar9;
LAB_8005f6a4:

  // instance rotation
  // looks like 5 int variables, but it's really
  // 9 short variables, 3x3 rotation matrix
  *(int *)(iVar6 + 0x30) = iVar14;
  *(int *)(iVar6 + 0x34) = iVar8;
  *(undefined4 *)(iVar6 + 0x38) = 0x1000;
  *(int *)(iVar6 + 0x3c) = -iVar8;
  *(short *)(iVar6 + 0x40) = (short)iVar14;
  
  puVar2 = PTR_DAT_8008d2ac;
  
  if (*(short *)(param_2 + 0x4fc) == 0) {
    *(undefined2 *)(param_2 + 0x4fc) = 0x1000;
	
	// if less than 2 screens
    if ((byte)puVar2[0x1ca8] < 2) 
	{
	  // get speed
      iVar14 = (int)*(short *)(param_2 + 0x38c);
	  
	  // absolute value
      if (iVar14 < 0) {
        iVar14 = -iVar14;
      }
	  
      if (
			// if speed is high
			(0xc00 < iVar14) && 
			
			(
				// spawn 10 particles
				iVar14 = 10, 

				// racerY position is more than -0x200
				-0x200 < *(int *)(param_2 + 0x2e4)
			)
		  ) 
	  {
		// spawn particles till counter runs out
        do 
		{
		  // 0x2138 = "falling"
		  // like splashing in water on coco park

		  // Create instance in particle pool
          iVar8 = FUN_80040308(0,*(undefined4 *)(PTR_DAT_8008d2ac + 0x2138),&DAT_80089a94);
          
		  // if particle was made properly
		  if (iVar8 != 0) 
		  {
            *(undefined *)(iVar8 + 0x18) = *(undefined *)(*(int *)(param_2 + 0x1c) + 0x50);

			// driver->instSelf
			*(undefined4 *)(iVar8 + 0x20) = *(undefined4 *)(param_2 + 0x1c);

			// driverID
            *(undefined *)(iVar8 + 0x19) = *(undefined *)(param_2 + 0x4a);
          }

		  // reduce counter
          iVar14 = iVar14 + -1;
		  
        } while (iVar14 != 0);
      }
    }
  }
  
  // if number of screens is less than 2
  else if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 2) 
  {
	// get speed
    iVar14 = (int)*(short *)(param_2 + 0x38c);
	
	// absolute value
    if (iVar14 < 0) {
      iVar14 = -iVar14;
    }
	
    if (
			// if speed is high
			(0xc00 < iVar14) &&
			
			// spawn one particle
			(
				// 0x2138 = "falling"
				// like splashing in water on coco park

				// Create instance in particle pool
				iVar14 = FUN_80040308(0,*(undefined4 *)(PTR_DAT_8008d2ac + 0x2138),&DAT_80089a94),
				iVar14 != 0
			)
		) 
	{
      *(undefined *)(iVar14 + 0x18) = *(undefined *)(*(int *)(param_2 + 0x1c) + 0x50);
      
	  // driver -> instSelf
	  *(undefined4 *)(iVar14 + 0x20) = *(undefined4 *)(param_2 + 0x1c);
      
	  // driverID
	  *(undefined *)(iVar14 + 0x19) = *(undefined *)(param_2 + 0x4a);
    }
  }

  // instance -> scale (x, z)
  *(undefined2 *)(iVar6 + 0x1c) = *(undefined2 *)(param_2 + 0x4fc);
  *(undefined2 *)(iVar6 + 0x20) = *(undefined2 *)(param_2 + 0x4fc);
  return;
}


// Rot_AxisAngle
// param1 - matrix
// param2 - normal axis
// param3 - angle
// equivalent to glm::AngleAxis, Unity Quaternion.AngleAxis, UE4 FVector AngleAxis
void FUN_8005f89c(undefined2 *param_1,short *param_2,uint param_3)

{
  short sVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  short sVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  short sVar9;
  int iVar10;
  int iVar11;
  undefined4 uVar12;
  int iVar13;
  undefined4 uVar14;
  undefined4 uVar15;
  int iVar16;
  int iVar17;
  int iVar18;

  // normalX
  sVar1 = *param_2;
  param_1[1] = sVar1;

  // normalY
  sVar9 = param_2[1];
  iVar11 = (int)sVar1;
  param_1[4] = sVar9;

  // normalZ
  iVar10 = (int)param_2[2];
  param_1[7] = param_2[2];

  // approximate trigonometry
  sVar1 = (short)*(int *)(&DAT_800845a0 + (param_3 & 0x3ff) * 4);
  iVar2 = *(int *)(&DAT_800845a0 + (param_3 & 0x3ff) * 4) >> 0x10;

  // if (0 < angle < 90) or (180 < angle < 270)
  if ((param_3 & 0x400) == 0)
  {
    iVar7 = (int)sVar1;

	// if (0 < angle < 90)
    if ((param_3 & 0x800) == 0) goto LAB_8005f934;

	// if (180 < angle < 270)
	// make X and Y values negative
	iVar8 = -iVar2;
  }

  // if (90 < angle < 180) or (270 < angle < 360)
  else
  {
    iVar8 = (int)sVar1;
    iVar7 = iVar2;

	// if (90 < angle < 180)
    if ((param_3 & 0x800) == 0) {
      iVar2 = -iVar8;
      goto LAB_8005f934;
    }

	// if (270 < angle < 360)
		// proceed without "goto"
  }

  iVar7 = -iVar7;
  iVar2 = iVar8;

  LAB_8005f934:
  iVar16 = iVar11 * iVar11;
  iVar17 = iVar10 * iVar10;
  iVar18 = iVar11 * -iVar10;
  iVar6 = iVar16 + iVar17;
  iVar13 = iVar7 * sVar9 >> 0xc;
  sVar1 = (short)iVar13;
  iVar8 = iVar2 * sVar9 >> 0xc;
  sVar9 = (short)iVar8;
  
  gte_ldLZCS(iVar6);
  iVar3 = gte_stLZCR();

  if (iVar6 == 0)
  {
    iVar2 = iVar7 * iVar11 + iVar2 * iVar10;

	// if normalY is negative
	if (param_2[1] < 0)
	{
	  // flip
      sVar1 = -sVar1;
    }
  }
  else {
    uVar4 = 0x14 - iVar3;
    if (0 < (int)uVar4) {
      iVar16 = iVar16 >> (uVar4 & 0x1f);
      iVar17 = iVar17 >> (uVar4 & 0x1f);
      iVar18 = iVar18 >> (uVar4 & 0x1f);
      iVar6 = iVar6 >> (uVar4 & 0x1f);
    }
    iVar13 = iVar7 - iVar13;
    iVar8 = iVar2 - iVar8;
    iVar3 = iVar13 * iVar17 + iVar8 * iVar18;
    if (iVar6 == 0) {
      trap(0x1c00);
    }
    if ((iVar6 == -1) && (iVar3 == -0x80000000)) {
      trap(0x1800);
    }
    iVar8 = iVar13 * iVar18 + iVar8 * iVar16;
    if (iVar6 == 0) {
      trap(0x1c00);
    }
    if ((iVar6 == -1) && (iVar8 == -0x80000000)) {
      trap(0x1800);
    }
    sVar1 = sVar1 + (short)(iVar3 / iVar6);
    iVar2 = iVar7 * iVar11 + iVar2 * iVar10;
    sVar9 = sVar9 + (short)(iVar8 / iVar6);
  }

  // write to matrix
  param_1[2] = sVar1;
  sVar5 = (short)(-iVar2 >> 0xc);
  param_1[5] = sVar5;
  param_1[8] = sVar9;

  // axis to rotate on
  gte_ldopv1SV(param_2);


  // new GTE calls this 
  // gte_ldopv2SV(r0);
  setCopReg(2,0x4800,(int)sVar1);
  setCopReg(2,0x5000,(int)sVar5);
  setCopReg(2,0x5800,(int)sVar9);


  gte_op12();
  read_mt(uVar12,uVar14,uVar15);
  

  // write to matrix
  *param_1 = (short)uVar12;
  param_1[3] = (short)uVar14;
  param_1[6] = (short)uVar15;

  return;
}


// param1 - driver object
// called from:
//		Player_Driving_Interpolate
//		Player_Drifting_Interpolate
uint FUN_8005fb4c(int param_1)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  undefined4 uVar5;

  // speed
  iVar1 = (int)*(short *)(param_1 + 0x38e);

  *(undefined2 *)(param_1 + 0x3cc) = 0;
  *(undefined2 *)(param_1 + 0x3ce) = 0;
  if (iVar1 < 0) {
    iVar1 = -iVar1;
  }

  // low speed (useless? shoould just be '= 0;')
  uVar2 = (uint)(iVar1 < 0x301);

  *(undefined2 *)(param_1 + 0x3d0) = 0;

  if (
		// high speed
		(iVar1 >= 0x301) &&

		(
			// high speed
			uVar2 = 1,

			// if not crashing
			*(char *)(param_1 + 0x376) != '\x01'
		)
	  )
  {
	// check if driver is in warppad
    uVar2 = *(uint *)(param_1 + 0x2c8) & 0x4000;

	if (
		// if driver is not being warped
		(uVar2 == 0) &&
		(
			(
				(
					// if driver is on quadblock
					uVar2 = *(uint *)(param_1 + 0x2c8) & 1,

					*(short *)(param_1 + 0x3fe) == 0 &&

					// if driver is on quadblock
					(uVar2 != 0)
				)
				&&
				(
					// driver -> terrain meta -> ???
					uVar2 = *(uint *)(*(int *)(param_1 + 0x358) + 0x10),

					// if valid ???
					uVar2 != 0
				)
			)
		)
	   )
	{

	  uVar4 = (int)*(short *)(param_1 + 0x3c6) - (int)*(short *)(param_1 + 0x3c8);

	  // kart angle cap from 'straight to camera'
	  uVar3 = (uint)*(byte *)(param_1 + 0x457);

	  if ((int)uVar3 < (int)uVar4) {
        uVar4 = uVar3;
      }
      if ((int)uVar4 < (int)-uVar3) {
        uVar4 = -uVar3;
      }

	  // approximate trigonometry
      iVar1 = *(int *)(&DAT_800845a0 + (uVar4 & 0x3ff) * 4);

	  if ((uVar4 & 0x400) == 0) {
        iVar1 = iVar1 << 0x10;
      }
      iVar1 = iVar1 >> 0x10;
      if ((uVar4 & 0x800) != 0) {
        iVar1 = -iVar1;
      }

	  // before this function is called, there is always
	  // gte_SetRotMatrix, AxisAngle, driver -> 0x310

      uVar2 = ((int)(uVar2 * -8000) >> 8) * iVar1 >> 0xc & 0xffff;
      gte_ldVXY0(uVar2);
      gte_ldVZ0(0);
      gte_rtv0();
      uVar5 = gte_stMAC1();
      *(short *)(param_1 + 0x3cc) = (short)uVar5;
      uVar5 = gte_stMAC2();
      *(short *)(param_1 + 0x3ce) = (short)uVar5;
      uVar5 = gte_stMAC3();
      *(short *)(param_1 + 0x3d0) = (short)uVar5;
    }
  }

  // does not really "return" anything, it just
  // sees something in r2 and assumes. Stupid ghidra
  return uVar2;
}


// Player_Driving_Interpolate
void FUN_8005fc8c(undefined4 param_1,int param_2)

{
  bool bVar1;
  bool bVar2;
  undefined2 uVar3;
  short sVar4;
  int iVar5;
  int iVar6;
  undefined4 uVar7;
  int iVar8;
  int iVar9;
  uint uVar10;
  int iVar11;
  int iVar12;
  short sVar13;
  int iVar14;
  int iVar15;
  int iVar16;
  short sVar17;
  int iVar18;
  int iVar19;
  uint local_38;

  // get camera rotation
  iVar14 = (int)*(short *)(param_2 + 0x2f2);

  // copy the variable
  iVar5 = iVar14;

  // make sure the camera is not negative; ie. get camera angle absolute
  if (iVar14 < 0) {
    iVar5 = -iVar14;
  }

  // elapsed milliseconds per frame, ~32
  iVar8 = *(int *)(PTR_DAT_8008d2ac + 0x1d04);

  uVar10 = iVar5 >> 3;
  if (uVar10 == 0) {
    uVar10 = 1;
  }
   // meta behaviour
  if ((int)(uint)*(byte *)(param_2 + 0x46a) < (int)uVar10) {
    uVar10 = (uint)*(byte *)(param_2 + 0x46a);
  }

  // Interpolate rotation by speed 
  // Rotation_Interpolation(rotPrev.w, 8, uVar10)
  iVar5 = FUN_80058f54((int)*(short *)(param_2 + 0x2fa),8,uVar10);

  // rotPrev.w = iVar5
  *(undefined2 *)(param_2 + 0x2fa) = (short)iVar5;

  // Interpolate rotation by speed
  // Rotation_Interpolation( abs(camerarotation), rotPrev.w * elapsedTimeInMS >> 5, 0)
  uVar3 = FUN_80058f54(iVar14,iVar5 * iVar8 >> 5,0);

  local_38 = *(uint *)(param_2 + 0x2c8);
  // sVar4 = numFramesSpentSteering
  sVar4 = *(short *)(param_2 + 1000);

  // set camera rotation (rotCurr.W)
  *(undefined2 *)(param_2 + 0x2f2) = uVar3;

  // speedApprox
  iVar14 = (int)*(short *)(param_2 + 0x38e);
  // int simpTurnState256 = simpTurnState * 0x100
  iVar5 = (int)*(char *)(param_2 + 0x4b) * 0x100;
  if (iVar14 < 1) {
    if (*(short *)(param_2 + 0x39c) < 0) {
      sVar4 = -1;
      *(undefined2 *)(param_2 + 1000) = 0xffff; // -1
    }
    if (-1 < iVar14) goto LAB_8005fd74;
  }
  else {
LAB_8005fd74:
    if (-1 < *(short *)(param_2 + 0x39c)) {
      sVar4 = 1;
      *(undefined2 *)(param_2 + 1000) = 1;
    }
  }
  if (sVar4 < 0) {
    // simpTurnState256 = simpTurnState * -0x100;
    iVar5 = (int)*(char *)(param_2 + 0x4b) * -0x100;
    // ActionsFlagSet = ActionsFlagSet ^ 0x10
    local_38 = local_38 ^ 0x10;
  }
  if (iVar14 < 0) {
    iVar14 = -iVar14;
  }
  if (
		((local_38 & 1) != 0) &&

		// if you're not on any turbo pad
		((*(uint *)(param_2 + 0xbc) & 3) == 0)
	  )
  {

    // Map value from [oldMin, oldMax] to [newMin, newMax]
    // inverting newMin and newMax will give an inverse range mapping
    iVar5 = FUN_80058f9c(iVar14,0x10,0x300,0,iVar5);
  }
  //terrainMeta1
  iVar12 = *(int *)(param_2 + 0x358);
  // turningAcceleration = driver.turningAcceleration;
  iVar9 = (int)*(short *)(param_2 + 0x3b4);
  if (iVar5 == 0)
  {
	// Interpolate rotation by speed
    //
    sVar4 = FUN_80058f54(iVar9,((int)*(short *)(param_2 + 0x43e) +
                               (int)*(char *)(param_2 + 0x34) * 0x32) * *(int *)(iVar12 + 0x28) >> 8
                         ,0);
  }
  else {
    bVar1 = iVar5 < 0;
    if (bVar1) {
      iVar5 = -iVar5;
      iVar9 = -iVar9;
    }
    sVar4 = (short)iVar9;
    //if (turningAcceleration < simpTurnState256) {
    if (iVar9 < iVar5) {
      //turningAcceleration = turningAcceleration + ((TurningInputResponseStat + TurnConst * 100) * (terrainMeta1 + 0x28) >> 8);
        // 100%
      iVar9 = iVar9 + (((int)*(short *)(param_2 + 0x43e) + (int)*(char *)(param_2 + 0x34) * 100) *
                       *(int *)(iVar12 + 0x28) >> 8);
      //turningAccelerationS16 = (short)turningAcceleration;
      sVar4 = (short)iVar9;

      /*if (simpTurnState256 < turningAcceleration) {
         turningAccelerationS16 = (short)simpTurnState256;
      }*/
      bVar2 = iVar5 < iVar9;
LAB_8005fee4:
      if (bVar2) {
        sVar4 = (short)iVar5;
      }
    }
    else {
      //if (simpTurnState256 < turningAcceleration)
      if (iVar5 < iVar9) {
        //turningAcceleration = turningAcceleration - ((TurningInputResponseStat + TurnConst * 0x32) * (terrainMeta1 + 0x28) >> 8)
        // 50%
        iVar9 = iVar9 - (((int)*(short *)(param_2 + 0x43e) + (int)*(char *)(param_2 + 0x34) * 0x32)
                         * *(int *)(iVar12 + 0x28) >> 8);
        //turningAccelerationS16 = (short)turningAcceleration;
        sVar4 = (short)iVar9;

        /*if (turningAcceleration < simpTurnState256) {
            turningAccelerationS16 = (short)simpTurnState256;
        }*/
        bVar2 = iVar9 < iVar5;
        goto LAB_8005fee4;
      }
    }
    //if (isTurnSignNegative)
    if (bVar1) {
        //turningAccelerationS16 = -turningAccelerationS16
      sVar4 = -sVar4;
    }
  }
  // timeUntilDriftSpinout spin out timer.
  iVar5 = (int)*(short *)(param_2 + 0x3ec);

  //turningAcceleration = turningAccelerationS16;
  iVar9 = (int)sVar4;
  // driver.turningAcceleration = turningAccelerationS16
  *(short *)(param_2 + 0x3b4) = sVar4;

  if (iVar5 != 0) {
    //int deltaTime = (timeUntilDriftSpinout - elapsedTimeInMS);
    uVar3 = (undefined2)(iVar5 - iVar8);

    // Map value from [oldMin, oldMax] to [newMin, newMax]
    // inverting newMin and newMax will give an inverse range mapping
    // deltaRotation = Misc.MapToRange(timeUntilDriftSpinout,0,0x140,0,previousFrameMultDrift);
    iVar6 = FUN_80058f9c(iVar5,0,0x140,0,(int)*(short *)(param_2 + 0x3ea));
    // turningAcceleration = turningAcceleration + deltaRotation;
    iVar9 = iVar9 + iVar6;
    // if (deltaTime < 0)
    if (iVar5 - iVar8 < 0) {
      uVar3 = 0;
    }
    // timeUntilDriftSpinout = 
    *(undefined2 *)(param_2 + 0x3ec) = uVar3;
  }
  // iVar11 = character_Speed << 10;
  iVar11 = (uint)*(ushort *)(param_2 + 0x42c) << 0x10;
  // iVar6 = iVar11 >> 10; back to, kind of unoptimized haha
  iVar6 = iVar11 >> 0x10;
  // not sure?
  iVar19 = (uint)*(byte *)(param_2 + 0x45d) * iVar6;
  // kartTurnAnimation = MetaPhys.kartTurnAnimation * iVar6
  iVar6 = (uint)*(byte *)(param_2 + 0x45c) * iVar6;
  sVar4 = *(short *)(param_2 + 0x3d2);
  iVar5 = (int)*(short *)(param_2 + 0x452);
  iVar18 = iVar19 >> 8;
  iVar16 = iVar6 >> 8;
  if ((local_38 & 0x20) != 0) {
    iVar18 = iVar19 >> 9;
    if (0x300 < iVar14)
	{
	  // driver is leaving skids
      *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) | 0x800;
    }
    iVar16 = iVar6 >> 9;
    if (*(short *)(param_2 + 0x39c) == 0) {
      iVar5 = (int)*(short *)(param_2 + 0x454);
    }
    else {
      iVar6 = (int)*(short *)(param_2 + 0x38c);
      if (iVar6 < 0) {
        iVar6 = -iVar6;
      }

      // Map value from [oldMin, oldMax] to [newMin, newMax]
      // inverting newMin and newMax will give an inverse range mapping
      iVar5 = FUN_80058f9c(iVar6,0x300,iVar11 >> 0x11,(int)*(short *)(param_2 + 0x454),iVar5);
    }
  }
  iVar6 = (int)*(short *)(param_2 + 0x38c);
  if (iVar6 < 0) {
    iVar6 = -iVar6;
  }
  iVar19 = ((uint)*(byte *)(param_2 + 0x43a) + ((int)*(char *)(param_2 + 0x34) << 1) / 5) * 0x100;

  // Map value from [oldMin, oldMax] to [newMin, newMax]
  // inverting newMin and newMax will give an inverse range mapping
  iVar11 = FUN_80058f9c(iVar6,iVar16,iVar18,iVar19,0);
  iVar6 = 0;
  if (iVar16 <= iVar14) {
    iVar15 = iVar9;
    if (iVar9 < 0) {
      iVar15 = -iVar9;
    }
    if (iVar11 < iVar15) {
      iVar6 = (int)*(short *)(param_2 + 0x39e);
      if (iVar6 < 0) {
        iVar6 = -iVar6;
      }

      // Map value from [oldMin, oldMax] to [newMin, newMax]
      // inverting newMin and newMax will give an inverse range mapping
      uVar7 = FUN_80058f9c(iVar6,iVar16,iVar18,0,iVar5);

      // Map value from [oldMin, oldMax] to [newMin, newMax]
      // inverting newMin and newMax will give an inverse range mapping
      iVar6 = FUN_80058f9c(iVar15,iVar11,iVar19,0,uVar7);
      if (iVar9 < 0) {
        iVar6 = -iVar6;
      }
    }
  }
  sVar13 = *(short *)(param_2 + 0x3c6);

  // Player_Driving_LerpToForwards
  sVar4 = FUN_80060488(param_2,(int)sVar13,(int)sVar4,iVar6);

  *(short *)(param_2 + 0x3d2) = sVar4;
  iVar6 = (int)sVar4;
  if (*(int *)(iVar12 + 0x24) != 0x100) {
    iVar6 = *(int *)(iVar12 + 0x24) * iVar6 >> 8;
  }
  iVar16 = (int)sVar13 + (iVar6 * iVar8 >> 5);
  *(short *)(param_2 + 0x3c6) = (short)iVar16;
  iVar11 = iVar9;
  if ((0x2ff < iVar14) && ((local_38 & 1) != 0))
  {
	// number of frames spent steering
    sVar4 = *(short *)(param_2 + 0x3e6);

	// Player_Steer_GetAngularVelocity
	// all these offsets are MetaPhys, and each one is only used here
    iVar18 = FUN_8005900c(

		// frames spent steering
		(int)sVar4,

		(int)*(char *)(param_2 + 0x447),
		(int)*(char *)(param_2 + 0x448),
		(int)*(char *)(param_2 + 0x446),


		(int)*(short *)(param_2 + 0x44c),

		// max steer strength (0xc00)
        (int)*(short *)(param_2 + 0x44a)
	);

    if (iVar9 < 0) {
      iVar11 = -iVar9;
    }
    iVar11 = *(short *)(param_2 + 0x44e) * iVar11 >> 8;

	// increment frame counter
    *(short *)(param_2 + 0x3e6) = sVar4 + 1;

	// the higher the value of iVar18,
	// the more steering is "locked up",
	// try setting mov r3, xxxx at 80060170 for proof

    if (iVar11 < iVar18) {
      iVar18 = iVar11;
    }
    if ((local_38 & 0x10) != 0) {
      iVar18 = -iVar18;
    }
    iVar19 = (int)*(short *)(param_2 + 0x450);
    if ((iVar9 < 1) || (iVar11 = -iVar19, iVar11 <= iVar9 + iVar18)) {
      if (iVar9 < 0) {
        iVar11 = iVar9 + iVar18;
        if (iVar19 < iVar9 + iVar18) {
          iVar11 = iVar19;
        }
      }
      else {
        iVar11 = iVar9 + iVar18;
      }
    }
  }
  iVar9 = (int)*(short *)(param_2 + 0x3d4);
  sVar4 = *(short *)(param_2 + 0x3d8);
  sVar13 = *(short *)(param_2 + 0x3d6);
  if (((*(uint *)(iVar12 + 4) & 0x10) == 0) && ((local_38 & 1) != 0)) {
    iVar18 = iVar16;
    if (iVar16 < 0) {
      iVar18 = -iVar16;
    }
    if (iVar5 * 3 >> 2 < iVar18) {
      iVar5 = iVar6;
      if (iVar6 < 0) {
        iVar5 = -iVar6;
      }
      if (iVar5 < 3) {
        iVar5 = iVar9;
        if (iVar9 < 0) {
          iVar5 = -iVar9;
        }
        if (iVar5 < 10) {
          sVar4 = 8;
          sVar13 = 0x14;
          if (iVar16 < 0) {
            sVar13 = -0x14;
          }
        }
      }
      goto LAB_80060284;
    }
  }
  sVar4 = 0;
LAB_80060284:
  iVar5 = iVar9;
  if (iVar9 < 0) {
    iVar5 = -iVar9;
  }
  if (0x32 < iVar5) {
    sVar4 = 0;
  }
  if (sVar4 == 0) {
    iVar5 = 10;
    if (0 < iVar9) {
      iVar5 = -10;
    }
    sVar13 = (short)iVar5;
    if (iVar5 < 0) {
      iVar5 = -iVar5;
    }

	// Interpolate rotation by speed
    sVar17 = FUN_80058f54(iVar9,iVar5,0);
  }
  else {
    sVar4 = sVar4 + -1;
    sVar17 = *(short *)(param_2 + 0x3d4) + sVar13;
  }
  uVar10 = SEXT24(*(short *)(param_2 + 0x39a));
  *(short *)(param_2 + 0x3d8) = sVar4;
  *(short *)(param_2 + 0x3d4) = sVar17;
  *(short *)(param_2 + 0x3d6) = sVar13;

  // Map value from [oldMin, oldMax] to [newMin, newMax]
  // inverting newMin and newMax will give an inverse range mapping
  iVar5 = FUN_80058f9c(iVar14,0,0x600,iVar6,0);
  iVar14 = iVar5 * iVar8 >> 5;
  iVar5 = iVar14;
  if (iVar14 < 0) {
    iVar5 = -iVar14;
  }
  if (1 < iVar5) {
    uVar10 = uVar10 - iVar14 & 0xfff;
  }
  *(undefined2 *)(param_2 + 0xc0) = (short)iVar11;
  uVar10 = uVar10 + (iVar11 * iVar8 >> 0xd) & 0xfff;
  sVar4 = (short)uVar10;
  *(short *)(param_2 + 0x39a) = sVar4;
  *(short *)(param_2 + 0x2ee) = sVar4 + (short)iVar16 + sVar17;
  if (((local_38 & 8) == 0) && (*(short *)(param_2 + 0x3c2) < 7)) {
    if (*(int *)(iVar12 + 0x14) != 0x100) {
      iVar11 = iVar11 * *(int *)(iVar12 + 0x14) >> 8;
    }
  }
  else {
    iVar11 = iVar11 * 10 >> 8;
  }
  *(ushort *)(param_2 + 0x396) =
       *(short *)(param_2 + 0x396) + (short)(iVar11 * iVar8 >> 0xd) & 0xfff;

  // Rot_AxisAngle
  FUN_8005f89c((undefined4 *)(param_2 + 0x310),param_2 + 0x360,uVar10);
  gte_SetRotMatrix((MATRIX *)(param_2 + 0x310));

  FUN_8005fb4c(param_2);
  return;
}



int FUN_80060458(int param_1,int param_2)

{
  if (
		// if desired != 0
		(param_2 != 0) &&
		(
			// desired /= 4
			param_2 = param_2 >> 2,

			// if desired == 0
			param_2 == 0
		)
	 )
  {
	// desired = 1
    param_2 = 1;
  }

  // if current >= desired/4
  if (param_2 <= param_1)
  {
	// current = desired/4
    param_1 = param_2;
  }

  return param_1;
}


// Player_Driving_LerpToForwards
// "return 0;" will make car stay in "drift steer" rotation,
// and not interpolate to rotate a forwards direction
int FUN_80060488(int param_1,int param_2,int param_3,int param_4)

{
  bool bVar1;
  uint uVar2;
  int iVar3;

  bVar1 = false;
  *(undefined2 *)(param_1 + 0x3ca) = 0;
  if ((param_4 < 0) || ((param_4 == 0 && (param_2 < 0)))) {
    bVar1 = true;
    param_2 = -param_2;
    param_3 = -param_3;
    param_4 = -param_4;
  }
  iVar3 = 0;
  if (*(short *)(param_1 + 0x3fe) != 0xf0) {
    if (param_4 < param_2) {
      if (*(short *)(param_1 + 0x452) < param_2) {
        uVar2 = (uint)*(byte *)(param_1 + 0x458) * 0xf;
      }
      else {
        uVar2 = (uint)*(byte *)(param_1 + 0x458);
      }
      iVar3 = FUN_80060458(uVar2,param_2 - param_4,0);
      iVar3 = -iVar3;
    }
    else {
      if (param_2 < param_4) {
        if (param_2 < 0) {
          iVar3 = FUN_80060458((uint)*(byte *)(param_1 + 0x459),param_4 - param_2,0);
        }
        else {
          iVar3 = FUN_80060458((uint)*(byte *)(param_1 + 0x457),param_4 - param_2,0);
          *(undefined2 *)(param_1 + 0x3ca) = (short)param_4;
        }
      }
    }
  }

  // Interpolate rotation by speed
  iVar3 = FUN_80058f54(param_3,(uint)*(byte *)(param_1 + 0x45a),iVar3);
  if (bVar1) {
    iVar3 = -iVar3;
  }
  return iVar3;
}


// Driver_Jump_GetVelY
// if "return 0;" then you jump off a ramp and get no height
int FUN_800605a0(short *param_1,int *param_2)

{
  int iVar1;
  int iVar2;

  // y1
  iVar2 = (int)param_1[1];

  iVar1 = iVar2;
  if (iVar2 < 0) {
    iVar1 = -iVar2;
  }

  if (0x14 < iVar1)
  {

    iVar1 =

		// x2 * x1
		*param_2 * (int)*param_1 +

		// z2 * z1
		param_2[2] * (int)param_1[2];

	// alert debugger on error
	if (iVar2 == 0) trap(0x1c00);
    if ((iVar2 == -1) && (iVar1 == -0x80000000)) trap(0x1800);

    return iVar1 / iVar2;
  }
  return 0;
}


 // Player_JumpAndFriction
void FUN_80060630(undefined4 param_1,int param_2)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  short sVar6;
  int iVar7;
  short sVar8;
  short sVar9;
  int iVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  int local_28;
  uint local_24;
  int local_20;

  // driver -> 0x310
  gte_SetRotMatrix((MATRIX *)(param_2 + 0x310));

  if (
		(
			// if driver is not drifting
			(*(char *)(param_2 + 0x376) != '\x02') &&

			//if driver is not using mask weapon
			((*(uint *)(param_2 + 0x2c8) & 0x800000) == 0)
		) &&

		(*(short *)(param_2 + 0x3e2) == 0)
	 )
  {
    iVar7 = (int)((uint)*(ushort *)(param_2 + 0xc0) << 0x10) >> 0x18;
    if (iVar7 < 0) {
      iVar7 = -iVar7;
    }

    // Map value from [oldMin, oldMax] to [newMin, newMax]
    // inverting newMin and newMax will give an inverse range mapping
    iVar2 = FUN_80058f9c(iVar7,0,(uint)*(byte *)(param_2 + 0x43b),0,(int)*(short *)(param_2 + 0x43c)
                        );
    iVar10 = (int)*(short *)(param_2 + 0x39c);
    iVar7 = iVar10;
    if (iVar10 < 0) {
      iVar7 = -iVar10;
    }
    sVar6 = (short)iVar2;
    if (iVar7 < iVar2) {
      sVar6 = (short)iVar7;
    }
    sVar8 = -sVar6;
    if (iVar10 < 0) {
      sVar8 = sVar6;
    }
    *(short *)(param_2 + 0x39c) = *(short *)(param_2 + 0x39c) + sVar8;
  }
  if (*(short *)(param_2 + 0x3fe) != 0) {
    if (*(short *)(param_2 + 0x38a) < *(short *)(param_2 + 0x39c)) {
      *(undefined2 *)(param_2 + 0x39c) = *(undefined2 *)(param_2 + 0x38a);
    }
    if ((int)*(short *)(param_2 + 0x39c) < -(int)*(short *)(param_2 + 0x38a)) {
      *(short *)(param_2 + 0x39c) = -*(short *)(param_2 + 0x38a);
    }
  }
  local_28 = *(int *)(param_2 + 0x88);
  local_24 = *(uint *)(param_2 + 0x8c);
  local_20 = *(int *)(param_2 + 0x90);
  uVar13 = 0;
  iVar7 = 0;

  // if driver is not on quadblock
  if ((*(uint *)(param_2 + 0x2c8) & 1) == 0) {
LAB_80060ab0:

	if (
			// If you want to fire a weapon
			((*(uint *)(param_2 + 0x2c8) & 0x8000) != 0) &&

			// If that weapon is a spring
			(*(char *)(param_2 + 0x36) == '\x05')
		)
	{
		// Remove the request to fire a weapon, since we will use it now
      *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) & 0xffff7fff;

      if ((*(short *)(param_2 + 0x3f4) != 0) && (*(short *)(param_2 + 0x3f2) == 0))
	  {
		// driver is now forced to jump
        *(undefined2 *)(param_2 + 0x3f6) = 0xa0;

		// const_Jump * 9
        iVar7 = (int)*(short *)(param_2 + 0x418) * 9;

		// always true
        if (iVar7 < 0)
		{
		  // add 3
          iVar7 = iVar7 + 3;
        }

        *(undefined2 *)(param_2 + 0x3f8) = (short)(iVar7 >> 2);

		// OtherFX_Play_Echo
		// spring weapon sound
        FUN_80028494(9,1,(uint)*(ushort *)(param_2 + 0x2ca) & 1);

        *(undefined2 *)(param_2 + 0x3fa) = 0x180;
        goto LAB_80060c30;
      }
      *(undefined2 *)(param_2 + 0x3c) = 0;
    }

	// if not being forced to jump (turtles), this should cause the tiny jumps on top of walls.
	if (*(char *)(param_2 + 0x366) == '\0')
	{
      if (
			(
				// if driver left quadblock more than 0.16s ago
				(*(short *)(param_2 + 0x3f4) == 0) ||

				// jump buffer is zero
				(*(short *)(param_2 + 0x3f0) == 0)
			) ||

			(*(short *)(param_2 + 0x3f2) != 0)
		 )
	  {
        if (
			(
			 // if player is touching ground
			 ((*(uint *)(param_2 + 0x2c8) & 1) != 0) &&

			 // if player is over a quadblock
			 (*(int *)(param_2 + 0x350) != 0)
			) &&
            (
			 // unknown quadblock variable
			 iVar7 = (int)*(char *)(*(int *)(param_2 + 0x350) + 0x3b),
			 iVar7 != 0
			)
		   )
		{
		  // player speed
          iVar2 = (int)*(short *)(param_2 + 0x38e);
          if (iVar2 < 0) { // change sign of player speed
            iVar2 = -iVar2;
          }
		  
          gte_ldVXY0((iVar7 * iVar2 >> 8) << 0x10);
          gte_ldVZ0(0);
          gte_rtv0();
          read_mt(iVar7,iVar2,iVar10);

          local_28 = local_28 + iVar7;
          local_20 = local_20 + iVar10;
          local_24 = local_24 + iVar2;
        }
        goto LAB_80060e1c;
      }
      *(undefined2 *)(param_2 + 0x3f6) = 0xa0;
	  
	  // increment jump counter (all jumps? what kind of jump?)
      *(short *)(param_2 + 0x554) = *(short *)(param_2 + 0x554) + 1;

	  // const_Jump
      *(undefined2 *)(param_2 + 0x3f8) = *(undefined2 *)(param_2 + 0x418);

	  // OtherFX_Play_Echo
	  // play jump sound
      FUN_80028494(8,1,(uint)*(ushort *)(param_2 + 0x2ca) & 1);
    }

	// if being forced to jump (by turtles)
    else
	{
	  // if first frame (basically)
      if (
			// if not currently airborne from forced jump
			(*(short *)(param_2 + 0x3f6) == 0) ||

         (*(short *)(param_2 + 0x3f8) == *(short *)(param_2 + 0x418)))
	  {
		// OtherFX_Play
        FUN_80028468(0x7e,1);
      }

	  // currently forced airborne
      *(undefined2 *)(param_2 + 0x3f6) = 0xa0;

	  // if big force jump (turtles)
      if (*(char *)(param_2 + 0x366) == '\x02')
	  {
        *(undefined2 *)(param_2 + 0x3fa) = 0x180;

		// const_Jump * 3
        *(short *)(param_2 + 0x3f8) = *(short *)(param_2 + 0x418) * 3;
      }

	  // if small force jump (turtles)
      else
	  {
		// const_Jump * 1.5
        *(undefined2 *)(param_2 + 0x3f8) = (short)(((int)*(short *)(param_2 + 0x418) * 3) / 2);
      }

	  // remove force jump (turtles)
      *(undefined *)(param_2 + 0x366) = 0;
    }
  }

  // if driver is on a quadblock
  else
  {
    if (
			// if driver is not on any turbo pad
			((*(uint *)(param_2 + 0xbc) & 3) == 0) ||

			(*(short *)(param_2 + 0x39c) < 1)
		)
	{
      if (*(short *)(param_2 + 0x39c) != 0) {
        if ((((*(uint *)(*(int *)(param_2 + 0x358) + 4) & 4) == 0) ||
            (*(short *)(param_2 + 0x39c) < 1)) || (-1 < *(short *)(param_2 + 0x38e))) {
          iVar10 = (int)*(short *)(param_2 + 0x38e);
          iVar2 = iVar10;
          if (iVar10 < 0) {
            iVar2 = -iVar10;
          }
          if (((0x2ff < iVar2) && ((*(short *)(param_2 + 0x39c) < 1 || (iVar10 < 1)))) &&
             ((-1 < *(short *)(param_2 + 0x39c) || (-1 < iVar10)))) goto LAB_800608fc;
        }

		// const_accel_noReserves + driver-specific acceleration
        iVar7 = (int)*(short *)(param_2 + 0x428) + ((int)*(char *)(param_2 + 0x33) << 5) / 5;

		// if you're not on any turbo pad
        if ((*(uint *)(param_2 + 0xbc) & 3) == 0)
		{
          if (
				// if reserves are not zero
				(*(short *)(param_2 + 0x3e2) != 0) &&

				(0 < *(short *)(param_2 + 0x39c))
			  )
		  {
			// const_accel_withReserves
            iVar7 = (int)*(short *)(param_2 + 0x42a);
          }

		  // driver -> terrain meta -> slowUntilSpeed,
		  // if 0, driver will slow down until completely stuck
		  iVar2 = *(int *)(*(int *)(param_2 + 0x358) + 0xc);

          if (
				(iVar2 != 0x100) &&

				// if driver is not using mask weapon
				((*(uint *)(param_2 + 0x2c8) & 0x800000) == 0)
			 )
		  {
            iVar7 = iVar2 * iVar7 >> 8;
          }
        }
        else {
          if (0 < *(short *)(param_2 + 0x39c)) goto LAB_8006089c;
        }
      }
    }

	// if driver is on a turbo pad
	else
	{
LAB_8006089c:

	  // high acceleration
      iVar7 = 8000;
    }
LAB_800608fc:
						// elapsed milliseconds per frame, ~32
    uVar11 = iVar7 * *(int *)(PTR_DAT_8008d2ac + 0x1d04) >> 5;
	
    gte_ldVXY0(0);
    gte_ldVZ0(uVar11 & 0xffff);
    gte_rtv0();
    read_mt(sVar6,sVar8,sVar9);
	
    if (*(short *)(param_2 + 0x39c) < 0) {
      *(short *)(param_2 + 0x3b2) = -(short)uVar11;
      iVar7 = -iVar7;
      iVar2 = -iVar2;
      iVar10 = -iVar10;
      *(short *)(param_2 + 0x3ac) = -sVar6;
      *(short *)(param_2 + 0x3ae) = -sVar8;
      *(short *)(param_2 + 0x3b0) = -sVar9;
    }
    else {
      *(short *)(param_2 + 0x3b2) = (short)uVar11;
      *(short *)(param_2 + 0x3ac) = sVar6;
      *(short *)(param_2 + 0x3ae) = sVar8;
      *(short *)(param_2 + 0x3b0) = sVar9;
    }
    local_20 = local_20 + iVar2;
    local_24 = local_24 + iVar10;
    local_28 = local_28 + iVar7;

    // uVar13 = sqrt(param_1 * 2 ^ param_2)
    uVar13 = FUN_80059070(local_28 * local_28 + local_24 * local_24 + local_20 * local_20,0x10);

    iVar7 = (int)*(short *)(param_2 + 0x39c);
    if (iVar7 < 0) {
      iVar7 = -iVar7;
    }
    uVar13 = (uVar13 >> 8) - iVar7;
    bVar1 = (int)uVar11 < (int)uVar13;
    if ((int)uVar13 < 0) {
      uVar13 = 0;
      bVar1 = (int)uVar11 < 0;
    }
    if (bVar1) {
      uVar13 = uVar11;
    }

    if (((*(uint *)(param_2 + 0x2c8) & 1) == 0) || (*(short *)(param_2 + 0x3f6) == 0))
    goto LAB_80060ab0;

    if (*(short *)(param_2 + 0x3fa) != 0) {
      *(undefined2 *)(param_2 + 0x3fa) = 0x180;
    }

	// If you're "blasted", flipping around after hit by missile, bomb, etc
    if (*(char *)(param_2 + 0x376) == '\x06')
	{
	  // controller vibration
      FUN_80026440(param_2,8,0);
      FUN_800264c0(param_2,8,0x7f);
    }
  }
LAB_80060c30:
  iVar7 = 0;
  iVar10 = 0x378;

  // jump timer
  *(undefined2 *)(param_2 + 0x3f2) = 0x180;

  *(undefined2 *)(param_2 + 0x3f0) = 0;
  *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) | 0x480;

  // this loop has one iteration
  iVar2 = iVar7;
  do
  {
	// Driver_Jump_GetVelY
    iVar3 = FUN_800605a0(param_2 + iVar10,&local_28);

    iVar5 = iVar3;
    if (iVar3 < 0) {
      iVar5 = -iVar3;
    }
    iVar4 = iVar7;
    if (iVar7 < 0) {
      iVar4 = -iVar7;
    }
    if (iVar4 < iVar5) {
      iVar7 = iVar3;
    }
    iVar2 = iVar2 + 1;
    iVar10 = iVar10 + 8;
  } while (iVar2 < 1);

  iVar2 = param_2 + 0x360;
  if ((*(uint *)(param_2 + 0x2c8) & 1) == 0) {
    iVar2 = param_2 + 0x368;
  }

  // Driver_Jump_GetVelY
  iVar10 = FUN_800605a0(iVar2,&local_28);

  iVar2 = iVar10;
  if (iVar10 < 0) {
    iVar2 = -iVar10;
  }
  iVar5 = iVar7;
  if (iVar7 < 0) {
    iVar5 = -iVar7;
  }
  iVar3 = iVar7 * iVar7;
  if (iVar5 < iVar2) {
    iVar3 = iVar10 * iVar10;
    iVar7 = iVar10;
  }

  // iVar2 = sqrt(param_1 * 2 ^ param_2)
  iVar2 = FUN_80059070(iVar3 + (int)*(short *)(param_2 + 0x3f8) * (int)*(short *)(param_2 + 0x3f8)
                       >> 8);

  uVar11 = (uint)*(byte *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x18c) << 8;
  if (*(byte *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x18c) == 0) {
    uVar11 = 0x3700;
  }
  else {
    if (0x5000 < uVar11) {
      uVar11 = 0x5000;
    }
  }
  uVar12 = iVar2 - iVar7;
  if ((int)uVar11 < iVar2 - iVar7) {
    uVar12 = uVar11;
  }
  if ((int)local_24 < (int)uVar12) {
    local_24 = uVar12;
  }
LAB_80060e1c:
  FUN_8005cd1c(param_2,&local_28,0);
  iVar7 = *(ushort *)(param_2 + 0x38c) - uVar13;
  *(undefined2 *)(param_2 + 0x38c) = (short)iVar7;
  if (iVar7 * 0x10000 < 0) {
    *(undefined2 *)(param_2 + 0x38c) = 0;
  }
  iVar7 = (int)*(short *)(param_2 + 0x38e);
  if (iVar7 < 0) {
    if (iVar7 < 0) {
      iVar7 = -iVar7;
    }
    if (iVar7 < 0x100) {
      sVar6 = *(short *)(param_2 + 0x36e) - (*(short *)(param_2 + 0x36e) >> 3);
    }
    else {
      sVar6 = (short)((int)*(short *)(param_2 + 0x36e) * 0xd +
                      (*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 7) * 0x300 >> 4);
    }
  }
  else {
    sVar6 = (short)((int)*(short *)(param_2 + 0x36e) * 0xd + iVar7 * 3 >> 4);
  }
  *(short *)(param_2 + 0x36e) = sVar6;
  return;
}


// SetDriverItem
void FUN_80060f0c(int param_1)
//Select a random Item for driver
//param_1 = Driver struct
{
  char cVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  
  // refer to chart
  // https://media.discordapp.net/attachments/637616020177289236/982513721354092564/unknown.png?width=602&height=431

  //iVar4 = Place division
  iVar4 = -1;

  // If you're not in Battle Mode
  if ((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0) {
    // If you're not in Crystal Challenge (in adventure mode)
    if ((*(uint *)PTR_DAT_8008d2ac & 0x8000000) == 0) {
      // number of Drivers + number of AIs
      switch((uint)(byte)PTR_DAT_8008d2ac[0x1ca8] + (uint)(byte)PTR_DAT_8008d2ac[0x1cab]) {
      // 2P VS
      // 1P Boss Race
      case 2:
        //if racer is 2nd, give 7th Place division
        iVar4 = 7;

        //if racer is 1st, give 1st Place division
        if (*(short *)(param_1 + 0x482) == 0) {
LAB_80061060:
          iVar4 = 0;
        }
        break;

      // 3P Splitscreen
      // 3 Players
      case 3:
        //if driver is 1st, give 1st Place division
        if (*(short *)(param_1 + 0x482) == 0) goto LAB_80061060;

        //if driver is 3rd, give 4th Place division
        iVar4 = 3;

        //if driver is 2nd, give 2nd or 3rd Place division (~50% chance)
        if (*(short *)(param_1 + 0x482) == 1) {
          //iVar4 = 3rd Place division
          iVar4 = 2;

          //Get random number to decide Place division
          uVar3 = FUN_8003ea28();

          //if the number is odd (~50% chance)
          if ((uVar3 & 1) != 0)
		      {
            //iVar4 = 2nd Place division
            goto LAB_80061040;
          }
        }
        break;

      // 4P Splitscreen
      // 4 Players
      case 4:
        //give (place in race)th Place division
        iVar4 = (int)*(short *)(param_1 + 0x482);
        break;

      // Purple Gem Cup
      // 1 player, 4 AIs
      case 5:
        //give (place in race)th Place division
        iVar4 = (int)*(short *)(param_1 + 0x482);

        //if racer is 5th
        if (iVar4 == 4) {
          //make 5th count in 4th Place division
          iVar4 = 3;
        }
        break;

      // 2P Splitscreen
      // 2 players, 4 AIs
      case 6:
        //give (place in race)th Place division
        iVar4 = (int)*(short *)(param_1 + 0x482);

        //if racer is in 1st place, give 1st Place division
        if (iVar4 == 0) goto LAB_80061060;

        //if racer is 6th
        if (iVar4 == 5) {
          //make it count in 4th Place division
          iVar4 = 3;
        }
        // if racer is not 1st or 6th
        else {
          //give Place division 2nd / 3rd
          iVar4 = (iVar4 + -1) / 2 + 1;
        }
        break;

      // 1P Arcade, Adventure
      // 1 player, 7 AIs
      case 8:
        //iVar2 = place in race * 0x10000
        iVar2 = (uint)*(ushort *)(param_1 + 0x482) << 0x10;
        //iVar4 = place in race
        iVar4 = iVar2 >> 0x10;
        //if racer is second
        if (iVar4 == 1) {
LAB_80061040:
          //give 2nd Place division
          iVar4 = 1;
        }
        else {
          //give Place division 1st to 4th
          iVar4 = iVar4 - (iVar2 >> 0x1f) >> 1;
        }
      }
    }
    // if you are in Crystal Challenge
    else {
      iVar4 = 6;
    }
  }
  // If you are in Battle Mode
  else
  {
	// battle, custom weapon set
    iVar4 = 5;

	// battle, default set
    if (*(int *)(PTR_DAT_8008d2ac + 0x1da0) == 0x34de) {
      iVar4 = 4;
    }
  }

  //simulate you're in 3rd Place division instead of 4th in first lap
  if ((iVar4 == 3) && (*(char *)(param_1 + 0x44) == '\0')) {
    iVar4 = 2;
  }

  // Get random number to decide item
  iVar2 = FUN_8003ea28();
  // Reduce random number to a range of 0 - 199
  uVar3 = (iVar2 >> 3) % 200;

  //based on Place division and a 1-200 number, give item
  switch(iVar4)
  {

  //if you're in 1st Place division
  case 0:
	// weapon = RNG/10 (range of 0 - 19)
    *(undefined *)(param_1 + 0x36) = (&DAT_80089b6c)[uVar3 / 10];
    break;

  //if you're in 2nd Place division
  case 1:
	// weapon = (range of 0 - 52)
    *(undefined *)(param_1 + 0x36) = (&DAT_80089b80)[(uVar3 * 0x34) / 200];
    break;

  //if you're in 3rd Place division
  case 2:
    // weapon = RNG/10 (range of 0 - 19)
    *(undefined *)(param_1 + 0x36) = (&DAT_80089bb4)[uVar3 / 10];
    break;

  //if you're in 4th Place division (last place: arcade, VS, not Boss, etc)
  case 3:
    // weapon = (range of 0 - 18)
    *(undefined *)(param_1 + 0x36) = (&DAT_80089bc8)[(uVar3 * 0x13) / 200];
    break;

  // Battle, default set
  case 4:
	// weapon = RNG/10 (range of 0 - 19)
    *(undefined *)(param_1 + 0x36) = (&DAT_80089bf0)[uVar3 / 10];
    break;

  // Battle, custom set
  case 5:
	// weapon = RNG out of custom (int) array
    *(undefined *)(param_1 + 0x36) =
         PTR_DAT_8008d2ac[((int)(uVar3 * *(int *)(PTR_DAT_8008d2ac + 0x1df0)) / 200) * 4 + 0x1df4];
    break;

  // If you are in Crystal Challenge
  case 6:
		// Only true at Rocky Road and Nitro Court
    if (
			// if Level ID is not 21 (Skull Rock)
			(*(int *)(PTR_DAT_8008d2ac + 0x1a10) != 0x15) &&
			(
				// Item = Bomb
				cVar1 = '\x01',
				// if Level ID is not 19 (Rampage Ruins)
				*(int *)(PTR_DAT_8008d2ac + 0x1a10) != 0x13
			)
		) goto LAB_800612c4;
    // Only true at Skull Rock and Rampage Ruins
    //set held Item to Turbo
    *(undefined *)(param_1 + 0x36) = 0;
    break;

  //if racer is 2nd in a 2 racer race
  //7th Place division
  case 7:
    *(undefined *)(param_1 + 0x36) = (&DAT_80089bdc)[uVar3 / 10];
    break;

  //-1st Place division (place in race is 0xFFFF when not decided)
  default:
    // Get random number
    iVar4 = FUN_8003ea28();
    // Pick a random Item
    cVar1 = (char)iVar4 + ((char)(iVar4 / 6 + (iVar4 >> 0x1f) >> 1) - (char)(iVar4 >> 0x1f)) * -0xc;
LAB_800612c4:
  	// Give racer said Item
    *(char *)(param_1 + 0x36) = cVar1;
  }

  // If you're in a Boss Race
  // 0x80000000
  if (*(int *)PTR_DAT_8008d2ac < 0)
  {
    //cVar1 = Times lost against boss
    cVar1 = (&DAT_8008fbeb)[*(int *)(PTR_DAT_8008d2ac + 0x1eb8)];

    if (cVar1 < '\x03')
    {
      //if Held item is Mask, Clock or Warpball
      if ((uint)*(byte *)(param_1 + 0x36) - 7 < 3)
      {
        //replace Held item with 3 Missiles
        *(undefined *)(param_1 + 0x36) = 0xb;
      }
    }
    else
    {
      if (cVar1 < '\x04')
      {
        //if Held item is Mask or Clock
        if ((uint)*(byte *)(param_1 + 0x36) - 7 < 2)
        {
		      //replace Held item with 3 Missiles
          *(undefined *)(param_1 + 0x36) = 0xb;
        }
      }
      else
      {
        if (
				  (cVar1 < '\x05') &&
				  //if Held item is Clock (\b = Backspace, 0x8 in ASCII)
				  (*(char *)(param_1 + 0x36) == '\b')
        )
        {
		      //replace Held item with 3 Missiles
          *(undefined *)(param_1 + 0x36) = 0xb;
        }
      }
    }

    // If Level ID is 1
    // If you're at Dragon Mines
    if (*(int *)(PTR_DAT_8008d2ac + 0x1a10) == 1)
    {
      // Get your current Item
      cVar1 = *(char *)(param_1 + 0x36);

      //if Held item is not 3 Missiles
      //skip next 2 lines of code
      if (cVar1 != '\v') goto LAB_800613a4;
      //if Held item is 3 Missiles
      //replace it with 1 Missile
      *(undefined *)(param_1 + 0x36) = 2;
    }
  }

  // Get your current Item
  cVar1 = *(char *)(param_1 + 0x36);
LAB_800613a4:

  // If Item ID is unused Spring powerup
  if (cVar1 == '\x05')
  {
    // Change Item to Turbo
    *(undefined *)(param_1 + 0x36) = 0;
  }

  // if Item is warpball
  // Make sure Warpball is only used once per race
  if (*(char *)(param_1 + 0x36) == '\t')
  {
    //if 13th flag of 0x96B20 is off (means there isn't a warpball held / waddling around)
    if ((*(uint *)PTR_DAT_8008d2ac & 0x1000) == 0)
    {
      //turn 13th flag of 0x96B20 on (means warpball is active)
      *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac | 0x1000;
    }
    // if warpball is held or waddling around
    else
    {
      //change Item to 3 missiles to prevent having two warpballs waddling around at once
      *(undefined *)(param_1 + 0x36) = 0xb;
    }
  }

  // To prevent having too many missiles,
  // If you are in 3P or 4P mode, make it
  // so a maximum of 2 players can have
  // multiple missiles, during "normal race"

  if (
		(
			// If number of screens is more than 2 and
			(2 < (byte)PTR_DAT_8008d2ac[0x1ca8]) &&

			// you're not in Battle Mode, and
			((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0)
		) &&
		// racer has 3 missiles
		(*(char *)(param_1 + 0x36) == '\v')
	)
	{
		// If there aren't already 2 players with 3 missiles
		if (*(int *)(PTR_DAT_8008d2ac + 0x1ec4) < 2)
		{
			// increment number of players with 3 missiles
			*(int *)(PTR_DAT_8008d2ac + 0x1ec4) = *(int *)(PTR_DAT_8008d2ac + 0x1ec4) + 1;
		}

		// if 2 players already have 3 missiles
		else
		{
			// Change Item to one missile
			*(undefined *)(param_1 + 0x36) = 2;
		}
  }

  //if Held item is either 3 Bombs or 3 Missiles
  //- 10 < 2 is intended in the formula because unsigned negatives are not < 2
  //(Items available excluding Invisibility and Super Engine)
  if ((uint)*(byte *)(param_1 + 0x36) - 10 < 2) {
    //set Held item Quantity to 3
    *(undefined *)(param_1 + 0x37) = 3;
  }
  return;
}



//returns Base Speed for specified Racer
int FUN_80061488(int param_1)
//param_1 = Racer struct Pointer
{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;

  //iVar3 = Wumpa count, assume max of 9
  iVar3 = (int)*(char *)(param_1 + 0x30);
  if (9 < iVar3) {
    iVar3 = 9;
  }

  // Turbo multiplier, limit to 5,
  // part of Super Engine from beta builds
  // still used?
  iVar4 = (int)*(char *)(param_1 + 0x35);
  if (5 < iVar4) {
    iVar4 = 5;
  }

  //iVar2 = Character's Speed stat
  iVar2 = (int)*(short *)(param_1 + 0x42c);

  //iVar1 = Net Speed stat
  //iVar1 = (((Negative Speedometer offset - Character's Speed stat) * 0x1000) / 5) - 1
  iVar1 = ((*(short *)(param_1 + 0x42e) - iVar2) * 0x1000) / 5 + -1;

  //iVar3 = Speed Additional
  //iVar3 = ((Wumpa count * Net Speed stat) / 10) + (Speed multiplier * Net Speed stat) >> 0xC
  iVar3 = (iVar3 * iVar1) / 10 + iVar4 * iVar1 >> 0xc;

  //if racer is using mask weapon
  if ((*(uint *)(param_1 + 0x2c8) & 0x800000) != 0) {
    //add Mask speed Constant to Speed Additional
    iVar3 = iVar3 + *(short *)(param_1 + 0x436);
  }

  //if racer has reserves
  if (*(short *)(param_1 + 0x3e2) != 0) {
    //iVar4 = Net Speed cap
    //iVar4 = (Sacred fire Cap * 2 - Single turbo Cap) - Current Speed cap
    iVar4 = ((int)*(short *)(param_1 + 0x432) * 2 - (int)*(short *)(param_1 + 0x430)) -
            (int)*(short *)(param_1 + 0x3e4);

    //iVar2 = Stat Additional
    //iVar2 = Gross Speed stat + Current Speed cap
    iVar2 = iVar2 + (int)*(short *)(param_1 + 0x3e4);

    //prevent Net Speed cap from going negative
    if (iVar4 < 0) {
      iVar4 = 0;
    }

    //prevent Speed from going above Speed cap
    //if Speed Additional > Net Speed cap
    if (iVar4 < iVar3) {
      //Speed Additional = Net Speed cap
      iVar3 = iVar4;
    }
  }
  //iVar4 is not Net Speed cap anymore
  //iVar4 will now be some form of Damaged speed Constant
  iVar4 = 0;

  //if racer has TNT over them
  if (*(int *)(param_1 + 0x18) != 0) {
    //iVar4 = (Damaged speed Constant u<< 0x10) s>> 0x11
    //iVar4 = (0x1000 u<< 0x10) s>> 0x11 = 0x10000000 s>> 0x11 = 0x800
    iVar4 = (int)((uint)*(ushort *)(param_1 + 0x438) << 0x10) >> 0x11;
  }

  //if racer is burnt or squished, or 0x50A = 0
  if (((*(short *)(param_1 + 0x402) != 0) || (*(short *)(param_1 + 0x404) != 0)) ||
     (*(short *)(param_1 + 0x50a) == 0)) {
    //iVar4 = Damaged speed Constant
    //iVar4 = 0x1000
    iVar4 = (int)*(short *)(param_1 + 0x438);
  }

  //if racer is affected by Clock item and
    //definition: iVar1 = Damaged speed Constant * ((0x14 - Place in race) >> 4)
    //(iVar1 = Damaged speed Constant (0x1000) when racer is 1st to 5th, iVar1 = 0 when 6th to 8th),
  //iVar4 < iVar1 (if racer has a TNT over them)
  if ((*(short *)(param_1 + 0xc) != 0) && (iVar1 = (int)*(short *)(param_1 + 0x438) *
    (0x14 - (int)*(short *)(param_1 + 0x482)) >> 4, iVar4 < iVar1)) {
    //correct 0x800 to 0x1000
    iVar4 = iVar1;
  }

  //iVar4 = Net Speed
  //iVar4 = (Stat Additional + Speed Additional) - Damaged speed Constant
  iVar4 = (iVar2 + iVar3) - iVar4;

  //if Net Speed is higher than USF Speed
  if (0x6400 < iVar4) {
    //prevent Speed from going over USF Speed
    iVar4 = 0x6400;
  }
  //return Net Speed for racer
  return iVar4;
}


// Player_Steer_ReturnToRest
int FUN_8006163c(int param_1,undefined4 param_2,short *param_3)

{
  int iVar1;
  int iVar2;
  int iVar3;

  // if not using racing wheel
  if (param_3 == (short *)0x0)
  {
	// deadzone
    iVar2 = 0x30;

	// range
    iVar3 = 0x7f;

	// center of wheel
    iVar1 = -0x80;
  }

  // if using racing wheel
  else
  {
	// deadzone
    iVar2 = (int)param_3[1];

	// range
    iVar3 = (int)param_3[2];

	// center of wheel
    iVar1 = -(int)*param_3;
  }

  param_1 = param_1 + iVar1;

  if (param_1 < 0) {

    // Map value from [oldMin, oldMax] to [newMin, newMax]
    // inverting newMin and newMax will give an inverse range mapping
    iVar1 = FUN_80058f9c(-param_1,iVar2,iVar3,0,param_2);
    iVar1 = -iVar1;
  }
  else {

    // Map value from [oldMin, oldMax] to [newMin, newMax]
    // inverting newMin and newMax will give an inverse range mapping
    iVar1 = FUN_80058f9c(param_1,iVar2,iVar3,0,param_2);
  }
  return iVar1;
}


// param_1 is desired steer strength
// param_2 is max possible steer
// param_3 RacingWheelData struct

// Player_Steer_AnalogStrength
// can only be positive (negated elsewhere)
int FUN_800616b0(int param_1,int param_2,int param_3)

{
  int iVar1;
  int iVar2;
  int iVar3;

  // dead zone
  iVar1 = 0x30;

  // if not using a racing wheel
  if (param_3 == 0)
  {
	// range of steering
    iVar2 = 0x7f;

	// strength of steering
    iVar3 = 0x5e;
  }

  // if using a racing wheel
  else
  {
	// dead zone
    iVar1 = (int)*(short *)(param_3 + 2);

	// range
	iVar2 = (int)*(short *)(param_3 + 4);

	// strength of steering
	iVar3 = iVar2 - iVar1;
  }

  // if desired steer strength is
  // less than minimum possible steer strength
  if (param_1 < iVar1)
  {
	// dont steer
    return 0;
  }

  // subtract steer from deadzone
  iVar1 = param_1 - iVar1;

  // if you attempt to steer farther
  // than maximum possible range
  if (iVar2 <= param_1)
  {
	// default to max desired steer
    return param_2;
  }

  if (iVar3 / 2 <= iVar1) {
    iVar1 = (iVar1 - iVar3 / 2) * (param_2 - param_2 / 5) * 2;
    if (iVar3 == 0) {
      trap(0x1c00);
    }
    if ((iVar3 == -1) && (iVar1 == -0x80000000)) {
      trap(0x1800);
    }
    return iVar1 / iVar3 + param_2 / 5;
  }
  iVar1 = iVar1 * (param_2 / 5) * 2;
  if (iVar3 == 0) {
    trap(0x1c00);
  }
  if ((iVar3 == -1) && (iVar1 == -0x80000000)) {
    trap(0x1800);
  }
  return iVar1 / iVar3;
}


// param_1 is steer
//		DPAD: 00 for left, 80 for neutral, FF for right
//		Analog: anything 00 - FF
// param_2 is max possible steer
// param_3 RacingWheelData struct

// Player_Steer_AbsoluteStrength
// can be positive or negative
int FUN_800617cc(int param_1,undefined4 param_2,short *param_3)

{
  int iVar1;

  // center steering
  iVar1 = 0x80;

  // if racing wheel data exists
  if (param_3 != (short *)0x0)
  {
	// get center of wheel
    iVar1 = (int)*param_3;
  }

  // if steering right
  if (param_1 - iVar1 < 0)
  {
	// assume steering left (negate)
    iVar1 = FUN_800616b0(-(param_1 - iVar1), param_2, param_3);

	// negate result to steer right
	iVar1 = -iVar1;
  }

  // if steer left
  else
  {
	// steer left
    iVar1 = FUN_800616b0(param_1 - iVar1, param_2, param_3);
  }

  // steer result
  return iVar1;
}



// Player_Driving_Input
void FUN_8006181c(int param_1,int param_2)
{
  char cVar1;
  char cVar2;
  short sVar3;
  bool bVar4;
  undefined *puVar5;
  ushort uVar6;
  undefined2 uVar7;
  int iVar8;
  uint uVar9;
  int iVar10;
  int iVar11;
  undefined4 *puVar12;
  short sVar13;
  int iVar14;
  uint uVar15;
  undefined4 uVar16;
  undefined uVar17;
  ushort uVar18;
  int iVar19;
  uint uVar20;
  int iVar21;
  uint uVar22;
  int iVar23;
  undefined *puVar24;
  uint local_38;
  uint local_34;

  // If race timer is not supposed to stop for this racer
  if ((*(uint *)(param_2 + 0x2c8) & 0x40000) == 0)
  {
	// set racer's timer to the time on the clock
    *(undefined4 *)(param_2 + 0x514) = *(undefined4 *)(PTR_DAT_8008d2ac + 0x1d10);
  }

  // elapsed milliseconds per frame, ~32
  iVar14 = *(int *)(PTR_DAT_8008d2ac + 0x1d04);

  // negative elapsed milliseconds per frame
  iVar8 = -iVar14;

  if (
		// time on the clock
		(*(int *)(PTR_DAT_8008d2ac + 0x1d10) < 0x8ca00) &&

		// race timer is not frozen for this player
		((*(uint *)(param_2 + 0x2c8) & 0x40000) == 0)
	  )
  {
	// increment timer by (speed * time)
    *(int *)(param_2 + 0x518) =
    *(int *)(param_2 + 0x518) + 
		(*(short *)(param_2 + 0x38e) * iVar14 >> 8);
  }

  // Next 7 lines are repetitive, this time for Reserves (0x3e2)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x3e2) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x3e2)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x3e2) = uVar7;

    //adds *spent* Reserves to cumulative counter
    *(int *)(param_2 + 0x534) = *(int *)(param_2 + 0x534) + iVar14;
  }

  // Next 7 lines are repetitive, this time for Outside Turbo Timer (0x3de)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x3de) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x3de)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x3de) = uVar7;
  }

  // Next 7 lines are repetitive, this time for Outside Turbo Sound (0x3e0)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x3e0) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x3e0)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x3e0) = uVar7;
  }

  // Next 7 lines are repetitive, this time for Collision (0x3fe)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x3fe) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x3fe)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x3fe) = uVar7;

	// Add elapsed time to a counter for how long you've driven against a wall
    *(int *)(param_2 + 0x530) = *(int *)(param_2 + 0x530) + iVar14;
  }

  // Next 7 lines are repetitive, this time for Jump Animation (0x3f6)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x3f6) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x3f6)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x3f6) = uVar7;
  }

  // Next 7 lines are repetitive, this time for Unknown (0x3f2)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x3f2) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x3f2)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x3f2) = uVar7;
  }

  // Next 7 lines are repetitive, this time for Unknown (0x3fa)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x3fa) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x3fa)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x3fa) = uVar7;
  }

  // Next 7 lines are repetitive, this time for Burnt Effect Timer (0x402)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x402) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x402)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x402) = uVar7;

	// increment timer for total frames burnt
    *(int *)(param_2 + 0x54c) = *(int *)(param_2 + 0x54c) + iVar14;
  }

  // Next 7 lines are repetitive, this time for Squished Effect Timer (0x404)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x404) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x404)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x404) = uVar7;

	// increment timer for total frames squished
    *(int *)(param_2 + 0x544) = *(int *)(param_2 + 0x544) + iVar14;
  }

  // Next 7 lines are repetitive, this time for Unknown (0x406)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x406) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x406)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x406) = uVar7;
  }

  // Next 7 lines are repetitive, this time for Unknown (0x408)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x408) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x408)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x408) = uVar7;
  }

  // If Super Engine Cheat is not enabled
  if ((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x10000) == 0)
  {
	// Next 7 lines are repetitive, this time for Super Engine Timer (0x38)
	// Make "desired" amount by subtracting elapsed time from "current" amount,
	// store desired into iVar11, then copy it into iVar7. If current is more than 0,
	// then handle subtraction. In subtraction, make sure desired is not negative,
	// then set current to desired

    iVar11 = (int)*(short *)(param_2 + 0x38) + iVar8;
    uVar7 = (undefined2)iVar11;
    if (0 < (int)*(short *)(param_2 + 0x38)) {
      if (iVar11 < 0) {
        uVar7 = 0;
      }
      *(undefined2 *)(param_2 + 0x38) = uVar7;
    }
  }

  // Next 7 lines are repetitive, this time for Clock Weapon Timer (0xC)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0xc) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0xc)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0xc) = uVar7;
  }

  // Next 7 lines are repetitive, this time for "Mashing X makes it big" (0x3c0)
  // Make "desired" amount by subtracting elapsed time from "current" amount,
  // store desired into iVar11, then copy it into iVar7. If current is more than 0,
  // then handle subtraction. In subtraction, make sure desired is not negative,
  // then set current to desired

  iVar11 = (int)*(short *)(param_2 + 0x3c0) + iVar8;
  uVar7 = (undefined2)iVar11;
  if (0 < (int)*(short *)(param_2 + 0x3c0)) {
    if (iVar11 < 0) {
      uVar7 = 0;
    }
    *(undefined2 *)(param_2 + 0x3c0) = uVar7;
  }

  // This one is a frame timer, not a millisecond timer,
  // Decrease one frame from Jump Buffering as long as timer is more than zero
  if (0 < *(short *)(param_2 + 0x3f0)) {
    *(short *)(param_2 + 0x3f0) = *(short *)(param_2 + 0x3f0) + -1;
  }

  //keep track of time spent with full wumpa
  if ('\t' < *(char *)(param_2 + 0x30)) {
    *(int *)(param_2 + 0x52c) = *(int *)(param_2 + 0x52c) + iVar14;
  }

  //keep track of time spent in mud
  if (*(char *)(param_2 + 0xc2) == '\x0e') {
    *(int *)(param_2 + 0x524) = *(int *)(param_2 + 0x524) + iVar14;
  }

  // Get placement of racer (1st place, 2nd, 3rd, etc)
  sVar13 = *(short *)(param_2 + 0x482);

  // Basically, if racer is in last place in any possible race scenario
  if (
		(
			(
				(
					// If racer is in 8th place
					(sVar13 == 7) &&

					// If number of screens is 1
					(PTR_DAT_8008d2ac[0x1ca8] == '\x01')
				) ||

				(
					(
						// If racer is in 6th place
						sVar13 == 5 &&

						// if number of screens is 2
						(PTR_DAT_8008d2ac[0x1ca8] == '\x02')
					)
				)
			) ||
			(
				(
					// if racer is in 4th place
					sVar13 == 3 &&

					// if number of screens is more than 2
					(2 < (byte)PTR_DAT_8008d2ac[0x1ca8])
				)
			)
		) &&
		(
			// race timer is not frozen for this player
			(*(uint *)(param_2 + 0x2c8) & 0x40000) == 0)
		)
  {
	// Increase the time racer has been in last place by elapsed milliseconds
    *(int *)(param_2 + 0x528) = *(int *)(param_2 + 0x528) + iVar14;
  }

  sVar13 = 4;

  // if you have a raincloud over your head from potion
  if (*(int *)(param_2 + 0x4a0) != 0) {
    sVar13 = *(short *)(*(int *)(*(int *)(param_2 + 0x4a0) + 0x30) + 6);
  }

  // get approximate speed
  iVar11 = (int)*(short *)(param_2 + 0x38e);

  // Action flags (isRaceOver, isTimeFrozen, etc)
  uVar22 = *(uint *)(param_2 + 0x2c8);

  // driver->clockReceive
  iVar19 = (int)*(short *)(param_2 + 0xc);

  *(short *)(param_2 + 0x50a) = sVar13;

  // absolute value of speed
  if (iVar11 < 0) {
    iVar11 = -iVar11;
  }

  if (
		(
			// if you are not impacted by clock weapon
			(iVar19 == 0) &&
			(
				// get squished timer
				iVar19 = (int)*(short *)(param_2 + 0x404),

				// if you are not squished
				iVar19 == 0
			)
		) &&
		(
			(
				sVar13 != 0 ||
				(
					// if time on the clock is zero
					iVar19 = *(int *)(PTR_DAT_8008d2ac + 0x1d10),
					iVar19 == 0
				)
			)
		)
	  )
  {
  	//uVar20 = Hazard Timer (sign extended 2 to 4 bytes)
    uVar20 = SEXT24(*(short *)(param_2 + 0xe));

	// hazard timer will not go
	// down unless you keep moving,
	// is this for red potion raincloud?

	// if you have high speed
    if (0x100 < iVar11)
	{
	  // decrease hazard by elapsed time
      uVar20 = uVar20 + iVar8;
    }

    uVar7 = (undefined2)(uVar20 & 0xfffffffe);
    if (-1 < (int)(uVar20 & 0xfffffffe)) {
      uVar7 = 0xfffe;
    }

    //Hazard Timer = uVar7
    *(undefined2 *)(param_2 + 0xe) = uVar7;
  }

  // if you are not impacted by hazard (other than clock)
  else {
    uVar18 = (ushort)iVar19;

	// if you are not touching the ground
    if ((uVar22 & 1) == 0)
	{
	  // if speed is low
      if (iVar11 < 0x101) goto LAB_80061cf8;

	  // if speed is high...

	  // absolute value of clock hazard
      if (iVar19 < 0) {
        uVar18 = -uVar18;
      }

LAB_80061d0c:
      uVar6 = -uVar18 | 1;
    }

	// if you are touching the ground
    else
	{
	  // if speed is low
      if (iVar11 < 0x101)
	  {
LAB_80061cf8:
				//uVar18 = Hazard Timer
        uVar18 = *(ushort *)(param_2 + 0xe);
        uVar6 = uVar18 | 1;
        if (0 < (short)uVar18) goto LAB_80061d0c;
      }

	  // if speed is high
      else
	  {
	    // absolute value of clock hazard
        if (iVar19 < 0) {
          uVar18 = -uVar18;
        }

		// Use trigonometry with speed and
		// clock timer to make the car waddle

        //iVar8 = Clock Item (Receive) Timer << 0x10
        iVar8 = (uint)*(ushort *)(param_2 + 0xc) << 0x10;

        iVar19 = iVar8 >> 0x16;
        if (0x40 < iVar19) {
          iVar19 = 0x40;
        }

        uVar20 = (iVar8 >> 0x10) << 4;

		// approximate trigonometry
        iVar8 = *(int *)(&DAT_800845a0 + (uVar20 & 0x3ff) * 4);

        if ((uVar20 & 0x400) == 0) {
          iVar8 = iVar8 << 0x10;
        }
        iVar8 = iVar8 >> 0x10;
        if ((uVar20 & 0x800) != 0) {
          iVar8 = -iVar8;
        }
        iVar21 = iVar11 >> 8;
        if (0x20 < iVar21) {
          iVar21 = 0x20;
        }

		// controller vibration
		FUN_800264c0(param_2,4,iVar19 + (iVar8 >> 5) + iVar21 + 0x18);

        uVar6 = uVar18 | 1;
      }
    }
    //Hazard Timer = uVar6
    *(ushort *)(param_2 + 0xe) = uVar6;
  }

  //trigger Item roll / selection
  //if Held Item = None
  if (*(char *)(param_2 + 0x36) == '\x10') {

	//if Item roll is done
    if (*(short *)(param_2 + 0x3a) == 0)
		{
	  // Select a random weapon for driver
      FUN_80060f0c(param_2);

	  	// if 9 < number of wumpa
	  	// if wumpa is 10
      bVar4 = '\t' < *(char *)(param_2 + 0x30);

	  // if you have less than 10 wumpa

	  // "ding" sound
      uVar16 = 0x5e;

	  // if you have 10 wumpa
      if (bVar4)
	  {
		// "ka-ching" sound
        uVar16 = 0x41;
      }

      // OtherFX_Play of getting weapon
      FUN_80028468(uVar16,(uint)bVar4);
    }

	//if Item roll is not done
    else
	{
    	//Item roll Timer--
      *(short *)(param_2 + 0x3a) = *(short *)(param_2 + 0x3a) + -1;
    }
  }

  //sVar3 = No Item Timer
  sVar3 = *(short *)(param_2 + 0x3c);

  //if Item is going away
  if (sVar3 != 0) {

	//if Item is about to be gone and Number of Items = 0
    if ((sVar3 == 1) && (*(char *)(param_2 + 0x37) == '\0')) {

	  // if number of screens is > 2
	  if ((2 < (byte)PTR_DAT_8008d2ac[0x1ca8]) &&

		  // If you're not in Battle Mode
         ((((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0 &&

		 // your weapon is 3 missiles
		 (*(char *)(param_2 + 0x36) == '\v')) &&

		  // If there are racers that had 3 missiles
          (0 < *(int *)(PTR_DAT_8008d2ac + 0x1ec4)))))
	  {
		// decrement the number of players that had 3 missiles
        *(int *)(PTR_DAT_8008d2ac + 0x1ec4) = *(int *)(PTR_DAT_8008d2ac + 0x1ec4) + -1;
      }

	  // take away weapon
      *(undefined *)(param_2 + 0x36) = 0xf;
    }

    //No Item Timer--
    *(short *)(param_2 + 0x3c) = sVar3 + -1;
  }

  // If Invinsibility effect is active (timer at 0x24)
  // Make "desired" timer by subtracting elapsed time from "current",
  // set "current" to "desired", then set "current" to zero if "desired" is negative

  if ((*(int *)(param_2 + 0x24) != 0) &&
     (iVar8 = *(int *)(param_2 + 0x24) - *(int *)(PTR_DAT_8008d2ac + 0x1d04),
     *(int *)(param_2 + 0x24) = iVar8, iVar8 < 0)) {
    *(undefined4 *)(param_2 + 0x24) = 0;
  }

  // If Invincibility effect is active (timer at 0x28) and if Cheat Code is Disabled
  // Make "desired" timer by subtracting elapsed time from "current",
  // set "current" to "desired", then set "current" to zero if "desired" is negative

  if (
		// if driver is invisible
		(*(int *)(param_2 + 0x28) != 0) &&

		// If Permanent Invisibility Cheat is Disabled
		((*(uint *)(PTR_DAT_8008d2ac + 8) & 0x8000) == 0)
	)
  {
	// decrease invisibility timer,
	// can not go below zero
    iVar8 = *(int *)(param_2 + 0x28) - *(int *)(PTR_DAT_8008d2ac + 0x1d04);
    *(int *)(param_2 + 0x28) = iVar8;
    if (iVar8 < 0) {
      *(undefined4 *)(param_2 + 0x28) = 0;
    }

	// If the timer expires, make yourself visible
    if (*(int *)(param_2 + 0x28) == 0)
	{
	  // restore backup of instance flags
      *(undefined4 *)(*(int *)(param_2 + 0x1c) + 0x28) = *(undefined4 *)(param_2 + 0x2c);

	  // set instance transparency to zero
      *(undefined2 *)(*(int *)(param_2 + 0x1c) + 0x22) = 0;

	  // OtherFX_Play
      FUN_80028468(0x62,1);
    }
  }

  // Random guess, this next block is probably for making a backup
  // of current position and rotation, to calculate linear + angular
  // velocity by comparing two frames

  *(undefined4 *)(param_2 + 0x2f4) = *(undefined4 *)(param_2 + 0x2ec);
  puVar24 = PTR_DAT_8008d2ac;
  
  // action flags
  *(uint *)(param_2 + 0x2cc) = uVar22;
  
  *(undefined4 *)(param_2 + 0x2e4) = *(undefined4 *)(param_2 + 0x2d8);
  *(undefined4 *)(param_2 + 0x2e8) = *(undefined4 *)(param_2 + 0x2dc);
  *(undefined2 *)(param_2 + 0x2f8) = *(undefined2 *)(param_2 + 0x2f0);
  *(undefined2 *)(param_2 + 0x392) = *(undefined2 *)(param_2 + 0x390);
  *(undefined2 *)(param_2 + 0x3c8) = *(undefined2 *)(param_2 + 0x3c6);
  *(undefined4 *)(param_2 + 0x2e0) = *(undefined4 *)(param_2 + 0x2d4);

  uVar20 = uVar22 & 0x7f1f83d5;
  
  if ((*(uint *)(puVar24 + 8) & 0x4004) != 0) goto LAB_800629f8;
  iVar19 = (uint)*(byte *)(param_2 + 0x380) + 1;
  uVar17 = (undefined)iVar19;
  
  // vectorID * 8, vec4s = 8 bytes
  iVar8 = iVar19 * 8;
  
  if (iVar19 != 0) {
    uVar17 = 0;
    iVar8 = 0;
  }
  
  // get pointer to normalVec, iVar8 is which vector
  puVar12 = (undefined4 *)(param_2 + iVar8 + 0x378);
  
  // if not touching ground
  if ((uVar22 & 1) == 0) 
  {
	// AngleAxis2_NormalVec
    *puVar12 = *(undefined4 *)(param_2 + 0x368);
    *(undefined2 *)(puVar12 + 1) = *(undefined2 *)(param_2 + 0x36c);
  }
  
  // if touching ground
  else 
  {
	// AngleAxis1_NormalVec
    *puVar12 = *(undefined4 *)(param_2 + 0x360);
    *(undefined2 *)(puVar12 + 1) = *(undefined2 *)(param_2 + 0x364);
  }
  
  *(undefined *)(param_2 + 0x380) = uVar17;

  // driver -> instBubble
  iVar8 = *(int *)(param_1 + 0x14);

  while (uVar22 = uVar20, iVar8 != 0)
  {
	// If thread->modelIndex is Aku or Uka
    if ((*(short *)(iVar8 + 0x44) == 0x3a) || (*(short *)(iVar8 + 0x44) == 0x39)) {
      uVar22 = uVar20 | 0x800000;
      break;
    }

	// check next player in linked list
    iVar8 = *(int *)(iVar8 + 0x10);
  }

  // pointer to controller input of current player (param_2)
  puVar24 = PTR_DAT_8008d2b0 + (uint)*(byte *)(param_2 + 0x4a) * 0x50;

  // by default, hold no buttons
  uVar20 = 0;

  // If you're not in End-Of-Race menu
  if ((*(uint *)PTR_DAT_8008d2ac & 0x200000) == 0)
  {
	// Get which button is held
    uVar20 = *(uint *)(puVar24 + 0x10);
  }

  // by default, tap no buttons
  uVar15 = 0;

  // If you're not in End-Of-Race menu
  if ((*(uint *)PTR_DAT_8008d2ac & 0x200000) == 0)
  {
	// Get which button is tapped
    uVar15 = *(uint *)(puVar24 + 0x14);
  }

  // If you hold Cross
  local_38 = uVar20 & 0x10;

  // If you hold Square
  local_34 = uVar20 & 0x20;

  // state of kart
  cVar1 = *(char *)(param_2 + 0x376);

  if (
		(
			// If you press circle
			((uVar15 & 0x40) != 0) &&


			(
				// if neutral driving
				((cVar1 == '\0' ||

				// or sliding
				(cVar1 == '\x02')) ||

				// or ???
				(cVar1 == '\t'))
			)
		) &&

		// if there is no tnt on your head
		(*(int *)(param_2 + 0x18) == 0)
	  )
  {
	// If there is no Bomb pointer
    if (*(int *)(param_2 + 0x10) == 0) {

	  // If there is no Bubble pointer
      if (*(int *)(param_2 + 0x14) == 0) {

		// If there is no "weapon roulette" animation
        sVar3 = *(short *)(param_2 + 0x3a);
        if (sVar3 == 0) {

		  // If you dont have "roulette" weapon (0x10), and if you dont have "no weapon" (0xf)
		  // and if you did not have a weapon last frame (0x3c->0),
		  // and if (unknown sVar13 related to 0x4a0),
		  // and if you are not being effected by Clock Weapon
          cVar2 = *(char *)(param_2 + 0x36);
          if (((cVar2 != '\x0f') && (cVar2 != '\x10')) &&
             ((*(short *)(param_2 + 0x3c) == 0 &&
              ((sVar13 != 1 && (*(short *)(param_2 + 0xc) == 0))))))
		  {
			// This driver wants to fire a weapon (0x2c8 flags)
            uVar22 = uVar22 | 0x8000;

			// If "held item quantity" is zero
            if (*(char *)(param_2 + 0x37) == '\0') 
			{
              *(undefined2 *)(param_2 + 0x3c) = 0x1e;
              goto LAB_800621cc;
            }

			// If you have the Spring weapon
            if (cVar2 == '\x05') 
			{
              if (*(short *)(param_2 + 0x3f4) != 0) {
                uVar9 = SEXT24(*(short *)(param_2 + 0x3f2));
                goto LAB_80062188;
              }
            }
            
			// any other weapon
			else 
			{
			  // CHEAT_MASK, CHEAT_TURBO, or CHEAT_BOMBS
              uVar9 = *(uint *)(PTR_DAT_8008d2ac + 8) & 0x400c00;
LAB_80062188:
			  // if cheats aren't enabled
              if (uVar9 == 0) 
			  {
				// reduce number of items held
                *(char *)(param_2 + 0x37) = *(char *)(param_2 + 0x37) + -1;
              }
            }
			
			// 5-frame cooldown before next weapon
            *(undefined2 *)(param_2 + 0x3c) = 5;
			
            goto LAB_800621cc;
          }
          sVar3 = *(short *)(param_2 + 0x3a);
        }

		// if there are less than 70 frames (2.3 sec remaining)
        if (sVar3 < 0x46)
		{
		  // skip to the end of the countdown
          *(undefined2 *)(param_2 + 0x3a) = 0;
        }
      }

	  // If there is a Bubble Pointer
      else
	  {
		// Shoot the bubble

		// We can see the bubble pointer (driver + 0x14)

		// instance -> thread -> object
        iVar8 = *(int *)(*(int *)(*(int *)(param_2 + 0x14) + 0x6c) + 0x30);

        *(ushort *)(iVar8 + 6) = *(ushort *)(iVar8 + 6) | 2;

		// Reset to nullptr
	   *(undefined4 *)(param_2 + 0x14) = 0;
      }
    }

	// If there is a Bomb Pointer
    else
	{
	  // Detonate the bomb

	  // We can see the bomb pointer (driver + 0x10)

	  // instance -> thread -> object
      iVar8 = *(int *)(*(int *)(*(int *)(param_2 + 0x10) + 0x6c) + 0x30);

	  // always face camera
	  *(ushort *)(iVar8 + 0x16) = *(ushort *)(iVar8 + 0x16) | 2;

	  // Reset to nullptr
      *(undefined4 *)(param_2 + 0x10) = 0;
    }
  }
LAB_800621cc:

  // Check for Tapping L1 and R1
  uVar15 = uVar15 & 0xc00;

  if (
		//if you're not pressing L1 or R1
		(uVar15 == 0) ||
		// or you are sliding
		(*(char *)(param_2 + 0x376) == '\x02')
	)
  {
    if (
			// If you are holding L1 or R1 and
			((uVar20 & 0xc00) != 0) &&
			(sVar13 != 3)
	  )
    {
      if ((uVar22 & 4) == 0)
	  {
		// 10 frame jump buffer
        *(undefined2 *)(param_2 + 0x3f0) = 10;
      }
      goto LAB_8006222c;
    }
    uVar22 = uVar22 & 0xfffffffb;
    if (0 < *(short *)(param_2 + 0x3f0)) {
      *(undefined2 *)(param_2 + 0x3f0) = 0;
    }
  }

  //if you're pressing jump buttons and not sliding
  else
  {
    //if L1 and R1 were being tapped at once
    if (uVar15 == 0xc00)
	{
      //set Last Jump button pressed to R1
      *(undefined2 *)(param_2 + 0x382) = 0x400;
    }

    //if you're not tapping L1 and R1 at once
    else
	{
      //Last Jump button pressed = uVar15
      *(undefined2 *)(param_2 + 0x382) = (short)uVar15;
    }

    if (sVar13 != 3)
	{
	  // 10 frame jump buffer
      *(undefined2 *)(param_2 + 0x3f0) = 10;
LAB_8006222c:
      uVar22 = uVar22 | 4;
    }
  }

  if (
		// If you are holding Square
		(local_34 != 0) &&

		// if you're not on any turbo pad
		((*(uint *)(param_2 + 0xbc) & 3) == 0)
	)
  {
	// Set Reserves to zero
    *(undefined2 *)(param_2 + 0x3e2) = 0;
  }

  // assume normal gas pedal
  iVar8 = 0x80;

  // If you're not in End-Of-Race menu
  if ((*(uint *)PTR_DAT_8008d2ac & 0x200000) == 0)
  {
	// gamepadBuffer -> stickRY (for gas or reverse)
    iVar8 = (int)*(short *)(puVar24 + 0xe);
  }

  if (
		// If Reserves are not zero
		(*(short *)(param_2 + 0x3e2) != 0) ||

		(sVar13 == 6)
	 )
  {
    if (
			// If you are not holding Cross
			(local_38 == 0) &&

			// Player_Steer_ReturnToRest
			(iVar19 = FUN_8006163c(iVar8,0x80,0), -1 < iVar19)
		)
	{
      uVar22 = uVar22 | 0x400000;
    }


    if (
			// If are holding Square
			(local_34 != 0) &&

			(0x300 < iVar11)
		)
	{
      uVar22 = uVar22 | 0x800;
    }

	// if you're on any turbo pad
    if ((*(uint *)(param_2 + 0xbc) & 3) != 0)
	{
	  // assume not holding square until boost is over
      local_34 = 0;
    }

	// Assume you're holding Cross, because
	// you have Reserves and you aren't slowing down
    local_38 = 0x10;
  }

  iVar19 = 0x80;

  // If you're not in End-Of-Race menu
  if ((*(uint *)PTR_DAT_8008d2ac & 0x200000) == 0) {
    iVar19 = (int)*(short *)(puVar24 + 6);
  }

  if ((*(char *)(param_2 + 0x4b) < '\0') ||
     (uVar22 = uVar22 & 0xdfffffff, *(char *)(param_2 + 0x4b) < '\x01')) {
    uVar22 = uVar22 & 0xbfffffff;
  }
  iVar21 = (int)*(short *)(param_2 + 0x38e);
  if (iVar21 < 0) {
    iVar21 = -iVar21;
  }
  if (iVar21 < 0x300) {
    uVar22 = uVar22 & 0x9fffffff;
  }
  iVar21 = 0;
  //iVar10 = Racer's Base Speed (4s)
  iVar10 = FUN_80061488(param_2);
  //uVar7 = Racer's Base Speed (2u)
  uVar7 = (undefined2)iVar10;

  // If you are not holding Square
  if (local_34 == 0) {
    //iVar23 = Racer's Base Speed
    iVar23 = iVar10;

    // If you are holding Cross, or if you have Reserves
    if (local_38 != 0) {
LAB_8006253c:
      uVar22 = uVar22 & 0xfffdffff;
      goto LAB_80062548;
    }

    // if you are not holding cross, or have no Reserves...
    //iVar23 is replaced

	// Player_Steer_ReturnToRest
    iVar23 = FUN_8006163c(iVar8,0x80,0);

	iVar8 = -iVar23;
    if (iVar23 < 1) {
      if ((iVar8 == 0) &&

		  // Player_Steer_ReturnToRest
         ((iVar19 = FUN_8006163c(iVar19,0x80,0), 99 < iVar19 ||

		  ((0 < iVar19 && ((uVar22 & 0x20000) != 0))))))
	  {
		// driver is steering?
        uVar22 = uVar22 | 0x20000;
		
        iVar23 = -(int)*(short *)(param_2 + 0x434);
        goto LAB_80062548;
      }
      iVar8 = iVar10 * iVar8;
      iVar23 = iVar8 >> 7;
      if (iVar8 < 0) {
        iVar23 = iVar8 + 0x7f >> 7;
      }
      goto LAB_8006253c;
    }
    if ((*(short *)(param_2 + 0x38e) < 0x301) && ((uVar22 & 0x60000000) == 0)) {
      iVar8 = *(short *)(param_2 + 0x434) * iVar8;
      if (iVar8 < 0) {
        iVar8 = iVar8 + 0x7f;
      }
      iVar21 = iVar8 >> 7;
      uVar15 = 0x20000;
LAB_800625c4:
      uVar20 = uVar22 | uVar15;
    }
    else {
      uVar20 = uVar22 | 8;
      if ('\0' < *(char *)(param_2 + 0x4b)) {
        uVar20 = uVar22 | 0x40000008;
      }
      if (*(char *)(param_2 + 0x4b) < '\0') {
        uVar15 = 0x20000000;
        uVar22 = uVar20;
        goto LAB_800625c4;
      }
    }
  }
  // If you are holding Square
  else
  {
	// Player_Steer_ReturnToRest
    iVar19 = FUN_8006163c(iVar19,0x80,0);

	if ((iVar19 < 100) && ((iVar19 < 1 || ((uVar22 & 0x20000) == 0))))
	{
	  // if you are not holding cross, and you have no Reserves
      if (local_38 == 0)
	  {
        // Player_Steer_ReturnToRest
		iVar8 = FUN_8006163c(iVar8,0x80,0);

		iVar23 = iVar10 * -iVar8;
        if (iVar8 < 0) {
          if (iVar23 < 0) {
            iVar23 = iVar23 + 0xff;
          }
          iVar23 = iVar23 >> 8;
          uVar22 = uVar22 | 0x20;
          goto LAB_80062548;
        }
        if (0 < iVar8) {
          iVar8 = (int)*(short *)(param_2 + 0x434) * -iVar8;
          iVar23 = iVar8 >> 8;
          if (iVar8 < 0) {
            iVar23 = iVar8 + 0xff >> 8;
          }
          goto LAB_8006248c;
        }
        uVar22 = uVar22 | 8;
        iVar23 = iVar21;
      }
      // If you are holding cross, or you have Reserves
      else {
        uVar22 = uVar22 | 0x20;
        iVar23 = iVar10 / 2;
      }
      goto LAB_8006253c;
    }
    iVar8 = (int)*(short *)(param_2 + 0x434) * -3;
    iVar23 = iVar8 >> 2;
    if (iVar8 < 0) {
      iVar23 = iVar8 + 3 >> 2;
    }
LAB_8006248c:
    uVar22 = uVar22 | 0x20020;
LAB_80062548:
    uVar20 = uVar22 & 0x9fffffff;
    //iVar21 = Racer's Base Speed
    iVar21 = iVar23;
  }
  
  if ((uVar20 & 0x20000) == 0) 
  {
    uVar22 = uVar20 & 8;
    if (*(short *)(param_2 + 0x38) != 0) {
      //if Racer is moving
      if (0 < iVar21) {
        uVar22 = uVar20 & 8;
        if ((uVar20 & 0x400020) != 0) goto LAB_80062648;

        // if you have less than 10 wumpa
        uVar16 = 0x80;

        *(uint *)(param_2 + 0x2c8) = uVar20;

		// if 9 < number of wumpa
        // if wumpa is 10
        if ('\t' < *(char *)(param_2 + 0x30)) {
          uVar16 = 0x100;
        }

		// Turbo_Increment
		// add 0.12s reserves
		FUN_8005abfc(param_2,0x78,0x14,uVar16);

        uVar20 = *(uint *)(param_2 + 0x2c8);
      }
      goto code_r0x80062644;
    }
  }

  else
  {
	// Increase [uknown] by elapsed time
    *(int *)(param_2 + 0x520) = *(int *)(param_2 + 0x520) + iVar14;
code_r0x80062644:
    uVar22 = uVar20 & 8;
  }

LAB_80062648:
  if (uVar22 != 0) {
    iVar8 = (int)*(short *)(param_2 + 0x38e);
    if (iVar8 < 0) {
      iVar8 = -iVar8;
    }
    
	if (0x300 < iVar8) 
	{
	  // record amount of time with high speed
      *(int *)(param_2 + 0x51c) = *(int *)(param_2 + 0x51c) + iVar14;
    }
  }

  if ((*(short *)(param_2 + 0x3c0) == 0) ||

	  // kart state not 0, and kart state not 9
     ((*(char *)(param_2 + 0x376) != '\0' && (*(char *)(param_2 + 0x376) != '\t'))))
  {
	*(undefined2 *)(param_2 + 0x3c2) = 0;
  }

  if (*(short *)(param_2 + 0x39e) < 1) {
    //if Racer is moving, skip next 4 lines of code
    if (0 < iVar21) goto LAB_800626d4;
LAB_800626fc:
    //Racer struct + 0x39E = Racer's Base Speed
    *(undefined2 *)(param_2 + 0x39e) = (short)iVar21;
  }
  else {
    //if Racer is not moving
    if (iVar21 < 1) {
LAB_800626d4:
      if (*(short *)(param_2 + 0x3c0) != 0) {
        *(short *)(param_2 + 0x3c2) = *(short *)(param_2 + 0x3c2) + 1;
      }
      *(undefined2 *)(param_2 + 0x3c0) = 0x100;
      goto LAB_800626fc;
    }
    //Racer struct + 0x39E = Racer's Base Speed
    *(undefined2 *)(param_2 + 0x39e) = (short)iVar21;
  }
  if ((uVar20 & 0x800020) == 0) {
    iVar8 = *(int *)(*(int *)(param_2 + 0x35c) + 8);
    //if racer is out of normal driving conditions?
    //for example, 0x35C[0x8] is 0xB4 when in water at Cove
    //and the value of 0x39C fits the result perfectly
    if (iVar8 != 0x100) {
      //Base Speed = 0xB4 (at Cove water) * Base Speed >> 8
      iVar21 = iVar8 * iVar21 >> 8;
      uVar7 = (undefined2)((uint)(iVar8 * iVar10) >> 8);
    }
  }
  *(undefined2 *)(param_2 + 0x3c4) = uVar7;
  //Basic Speed = iVar21
  *(undefined2 *)(param_2 + 0x39c) = (short)iVar21;

  // assume neutral steer (drive straight)
  iVar8 = 0x80;

  puVar5 = PTR_DAT_8008d2ac;

  // If you're not in End-Of-Race menu
  if ((*(uint *)puVar5 & 0x200000) == 0)
  {
	// gamepadBuffer -> stickLX
    iVar8 = (int)*(short *)(puVar24 + 4);
  }

  iVar14 = (uint)*(byte *)(param_2 + 0x43a) + ((int)*(char *)(param_2 + 0x34) << 1) / 5;
  if ((*(short *)(param_2 + 0x3c2) < 7) || (0x25ff < iVar11)) {
    if (*(short *)(param_2 + 0x3fe) == 0) {
      if ((uVar20 & 0x28) == 0)
	  {
		// gamepadBuffer -> racingWheelData
        uVar16 = *(undefined4 *)(puVar24 + 0x4c);
      }
      else
	  {
		// if you are not holding cross
        if (local_38 == 0)
		{
          // gamepadBuffer -> racingWheelData
		  uVar16 = *(undefined4 *)(puVar24 + 0x4c);

		  iVar14 = 0x40;
        }

		// if you are holding cross
        else
		{
		  // get speed
          iVar19 = (int)*(short *)(param_2 + 0x38c);

		  // set speed to absolute value
          if (iVar19 < 0) {
            iVar19 = -iVar19;
          }

          // Map value from [oldMin, oldMax] to [newMin, newMax]
          // inverting newMin and newMax will give an inverse range mapping
          iVar14 = FUN_80058f9c(iVar19,0x300,
                                (int)((uint)*(ushort *)(param_2 + 0x42c) << 0x10) >> 0x11,0x40,
                                iVar14);

		  // gamepadBuffer -> racingWheelData
		  uVar16 = *(undefined4 *)(puVar24 + 0x4c);
        }
      }
    }
    else
	{
	  // gamepadBuffer -> racingWheelData
      uVar16 = *(undefined4 *)(puVar24 + 0x4c);
      iVar14 = 0x30;
    }
  }
  else
  {
	// gamepadBuffer -> racingWheelData
    uVar16 = *(undefined4 *)(puVar24 + 0x4c);

    iVar14 = 0x5a;
  }

  // Steer
  iVar14 = FUN_800617cc(iVar8,iVar14,uVar16);

  if (-iVar14 == 0) {
    *(undefined2 *)(param_2 + 0x3e6) = 10000;
  }
  else {
    if ((iVar14 < 1) || (*(char *)(param_2 + 0x4b) < '\0')) {
      if ((-1 < iVar14) || ('\0' < *(char *)(param_2 + 0x4b))) goto LAB_800628b0;
      uVar20 = uVar20 | 0x10;
    }
    else {
      uVar20 = uVar20 & 0xffffffef;
    }
    *(undefined2 *)(param_2 + 0x3e6) = 0;
  }
LAB_800628b0:
  *(undefined *)(param_2 + 0x4b) = (char)-iVar14;

  // Steer
  iVar8 = FUN_800617cc(iVar8,0x40,*(undefined4 *)(puVar24 + 0x4c));

  // Interpolate rotation by speed
  uVar7 = FUN_80058f54((int)*(short *)(param_2 + 6),0x18,-iVar8);

  iVar8 = (int)*(short *)(param_2 + 0x39e);
  *(undefined2 *)(param_2 + 6) = uVar7;
  if (iVar8 < 0) {
    iVar8 = -iVar8;
  }
  if (((*(uint *)(param_2 + 0x2cc) & 1) == 0) || (cVar1 == '\x02')) {
    iVar8 = iVar8 + 0xf00;
  }
  else {
    iVar8 = iVar8 + iVar11 >> 1;
  }
  sVar13 = (short)((iVar8 * 0x89 + (int)*(short *)(param_2 + 0x3be) * 0x177) * 8 >> 0xc);
  *(short *)(param_2 + 0x3be) = sVar13;
  if ((*(uint *)(param_2 + 0x2cc) & 8) == 0) {
    //prevent Basic Speed from being negative
    if (iVar21 < 0) {
      iVar21 = -iVar21;
    }
    //if Base Speed > 0x200 or iVar11 = 0x200 (?)
    if ((0x200 < iVar21) || (0x200 < iVar11)) {
      *(short *)(param_2 + 0x3bc) = *(short *)(param_2 + 0x3bc) - sVar13;
    }
  }
  //if 0x3BC <= 0 and last bit of jittery number 2 is off and
  if (((*(short *)(param_2 + 0x3bc) < 1) && ((*(uint *)(param_2 + 8) & 1) == 0)) &&
     (cVar1 != '\x04')) {
  	//reset 0x3BC
    *(undefined2 *)(param_2 + 0x3bc) = 0x1e00;
    //Jittery number 1
    *(undefined4 *)(param_2 + 8) = 0x2e606061;
  }
  else {
  	//jittery number 2
    *(undefined4 *)(param_2 + 8) = 0x2e808080;
  }
LAB_800629f8:
  *(uint *)(param_2 + 0x2c8) = uVar20;
  return;
}


// Player_Driving_Audio (universal)
// param1 = thread, param2 = driver
void FUN_80062a2c(undefined4 param_1,undefined4 param_2)
{
  // EngineSound_Player
  FUN_8002f5f4(param_2);
  return;
}


// Player_Driving_Update
// param1 = thread, param2 = driver
void FUN_80062a4c(undefined4 param_1,int param_2)
{
  int iVar1;

  //if racer touched the ground in this frame
  if ((*(uint *)(param_2 + 0x2c8) & 2) != 0) {
    //iVar1 = Simplified Turning state
    iVar1 = (int)*(char *)(param_2 + 0x4b);

    //set Simplified Turning state to its own absolute value
    if (iVar1 < 0) {
      iVar1 = -iVar1;
    }

    //driftStart:
    //this first condition happens when drifting?
    //if ((Character's Turn stat + (Turning multiplier? << 1) / 5) >> 1) < Simplified turning state and
    if (
		(
			(
				(
					(int)((uint)*(byte *)(param_2 + 0x43a) +
					((int)*(char *)(param_2 + 0x34) << 1) / 5) >> 1
					< iVar1
				) &&

				(
					//player has jump buttons held
					(*(uint *)(PTR_DAT_8008d2b0 + (uint)*(byte *)(param_2 + 0x4a) * 0x50 + 0x10) &
					(int)*(short *)(param_2 + 0x382)) != 0
				)
			) &&

			//player is not in accel prevention or braking and
			((*(uint *)(param_2 + 0x2c8) & 8) == 0)
		) &&

		//Character's Speed stat (divided by 2?) <= Speed Approximate
		(
			(int)((uint)*(ushort *)(param_2 + 0x42c) << 0x10) >> 0x11 <=
			(int)*(short *)(param_2 + 0x38e)
		)
	   )
    {
      // Player_Drifting_Init
      FUN_80063934(param_1);

      //exit the function
      return;
    }
  }

  // at this point, assume driver is not touching ground

  if (
		// if driver has been "Player_Driving" more than 0.1 seconds?
		(*(short *)(param_2 + 0x406) == 0) &&

		(4 < *(short *)(param_2 + 0x40a))
	 )
  {
    // OnInit_State9 (what is it?)
    FUN_80062e94(param_1);
  }

  else {

	// if driver has been "Player_Driving" more than 0.64 seconds
    if (*(short *)(param_2 + 0x408) == 0)
	{
      //traction related
      *(undefined2 *)(param_2 + 0x40a) = 0;
    }
  }
  return;
}



// Player_Driving_Init
// param1 = thread, param2 = driver
void FUN_80062b74(undefined4 param_1,int param_2)
{
	// spawn function that gives you immediate control,
	// used for adventure spawn, and dropping a mask-grab

  int iVar1;

  // This if-statement prevents driving in Main Menu,
  // Cutscenes, Naughty Dog Box Scene, etc

  if (
		// if Level ID is not an adv hub
		(4 < *(int *)(PTR_DAT_8008d2ac + 0x1a10) - 0x19U) ||
		(
			// or, this is an adv hub, and 232 is loaded

			//if 232 dll is loaded
		    iVar1 = FUN_80034920(),
			iVar1 != 0
		)
	)
  {
    if (
			// If you're in Battle Mode and
			((*(uint *)PTR_DAT_8008d2ac & 0x20) != 0) &&

			//player is blasted
			(*(char *)(param_2 + 0x376) == '\x06')
		)
    {
      //set Invincibility Timer to 0xB40
      *(undefined4 *)(param_2 + 0x24) = 0xb40;
    }

    *(undefined2 *)(param_2 + 0x406) = 0x60;
    *(undefined2 *)(param_2 + 0x408) = 0x280;

	// Player_Driving_Update
    *(undefined4 *)(param_2 + 0x58) = 0x80062a4c;

	// Player_Driving_Input
    *(undefined4 *)(param_2 + 0x5c) = 0x8006181c;

	*(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
    *(undefined4 *)(param_2 + 100) = 0x8005fc8c; // OnInterpolate
    *(undefined4 *)(param_2 + 0x68) = 0x8005ea60; // OnApplyForces
    *(undefined4 *)(param_2 + 0x6c) = 0x80020410; // OnPhysics
    *(undefined4 *)(param_2 + 0x70) = 0x8005ebac; // OnCollide -- handle collision with turbo pads and robotcars
    *(undefined4 *)(param_2 + 0x74) = 0x8001d944; // Searches for quadblock
    *(undefined4 *)(param_2 + 0x78) = 0x80060630; // JumpAndFriction
    *(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix
    *(undefined4 *)(param_2 + 0x80) = 0x8005b178; // OnAnimate_Driving

    //Kart state = normal
    *(undefined *)(param_2 + 0x376) = 0;

	//Turbo meter = full
    *(undefined2 *)(param_2 + 0x3dc) = 0;

	*(undefined2 *)(param_2 + 0x40a) = 0;
    *(undefined4 *)(param_2 + 0x54) = 0;

	// SpawnParticle_DriverMain
    *(undefined4 *)(param_2 + 0x84) = 0x80059a18;
  }
  return;
}


// Player_Freeze_Input
void FUN_80062ca8(undefined4 param_1,int param_2)
{
  uint uVar1;

  // Player_Driving_Input
  FUN_8006181c();

  // get flags
  uVar1 = *(uint *)(param_2 + 0x2c8);

  // reset two speed variables
  *(undefined2 *)(param_2 + 0x39c) = 0;
  *(undefined2 *)(param_2 + 0x39e) = 0;

  // reset amplified turn state
  *(undefined2 *)(param_2 + 0xc0) = 0;

  // reset turn state
  *(undefined *)(param_2 + 0x4b) = 0;

  // reset wheel Y rotation
  *(undefined2 *)(param_2 + 6) = 0;

  // edit flags
  *(uint *)(param_2 + 0x2c8) = uVar1 | 8;
  *(uint *)(param_2 + 0x2c8) = uVar1 & 0xfffffffb | 8;

  if (0 < *(short *)(param_2 + 0x3f0)) {
    *(undefined2 *)(param_2 + 0x3f0) = 0;
  }
  return;
}

// Player_Freeze_Init
// param1 = thread, param2 = driver
void FUN_80062d04(undefined4 param_1,int param_2)

{
  if (*(char *)(param_2 + 0x376) != '\v')
  {
	// Player_Freeze_Input
    *(undefined4 *)(param_2 + 0x5c) = 0x80062ca8;

	*(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
    *(undefined4 *)(param_2 + 100) = 0x8005fc8c; // OnInterpolate
    *(undefined4 *)(param_2 + 0x68) = 0x8005ea60; // OnApplyForces
    *(undefined4 *)(param_2 + 0x6c) = 0x80020410; // OnPhysics
    *(undefined4 *)(param_2 + 0x70) = 0x8005ebac; // OnCollide -- handle collision with turbo pads and robotcars
    *(undefined4 *)(param_2 + 0x74) = 0x8001d944; // Searches for quadblock
    *(undefined4 *)(param_2 + 0x78) = 0x80060630; // JumpAndFriction
    *(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix
    *(undefined4 *)(param_2 + 0x80) = 0x8005b178; // OnAnimate_Driving

	// kart state = 11
    *(undefined *)(param_2 + 0x376) = 0xb;

    *(undefined2 *)(param_2 + 0x38c) = 0;
    *(undefined2 *)(param_2 + 0x38e) = 0;
    *(undefined4 *)(param_2 + 0x54) = 0;
    *(undefined4 *)(param_2 + 0x58) = 0;

	// SpawnParticle_DriverMain
    *(undefined4 *)(param_2 + 0x84) = 0x80059a18;
  }
  return;
}

// param1 = thread, param2 = driver
void FUN_80062db0(undefined4 param_1,int param_2)
//seems to handle end of blasted effect
{
  //if 0x39E of player struct = 0 and
  //(player is not in accel prevention (4),
  //not pressing Square (4, 6),
  if (
		(*(short *)(param_2 + 0x39e) == 0) &&

		// not in player-on-player collision
		((*(uint *)(param_2 + 0x2c8) & 0x10000028) == 0)
	 )
  {
    //player's speed = 0
    *(undefined2 *)(param_2 + 0x38c) = 0;

    //player's speed approximate = 0
    *(undefined2 *)(param_2 + 0x38e) = 0;
  }
  else
  {
	// Player_Driving_Init
    FUN_80062b74();
  }
  return;
}


// param1 = thread, param2 = driver
// reverse one frame of position
void FUN_80062e04(undefined4 param_1,int param_2)

{
   // Player_JumpAndFriction
  FUN_80060630();

  // if player did not start jumping this frame
  if ((*(uint *)(param_2 + 0x2c8) & 0x400) == 0)
  {
	// if there are not two humans colliding
    if ((*(uint *)(param_2 + 0x2c8) & 0x10000000) == 0)
	{
	  // remove speed (x, y, z)
      *(undefined4 *)(param_2 + 0x3a0) = 0;
      *(undefined4 *)(param_2 + 0x3a4) = 0;
      *(undefined4 *)(param_2 + 0x3a8) = 0;

	  // remove speed and speedApprox
      *(undefined2 *)(param_2 + 0x38c) = 0;
      *(undefined2 *)(param_2 + 0x38e) = 0;

	  // set position to previous position
      *(undefined4 *)(param_2 + 0x2d4) = *(undefined4 *)(param_2 + 0x2e0);
      *(undefined4 *)(param_2 + 0x2d8) = *(undefined4 *)(param_2 + 0x2e4);
      *(undefined4 *)(param_2 + 0x2dc) = *(undefined4 *)(param_2 + 0x2e8);
    }
  }

  // if player did start jumping this frame
  else
  {
	// Player_Driving_Init
    FUN_80062b74(param_1,param_2);
  }

  return;
}


// param1 = thread, param2 = driver
// state9
void FUN_80062e94(undefined4 param_1,int param_2)
{
  //kart state = 9? what is this state?
  *(undefined *)(param_2 + 0x376) = 9;

  // OnUpdate
  *(undefined4 *)(param_2 + 0x58) = 0x80062db0;

  // Player_Driving_Input
  *(undefined4 *)(param_2 + 0x5c) = 0x8006181c;

  *(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
  *(undefined4 *)(param_2 + 100) = 0x8005fc8c; // OnInterpolate
  *(undefined4 *)(param_2 + 0x68) = 0x8005ea60; // OnApplyForces
  *(undefined4 *)(param_2 + 0x6c) = 0x80020410; // OnPhysics
  *(undefined4 *)(param_2 + 0x70) = 0x8005ebac; // OnCollide -- handle collision with turbo pads and robotcars
  *(undefined4 *)(param_2 + 0x74) = 0x8001d944; // Searches for quadblock
  *(undefined4 *)(param_2 + 0x78) = 0x80062e04; // NO WEAPONS
  *(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix
  *(undefined4 *)(param_2 + 0x80) = 0x8005b178; // OnAnimate_Driving

  //Turbo meter = full
  *(undefined2 *)(param_2 + 0x3dc) = 0;

  *(undefined4 *)(param_2 + 0x54) = 0;

	// SpawnParticle_DriverMain
  *(undefined4 *)(param_2 + 0x84) = 0x80059a18;

  //turn off 29th flag of actions flag set (means players dont collide anymore)
  *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) & 0xefffffff;
  return;
}

// Player_Drifting_Interpolate
// param1 = thread, param2 = driver
void FUN_80062f4c(undefined4 param_1,int param_2)

{
  char cVar1;
  bool bVar2;
  bool bVar3;
  undefined *puVar4;
  short sVar5;
  undefined2 uVar6;
  ushort uVar7;
  int iVar8;
  int iVar9;
  uint uVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  uint uVar14;
  int iVar15;

  iVar12 = (((int)*(short *)(param_2 + 0x396) - (int)*(short *)(param_2 + 0x39a)) + 0x800U & 0xfff)
           - 0x800;
  iVar13 = iVar12 >> 3;
  if (iVar12 != 0) {
    if (iVar13 == 0) {
      iVar13 = 1;
    }

				// elapsed milliseconds per frame, ~32
    iVar12 = (*(int *)(PTR_DAT_8008d2ac + 0x1d04) << 6) >> 5;

    if (iVar12 < iVar13) {
      iVar13 = iVar12;
    }
    sVar5 = (short)iVar13;
    if (iVar13 < -iVar12) {
      sVar5 = (short)-iVar12;
    }

	// change player rotation
    *(short *)(param_2 + 0x39a) = *(short *)(param_2 + 0x39a) + sVar5;

	*(ushort *)(param_2 + 0x396) = *(short *)(param_2 + 0x396) - sVar5 & 0xfff;
  }
  if (*(short *)(param_2 + 0x3da) < 0) {
    iVar13 = -(int)*(short *)(param_2 + 0x468);
  }
  else {
    iVar13 = (int)*(short *)(param_2 + 0x468);
  }

  // get camera rotation
  iVar12 = *(short *)(param_2 + 0x2f2) - iVar13;

  // make sure it's not negative
  if (iVar12 < 0) {
    iVar12 = -iVar12;
  }

  uVar14 = iVar12 >> 3;
  if (uVar14 == 0) {
    uVar14 = 1;
  }
  uVar10 = (uint)*(byte *)(param_2 + 0x46a);
  if ((int)uVar14 < (int)(uint)*(byte *)(param_2 + 0x46a)) {
    uVar10 = uVar14;
  }

  // Interpolate rotation by speed
  sVar5 = FUN_80058f54((int)*(short *)(param_2 + 0x2fa),8,uVar10);
  puVar4 = PTR_DAT_8008d2ac;
  *(short *)(param_2 + 0x2fa) = sVar5;

  // Interpolate rotation by speed
  uVar6 = FUN_80058f54((int)*(short *)(param_2 + 0x2f2),(int)sVar5 * *(int *)(puVar4 + 0x1d04) >> 5,
                       iVar13);

  iVar12 = (int)*(short *)(param_2 + 0x3b4);
  iVar15 = (int)*(short *)(param_2 + 0x3da);
  bVar3 = false;

  // set new rotation variable
  *(undefined2 *)(param_2 + 0x2f2) = uVar6;

  iVar9 = (int)*(char *)(param_2 + 0x4b);
  iVar13 = iVar9 * 0x100;
  if (iVar15 < 0) {
    if (iVar13 < 1) {
      iVar13 = iVar9 * -0x100;
      iVar9 = -(int)*(char *)(param_2 + 0x45f);
    }
    else {
      iVar9 = -(int)*(char *)(param_2 + 0x45e);
    }
  }
  else {
    if (iVar13 < 0) {
      iVar13 = iVar9 * -0x100;
      cVar1 = *(char *)(param_2 + 0x45e);
    }
    else {
      cVar1 = *(char *)(param_2 + 0x45f);
    }
    iVar9 = (int)cVar1;
  }

  // Map value from [oldMin, oldMax] to [newMin, newMax]
  // inverting newMin and newMax will give an inverse range mapping
  iVar13 = FUN_80058f9c(iVar13,0,((uint)*(byte *)(param_2 + 0x43a) +
                                 ((int)*(char *)(param_2 + 0x34) << 1) / 5) * 0x100,0,iVar9 << 8);
  if ((iVar13 < 0) || ((bVar2 = iVar13 < iVar12, iVar13 == 0 && (iVar12 < 0)))) {
    bVar3 = true;
    iVar13 = -iVar13;
    iVar12 = -iVar12;
    iVar15 = -iVar15;
    bVar2 = iVar13 < iVar12;
  }

  if (bVar2)
  {
														// elapsed milliseconds per frame, ~32
    iVar12 = iVar12 - ((int)*(short *)(param_2 + 0x466) * *(int *)(PTR_DAT_8008d2ac + 0x1d04) >> 5);
    bVar2 = iVar12 < iVar13;
  }
  else
  {
														// elapsed milliseconds per frame, ~32
    iVar12 = iVar12 + ((int)*(short *)(param_2 + 0x464) * *(int *)(PTR_DAT_8008d2ac + 0x1d04) >> 5);
    bVar2 = iVar13 < iVar12;
  }
  if (bVar2) {
    iVar12 = iVar13;
  }
  if (iVar13 == 0) {
LAB_80063244:

	// Interpolate rotation by speed
    uVar6 = FUN_80058f54((int)*(short *)(param_2 + 0x580),1,0);
    *(undefined2 *)(param_2 + 0x580) = uVar6;
  }
  else {
    if (iVar15 < 1) {
      if (-1 < iVar15) goto LAB_80063244;
      uVar7 = *(short *)(param_2 + 0x580) - 1;
      *(ushort *)(param_2 + 0x580) = uVar7;
      if (0 < (int)((uint)uVar7 << 0x10)) {
        *(undefined2 *)(param_2 + 0x580) = 0;
      }
    }
    else {
      uVar7 = *(short *)(param_2 + 0x580) + 1;
      *(ushort *)(param_2 + 0x580) = uVar7;
      if ((int)((uint)uVar7 << 0x10) < 0) {
        *(undefined2 *)(param_2 + 0x580) = 0;
      }
    }
  }
  if (bVar3) {
    iVar12 = -iVar12;
    iVar15 = -iVar15;
  }

  // Map value from [oldMin, oldMax] to [newMin, newMax]
  // inverting newMin and newMax will give an inverse range mapping
  iVar13 = FUN_80058f9c((int)*(short *)(param_2 + 0x584),0,(uint)*(byte *)(param_2 + 0x462) << 5,
                        (int)*(char *)(param_2 + 0x461) * (int)*(short *)(param_2 + 0x3da) >> 8,
                        iVar15);
  if (-1 < iVar13) {
    if (iVar12 < -iVar13) {
      iVar12 = -iVar13;
    }
    sVar5 = (short)iVar12;
    if (0 < iVar13) goto LAB_800632cc;
  }
  sVar5 = (short)iVar12;
  if (-iVar13 < iVar12) {
    sVar5 = (short)-iVar13;
  }
LAB_800632cc:
  iVar12 = iVar13;
  if (iVar13 < 0) {
    iVar12 = -iVar13;
  }
  *(short *)(param_2 + 0x3b4) = sVar5;
  iVar9 = (int)sVar5;

  // Map value from [oldMin, oldMax] to [newMin, newMax]
  // inverting newMin and newMax will give an inverse range mapping
  iVar12 = FUN_80058f9c(iVar12,0,(int)*(char *)(param_2 + 0x460) +
                                 ((int)*(char *)(param_2 + 0x34) << 2) / 5,0,
                        (int)*(short *)(param_2 + 0x474));
  iVar15 = iVar9;
  if (iVar13 < 0) {
    iVar12 = -iVar12;
    if (iVar9 < 0) {
      if (iVar9 < 0) {
        iVar15 = -iVar9;
      }
      iVar11 = (int)*(char *)(param_2 + 0x45f) << 8;
      iVar8 = -(int)*(short *)(param_2 + 0x470);
    }
    else {
      iVar11 = (int)*(char *)(param_2 + 0x45e) << 8;
      iVar8 = -(int)*(short *)(param_2 + 0x472);
    }
  }
  else {
    if (iVar9 < 0) {
      if (iVar9 < 0) {
        iVar15 = -iVar9;
      }
      cVar1 = *(char *)(param_2 + 0x45e);
      sVar5 = *(short *)(param_2 + 0x472);
    }
    else {
      cVar1 = *(char *)(param_2 + 0x45f);
      sVar5 = *(short *)(param_2 + 0x470);
    }
    iVar8 = (int)sVar5;
    iVar11 = (int)cVar1 << 8;
  }

  // Map value from [oldMin, oldMax] to [newMin, newMax]
  // inverting newMin and newMax will give an inverse range mapping
  iVar15 = FUN_80058f9c(iVar15,0,iVar11,0,iVar8);
  iVar12 = (iVar12 + iVar15) - (int)*(short *)(param_2 + 0x3c6);
  iVar15 = iVar12 >> 3;
  sVar5 = (short)iVar15;
  if (iVar12 != 0) {
    if (iVar15 == 0) {
      sVar5 = 1;
    }
    *(short *)(param_2 + 0x3c6) = *(short *)(param_2 + 0x3c6) + sVar5;
  }
  iVar12 = (int)*(short *)(param_2 + 0x580);
  if (iVar12 < 0) {
    iVar12 = -iVar12;
  }

  // get half of spin-out constant, this determines
  // when to start making tire sound effects, after the
  // turbo meter finishes filling past it's max capacity

  // if you drift beyond the limit of the turbo meter
  if ((int)(uint)(*(byte *)(param_2 + 0x463) >> 1) < iVar12)
  {
    iVar12 = (int)*(short *)(param_2 + 0x3d4);
    if (iVar12 < 0) {
      iVar12 = -iVar12;
    }
    if (iVar12 < 10) {
      *(undefined2 *)(param_2 + 0x3d8) = 8;
      *(undefined2 *)(param_2 + 0x3d6) = 0x14;
      if (iVar13 < 0) {
        *(undefined2 *)(param_2 + 0x3d6) = 0xffec;
      }
    }
  }
  else {
    *(undefined2 *)(param_2 + 0x3d8) = 0;
  }
  iVar12 = (int)*(short *)(param_2 + 0x3d4);
  if (iVar12 < 0) {
    iVar12 = -iVar12;
  }
  if (0x32 < iVar12) {
    *(undefined2 *)(param_2 + 0x3d8) = 0;
  }
  if (*(short *)(param_2 + 0x3d8) == 0) {
    *(undefined2 *)(param_2 + 0x3d6) = 10;
    if (0 < *(short *)(param_2 + 0x3d4)) {
      *(undefined2 *)(param_2 + 0x3d6) = 0xfff6;
    }
    iVar12 = (int)*(short *)(param_2 + 0x3d6);
    if (iVar12 < 0) {
      iVar12 = -iVar12;
    }

	// Interpolate rotation by speed
    sVar5 = FUN_80058f54((int)*(short *)(param_2 + 0x3d4),iVar12,0);
  }
  else {
    *(short *)(param_2 + 0x3d8) = *(short *)(param_2 + 0x3d8) + -1;
    sVar5 = *(short *)(param_2 + 0x3d4) + *(short *)(param_2 + 0x3d6);
  }
  *(short *)(param_2 + 0x3d4) = sVar5;
  puVar4 = PTR_DAT_8008d2ac;
  *(undefined2 *)(param_2 + 0xc0) = (short)(iVar9 + iVar13);
  *(ushort *)(param_2 + 0x39a) =
       *(short *)(param_2 + 0x39a) + (short)((iVar9 + iVar13) * *(int *)(puVar4 + 0x1d04) >> 0xd) &
       0xfff;
  if (*(short *)(param_2 + 0x582) != 0) {
    iVar13 = (uint)*(ushort *)(param_2 + 0x582) - (uint)*(ushort *)(puVar4 + 0x1d04);
    *(undefined2 *)(param_2 + 0x582) = (short)iVar13;
    if (iVar13 * 0x10000 < 0) {
      *(undefined2 *)(param_2 + 0x582) = 0;
    }
															// elapsed milliseconds per frame, ~32
    sVar5 = (short)((int)((uint)*(byte *)(param_2 + 0x47a) * *(int *)(PTR_DAT_8008d2ac + 0x1d04)) >>
                   5);
    if (*(short *)(param_2 + 0x3c6) < 0) {
      sVar5 = -sVar5;
    }
    *(ushort *)(param_2 + 0x396) = *(short *)(param_2 + 0x396) + sVar5 & 0xfff;
  }
  puVar4 = PTR_DAT_8008d2ac;
  *(short *)(param_2 + 0x2ee) =
       *(short *)(param_2 + 0x3d4) + *(short *)(param_2 + 0x39a) + *(short *)(param_2 + 0x3c6);

  // increment this by milliseconds
  sVar5 = *(short *)(param_2 + 0x584) + *(short *)(puVar4 + 0x1d04);
  *(short *)(param_2 + 0x584) = sVar5;

  if ((int)((uint)*(byte *)(param_2 + 0x462) << 5) < (int)sVar5) {
    *(short *)(param_2 + 0x584) = (ushort)*(byte *)(param_2 + 0x462) << 5;
  }

  // Rot_AxisAngle
  FUN_8005f89c((undefined4 *)(param_2 + 0x310),param_2 + 0x360,(int)*(short *)(param_2 + 0x39a));
  gte_SetRotMatrix((MATRIX *)(param_2 + 0x310));

  FUN_8005fb4c(param_2);
  return;
}


// Player_Drifting_Finalize
void FUN_80063634(int param_1)

{
  *(undefined2 *)(param_1 + 0x3ea) = *(undefined2 *)(param_1 + 0x3da);
  *(short *)(param_1 + 0x3ec) = (ushort)*(byte *)(param_1 + 0x46b) << 5;
  return;
}


// Player_Drifting_Update
// param1 = thread, param2 = driver
void FUN_8006364c(undefined4 param_1,int param_2)

{
  char cVar1;
  undefined2 uVar2;
  undefined4 uVar3;
  int iVar4;
  int iVar5;

  // If you do not press L1 or R1
  if ((*(uint *)(PTR_DAT_8008d2b0 + (uint)*(byte *)(param_2 + 0x4a) * 0x50 + 0x14) & 0xc00) == 0) {

	// If there is no room in the turbo meter left to fill
	if (*(short *)(param_2 + 0x3dc) == 0) {

	  // If you have not attempted to boost 3 times in a row
      if (*(char *)(param_2 + 0x586) < '\x03')
	  {
		// set turbo meter to empty
        *(short *)(param_2 + 0x3dc) = (ushort)*(byte *)(param_2 + 0x476) << 5;
      }
    }

	// If the turbo meter is not full
	else
	{
	  // decreaes the amoutn of room remaining, by elapsed milliseconds per frame, ~32
      iVar4 = (uint)*(ushort *)(param_2 + 0x3dc) - (uint)*(ushort *)(PTR_DAT_8008d2ac + 0x1d04);
      *(undefined2 *)(param_2 + 0x3dc) = (short)iVar4;

	  // if the bar goes beyond full
      if (iVar4 * 0x10000 < 0)
	  {
		// set bar to full
        *(undefined2 *)(param_2 + 0x3dc) = 0;
      }

	  // If bar is full
      if (*(short *)(param_2 + 0x3dc) == 0)
	  {
		// Make a sound
        FUN_80028494(0xf,1,(uint)*(ushort *)(param_2 + 0x2ca) & 1);

		// Add to your number of boost attempts, this makes it
		// so you can't attempt to boost again until you release L1 + R1
        *(char *)(param_2 + 0x586) = *(char *)(param_2 + 0x586) + '\x03';
      }
    }
  }

  // If you do press L1 or R1
  else {

	// Get P1's turbo meter
	// This is the distance remaining that can be filled
    iVar4 = (int)*(short *)(param_2 + 0x3dc);

	// Set drift timer to zero, start the drift
    *(undefined2 *)(param_2 + 0x580) = 0;

	// If turbo meter is not empty
	if (iVar4 != 0) {

	  // get length where turbo turns from green to red
      iVar5 = (uint)*(byte *)(param_2 + 0x477) << 5;

	  // If distance remaining to be filled in turbo bar, is less than,
	  // the distance remaining from the red/green "turning point" to the end,

	  // If meter is in the red
	  if (iVar4 < iVar5)
	  {
		// reserves_gain = map from old range to new range
		// [distance remaining in bar, to, zero]
		// [bit shift green-to-red meter const, to bit shift 0x478]
        uVar3 = FUN_80058f9c(iVar4,0,iVar5,(uint)*(byte *)(param_2 + 0x478) << 5,0);

		// Turbo_Increment
		FUN_8005abfc(

			// driver
			param_2,

			// amount of reserves
			uVar3,

			2,

			// fire level, bigger boost for attempt number (1,2, or 3)
			(int)*(char *)(param_2 + 0x587) << 6);


		// increase the counter for number of times you've boosted in a row (0-3)
		cVar1 = *(char *)(param_2 + 0x587) + '\x01';
        *(char *)(param_2 + 0x587) = cVar1;

		// if you've boosted less than 3 times in a row
        if (cVar1 < '\x03')
		{
			// give a chance to boost again
          *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) | 0x80;
        }

        *(short *)(param_2 + 0x582) = (ushort)*(byte *)(param_2 + 0x479) << 5;
      }

	  // If meter is in the green
      else
	  {
		  // reset meter to beginning
        *(undefined *)(param_2 + 0x381) = 8;
      }

      *(undefined2 *)(param_2 + 0x3dc) = 0;

	  // increase number of boost attempts (both success and failure)
      *(char *)(param_2 + 0x586) = *(char *)(param_2 + 0x586) + '\x01';
    }
  }

  // 1.0 seconds
  uVar2 = 0x3c0;

  if (
		// If the "spin-out" constant is less than your drift counter
		((int)(uint)*(byte *)(param_2 + 0x463) < (int)*(short *)(param_2 + 0x580)) ||

		(
			(
				*(short *)(param_2 + 0x38e) < 0 &&
				(
					// 2.0 seconds
					uVar2 = 0x780,

					// if you're not on any turbo pad
					(*(uint *)(param_2 + 0xbc) & 3) == 0
				)
			)
		)
	 )
  {
	// Make the character spin out from too much drifting

	// Set amount of NoInput
    *(undefined2 *)(param_2 + 0x400) = uVar2;

	// Start spinning out
    FUN_80063ec0(param_1,param_2);
  }

  // if you aren't spinning out
  else {

	// If your drift counter is less than the constant that makes you "spin out" from too much drift
    if (
			((int)*(short *)(param_2 + 0x580) < (int)-(uint)*(byte *)(param_2 + 0x463)) ||

			((
				((int)*(short *)(param_2 + 0x38c) <
				(int)((uint)*(ushort *)(param_2 + 0x42c) << 0x10) >> 0x11 ||
				((*(uint *)(param_2 + 0x2c8) & 0x2028) != 0)) ||

				// If the controller input is...
				((*(uint *)(PTR_DAT_8008d2b0 + (uint)*(byte *)(param_2 + 0x4a) * 0x50 + 0x10) &

				// not the jump button that you used to start drifting
				(int)*(short *)(param_2 + 0x382)) == 0)
			))
		)
	{
	  // Stop drifting, just drive

	  // Player_Drifting_Finalize
      FUN_80063634(param_2);

	  // Player_Driving_Init
      FUN_80062b74(param_1,param_2);
    }
  }
  return;
}


// Player_Drifting_Input
void FUN_800638d4(undefined4 param_1,int param_2)

{
  undefined *puVar1;

  // Player_Driving_Input
  FUN_8006181c();

  puVar1 = PTR_DAT_8008d2ac;

  // driver is drifting (0x1000)
  // driver is skidding (0x800)
  *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) | 0x1800;

  // drift timer += elapsed time
  *(int *)(param_2 + 0x538) = *(int *)(param_2 + 0x538) + *(int *)(puVar1 + 0x1d04);
  return;
}

// Player_Drifting_InitSetUpdate
// param1 = thread, param2 = driver
void FUN_80063920(undefined4 param_1,int param_2)
{
  // This is so the update function
  // is not called on the first frame,
  // just like spinning

  *(undefined4 *)(param_2 + 0x54) = 0;

  // Player_Drifting_Update
  *(undefined4 *)(param_2 + 0x58) = 0x8006364c;
  return;
}

// Player_Drifting_Init
// param1 = thread, param2 = driver
void FUN_80063934(undefined4 param_1,int param_2)
//seems to handle start of drifts
{
  short sVar1;
  //kart is drifting
  *(undefined *)(param_2 + 0x376) = 2;
  //sVar1 = Character's Drift stat + ((Turning multiplier? << 2) / 5)
  sVar1 = (short)*(char *)(param_2 + 0x460) + (short)(((int)*(char *)(param_2 + 0x34) << 2) / 5);
  //Multiplied drift = sVar1 * 100
  *(short *)(param_2 + 0x3da) = sVar1 * 0x100;
  //if simplified turning state is negative (means you're turning right)
  if (*(char *)(param_2 + 0x4b) < '\0') {
    //also make Multiplied drift negative
    *(short *)(param_2 + 0x3da) = sVar1 * -0x100;
  }

  // Player_Drifting_InitSetUpdate
  *(undefined4 *)(param_2 + 0x54) = 0x80063920;

  // Player_Drifting_Input
  *(undefined4 *)(param_2 + 0x5c) = 0x800638d4;

  *(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
  *(undefined4 *)(param_2 + 100) = 0x80062f4c; // OnInterpolate
  *(undefined4 *)(param_2 + 0x68) = 0x8005ea60; // OnApplyForces
  *(undefined4 *)(param_2 + 0x6c) = 0x80020410; // OnPhysics
  *(undefined4 *)(param_2 + 0x70) = 0x8005ebac; // OnCollide -- handle collision with turbo pads and robotcars
  *(undefined4 *)(param_2 + 0x74) = 0x8001d944; // Searches for quadblock
  *(undefined4 *)(param_2 + 0x78) = 0x80060630; // JumpAndFriction
  *(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix
  *(undefined4 *)(param_2 + 0x80) = 0x8005b178; // OnAnimate_Driving

  //Drifting Timer = 0
  *(undefined2 *)(param_2 + 0x580) = 0;
  *(undefined2 *)(param_2 + 0x584) = 0;
  *(undefined2 *)(param_2 + 0x582) = 0;
  //Boost attempts = 0
  *(undefined *)(param_2 + 0x586) = 0;
  //Successful boost attempts = 0
  *(undefined *)(param_2 + 0x587) = 0;
  *(undefined2 *)(param_2 + 0x3b4) = 0;
  *(undefined2 *)(param_2 + 0x3d2) = 0;
  *(undefined2 *)(param_2 + 0x3ec) = 0;
  *(undefined4 *)(param_2 + 0x58) = 0;

  // SpawnParticle_DriverMain
  *(undefined4 *)(param_2 + 0x84) = 0x80059a18;

  //Turbo meter space left to fill = Length of Turbo meter << 5
  *(short *)(param_2 + 0x3dc) = (ushort)*(byte *)(param_2 + 0x476) << 5;
  return;
}

// Player_Crashing_Interpolate
// param1 = thread, param2 = driver
void FUN_80063a44(undefined4 param_1,int param_2)
{
  undefined *puVar1;
  ushort uVar2;
  undefined2 uVar3;

  puVar1 = PTR_DAT_8008d2ac;
  uVar2 = *(short *)(param_2 + 0x39a) +				// elapsed milliseconds per frame, ~32
          (short)((int)*(short *)(param_2 + 0xc0) * *(int *)(PTR_DAT_8008d2ac + 0x1d04) >> 0xd) &
          0xfff;
  *(ushort *)(param_2 + 0x39a) = uVar2;
  *(short *)(param_2 + 0x2ee) = *(short *)(param_2 + 0x3d4) + uVar2 + *(short *)(param_2 + 0x3c6);

  // Interpolate rotation by speed
  uVar3 = FUN_80058f54((int)*(short *)(param_2 + 0x2f2),(*(int *)(puVar1 + 0x1d04) << 5) >> 5,0);
  puVar1 = PTR_DAT_8008d2ac;

  // set camera rotation angle around player
  *(undefined2 *)(param_2 + 0x2f2) = uVar3;

  // Interpolate rotation by speed
  uVar3 = FUN_80058f54((int)*(short *)(param_2 + 0x3c6),(*(int *)(puVar1 + 0x1d04) << 7) >> 5,0);
  *(undefined2 *)(param_2 + 0x3c6) = uVar3;

  // Rot_AxisAngle
  FUN_8005f89c(param_2 + 0x310,param_2 + 0x360,(int)*(short *)(param_2 + 0x39a));
  return;
}

// Player_Crashing_Update
void FUN_80063af8(void)

{
  return;
}

// Player_Crashing_Input
// param1 = thread, param2 = driver
void FUN_80063b00(undefined4 param_1,int param_2)

{
  // Player_Driving_Input
  FUN_8006181c();

  // reset two speed variables
  *(undefined2 *)(param_2 + 0x39c) = 0;
  *(undefined2 *)(param_2 + 0x39e) = 0;

  return;
}

// Player_Crashing_Animate
// param1 = thread, param2 = driver
void FUN_80063b2c(int param_1,int param_2)

{
  short sVar1;
  undefined2 uVar2;
  int iVar3;
  int iVar4;

  // get instance from thread
  iVar4 = *(int *)(param_1 + 0x34);

  // increase animation frame
  *(short *)(iVar4 + 0x54) = *(short *)(iVar4 + 0x54) + 1;

  *(char *)(param_2 + 0x4d) = *(char *)(param_2 + 0x4d) + '\x01';

  // get animation frame
  sVar1 = *(short *)(iVar4 + 0x54);

  // get number of frames in animation
  iVar3 = FUN_8005b0f4(iVar4,(uint)*(byte *)(iVar4 + 0x52));

  // if animation is finished
  if (iVar3 + -1 <= (int)sVar1)
  {
	// get number of frames in anim #0
    iVar3 = FUN_8005b0f4(iVar4,0);

	// if it has frames
    if (0 < iVar3)
	{
	  // reset animation
      *(undefined *)(iVar4 + 0x52) = 0;

      uVar2 = FUN_8005b0c4(0,iVar3);

	  // set animation
      *(undefined2 *)(iVar4 + 0x54) = uVar2;

      *(undefined *)(param_2 + 0x4c) = 0;
      *(undefined *)(param_2 + 0x4d) = 0;
    }

	// Player_Driving_Init
    *(undefined4 *)(param_2 + 0x54) = 0x80062b74;
  }
  return;
}


// Player_Crashing_Init
// param1 = thread, param2 = driver
void FUN_80063bd4(int param_1,int param_2)

{
  int iVar1;

  // get instance from thread
  iVar1 = *(int *)(param_1 + 0x34);

  // Set state to crashing
  *(undefined *)(param_2 + 0x376) = 1;

  *(undefined2 *)(param_2 + 0x3e6) = 10000;
  *(undefined2 *)(param_2 + 0x3dc) = 0;
  *(undefined2 *)(param_2 + 0x3b4) = 0;
  *(undefined2 *)(param_2 + 0x3d2) = 0;
  *(undefined2 *)(param_2 + 0x3d4) = 0;
  *(undefined2 *)(param_2 + 0x3d6) = 0;
  *(undefined2 *)(param_2 + 0x3d8) = 0;
  *(undefined2 *)(param_2 + 0xc0) = 0;
  *(undefined2 *)(param_2 + 0x38c) = 0;
  *(undefined2 *)(param_2 + 0x38e) = 0;
  *(undefined4 *)(param_2 + 0x3a0) = 0;
  *(undefined4 *)(param_2 + 0x3a4) = 0;
  *(undefined4 *)(param_2 + 0x3a8) = 0;
  *(undefined4 *)(param_2 + 0x88) = 0;
  *(undefined4 *)(param_2 + 0x8c) = 0;
  *(undefined4 *)(param_2 + 0x90) = 0;
  *(undefined2 *)(param_2 + 0x36e) = 0;
  *(undefined2 *)(param_2 + 0x3e2) = 0;
  *(undefined2 *)(param_2 + 0x3de) = 0;
  *(undefined2 *)(param_2 + 0x3e0) = 0;
  *(undefined *)(param_2 + 0x377) = 0;
  *(undefined2 *)(param_2 + 0x3ee) = 0;
  *(undefined2 *)(param_2 + 0x40e) = 0;
  *(undefined2 *)(param_2 + 0x410) = 0;
  *(undefined2 *)(param_2 + 0x40c) = 0;
  *(undefined2 *)(param_2 + 0x39c) = 0;
  *(undefined2 *)(param_2 + 0x39e) = 0;

  // Set driver scale
  *(undefined2 *)(iVar1 + 0x1e) = 0xccc;
  *(undefined2 *)(iVar1 + 0x1c) = 0xccc;

  // Player_Crashing_Update
  *(undefined4 *)(param_2 + 0x58) = 0x80063af8;

  // OnInit
  *(undefined4 *)(param_2 + 0x54) = 0;

  // Player_Crashing_Input
  *(undefined4 *)(param_2 + 0x5c) = 0x80063b00;

  *(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
  *(undefined4 *)(param_2 + 100) = 0x80063a44; // OnInterpolate
  *(undefined4 *)(param_2 + 0x68) = 0x8005ea60; // OnApplyForces
  *(undefined4 *)(param_2 + 0x6c) = 0x80020410; // OnPhysics
  *(undefined4 *)(param_2 + 0x70) = 0x8005ebac; // OnCollide -- handle collision with turbo pads and robotcars
  *(undefined4 *)(param_2 + 0x74) = 0x8001d944; // Searches for quadblock
  *(undefined4 *)(param_2 + 0x78) = 0x80060630; // JumpAndFriction
  *(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix

  // Player_Crashing_Animate
  *(undefined4 *)(param_2 + 0x80) = 0x80063b2c;


  // SpawnParticle_DriverMain
  *(undefined4 *)(param_2 + 0x84) = 0x80059a18;

  return;
}


// Player_Spinning_Update
// param1 = thread, param2 = driver
void FUN_80063cf4(undefined4 param_1,int param_2)

{
  int iVar1;

  // If you are not done spinning out
  if (*(short *)(param_2 + 0x400) != 0)
  {
	// Get approximate speed
    iVar1 = (int)*(short *)(param_2 + 0x38e);

	// If your speed somehow goes negative
    if (iVar1 < 0)
	{
	  // Make it positive
      iVar1 = -iVar1;
    }

	// If you have not slown down from spinning
    if (0x2ff < iVar1)
	{
	  // End the function
      return;
    }
  }

  // If you have slown down enough

  // Player_LastSpin_Init
  FUN_80064254();
  return;
}

// Player_Spinning_Input
// param1 = thread, param2 = driver
void FUN_80063d44(undefined4 param_1,int param_2)

{
  undefined *puVar1;
  int iVar2;

  // NoInput timer = NoInput timer  -  elapsed milliseconds per frame, ~32
  iVar2 = (uint)*(ushort *)(param_2 + 0x400) - (uint)*(ushort *)(PTR_DAT_8008d2ac + 0x1d04);
  *(undefined2 *)(param_2 + 0x400) = (short)iVar2;

  // If timer is less than zero
  if (iVar2 * 0x10000 < 0)
  {
	// Set to zero
    *(undefined2 *)(param_2 + 0x400) = 0;
  }

  // Player_Driving_Input
  FUN_8006181c(param_1,param_2);

  puVar1 = PTR_DAT_8008d2ac;

  // reset two speed variables
  *(undefined2 *)(param_2 + 0x39c) = 0;
  *(undefined2 *)(param_2 + 0x39e) = 0;

  // Driver flags
  *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) | 0x5808;

  // Increment amount of time spent spinning out
  *(int *)(param_2 + 0x540) = *(int *)(param_2 + 0x540) + *(int *)(puVar1 + 0x1d04);

  return;
}


// Player_Spinning_Interpolate
// param1 = thread, param2 = driver
void FUN_80063dc8(undefined4 param_1,int param_2)

{
  undefined *puVar1;
  ushort uVar2;
  undefined2 uVar3;

  *(undefined2 *)(param_2 + 0x3e6) = 10000;
  *(short *)(param_2 + 0x3b4) = *(short *)(param_2 + 0x3b4) - (*(short *)(param_2 + 0x3b4) >> 3);
  puVar1 = PTR_DAT_8008d2ac;

  // Drift angle += (drift angle rate of change + 180 degrees ???) & 0xfff - 180 degrees
  *(short *)(param_2 + 0x3c6) =
       (*(short *)(param_2 + 0x3c6) + *(short *)(param_2 + 0x580) + 0x800U & 0xfff) - 0x800;

  *(short *)(param_2 + 0xc0) = *(short *)(param_2 + 0x3b4);
  *(short *)(param_2 + 0x3d4) = *(short *)(param_2 + 0x3d4) - (*(short *)(param_2 + 0x3d4) >> 3);

  // angle change = angle + (??? * time lapsed between frames) & 0xFFF
  uVar2 = *(short *)(param_2 + 0x39a) +
          (short)((int)*(short *)(param_2 + 0x3b4) * *(int *)(puVar1 + 0x1d04) >> 0xd) & 0xfff;

  // angle = angle change
  *(ushort *)(param_2 + 0x39a) = uVar2;
  *(short *)(param_2 + 0x2ee) = *(short *)(param_2 + 0x3d4) + uVar2 + *(short *)(param_2 + 0x3c6);

  // Interpolate rotation by speed
  uVar3 = FUN_80058f54((int)*(short *)(param_2 + 0x2f2),(*(int *)(puVar1 + 0x1d04) << 5) >> 5,0);

  // set new rotation around player
  *(undefined2 *)(param_2 + 0x2f2) = uVar3;

  // Rot_AxisAngle
  FUN_8005f89c(param_2 + 0x310,param_2 + 0x360,(int)*(short *)(param_2 + 0x39a));
  return;
}

// Player_Spinning_InitSetUpdate
// param1 = thread, param2 = driver
void FUN_80063eac(undefined4 param_1,int param_2)

{
  // This delays setting the
  // update function, by one frame

  // OnInit
  *(undefined4 *)(param_2 + 0x54) = 0;

  // Player_Spinning_Update
  *(undefined4 *)(param_2 + 0x58) = 0x80063cf4;
  return;
}

// Player_Spinning_Init
// param1 = thread, param2 = driver
void FUN_80063ec0(undefined4 param_1,int param_2)

{
  int iVar1;
  undefined4 uVar2;

  // Kart is now spinning out
  *(undefined *)(param_2 + 0x376) = 3;

  *(undefined2 *)(param_2 + 0x3d2) = 0;
  *(undefined2 *)(param_2 + 0x3dc) = 0;

  // Check if 231 dll is loaded
  iVar1 = FUN_800348e8();

  if (
		// if it is loaded
		(iVar1 != 0) &&

		// If you're not in Adventure Arena
		((*(uint *)PTR_DAT_8008d2ac & 0x100000) == 0)
	 )
  {
	// RB_Player_ModifyWumpa, -1
    FUN_800abefc(param_2,0xffffffff);
  }

  // Make driver talk
  FUN_8002cbe8(3,(int)(short)(&DAT_80086e84)[*(byte *)(param_2 + 0x4a)],0x10);

  *(undefined2 *)(param_2 + 0x582) = 1;

  // Assume you are spinning left...

  // drift angle rate of change = 300
  *(undefined2 *)(param_2 + 0x580) = 300;

  // if you're spinning to the right
  if (*(short *)(param_2 + 0xc0) < 0)
  {
	// drift angle rate of change = -300
    *(undefined2 *)(param_2 + 0x580) = 0xfed4;
    *(undefined2 *)(param_2 + 0x582) = 0xffff;
  }

  // Set function pointers for spinning out
  *(undefined4 *)(param_2 + 0x54) = 0x80063eac // Player_Spinning_InitSetUpdate
  *(undefined4 *)(param_2 + 0x5c) = 0x80063d44; // Player_Spinning_Input
  *(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
  *(undefined4 *)(param_2 + 100) = 0x80063dc8;
  *(undefined4 *)(param_2 + 0x68) = 0x8005ea60; // OnApplyForces
  *(undefined4 *)(param_2 + 0x6c) = 0x80020410; // OnPhysics
  *(undefined4 *)(param_2 + 0x70) = 0x8005ebac; // OnCollide -- handle collision with turbo pads and robotcars
  *(undefined4 *)(param_2 + 0x74) = 0x8001d944; // Searches for quadblock
  *(undefined4 *)(param_2 + 0x78) = 0x80060630; // JumpAndFriction
  *(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix

  // OnAnimate_Spinning
  *(undefined4 *)(param_2 + 0x80) = 0x8005b510;

  *(undefined4 *)(param_2 + 0x58) = 0;

  // SpawnParticle_DriverMain
  *(undefined4 *)(param_2 + 0x84) = 0x80059a18;

  if (*(char *)(param_2 + 0x4b) < '\x01') {
    uVar2 = 0x19;
  }
  else {
    uVar2 = 0x29;
  }

  // controller vibration
  FUN_800263a0(param_2,uVar2,0x60);

  return;
}


// Player_LastSpin_Update
// param1 = thread, param2 = driver
void FUN_8006402c(undefined4 param_1,int param_2)
{
  // Transition from spinning to driving

  int iVar1;

  // Get Drift Angle
  iVar1 = (int)*(short *)(param_2 + 0x3c6);

  // Get absolute value
  if (iVar1 < 0) {
    iVar1 = -iVar1;
  }

  // If you're almost fully facing forward
  if (iVar1 < 0x10)
  {
	// Change all funcPtrs to transition
	// from LastSpin to Driving
	// Player_EndSpinning_Init
    FUN_800644d0();
  }
  return;
}

// Player_LastSpin_Input
// param1 = thread, param2 = driver
void FUN_8006406c(undefined4 param_1,int param_2)

{
  // Player_Driving_Input
  FUN_8006181c();

  // reset two speed variables
  *(undefined2 *)(param_2 + 0x39c) = 0;
  *(undefined2 *)(param_2 + 0x39e) = 0;

  *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) | 0x4008;
  return;
}

// Player_LastSpin_Interpolate
// param1 = thread, param2 = driver
void FUN_800640a4(undefined4 param_1,int param_2)

{
  undefined *puVar1;
  ushort uVar2;
  undefined2 uVar3;
  short sVar4;
  int iVar5;

  // Get drifting angle
  iVar5 = (int)*(short *)(param_2 + 0x3c6);

  // Set drift angle (temporarily)
  *(undefined2 *)(param_2 + 0x3e6) = 10000;

  sVar4 = *(short *)(param_2 + 0x3b4) - (*(short *)(param_2 + 0x3b4) >> 3);
  *(short *)(param_2 + 0x3b4) = sVar4;
  *(short *)(param_2 + 0x3d4) = *(short *)(param_2 + 0x3d4) - (*(short *)(param_2 + 0x3d4) >> 3);
  *(short *)(param_2 + 0xc0) = sVar4;
  if (iVar5 < 1) {
    if (iVar5 < 0) {
      if (((0 < *(short *)(param_2 + 0x580)) && (-400 < iVar5)) &&
         (iVar5 = iVar5 * -4 >> 3, *(undefined2 *)(param_2 + 0x580) = (short)iVar5, iVar5 < 0x20)) {
        *(undefined2 *)(param_2 + 0x580) = 0x20;
      }

	  // Drift angle += (drift angle rate of change + 180 degrees ???) & 0xfff - 180 degrees
      uVar2 = (*(short *)(param_2 + 0x3c6) + *(short *)(param_2 + 0x580) + 0x800U & 0xfff) - 0x800;

	  // set drift angle
	  *(ushort *)(param_2 + 0x3c6) = uVar2;

      if ((0 < *(short *)(param_2 + 0x580)) && (0 < (int)((uint)uVar2 << 0x10))) {
        *(undefined2 *)(param_2 + 0x3c6) = 0;
      }
    }
  }
  else {
    if (((*(short *)(param_2 + 0x580) < 0) && (iVar5 < 400)) &&
       (iVar5 = iVar5 * -4 >> 3, *(undefined2 *)(param_2 + 0x580) = (short)iVar5, -0x20 < iVar5)) {
      *(undefined2 *)(param_2 + 0x580) = 0xffe0;
    }
    uVar2 = (*(short *)(param_2 + 0x3c6) + *(short *)(param_2 + 0x580) + 0x800U & 0xfff) - 0x800;
    *(ushort *)(param_2 + 0x3c6) = uVar2;
    if ((*(short *)(param_2 + 0x580) < 0) && ((int)((uint)uVar2 << 0x10) < 0)) {
      *(undefined2 *)(param_2 + 0x3c6) = 0;
    }
  }
  puVar1 = PTR_DAT_8008d2ac;
  uVar2 = *(short *)(param_2 + 0x39a) +
													// elapsed milliseconds per frame, ~32
          (short)((int)*(short *)(param_2 + 0xc0) * *(int *)(PTR_DAT_8008d2ac + 0x1d04) >> 0xd) &
          0xfff;
  *(ushort *)(param_2 + 0x39a) = uVar2;
  *(short *)(param_2 + 0x2ee) = *(short *)(param_2 + 0x3d4) + uVar2 + *(short *)(param_2 + 0x3c6);

  // Interpolate rotation by speed
  uVar3 = FUN_80058f54((int)*(short *)(param_2 + 0x2f2),(*(int *)(puVar1 + 0x1d04) << 5) >> 5,0);

  // set new camera rotation around player
  *(undefined2 *)(param_2 + 0x2f2) = uVar3;

  // Rot_AxisAngle
  FUN_8005f89c(param_2 + 0x310,param_2 + 0x360,(int)*(short *)(param_2 + 0x39a));
  return;
}


// param1 = thread, param2 = driver
// Player_LastSpin_Init
void FUN_80064254(undefined4 param_1,int param_2)
{
	// Transition out of spinning

  // Player_LastSpin_Update
  *(undefined4 *)(param_2 + 0x58) = 0x8006402c;

  // Player_LastSpin_Input
  *(undefined4 *)(param_2 + 0x5c) = 0x8006406c;

  *(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
  *(undefined4 *)(param_2 + 100) = 0x800640a4; // OnInterpolate
  *(undefined4 *)(param_2 + 0x68) = 0x8005ea60; // OnApplyForces
  *(undefined4 *)(param_2 + 0x6c) = 0x80020410; // OnPhysics
  *(undefined4 *)(param_2 + 0x70) = 0x8005ebac; // OnCollide -- handle collision with turbo pads and robotcars
  *(undefined4 *)(param_2 + 0x74) = 0x8001d944; // Searches for quadblock
  *(undefined4 *)(param_2 + 0x78) = 0x80060630; // JumpAndFriction
  *(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix

  // OnAnimate_LastSpin
  *(undefined4 *)(param_2 + 0x80) = 0x8005b5fc;

  *(undefined4 *)(param_2 + 0x54) = 0;

  // SpawnParticle_DriverMain
  *(undefined4 *)(param_2 + 0x84) = 0x80059a18;

  return;
}

// Player_EndSpinning_Update
void FUN_800642ec(void)
{
  return;
}

// Player_EndSpinning_Input
// param1 = thread, param2 = driver
void FUN_800642f4(undefined4 param_1,int param_2)
{
  // Player_Driving_Input
  FUN_8006181c();

  // reset two speed variables
  *(undefined2 *)(param_2 + 0x39c) = 0;
  *(undefined2 *)(param_2 + 0x39e) = 0;

  return;
}

// Player_EndSpinning_Interpolate
// param1 = thread, param2 = driver
void FUN_80064320(undefined4 param_1,int param_2)
{
  undefined *puVar1;
  ushort uVar2;
  undefined2 uVar3;

  puVar1 = PTR_DAT_8008d2ac;

  uVar2 = *(short *)(param_2 + 0x39a) +
													// elapsed milliseconds per frame, ~32
          (short)((int)*(short *)(param_2 + 0xc0) * *(int *)(PTR_DAT_8008d2ac + 0x1d04) >> 0xd) &
          0xfff;

  *(ushort *)(param_2 + 0x39a) = uVar2;
  *(short *)(param_2 + 0x2ee) = *(short *)(param_2 + 0x3d4) + uVar2 + *(short *)(param_2 + 0x3c6);

  // Interpolate rotation by speed
  uVar3 = FUN_80058f54((int)*(short *)(param_2 + 0x2f2),(*(int *)(puVar1 + 0x1d04) << 5) >> 5,0);

  puVar1 = PTR_DAT_8008d2ac;

  // set new camera rotation around player
  *(undefined2 *)(param_2 + 0x2f2) = uVar3;

  // Interpolate rotation by speed
  uVar3 = FUN_80058f54((int)*(short *)(param_2 + 0x3c6),(*(int *)(puVar1 + 0x1d04) << 7) >> 5,0);
  *(undefined2 *)(param_2 + 0x3c6) = uVar3;

  // Rot_AxisAngle
  FUN_8005f89c(param_2 + 0x310,param_2 + 0x360,(int)*(short *)(param_2 + 0x39a));
  return;
}


// param1 = thread, param2 = driver
// Player_EndSpinning_Animate
void FUN_800643d4(int param_1,int param_2)

{
  ushort uVar1;
  short sVar2;
  int iVar3;
  int iVar4;

  // get instance from thread
  iVar4 = *(int *)(param_1 + 0x34);

  // get number of frames in animation
  iVar3 = FUN_8005b0f4(iVar4,(uint)*(byte *)(iVar4 + 0x52));

  // if there are frames
  if (0 < iVar3)
  {
	// if you are spinning left???
    if (*(short *)(param_2 + 0x582) == -1) {
      sVar2 = *(short *)(iVar4 + 0x54) + 5;
      *(short *)(iVar4 + 0x54) = sVar2;
      if (sVar2 < iVar3) {
        return;
      }
      *(short *)(iVar4 + 0x54) = (short)iVar3 + -1;
      *(undefined2 *)(param_2 + 0x582) = 0;
      return;
    }

	// if you are spinning right???
    if (*(short *)(param_2 + 0x582) == 1) {
      uVar1 = *(short *)(iVar4 + 0x54) - 5;
      *(ushort *)(iVar4 + 0x54) = uVar1;
      if (-1 < (int)((uint)uVar1 << 0x10)) {
        return;
      }
      *(undefined2 *)(iVar4 + 0x54) = 0;
      *(undefined2 *)(param_2 + 0x582) = 0;
      return;
    }

    iVar3 = FUN_8005b0c4(0,iVar3);

	// Interpolate rotation by speed
    sVar2 = FUN_80058f54((int)*(short *)(iVar4 + 0x54),2,iVar3);

	// set animation frame
    *(short *)(iVar4 + 0x54) = sVar2;

	// if you are not facing forward
    if ((int)sVar2 != iVar3)
	{
	  // keep spinning till you face forward
      return;
    }
  }

  // if you are facing forward

  // Player_Driving_Init
  *(undefined4 *)(param_2 + 0x54) = 0x80062b74;
  return;
}

// param1 = thread, param2 = driver
// Player_EndSpinning_Init
void FUN_800644d0(undefined4 param_1,int param_2)

{
  // Transition from
  // LastSpin to Driving

  // Player_EndSpinning_Update,
  // "updating" happens in OnAnimate
  *(undefined4 *)(param_2 + 0x58) = 0x800642ec;

  // Player_EndSpinning_Input
  *(undefined4 *)(param_2 + 0x5c) = 0x800642f4;

  *(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
  *(undefined4 *)(param_2 + 100) = 0x80064320; // OnInterpolate
  *(undefined4 *)(param_2 + 0x68) = 0x8005ea60; // OnApplyForces
  *(undefined4 *)(param_2 + 0x6c) = 0x80020410; // OnPhysics
  *(undefined4 *)(param_2 + 0x70) = 0x8005ebac; // OnCollide -- handle collision with turbo pads and robotcars
  *(undefined4 *)(param_2 + 0x74) = 0x8001d944; // Searches for quadblock
  *(undefined4 *)(param_2 + 0x78) = 0x80060630; // JumpAndFriction
  *(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix

  // Player_EndSpinning_Animate, calls Player_Driving_Init
  *(undefined4 *)(param_2 + 0x80) = 0x800643d4;

  *(undefined4 *)(param_2 + 0x54) = 0;

  // SpawnParticle_DriverMain
  *(undefined4 *)(param_2 + 0x84) = 0x80059a18;

  return;
}


// Player_ChangeState
undefined4 FUN_80064568(int param_1,int param_2,int param_3,undefined4 param_4)

{
  char cVar1;
  byte bVar2;
  undefined4 uVar3;
  undefined *puVar4;
  undefined4 in_zero;
  undefined4 in_at;
  undefined *puVar5;
  int iVar6;
  int iVar7;
  undefined4 local_30;
  uint local_2c;
  short local_28;
  short sStack38;

  // get kart state
  cVar1 = *(char *)(param_1 + 0x376);
  *(undefined *)(param_1 + 0x4ff) = 0;

  // if kart is being mask-grabbed
  if (cVar1 == '\x05') {
    return 0;
  }

  if (
		// If player is using mask weapon
		((*(uint *)(param_1 + 0x2c8) & 0x800000) != 0) ||

		// If player invincibility timer is active
		(*(int *)(param_1 + 0x24) != 0)
	 )
  {
	// Player / AI structure + 0x4a shows driver index (0-7)

	// which driver this is (0-7)
	bVar2 = *(byte *)(param_1 + 0x4a);

LAB_8006462c:

	// Theory
	// Play sound of character laughing because they
	// were hit by weapon while invincible, and therefore
	// they take no damage

	// Make driver talk
    FUN_8002cbe8(2,(int)(short)(&DAT_80086e84)[bVar2],0x10);
    return 0;
  }

  // if you have a shield weapon
  if (*(int *)(param_1 + 0x14) != 0)
  {
	// driver -> shield -> thread -> object
    iVar6 = *(int *)(*(int *)(*(int *)(param_1 + 0x14) + 0x6c) + 0x30);

    *(ushort *)(iVar6 + 6) = *(ushort *)(iVar6 + 6) | 1;

	// give invincibility
    *(undefined4 *)(param_1 + 0x24) = 0x2a0;

    bVar2 = *(byte *)(param_1 + 0x4a);

	// you no-longer have a shield
    *(undefined4 *)(param_1 + 0x14) = 0;

    goto LAB_8006462c;
  }

  // driving
  if (param_2 == 0) {
    return 1;
  }

  // driver -> instance -> thread
  iVar6 = *(int *)(*(int *)(param_1 + 0x1c) + 0x6c);

  // Squish
  if (param_2 == 3) {
    if (cVar1 != '\x03')
	{
	  // OtherFX_Play_Echo
	  // squish sound
      FUN_80028494(0x5a,1,*(uint *)(param_1 + 0x2c8) >> 0x10 & 1);

	  // Make driver talk
      FUN_8002cbe8(4,(int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)],0x10);
    }

	// squish the character, put them into squished
	// animation for 0xF00 amount of time (frames?)
    *(undefined2 *)(param_1 + 0x404) = 0xf00;

	// NoInput = 0.25s
    *(undefined2 *)(param_1 + 0x400) = 0xf0;
  }
  else {
    if (param_2 < 4) {

	  // Blast
      if (param_2 == 2) {

		// if kart is already being "blasted"
        if (cVar1 == '\x06') {
          return 0;
        }

		// if function pointer is already set to make the kart "blasted"
        if (*(code **)(param_1 + 0x54) == FUN_800682a4) {
          return 0;
        }

		// You are only here if the player is not being
		// blasted, but needs to be blasted after being hit

		// NoInput = 2.4 seconds
        *(undefined2 *)(param_1 + 0x400) = 0x960;

		// Player / AI structure + 0x4a shows driver index (0-7)


		// which driver this is (0-7)
        bVar2 = *(byte *)(param_1 + 0x4a);

		// Undo the "Squish" effect
		*(undefined2 *)(param_1 + 0x404) = 0;

		// Player_Blasted_Init
        *(undefined4 *)(param_1 + 0x54) = 0x800682a4;

LAB_800646f0:

		// Make driver talk
		FUN_8002cbe8(1,(int)(short)(&DAT_80086e84)[bVar2],0x10);
        goto LAB_800647d8;
      }
    }
    else {

	  // Burn
      if (param_2 == 4) {

		// If player is not currently burned
        if (*(short *)(param_1 + 0x402) == 0)
		{
		  // OtherFX_Play "Just got Burned" sound
          FUN_80028468(0x69,1);

		  // Make driver talk
          FUN_8002cbe8(1,(int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)],0x10);
        }

		// Add to player's Burned timer
        *(undefined2 *)(param_1 + 0x402) = 0xf00;

		// NoInput set to 2.0 seconds
        *(undefined2 *)(param_1 + 0x400) = 0x780;

        goto LAB_800647c8;
      }

	  // mask grab
      if (param_2 == 5)
	  {
		// NoInput set to 3.36 seconds
        *(undefined2 *)(param_1 + 0x400) = 0xd20;

		// Player_MaskRespawn_Init
        *(undefined4 *)(param_1 + 0x54) = 0x800677d0;

        bVar2 = *(byte *)(param_1 + 0x4a);
        goto LAB_800646f0;
      }
    }

	// NoInput set to 1.0 seconds
    *(undefined2 *)(param_1 + 0x400) = 0x3c0;

	// If you're spinning: if you hit a glass or spun out from drifting
    if (*(char *)(param_1 + 0x376) == '\x03') goto LAB_800647d8;
  }
LAB_800647c8:

  // Player_Spinning_Init
  *(undefined4 *)(param_1 + 0x54) = 0x80063ec0;

LAB_800647d8:
  switch(param_4) {
  case 1:
    *(char *)(param_1 + 0x55e) = *(char *)(param_1 + 0x55e) + '\x01';
    if ((param_3 != 0) && (param_3 != param_1)) {
      *(char *)(param_3 + 0x55a) = *(char *)(param_3 + 0x55a) + '\x01';
      *(ushort *)(param_3 + 0x4f6) = *(ushort *)(param_3 + 0x4f6) | 1;
    }
    break;
  case 2:
    *(char *)(param_1 + 0x55f) = *(char *)(param_1 + 0x55f) + '\x01';
    break;
  case 3:
    *(char *)(param_1 + 0x55d) = *(char *)(param_1 + 0x55d) + '\x01';
    if ((param_3 != 0) && (param_3 != param_1)) {
      *(char *)(param_3 + 0x557) = *(char *)(param_3 + 0x557) + '\x01';
      *(ushort *)(param_3 + 0x4f6) = *(ushort *)(param_3 + 0x4f6) | 2;
    }
    break;
  case 4:
    if ((param_3 != 0) && (param_3 != param_1)) {
      *(char *)(param_3 + 0x556) = *(char *)(param_3 + 0x556) + '\x01';
      *(ushort *)(param_3 + 0x4f6) = *(ushort *)(param_3 + 0x4f6) | 4;
    }
    break;
  case 5:
    if ((param_3 != 0) && (param_3 != param_1)) {
      *(char *)(param_3 + 0x55b) = *(char *)(param_3 + 0x55b) + '\x01';
    }
    break;
  case 6:
    if ((param_3 != 0) && (param_3 != param_1)) {
      *(ushort *)(param_3 + 0x4f6) = *(ushort *)(param_3 + 0x4f6) | 8;
    }
  }
  *(undefined *)(param_1 + 0x376) = 0;
  *(undefined2 *)(param_1 + 0x3e2) = 0;
  *(undefined2 *)(param_1 + 0x3de) = 0;
  *(undefined *)(param_1 + 0x4c) = 0;
  *(undefined *)(param_1 + 0x4d) = 0;

  // controller vibration
  FUN_80026440(param_1,8,0);
  FUN_800264c0(param_1,8,0x7f);

  puVar4 = PTR_DAT_8008d2ac;

  // If you're not in End-Of-Race menu
  if ((param_3 != 0) && ((*(uint *)PTR_DAT_8008d2ac & 0x200000) == 0))
  {
    local_30 = CONCAT22(*(undefined2 *)(*(int *)(param_3 + 0x1c) + 0x48),
                        *(undefined2 *)(*(int *)(param_3 + 0x1c) + 0x44));

    local_2c = local_2c & 0xffff0000 | (uint)*(ushort *)(*(int *)(param_3 + 0x1c) + 0x4c);

	// camera index depending on player
    puVar5 = PTR_DAT_8008d2ac + (uint)*(byte *)(param_3 + 0x4a) * 0x110;

	// camera110 ViewProj
	gte_SetRotMatrix(puVar5 + 0x168 + 0x28);
	gte_SetTransMatrix(puVar5 + 0x168 + 0x28);
    
	// instance position on GTE
	setCopReg(2,in_zero,local_30);
    setCopReg(2,in_at,local_2c);

	// RTPS - Perspective Transformation (single)
	copFunction(2,0x180001);

	// get screenspace pos of driver
	uVar3 = getCopReg(2,0xe);
    local_28 = (short)uVar3;

	// set position of HUD element to position of driver (on screen)
	*(short *)(param_3 + 0x4d4) =
         local_28 + *(short *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_3 + 0x4a) * 0x110 + 0x184);
    sStack38 = (short)((uint)uVar3 >> 0x10);
    *(short *)(param_3 + 0x4d6) =
         sStack38 + *(short *)(puVar4 + (uint)*(byte *)(param_3 + 0x4a) * 0x110 + 0x186) + -0x14;

	// loop counter
	iVar7 = 0;

	// for iVar7 = 0; iVar7 < 1; iVar7++
    do
	{
	  // this only happens once

	  // RB_Player_KillPlayer
      FUN_800abbb4(param_3,param_1);

	  // If you're in End-Of-Race menu
      if ((*(uint *)PTR_DAT_8008d2ac & 0x200000) != 0) 
	  {
		// save something in the player that got the kill,
		// and the player that got killed
        *(undefined2 *)(param_3 + 0x4f0) = (short)param_4;
        *(undefined2 *)(param_1 + 0x4f4) = (short)param_4;
      }

	  // increment loop counter
      iVar7 = iVar7 + 1;
    } while (iVar7 < 1);

    if (
			// if attacked yourself
			(param_3 == param_1) &&

			// If you have a point limit (battle)
			((*(uint *)PTR_DAT_8008d2ac & 0x4000) != 0)
		)
	{
      if (*(int *)(param_1 + 0x4d0) == 5)
	  {
		// scoreDelta
        *(int *)(param_1 + 0x4dc) = *(int *)(param_1 + 0x4dc) + -1;
      }
      else
	  {
		// scoreDelta
        *(undefined4 *)(param_1 + 0x4dc) = 0xffffffff;
      }
    }
    
	// did not attack self
	else
	{
      if (*(int *)(param_3 + 0x4d0) == 5)
	  {
		// scoreDelta
        *(int *)(param_3 + 0x4dc) = *(int *)(param_3 + 0x4dc) + 1;
      }

      else
	  {
		// scoreDelta
        *(undefined4 *)(param_3 + 0x4dc) = 1;
      }
    }
	
	// cooldown
    *(undefined4 *)(param_3 + 0x4d0) = 5;
	
	// param_3 is attacker,
	// param_1 is attacked
    
	// count number of times attacked by this player
	// param_1->0x560[param_3->driverID]++
	iVar7 = param_1 + (uint)*(byte *)(param_3 + 0x4a);
    *(char *)(iVar7 + 0x560) = *(char *)(iVar7 + 0x560) + '\x01';
	
	// count number of times attacking this player
	// param_1->0x50c[param_3->driverID]++
    iVar7 = param_3 + (uint)*(byte *)(param_1 + 0x4a);
    *(char *)(iVar7 + 0x50c) = *(char *)(iVar7 + 0x50c) + '\x01';
    
	// if did not attack yourself
	if (param_3 != param_1) 
	{
	  // count number of times attacking
      *(char *)(param_3 + 0x559) = *(char *)(param_3 + 0x559) + '\x01';
    }
  }

  // enable collision for this thread
  *(uint *)(iVar6 + 0x1c) = *(uint *)(iVar6 + 0x1c) & 0xffffefff;

  // make visible
  *(uint *)(*(int *)(param_1 + 0x1c) + 0x28) =
  *(uint *)(*(int *)(param_1 + 0x1c) + 0x28) & 0xffffff7f;

  return 1;
}


// Weapon_Mask_boolGoodGuy
undefined4 FUN_80064be4(int param_1)

{
  // character ID (0 for crash, 1 for cortex, 2 for tiny, etc)
  short sVar1;

  // return (0 for uka, 1 for aku)
  undefined4 uVar2;

  // Player / AI structure + 0x4a shows driver index (0-7)


  // get character ID of current player (p1, p2, p3, etc)
  sVar1 = (&DAT_80086e84)[*(byte *)(param_1 + 0x4a)];

  // by default, player is bad guy and uses uka uka
  uVar2 = 0;

  // if you are crash, 		coco				polar			pura	or		penta
  if ((((sVar1 == 0) || (sVar1 == 3)) || (sVar1 == 6)) || ((sVar1 == 7 || (sVar1 == 0xd))))
  {
	// you are a good guy, use aku aku
    uVar2 = 1;
  }

  // return whether you use aku or uka
  return uVar2;
}


// Weapon_Mask_UseWeapon
// param1 is driver
// param2 (0 for mask grab, 1 for weapon)
undefined2 * FUN_80064c38(int param_1,int param_2)

{
  undefined2 uVar1;
  int iVar2;
  undefined2 *puVar3;
  uint uVar4;
  undefined4 uVar5;
  int iVar6;

  // Check if 231 dll is loaded
  iVar2 = FUN_800348e8();

  if (
		// if it is not loaded
		(iVar2 == 0) ||

		// If you're in Adventure Arena
		((*(uint *)PTR_DAT_8008d2ac & 0x100000) != 0)
	)
  {
	// return nullptr
	// no mask object in adv arena
    puVar3 = (undefined2 *)0x0;
  }
  else
  {
	// driver -> instance -> thread
    iVar6 = *(int *)(*(int *)(param_1 + 0x1c) + 0x6c);

	// thread -> childThread,
	// which gets mask thread from driver
    iVar2 = *(int *)(iVar6 + 0x14);

	// while pointer is not nullptr
    while (iVar2 != 0)
	{
	  // if thread->modelIndex is Aku or Uka
      if ((uint)*(ushort *)(iVar2 + 0x44) - 0x39 < 2)
	  {
		// RB_MaskWeapon_PerFrame
        *(undefined4 *)(iVar2 + 0x2c) = 0x800afdbc;

		// short duration
        uVar1 = 0x1e00;

		// if wumpa is less than 10
        if (*(char *)(param_1 + 0x30) < '\n') {
          iVar6 = *(int *)(iVar2 + 0x30);
        }

		// if wumpa is 10
        else {
          iVar6 = *(int *)(iVar2 + 0x30);

		  // long duration
          uVar1 = 0x2d00;
        }

		// duration
        *(undefined2 *)(iVar6 + 6) = uVar1;

        if (
				// If this is human and not AI
				((*(uint *)(param_1 + 0x2c8) & 0x100000) == 0) &&

				// if this is not a mask grab
				(param_2 != 0)
			)
		{
		  // if thread->modelIndex == Uka
          if (*(short *)(iVar2 + 0x44) == 0x3a) {
            uVar5 = 0x54;
          }

		  // if it is not aku
          else
		  {
			// if thread->modelIndex == Aku
            if (*(short *)(iVar2 + 0x44) != 0x39) goto LAB_80064d4c;
            uVar5 = 0x53;
          }

		  // OtherFX_Play_Echo
		  // activate mask weapon
          FUN_80028494(uVar5,1,*(uint *)(param_1 + 0x2c8) >> 0x10 & 1);
        }
LAB_80064d4c:

		// thread -> flags
        *(uint *)(iVar2 + 0x1c) = *(uint *)(iVar2 + 0x1c) & 0xfffff7ff;

		// return object attached to thread
        return (undefined2 *)*(undefined4 *)(iVar2 + 0x30);
      }

	  // go to next pointer
      iVar2 = *(int *)(iVar2 + 0x10);
    }

	// Weapon_Mask_boolGoodGuy
    uVar4 = FUN_80064be4(param_1);

	// If player uses Uka weapon
    if ((uVar4 & 0xffff) == 0)
	{
	  // s_doctor1_8008d62c
	  // "doctor1"

	  // 0x3a is index of model pointer array
	  // for uka head model

	  // 0x300 flag = SmallStackPool
	  // 0xd = "other" thread bucket
      iVar2 = FUN_800309a4(0x3a,s_doctor1_8008d62c,0x300,0xd,&DAT_800afdbc,0x14,iVar6);

	  // If this is human and not AI
      if (((*(uint *)(param_1 + 0x2c8) & 0x100000) == 0) &&

		  // OtherFX_Play_Echo
		  // uka activate
         (FUN_80028494(0x54,1,*(uint *)(param_1 + 0x2c8) >> 0x10 & 1),

         1 < (uint)*(byte *)(param_1 + 0x376) - 4))
	  {
		// Start playing uka uka mask song
        *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac & 0xfeffffff | 0x2000000;
      }

	  // get thread
      iVar6 = *(int *)(iVar2 + 0x6c);

	  // model pointer to uka beam
      uVar5 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x2260);
    }

	// If player uses Aku weapon
    else
	{
	  // s_doctor1_8008d62c
	  // "doctor1"

	  // 0x3a is index of model pointer array
	  // for aku head model

	  // 0x300 flag = SmallStackPool
	  // 0xd = "other" thread bucket
      iVar2 = FUN_800309a4(0x39,s_doctor1_8008d62c,0x300,0xd,&DAT_800afdbc,0x14,iVar6);

	  // If this is human and not AI
      if (((*(uint *)(param_1 + 0x2c8) & 0x100000) == 0) &&

		  // OtherFX_Play_Echo
		  // aku mask grab
         (FUN_80028494(0x53,1,*(uint *)(param_1 + 0x2c8) >> 0x10 & 1),
         1 < (uint)*(byte *)(param_1 + 0x376) - 4))
	  {
		// Start playing aku aku mask song
        *(uint *)PTR_DAT_8008d2ac = *(uint *)PTR_DAT_8008d2ac & 0xfdffffff | 0x1000000;
      }

	  // get thread from instance
      iVar6 = *(int *)(iVar2 + 0x6c);

	  // model pointer for aku beam
      uVar5 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x2258);
    }

	// get mask head object from thread
    puVar3 = *(undefined2 **)(iVar6 + 0x30);

	// INSTANCE_Birth3D -- ptrModel, name, thread
    uVar5 = FUN_8003086c(uVar5,"akubeam1",iVar6);

	// give beam instance to mask head object
    *(undefined4 *)(puVar3 + 4) = uVar5;

	// set funcOnDestroy to remove instance from instance pool
    *(undefined4 *)(iVar6 + 0x24) = 0x80041dfc;

	// allow this thread to ignore all collisions
    *(uint *)(iVar6 + 0x1c) = *(uint *)(iVar6 + 0x1c) | 0x1000;

	// make mask head invisible
    *(uint *)(iVar2 + 0x28) = *(uint *)(iVar2 + 0x28) | 0x80;

	// make mask beam invisible
    *(uint *)(*(int *)(puVar3 + 4) + 0x28) = *(uint *)(*(int *)(puVar3 + 4) + 0x28) | 0x80;

	// mask duration without 10 wumpa
	uVar1 = 0x1e00;

	// if 9 < number of wumpa
	// if wumpa is 10
	if ('\t' < *(char *)(param_1 + 0x30))
	{
	  // increased mask duration
      uVar1 = 0x2d00;
    }

	// duration
    puVar3[3] = uVar1;

	// rotX
    *puVar3 = 0x40;

	// rotY
    puVar3[1] = 0;

	// scale
    puVar3[9] = 0x1000;

	// rotZ
    puVar3[2] = 0;
  }

  // return mask object
  return puVar3;
}


// Weapon_Missile_GetTargetDriver
// param_1 driver who shot weapon
// return driver who will be chased
int FUN_80064f94(int param_1)

{
  int iVar1;
  int iVar2;
  MATRIX *pMVar3;
  int iVar4;
  int iVar5;
  long *r0;
  int iVar6;
  int iVar7;
  undefined *puVar8;
  undefined *puVar9;
  undefined auStack128 [16];
  undefined2 local_70;
  undefined2 local_6e;
  undefined2 local_6c;
  MATRIX MStack104;
  undefined auStack72 [48];

  puVar9 = auStack128;
  puVar8 = auStack128;

  // the ID of the player that the missile will chase
  iVar7 = 0;

  // set minimum distance from P1 to max possible distance
  iVar6 = 0x7fffffff;

  // if player shot missile
  // driver -> instance -> thread -> modelIndex == "player" of any kind
  if (*(short *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x44) == 0x18)
  {
	// camera110 ViewProj
    pMVar3 = (MATRIX *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_1 + 0x4a) * 0x110 + 0x168 + 0x28);
    gte_SetRotMatrix(pMVar3);
    gte_SetTransMatrix(pMVar3);
    puVar9 = puVar8;
  }

  // if robotcar shot missile
  else
  {
	// get rotation of AI
    local_70 = *(undefined2 *)(param_1 + 0x2ec);
    pMVar3 = &MStack104;
    local_6e = *(undefined2 *)(param_1 + 0x2ee);
    local_6c = *(undefined2 *)(param_1 + 0x2f0);

	// convert 3 rotation shorts into rotation matrix
    FUN_8006c2a4(pMVar3,&local_70);

	// get position of AI
    MStack104.t[0] = *(int *)(param_1 + 0x2d4) >> 8;
    MStack104.t[1] = *(int *)(param_1 + 0x2d8) >> 8;
    MStack104.t[2] = *(int *)(param_1 + 0x2dc) >> 8;

	// output: matrix ???
	// input: missile matrix
	// MATH_HitboxMatrix
    FUN_8003d264(auStack72,pMVar3);

    gte_SetRotMatrix(pMVar3);
    gte_SetTransMatrix(pMVar3);
  }

  // loop counter
  iVar5 = 0;

  r0 = (long *)(puVar9 + 0x60);

  // for iVar6 = 0; iVar6 < 8; iVar6++
  do
  {
	// get pointer to current player's structure
    iVar4 = *(int *)(PTR_DAT_8008d2ac + iVar5 * 4 + 0x24ec);

    if (
			(
				// if you hit a player with a weapon that is not yourself
				(
					// if pointer is not nullptr
					(iVar4 != 0) &&

					// if pointer is not the same as param1
					(iVar4 != param_1)
				) &&

				// if player hit, is not being picked up by mask
				(*(char *)(iVar4 + 0x376) != '\x05')
			) &&

			(
				(
					(
						// If you're not in Battle Mode
						(*(uint *)PTR_DAT_8008d2ac & 0x20) == 0 ||

						// if you are in battle mode,
						// if one player hit another that is on a different team
						(*(int *)(iVar4 + 0x4e8) != *(int *)(param_1 + 0x4e8))
					) &&

					// if player is not invisible
					(*(int *)(iVar4 + 0x28) == 0)
				)
			)
		)

	// If you hard-code iVar5 + 0x376 to be 5,
	// player can't be hit, weapons go right through them

	// however, if player hits another player on the same team,
	// and if this block still does not execute, the player hit still
	// gets animated like any other player getting hit

    {
	  // set position to driver -> instSelf -> position
      *(undefined2 *)(puVar9 + 0x58) = *(undefined2 *)(*(int *)(iVar4 + 0x1c) + 0x44);
      *(undefined2 *)(puVar9 + 0x5a) = *(undefined2 *)(*(int *)(iVar4 + 0x1c) + 0x48);
      *(undefined2 *)(puVar9 + 0x5c) = *(undefined2 *)(*(int *)(iVar4 + 0x1c) + 0x4c);
      gte_ldv0((SVECTOR *)(puVar9 + 0x58));

	  // RTPS - Perspective Transformation (single)
      gte_rtps();

      gte_stsxy(r0);
      gte_stflg((long *)(puVar9 + 100));

      if (
			(
				((*(uint *)(puVar9 + 100) & 0x40000) == 0) &&
				(0x1e < *(short *)(puVar9 + 0x60))
			) &&
			(
				(
					(int)*(short *)(puVar9 + 0x60) <

					// camera110[driverID]->0x20 (rect.w)
					*(short *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_1 + 0x4a) * 0x110 + 0x188) + -0x1e &&

					(
						(
							(
								0x14 < *(short *)((int)r0 + 2) &&

								(
									(int)*(short *)((int)r0 + 2) <

									// camera110[driverID]->0x22 (rect.h)
									*(short *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_1 + 0x4a) * 0x110 + 0x18a) + -0x14
								)
							) &&

							(
								// get X distance between two players
								iVar1 = *(int *)(iVar4 + 0x2d4) - *(int *)(param_1 + 0x2d4) >> 8,

								// get Z distance between two players
								iVar2 = *(int *)(iVar4 + 0x2dc) - *(int *)(param_1 + 0x2dc) >> 8,

								// if player is closer to missile than previous closest player
								iVar1 = iVar1 * iVar1 + iVar2 * iVar2, iVar1 < iVar6
							)
						)
					)
				)
			)
		)
	  {
		// set smallest distance to current distance
        iVar6 = iVar1;

		// set closest player to this player
        iVar7 = iVar4;
      }
    }

	// increment loop counter
    iVar5 = iVar5 + 1;

  } while (iVar5 < 8);

  // return address of player that missile will chase
  return iVar7;
}


// Weapon_Potion_Throw
// param1 is object
// param2 is instance
// param3 is flags (like throw forward potion)
undefined4 FUN_800652c8(int param_1,int param_2,uint param_3)

{
  short sVar1;
  uint uVar2;
  int iVar3;
  undefined2 uVar4;

  // For TNTs param3 != 0 shoots tnt up into air,
  // direction does not change (komodo joe)

  // For Potions
  // param3 & 1 shoots back a short distance
  // param3 & 2 shoots back a long distance
  // param3 & 4 shoots forward (hold up on d-pad)

  // if you dont want to throw forward
  if ((param_3 & 4) == 0)
  {
	// if you dont want to throw back long
    if ((param_3 & 2) == 0)
	{
	  // if you dont want to throw back short
      if ((param_3 & 1) == 0)
	  {
		// just quit and drop weapon as-is
        return 0;
      }

	  // if you want to throw back short

      uVar2 = FUN_8006c684(&DAT_8008d668);
      iVar3 = (uVar2 & 0x1f) - 0x10;
      *(undefined2 *)(param_1 + 0xc) = (short)(*(short *)(param_2 + 0x34) * iVar3 >> 0xc);
      sVar1 = *(short *)(param_2 + 0x40);
      *(undefined2 *)(param_1 + 0xe) = 0x30;
      *(undefined4 *)(param_1 + 8) = 0;
      *(ushort *)(param_1 + 0x28) = *(ushort *)(param_1 + 0x28) | 2;
      uVar4 = (undefined2)(sVar1 * iVar3 >> 0xc);
    }

	// if you want to throw back long
    else {
      *(undefined2 *)(param_1 + 0xc) = (short)((int)*(short *)(param_2 + 0x34) * -0x78 >> 0xc);
      sVar1 = *(short *)(param_2 + 0x40);
      *(undefined2 *)(param_1 + 0xe) = 0x30;
      *(undefined4 *)(param_1 + 8) = 0;
      *(ushort *)(param_1 + 0x28) = *(ushort *)(param_1 + 0x28) | 2;
      uVar4 = (undefined2)((int)sVar1 * -0x78 >> 0xc);
    }
  }

  // if you want to throw forward
  else {
    *(undefined2 *)(param_1 + 0xc) = (short)((int)*(short *)(param_2 + 0x34) * 0xf >> 9);
    sVar1 = *(short *)(param_2 + 0x40);
    *(undefined2 *)(param_1 + 0xe) = 0x30;
    *(undefined4 *)(param_1 + 8) = 0;
    *(ushort *)(param_1 + 0x28) = *(ushort *)(param_1 + 0x28) | 2;
    uVar4 = (undefined2)((int)sVar1 * 0xf >> 9);
  }
  *(undefined2 *)(param_1 + 0x10) = uVar4;
  return 1;
}


// Weapon_Shoot_Now
void FUN_8006540c(int param_1,undefined4 param_2,uint param_3)
// param1 is the address of the player/AI structure that fired the weapon
// param2 is weaponID
// param3 is "special" like throwing potions backward, or TNTs airborne
{
  undefined2 uVar1;
  short sVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  undefined4 uVar7;
  int iVar8;
  int iVar9;
  char *pcVar10;
  undefined2 *puVar11;
  undefined *puVar12;
  undefined4 local_48;
  undefined4 uVar13;
  int iVar14;
  int *piVar15;
  undefined4 *puVar16;
  undefined2 local_40;
  short local_3e;
  undefined2 local_3c;
  undefined2 local_38;
  short local_36;
  undefined2 local_34;
  undefined2 local_30;
  short local_2e;
  undefined2 local_2c;
  undefined2 local_28;
  short local_26;
  undefined2 local_24;

  // This function definitely handles the firing
  // of the weapons. I set the first instruction
  // of this function to "jr ra" to leave, and it
  // disabled the firing of all weapons

  // param1 is weapon ID
  switch(param_2)
  {

  // If your weapon is Turbo
  case 0:

	// small boost
    uVar7 = 0x80;

	// if 9 < number of wumpa
	// basically if wumpa < 10
    if ('\t' < *(char *)(param_1 + 0x30))
	{
	  // bigger boost
      uVar7 = 0x100;
    }

	// Turbo_Increment
	// 2.4 seconds reserve
    FUN_8005abfc(param_1,0x960,9,uVar7);

	break;

  // If your weapon is Missile
  case 2:

	// If there are more than 11 missiles on screen
    if (0xb < *(int *)(PTR_DAT_8008d2ac + 0x1ec0))
	{
	  // Quit, dont shoot more missiles
      return;
    }

	// set closest distance from missile-shooter to player, to max value,
	// so that we can loop through other players to find smaller distance
    iVar5 = 0x7fffffff;

	// number of missiles launched by player
    *(char *)(param_1 + 0x55c) = *(char *)(param_1 + 0x55c) + '\x01';

	// increment number of missiles that are on screen
    *(int *)(PTR_DAT_8008d2ac + 0x1ec0) = *(int *)(PTR_DAT_8008d2ac + 0x1ec0) + 1;

	// both controller vibration
    FUN_80026440(param_1,8,0);
    FUN_800264c0(param_1,8,0x7f);

	// Weapon_Missile_GetTargetDriver
    iVar8 = FUN_80064f94(param_1);

	// if a player was not found to chase
    if (iVar8 == 0)
	{
      iVar14 = 0;
      puVar12 = PTR_DAT_8008d2ac;

	  // If you're not in Battle Mode
      if ((*(uint *)PTR_DAT_8008d2ac & 0x20) == 0)
	  {
        if (
			(
				// driver -> instance -> thread -> modelIndex
				(*(short *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x44) != 0x18) &&

				// if racer is not in first place
				((int)*(short *)(param_1 + 0x482) != 0)
			) &&

			// if time on clock is an odd number
			((*(uint *)(PTR_DAT_8008d2ac + 0x1d10) & 1) != 0)
		  )
		{
			// the missile chases the driver, one place ahead of the driver that fired the weapon
			iVar8 = *(int *)(PTR_DAT_8008d2ac + ((int)*(short *)(param_1 + 0x482) + -1) * 4 + 0x250c);
        }
      }

	  // if you are in battle
      else
	  {
		// loop through all players to find
		// the closest player that the missile can seek

		// for iVar14 = 0; iVar14 < 8; iVar14++
        do
		{
		  // get address of player structure
          iVar9 = *(int *)(puVar12 + 0x24ec);

          if (
				(
					(
						// if pointer is not nullptr
						(iVar9 != 0) &&

						// if player is not the missile shooter
						(iVar9 != param_1)
					) &&

					(
						(
							// if enemy player is being picked up by mask
							*(char *)(iVar9 + 0x376) != '\x05' &&

							(
								(
									// if two players are not on same team in battle mode
									*(int *)(iVar9 + 0x4e8) != *(int *)(param_1 + 0x4e8) &&

									// if player is not invisible
									(*(int *)(iVar9 + 0x28) == 0)
								)
							)
						)
					)
				) &&
				(
					// Get the X distance between two players
					iVar3 = *(int *)(iVar9 + 0x2d4) - *(int *)(param_1 + 0x2d4) >> 8,

					// Get the Z distance between two players
					iVar4 = *(int *)(iVar9 + 0x2dc) - *(int *)(param_1 + 0x2dc) >> 8,

					// Get the distance between two players
					iVar3 = iVar3 * iVar3 + iVar4 * iVar4,

					// if player is closer to missile shooter than previous closest player
					iVar3 < iVar5
				)
			  )
		  {
			// set smallest distance to current distance
            iVar5 = iVar3;

			// set closest player to this player
            iVar8 = iVar9;
          }

		  // increment loop iteration counter
          iVar14 = iVar14 + 1;

		  // increment pointer
          puVar12 = puVar12 + 4;
        } while (iVar14 < 8);

		// when this loop ends, iVar8 is the player that the missile is tracking

      }
    }

    if (
			// if weapon is bomb
			(*(char *)(param_1 + 0x36) == '\x02') ||
			(
				// bomb model
				uVar7 = 0x3b,

				// if weapon is three missiles
				*(char *)(param_1 + 0x36) == '\v'
			)
		)
    {
	  // missile model
      uVar7 = 0x29;

      pcVar10 = "bombtracker1";

	  // 6 = "tracking" thread bucket
      uVar13 = 6;

      local_48 = 0;
    }
    else
	{
	  // s_bomb1_8008d634
	  // "bomb1"
      pcVar10 = s_bomb1_8008d634;

	  // driver -> instane -> thread
      local_48 = *(undefined4 *)(*(int *)(param_1 + 0x1c) + 0x6c);

	  // 0xd = "other" thread bucket
      uVar13 = 0xd;
    }

	// make thread for bomb or missile
	// 0x200 flag = MediumStackPool
    iVar5 = FUN_800309a4(uVar7,pcVar10,0x200,uVar13,FUN_800adb50,0x58,local_48);

	// driver instance
	iVar14 = *(int *)(param_1 + 0x1c);

	// copy driver position, rotation, and scale
	// into missile position, rotation, and scale
    uVar7 = *(undefined4 *)(iVar14 + 0x34);
    local_48 = *(undefined4 *)(iVar14 + 0x38);
    uVar13 = *(undefined4 *)(iVar14 + 0x3c);
    *(undefined4 *)(iVar5 + 0x30) = *(undefined4 *)(iVar14 + 0x30);
    *(undefined4 *)(iVar5 + 0x34) = uVar7;
    *(undefined4 *)(iVar5 + 0x38) = local_48;
    *(undefined4 *)(iVar5 + 0x3c) = uVar13;
    uVar7 = *(undefined4 *)(iVar14 + 0x44);
    local_48 = *(undefined4 *)(iVar14 + 0x48);
    uVar13 = *(undefined4 *)(iVar14 + 0x4c);
    *(undefined4 *)(iVar5 + 0x40) = *(undefined4 *)(iVar14 + 0x40);
    *(undefined4 *)(iVar5 + 0x44) = uVar7;
    *(undefined4 *)(iVar5 + 0x48) = local_48;
    *(undefined4 *)(iVar5 + 0x4c) = uVar13;

	// Rot_AxisAngle
	// rotation matrix of weapon,
	// face direction of driver facing, even with drift applied
    FUN_8005f89c(iVar5 + 0x30,param_1 + 0x360,(int)*(short *)(param_1 + 0x2ee));

	// THREAD_DestroyTracker
	// when missile needs to be destroyed,
	// decrease number of missiles,
    *(undefined4 *)(*(int *)(iVar5 + 0x6c) + 0x24) = 0x80041dc0;

	// RB_Hazard_OnCollide_Missile, remove 2D target being drawn on them
    *(undefined4 *)(*(int *)(iVar5 + 0x6c) + 0x28) = 0x800ac42c;

	// instance -> thread -> object
    piVar15 = *(int **)(*(int *)(iVar5 + 0x6c) + 0x30);

    *(undefined2 *)((int)piVar15 + 0x16) = 0;

	// record pointer that shot the missile
    piVar15[1] = param_1;

    piVar15[0x12] = 0;
    piVar15[0x15] = 0;
    piVar15[9] = 0;

	// if weapon is one bowling bomb or three bowling bombs
    if ((*(char *)(param_1 + 0x36) == '\x01') || (*(char *)(param_1 + 0x36) == '\n'))
	{
	  // CTR_MatrixToRot
	  // iVar5+0x30 is weapon inst->matrix
      FUN_80021edc(&local_40,iVar5 + 0x30,0x11);

	  // 6*4 = 0x18, missile->dir[x]
	  *(short *)(piVar15 + 6) = local_3e;

	  // missile->dir[y]
      *(undefined2 *)((int)piVar15 + 0x1a) = local_40;

	  // record "driver" pointer that bomb is chasing
	  *piVar15 = iVar8;

	  // 7*4 = 0x1C, missile->dir[z]
      *(undefined2 *)(piVar15 + 7) = local_3c;

      *(int *)(param_1 + 0x10) = iVar5;

	  // play sound of shooting bomb,
	  // the audio depends on distance
	  // from bomb to any human player
      FUN_8002f0dc(0x47,iVar5);

	  // get flags of driver that shot bombs
	  uVar6 = *(uint *)(param_1 + 0x2c8);

	  uVar7 = 10;
    }

	// if weapon is missile (should be every time)
    else
	{
	  // RB_Hazard_OnCollide_Missile, remove 2D target being drawn on them
      *(undefined4 *)(*(int *)(iVar5 + 0x6c) + 0x28) = 0x800ac42c;

	  // if missile does not have a target
	  if (iVar8 == 0)
	  {
		// set target to nullptr,
        *piVar15 = 0;
      }

	  // if missile has a target
      else
	  {
		// save address of player structure of target
        *piVar15 = iVar8;

		// if player is not aware a missile is chasing them
        if (*(int *)(iVar8 + 0x4a4) == 0)
		{
		  // RB_GetThread_ClosestTracker (missile or warpball)
          uVar7 = FUN_800b28c0(iVar8);

		  // Give the player a pointer to the missile chasing them
          *(undefined4 *)(iVar8 + 0x4a4) = uVar7;
        }
      }

	  // play sound of shooting missile,
	  // the audio depends on distance
	  // from missile to any human player
	  FUN_8002f0dc(0x4a,iVar5);

	  // get flags of the driver who shot the missile
      uVar6 = *(uint *)(param_1 + 0x2c8);

      uVar7 = 0xb;
    }

	// If driver shooting is human and not AI
    if ((uVar6 & 0x100000) == 0)
	{
	  // Make driver talk
      FUN_8002cbe8(uVar7,(int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)],0x10);
    }

    uVar1 = *(undefined2 *)(param_1 + 0x2ee);
    *(undefined2 *)((int)piVar15 + 0x12) = 0;
    *(undefined2 *)((int)piVar15 + 0x1e) = uVar1;

	// if weapon is one bowling bomb, or three bowling bombs
    if ((*(char *)(param_1 + 0x36) == '\x01') || (*(char *)(param_1 + 0x36) == '\n'))
	{
      *(short *)(piVar15 + 4) = (short)((int)*(short *)(iVar5 + 0x34) * 3 >> 7);
      *(short *)(piVar15 + 5) = (short)((int)*(short *)(iVar5 + 0x40) * 3 >> 7);

	  // if 9 < number of wumpa
	  // if wumpa is 10
      if ('\t' < *(char *)(param_1 + 0x30))
	  {
        *(ushort *)((int)piVar15 + 0x16) = *(ushort *)((int)piVar15 + 0x16) | 1;
      }

	  // If you press Down on D-Pad
      if (((*(uint *)(PTR_DAT_8008d2b0 + (uint)*(byte *)(param_1 + 0x4a) * 0x50 + 0x10) & 2) != 0)

		// or if you are pinstripe boss, I assume???
         || ((param_3 & 2) != 0))
	  {
		// roll bomb backwards
        *(ushort *)((int)piVar15 + 0x16) = *(ushort *)((int)piVar15 + 0x16) | 0x20;

		*(short *)(piVar15 + 4) =
             -(short)((((int)((uint)*(ushort *)(piVar15 + 4) << 0x10) >> 0x11) * 3) / 5);
        sVar2 = -(short)((((int)((uint)*(ushort *)(piVar15 + 5) << 0x10) >> 0x11) * 3) / 5);
        goto LAB_800659ec;
      }
    }

	// if weapon is not bowling bomb
    else
	{
	  // if wumpa < 10
      if (*(char *)(param_1 + 0x30) < '\n') {
        *(short *)(piVar15 + 4) = (short)((uint)((int)*(short *)(iVar5 + 0x34) * 5) >> 8);
        sVar2 = (short)((uint)((int)*(short *)(iVar5 + 0x40) * 5) >> 8);
      }

	  // if wumpa is 10
	  else
	  {
        *(short *)(piVar15 + 4) = (short)((int)*(short *)(iVar5 + 0x34) * 3 >> 7);
        sVar2 = *(short *)(iVar5 + 0x40);
        *(ushort *)((int)piVar15 + 0x16) = *(ushort *)((int)piVar15 + 0x16) | 1;
        sVar2 = (short)((int)sVar2 * 3 >> 7);
      }
LAB_800659ec:
      *(short *)(piVar15 + 5) = sVar2;
    }
    *(undefined2 *)(piVar15 + 8) = 0x3c;
    *(undefined2 *)((int)piVar15 + 0x22) = 0;

	// record the driver who shot the tracker
    piVar15[2] = *(int *)(param_1 + 0x1c);

    break;

  // if weapon ID is TNT / Nitro
  case 3:

	// If number of wumpa fruit is less than 10
	if (*(char *)(param_1 + 0x30) < '\n')
	{
      uVar7 = 0x27;

	  // DAT_8008d64c
	  // "tnt1"
      pcVar10 = &DAT_8008d64c;
    }

	// if you have 10 wumpa fruit
    else
	{
      uVar7 = 6;

	  // s_nitro1_8008d644
	  // "nitro1"
      pcVar10 = s_nitro1_8008d644;
    }

	// make TNT or Nitro thread
	// 0x300 flag = SmallStackPool
	// 4 = "mine" thread bucket
    iVar5 = FUN_800309a4(uVar7,pcVar10,0x300,4,&DAT_800acb60,0x2c,0);

	// get instance from driver
    iVar8 = *(int *)(param_1 + 0x1c);

	// copy rotation from driver, into weapon
    uVar7 = *(undefined4 *)(iVar8 + 0x34);
    local_48 = *(undefined4 *)(iVar8 + 0x38);
    uVar13 = *(undefined4 *)(iVar8 + 0x3c);
    *(undefined4 *)(iVar5 + 0x30) = *(undefined4 *)(iVar8 + 0x30);
    *(undefined4 *)(iVar5 + 0x34) = uVar7;
    *(undefined4 *)(iVar5 + 0x38) = local_48;
    *(undefined4 *)(iVar5 + 0x3c) = uVar13;

	// get position from player
    uVar7 = *(undefined4 *)(iVar8 + 0x44);
    local_48 = *(undefined4 *)(iVar8 + 0x48);
    uVar13 = *(undefined4 *)(iVar8 + 0x4c);

	// one more rotation variable
    *(undefined4 *)(iVar5 + 0x40) = *(undefined4 *)(iVar8 + 0x40);

	// set position of weapon
    *(undefined4 *)(iVar5 + 0x44) = uVar7;
    *(undefined4 *)(iVar5 + 0x48) = local_48;
    *(undefined4 *)(iVar5 + 0x4c) = uVar13;

	// set scale (x, y, z)
    *(undefined2 *)(iVar5 + 0x1c) = 0;
    *(undefined2 *)(iVar5 + 0x1e) = 0;
    *(undefined2 *)(iVar5 + 0x20) = 0;

	// set funcOnDestroy to remove instance from instance pool
    *(undefined4 *)(*(int *)(iVar5 + 0x6c) + 0x24) = 0x80041dfc

	// set onCollide function
    *(undefined4 *)(*(int *)(iVar5 + 0x6c) + 0x28) = 0x800ac4b8;

	// Play potion sound,
	// volume depends on disatnce
	// between instance and nearest camera110
    FUN_8002f0dc(0x52,iVar5);

	// If this is human and not AI
    if ((*(uint *)(param_1 + 0x2c8) & 0x100000) == 0)
	{
	  // Make driver talk
      FUN_8002cbe8(0xf,(int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)],0x10);
    }

	// instance -> thread -> object
    puVar16 = *(undefined4 **)(*(int *)(iVar5 + 0x6c) + 0x30);

	// save the driver that dropped the weapon
    puVar16[1] = *(undefined4 *)(param_1 + 0x1c);

    *(undefined2 *)(puVar16 + 3) = 0;
    *(undefined2 *)((int)puVar16 + 0xe) = 0;
    *(undefined2 *)(puVar16 + 4) = 0;
    *(undefined2 *)(puVar16 + 9) = 10;
    *(undefined2 *)(puVar16 + 5) = 0;
    *(undefined2 *)((int)puVar16 + 0x26) = 0;
    *puVar16 = 0;
    puVar16[2] = 0;
    *(undefined2 *)(puVar16 + 10) = 0;

	// RB_MinePool_Add
	FUN_800ac13c(puVar16);

	// Weapon_Potion_Throw
    FUN_800652c8(puVar16,iVar5,param_3);

	// instancePos - Y
    local_40 = *(undefined2 *)(iVar5 + 0x44);
    local_3e = *(short *)(iVar5 + 0x48) + -400;
    local_3c = *(undefined2 *)(iVar5 + 0x4c);

	// instancePos + Y
    local_38 = *(undefined2 *)(iVar5 + 0x44);
    local_36 = *(short *)(iVar5 + 0x48) + 0x40;
    local_34 = *(undefined2 *)(iVar5 + 0x4c);

	// ground quadblock flags
    DAT_1f80012c = 0x1000;

	DAT_1f800130 = 0;
	
	// low-LOD collision (2 triangles)
    DAT_1f80012a = 1;

	// if number of screens is less than 3
    if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 3) 
	{
	  // high-LOD collision (8 triangles)
      DAT_1f80012a = 3;
    }

    DAT_1f800134 = **(undefined4 **)(PTR_DAT_8008d2ac + 0x160);

	// check for collision in BSP
    FUN_8001eb0c(&local_40,&local_38,&DAT_1f800108,0x40);

	if (DAT_1f80014a == 0) {
      puVar16[2] = 0;
    }
    else {
      DAT_1f800114 = *(ushort *)(*(int *)(iVar5 + 0x18) + 0x10) | 0x8000;

	  // RB_Hazard_LevInstColl
      FUN_800ad9ac(&DAT_1f800108,*(undefined4 *)(iVar5 + 0x6c));

	  sVar2 = *(short *)(*(int *)(DAT_1f800150 + 0x1c) + 0x3c);

	  if ((sVar2 == 7) || (sVar2 == 8)) {
        puVar16[2] = *(undefined4 *)(*(int *)(DAT_1f800150 + 0x1c) + 0x2c);
      }
      else
	  {
		// RB_GenericMine_OnDestroy
        FUN_800ad250(*(undefined4 *)(iVar5 + 0x6c),iVar5,puVar16);
      }
	  
	  // low-LOD collision (2 triangles)
      DAT_1f80012a = 0;

	  // check for collision in BSP
      FUN_8001eb0c(&local_40,&local_38,&DAT_1f800108,0);
    }

	// RB_MakeInstanceReflective
    FUN_800abab0(&DAT_1f800108,iVar5);

	// if quadblock was not found
	if (DAT_1f800146 == 0)
	{
      *(undefined2 *)((int)puVar16 + 0x12) = *(undefined2 *)(iVar5 + 0x48);

	  local_40 = 0;
      local_3e = 0x1000;
      local_3c = 0;

	  sVar2 = *(short *)(param_1 + 0x39a);
      puVar11 = &local_40;
    }

	// if quadblock was found
    else {
      *(undefined2 *)((int)puVar16 + 0x12) = DAT_1f800124._2_2_;
      sVar2 = *(short *)(param_1 + 0x39a);
      puVar11 = &DAT_1f800178;
    }

	// Rot_AxisAngle
	// generate TNT/Nitro rotation matrix,
	// with driver rotation, and quadblock rotation
    FUN_8005f89c(iVar5 + 0x30,puVar11,(int)sVar2);

	*(int *)(param_1 + 0x20) = iVar5;
    *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) | 0x80000000;

	if (param_3 == 0)
	{
	  // RB_Follower_Init
      FUN_800b6f00(param_1,*(undefined4 *)(iVar5 + 0x6c));
    }

	break;

  // if Weapon ID is beaker
  case 4:

    // if you have less than 10 wumpa fruit
    if (*(char *)(param_1 + 0x30) < '\n')
	{
	  // "beaker1"
	  // 0x47 = green beaker

	  // 0x300 flag = SmallStackPool
	  // 4 = "mine" thread bucket
      iVar5 = FUN_800309a4(0x47,s_beaker1_8008d654,0x300,4,&FUN_800acb60,0x2c,0);

	  // if thread failed, then quit
      if (iVar5 == 0) {
        return;
      }

	  // instance -> thread -> object
      iVar8 = *(int *)(*(int *)(iVar5 + 0x6c) + 0x30);

	  // green beaker, not red
      *(undefined2 *)(iVar8 + 0x28) = 0;
    }

	// if you have 10 wumpa fruit
    else
	{
	  // "beaker1"
	  // 0x46 = red beaker

	  // 0x300 flag = SmallStackPool
	  // 4 = "mine" thread bucket
      iVar5 = FUN_800309a4(0x46,s_beaker1_8008d654,0x300,4,&DAT_800acb60,0x2c,0);

	  // instance->thread->object
      iVar8 = *(int *)(*(int *)(iVar5 + 0x6c) + 0x30);

	  // red beaker
      *(undefined2 *)(iVar8 + 0x28) = 1;
    }

	// get instance from player
    iVar14 = *(int *)(param_1 + 0x1c);

	// get player rotation
    uVar7 = *(undefined4 *)(iVar14 + 0x34);
    local_48 = *(undefined4 *)(iVar14 + 0x38);
    uVar13 = *(undefined4 *)(iVar14 + 0x3c);

	// set potion rotation to player rotation (4 of 5)
    *(undefined4 *)(iVar5 + 0x30) = *(undefined4 *)(iVar14 + 0x30);
    *(undefined4 *)(iVar5 + 0x34) = uVar7;
    *(undefined4 *)(iVar5 + 0x38) = local_48;
    *(undefined4 *)(iVar5 + 0x3c) = uVar13;

	// get player position
    uVar7 = *(undefined4 *)(iVar14 + 0x44);
    local_48 = *(undefined4 *)(iVar14 + 0x48);
    uVar13 = *(undefined4 *)(iVar14 + 0x4c);

	// rotation (last of 5)
    *(undefined4 *)(iVar5 + 0x40) = *(undefined4 *)(iVar14 + 0x40);

	// set potion position to player position
    *(undefined4 *)(iVar5 + 0x44) = uVar7;
    *(undefined4 *)(iVar5 + 0x48) = local_48;
    *(undefined4 *)(iVar5 + 0x4c) = uVar13;

	// beakerInst -> model -> header
    iVar14 = *(int *)(*(int *)(iVar5 + 0x18) + 0x14);

	// header -> flag: always face camera
    *(ushort *)(iVar14 + 0x16) = *(ushort *)(iVar14 + 0x16) | 2;

	// set funcOnDestroy to remove instance from instance pool
    *(undefined4 *)(*(int *)(iVar5 + 0x6c) + 0x24) = 0x80041dfc;

	// set funcOnCollide
	*(undefined4 *)(*(int *)(iVar5 + 0x6c) + 0x28) = 0x800ac4b8;

	// get instance of driver
	uVar7 = *(undefined4 *)(param_1 + 0x1c);

    *(undefined2 *)(iVar8 + 0x24) = 10;
    *(undefined2 *)(iVar8 + 0x14) = 0;
    *(undefined4 *)(iVar8 + 8) = 0;

	// save the driver who placed the weapon
    *(undefined4 *)(iVar8 + 4) = uVar7;

	// Play potion sound,
	// volume depends on distance
	// between instance and nearest camera110
    FUN_8002f0dc(0x52,iVar5);

	// If this is human and not AI
    if ((*(uint *)(param_1 + 0x2c8) & 0x100000) == 0)
	{
	  // Make driver talk
      FUN_8002cbe8(0xf,(int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)],0x10);
    }

	// RB_MinePool_Add
    FUN_800ac13c(iVar8);

	// If you hold Up on D-Pad
    if ((*(uint *)(PTR_DAT_8008d2b0 + (uint)*(byte *)(param_1 + 0x4a) * 0x50 + 0x10) & 1) != 0)
	{
	  // Shoot potion forward
      param_3 = param_3 | 4;
    }

	// Weapon_Potion_Throw
    uVar6 = FUN_800652c8(iVar8,iVar5,param_3);

	// if mine is not "thrown", just "dropped"
    if ((uVar6 & 0xffff) == 0)
	{
	  // set scale to zero, thread will make it grow
      *(undefined2 *)(iVar5 + 0x1c) = 0;
      *(undefined2 *)(iVar5 + 0x1e) = 0;
      *(undefined2 *)(iVar5 + 0x20) = 0;

      *(undefined2 *)(iVar8 + 0xc) = 0;
      *(undefined2 *)(iVar8 + 0xe) = 0;
      *(undefined2 *)(iVar8 + 0x10) = 0;

	  // hit top
      local_30 = *(undefined2 *)(iVar5 + 0x44);
      local_2e = *(short *)(iVar5 + 0x48) + -400;
      local_2c = *(undefined2 *)(iVar5 + 0x4c);

	  // hit bottom
      local_28 = *(undefined2 *)(iVar5 + 0x44);
      local_26 = *(short *)(iVar5 + 0x48) + 0x40;
      local_24 = *(undefined2 *)(iVar5 + 0x4c);

	  // ground quadblock flags
      DAT_1f80012c = 0x1000;

	  DAT_1f800130 = 0;
	  
	  // low-LOD collision (2 triangles)
      DAT_1f80012a = 1;

	  // if number of screens is less than 3
      if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 3) 
	  {
		// high-LOD collision (8 triangles)
        DAT_1f80012a = 3;
      }

      DAT_1f800134 = **(undefined4 **)(PTR_DAT_8008d2ac + 0x160);

	  // COLL_SearchTree_NoCallback
	  FUN_8001eb0c(&local_30,&local_28,&DAT_1f800108,0x40);

      if (DAT_1f80014a == 0) {
        *(undefined4 *)(iVar8 + 8) = 0;
      }
      else {
        DAT_1f800114 = *(ushort *)(*(int *)(iVar5 + 0x18) + 0x10);

		// RB_Hazard_LevInstColl
        FUN_800ad9ac(&DAT_1f800108,*(undefined4 *)(iVar5 + 0x6c));

		sVar2 = *(short *)(*(int *)(DAT_1f800150 + 0x1c) + 0x3c);
        if ((sVar2 == 7) || (sVar2 == 8)) {
          *(undefined4 *)(iVar8 + 8) = *(undefined4 *)(*(int *)(DAT_1f800150 + 0x1c) + 0x2c);
        }
        else
		{
		  // RB_GenericMine_OnDestroy
          FUN_800ad250(*(undefined4 *)(iVar5 + 0x6c),iVar5,iVar8);
        }
		
		// low-LOD collision (2 triangles)
        DAT_1f80012a = 0;

		// COLL_SearchTree_NoCallback
        FUN_8001eb0c(&local_30,&local_28,&DAT_1f800108,0);
      }

	  // RB_MakeInstanceReflective
      FUN_800abab0(&DAT_1f800108,iVar5);

	  // if no collision,
	  if (DAT_1f800146 == 0)
	  {
        *(undefined2 *)(iVar8 + 0x12) = *(undefined2 *)(iVar5 + 0x48);

		// rotate on Y axis
		local_30 = 0;
        local_2e = 0x1000;
        local_2c = 0;

		// driver rotation
		sVar2 = *(short *)(param_1 + 0x39a);

		puVar11 = &local_30;
      }

	  else
	  {
        *(undefined2 *)(iVar8 + 0x12) = DAT_1f800124._2_2_;

		// driver rotation
		sVar2 = *(short *)(param_1 + 0x39a);

		// rotate on slanted axis from quadblock
		puVar11 = &DAT_1f800178;
      }

	  // Rot_AxisAngle
	  // rotation matrix of beaker, given driver rotation and quadblock
	  FUN_8005f89c(iVar5 + 0x30,puVar11,(int)sVar2);

	  // RB_Follower_Init
      FUN_800b6f00(param_1,*(undefined4 *)(iVar5 + 0x6c));

      *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) | 0x80000000;
    }
    break;

  // if weapon ID is Shield Bubble
  case 6:

	// make thread and instance, function returns instance
	// 0x200 flag = MediumStackPool
	// 0xd = "other" thread bucket
    iVar5 = FUN_800309a4(0x5a,"shielddark",0x200,0xd,&DAT_800b0454,0x18,

										// driver -> instance -> thread
                         *(undefined4 *)(*(int *)(param_1 + 0x1c) + 0x6c));

	// set scale (x, y, z)
    *(undefined2 *)(iVar5 + 0x1c) = 0x700;
    *(undefined2 *)(iVar5 + 0x1e) = 0x700;
    *(undefined2 *)(iVar5 + 0x20) = 0x700;

	// set funcOnDestroy to remove instance from instance pool
    *(undefined4 *)(*(int *)(iVar5 + 0x6c) + 0x24) = 0x80041dfc;

	// OtherFX_Play Activate Shield sound
    FUN_80028468(0x57,1);

	// get object created with thread
    puVar16 = *(undefined4 **)(*(int *)(iVar5 + 0x6c) + 0x30);

	// if number of wumpa is less than 10
    if (*(char *)(param_1 + 0x30) < '\n')
	{
	  // Green shield model pointer (in instance)
      uVar7 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x22d8);
    }

	// if number of wumpa is 10
	else
	{
	  // Blue shield model pointer (in instance)
      uVar7 = *(undefined4 *)(PTR_DAT_8008d2ac + 0x22b8);
    }

	// s_shield_8008d63c
	// "shield"

	// INSTANCE_Birth3D -- ptrModel, name, thread
	uVar7 = FUN_8003086c(uVar7,s_shield_8008d63c);

	// give instance to object
	puVar16[2] = uVar7;

    puVar12 = PTR_DAT_8008d2ac;

	// scale (x, y, z)
    *(undefined2 *)(puVar16[2] + 0x1c) = 0x700;
    *(undefined2 *)(puVar16[2] + 0x1e) = 0x700;
    *(undefined2 *)(puVar16[2] + 0x20) = 0x700;

	// INSTANCE_Birth3D -- ptrModel, name, thread
    iVar8 = FUN_8003086c(*(undefined4 *)(puVar12 + 0x22d4),"highlight",*(undefined4 *)(iVar5 + 0x6c));

	// give instance to object
	puVar16[3] = iVar8;

	// scale (x, y, z)
    *(undefined2 *)(iVar8 + 0x1c) = 0x700;
    *(undefined2 *)(puVar16[3] + 0x1e) = 0x700;
    *(undefined2 *)(puVar16[3] + 0x20) = 0x700;

    *(undefined2 *)((int)puVar16 + 6) = 0;
    *(undefined2 *)(puVar16 + 4) = 0;
    *(undefined2 *)((int)puVar16 + 0x12) = 0xc00;
    *(undefined2 *)(puVar16 + 5) = 0;
    *(undefined2 *)((int)puVar16 + 0x16) = 0;

	// if wumpa < 10
    if (*(char *)(param_1 + 0x30) < '\n')
	{
	  // 12 seconds,
	  // 12 * 30 * 32
      *(undefined2 *)(puVar16 + 1) = 0x2d00;
    }

	// if weapon is 10
    else
	{
	  // use a flag to disable the countdown timer (in 231)
      *(ushort *)((int)puVar16 + 6) = *(ushort *)((int)puVar16 + 6) | 4;
    }

    *(undefined2 *)(iVar5 + 0x22) = 0x400;
    *puVar16 = 0;
    *(int *)(param_1 + 0x14) = iVar5;
    break;

  // if weapon ID is mask
  case 7:
    // Weapon_Mask_UseWeapon
    FUN_80064c38(param_1,1);
    break;

  // if weapon ID is clock
  case 8:
    *(char *)(param_1 + 0x558) = *(char *)(param_1 + 0x558) + '\x01';

	// OtherFX_Play
    FUN_80028468(0x44);

	// loop iteration counter
    iVar5 = 0;

	// If this is human and not AI
    if ((*(uint *)(param_1 + 0x2c8) & 0x100000) == 0)
	{
	  // Make driver talk
      FUN_8002cbe8(0xe,(int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)],0x10);
      iVar5 = 0;
    }

	// for iVar5 = 0; iVar5 < 8; iVar5++
	do
	{
	  // pointer incrementer, for each player structure
      iVar14 = iVar5 * 4;

      *(undefined *)(*(int *)(PTR_DAT_8008d2ac + iVar14 + 0x24ec) + 0x367) = 4;

	  // get pointer to each player structure
      iVar8 = *(int *)(PTR_DAT_8008d2ac + iVar14 + 0x24ec);

	  // if pointer is not nullptr
      if (iVar8 != 0)
	  {
		// do not put weapon effect on the player that used it
        if (iVar8 == param_1) {
          *(undefined *)(param_1 + 0x45) = 0x1e;
        }
        else
		{
		  // RB_Hazard_HurtDriver (spinout)
          iVar8 = FUN_800ac1b0(iVar8,1,0,0);

          if (iVar8 != 0)
		  {
			// if wumpa < 10
            if (*(char *)(param_1 + 0x30) < '\n')
			{
			  // little time
              *(undefined2 *)(*(int *)(PTR_DAT_8008d2ac + iVar14 + 0x24ec) + 0xc) = 0x1e00;
            }

			// if wumpa is 10
            else
			{
			  // long time
              *(undefined2 *)(*(int *)(PTR_DAT_8008d2ac + iVar14 + 0x24ec) + 0xc) = 0x2d00;
            }
          }
        }
      }

	  // increment loop counter
      iVar5 = iVar5 + 1;
    } while (iVar5 < 8);
    break;

  // if weapon ID is warp ball
  case 9:

    // both controller vibration
    FUN_80026440(param_1,8,0);
    FUN_800264c0(param_1,8,0x7f);

	// 0x200 flag = MediumStackPool
	// 6 = "tracking" thread bucket
    iVar5 = FUN_800309a4(0x36,"warpball",0x200,6,&DAT_800aef9c,0x58,0);

	// copy position from player to warpball
    *(int *)(iVar5 + 0x44) = *(int *)(param_1 + 0x2d4) >> 8;
    *(int *)(iVar5 + 0x48) = *(int *)(param_1 + 0x2d8) >> 8;
    iVar8 = *(int *)(param_1 + 0x2dc);

	// set scale
    *(undefined4 *)(iVar5 + 0x30) = 0x1000;
    *(undefined4 *)(iVar5 + 0x38) = 0x1000;
    *(undefined2 *)(iVar5 + 0x40) = 0x1000;

	// one more position variable
    *(int *)(iVar5 + 0x4c) = iVar8 >> 8;

	// rotation variables
    *(undefined4 *)(iVar5 + 0x34) = 0;
    *(undefined4 *)(iVar5 + 0x3c) = 0;

	// set funcOnDestroy to remove instance from instance pool
    *(undefined4 *)(*(int *)(iVar5 + 0x6c) + 0x24) = 0x80041dfc;

	// Play warpball spawn sound,
	// volume depends on distance
	// between instance and nearest camera110
    FUN_8002f0dc(0x4d,iVar5);

	// If this is human and not AI
    if ((*(uint *)(param_1 + 0x2c8) & 0x100000) == 0)
	{
	  // Make driver talk
      FUN_8002cbe8(0xc,(int)(short)(&DAT_80086e84)[*(byte *)(param_1 + 0x4a)],0x10);
    }

	// warpball instance -> thread -> object
    piVar15 = *(int **)(*(int *)(iVar5 + 0x6c) + 0x30);

    piVar15[1] = param_1;

	// set animation to zero
    *(undefined2 *)((int)piVar15 + 0x52) = 0;

    piVar15[0x10] = 0;

	// by default, chase nobody
    iVar8 = 0;

	// If player is not in first place
    if ((int)*(short *)(param_1 + 0x482) != 0)
	{
	  // start chasing the player in front of you
      iVar8 = *(int *)(PTR_DAT_8008d2ac + ((int)*(short *)(param_1 + 0x482) + -1) * 4 + 0x250c);
    }

	// store target driver in warpball object
    *piVar15 = iVar8;

	// RB_Warpball_SeekDriver
    FUN_800aece0(piVar15,(uint)*(byte *)(param_1 + 0x495),param_1);

    iVar8 = *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c);
    *(byte *)((int)piVar15 + 0x45) = *(byte *)(piVar15 + 0x11);

	// if wumpa < 10
    *(undefined2 *)((int)piVar15 + 0x16) = 0;

    piVar15[0xb] = 0;
    piVar15[0xf] = iVar8 + (uint)*(byte *)(piVar15 + 0x11) * 0xc;

	// if 9 < wumpa
	// if wumpa is 10
	if ('\t' < *(char *)(param_1 + 0x30))
	{
	  // use flag to remember that 10 wumpa were used
      *(ushort *)((int)piVar15 + 0x16) = *(ushort *)((int)piVar15 + 0x16) | 1;
    }

	*(ushort *)((int)piVar15 + 0x16) = *(ushort *)((int)piVar15 + 0x16) | 8;
    piVar15[0xd] = 1 << ((uint)*(byte *)(param_1 + 0x4a) & 0x1f);

	// if driver is in first
	if (*(short *)(param_1 + 0x482) == 0)
	{
	  // warp ball will not chase any driver
      *piVar15 = 0;
    }

	// if driver is not in first
    else
	{
	  // Find a target driver to chase

	  // piVar15 is WarpBall object,
	  // iVar5 is WarpBall instance
	  
	  // RB_Warpball_GetDriverTarget
      iVar5 = FUN_800ae7dc(piVar15,iVar5);

	  // store pointer to driver that will be chased
	  *piVar15 = iVar5;
    }

	// if driver is in first (again?)
    if (*(short *)(param_1 + 0x482) == 0)
	{
	  // warp ball will not chase any driver
      *piVar15 = 0;
    }

	// if driver is being chased
    if (*piVar15 != 0)
	{
	  // RB_Warpball_SetTargetDriver
      FUN_800aeaac(piVar15);
    }

    if ((*(ushort *)((int)piVar15 + 0x16) & 4) == 0)
	{
	  // RB_Warpball_Start
      FUN_800ae778(piVar15);
    }
    else {
      *(ushort *)((int)piVar15 + 0x16) = *(ushort *)((int)piVar15 + 0x16) & 0xfff7;
    }

	// RB_Warpball_NewPathNode
    iVar5 = FUN_800ae668(piVar15[0xf],*piVar15);
    piVar15[0x10] = iVar5;

	// clear audio pointer
    piVar15[9] = 0;

	// get rotation of driver inst
    sVar2 = *(short *)(*(int *)(param_1 + 0x1c) + 0x34);

	// velY
    *(undefined2 *)((int)piVar15 + 0x12) = 0;

	// velX
	*(short *)(piVar15 + 4) = (short)((uint)((int)sVar2 * 7) >> 8);

	// get rotation of driver inst
	sVar2 = *(short *)(*(int *)(param_1 + 0x1c) + 0x40);

	*(undefined2 *)(piVar15 + 8) = 10;

	// velZ
	*(short *)(piVar15 + 5) = (short)((uint)((int)sVar2 * 7) >> 8);

	// gGT
	puVar12 = PTR_DAT_8008d2ac;

	// rotation
	*(undefined2 *)((int)piVar15 + 0x1a) = *(undefined2 *)(param_1 + 0x39a);

	// instance who shot the warpball
	piVar15[2] = *(int *)(param_1 + 0x1c);

	// Create instance in particle pool
    iVar5 = FUN_80040308(0,*(undefined4 *)(puVar12 + 0x2114),&DAT_80089c04);

	// offset 0xC
    piVar15[3] = iVar5;

    if (iVar5 != 0) {
      *(undefined *)(iVar5 + 0x18) = 0xfa;
    }
    break;

  // if weapon ID is Invisibility
  case 0xc:

	// if not already invisible
    if (*(int *)(param_1 + 0x28) == 0)
	{
	  // backup instance flags before invisible
      *(undefined4 *)(param_1 + 0x2c) = *(undefined4 *)(*(int *)(param_1 + 0x1c) + 0x28);

	  // instance flags
	  *(uint *)(*(int *)(param_1 + 0x1c) + 0x28) =
           *(uint *)(*(int *)(param_1 + 0x1c) + 0x28) & 0xfff8ffff;

	  // instance flags
      *(uint *)(*(int *)(param_1 + 0x1c) + 0x28) =
           *(uint *)(*(int *)(param_1 + 0x1c) + 0x28) | 0x60000;

	  // OtherFX_Play
      FUN_80028468(0x61,1);
    }

	// if wumpa is 10
    uVar7 = 0x1e00;

	// if 9 < wumpa
	// if wumpa is 10
    if ('\t' < *(char *)(param_1 + 0x30)) {
      uVar7 = 0x2d00;
    }

	// set invisible timer
    *(undefined4 *)(param_1 + 0x28) = uVar7;

    break;

  // if weapn ID is Super Engine
  case 0xd:

	// if wumpa is less than 10
    if (*(char *)(param_1 + 0x30) < '\n')
	{
	  // Set super engine powerup timer
      *(undefined2 *)(param_1 + 0x38) = 0x1e00;
    }

	// if wumpa is 10
    else
	{
	  // Set super engine powerup timer
      *(undefined2 *)(param_1 + 0x38) = 0x2d00;
    }
  }
  return;
}


// Weapon_Shoot_OnCirclePress
void FUN_800666e4(int param_1)

{
  uint uVar1;

  if (*(byte *)(param_1 + 0x4ff) != 0)
  {
	// Player_ChangeState
    FUN_80064568(param_1,(uint)*(byte *)(param_1 + 0x4ff),*(undefined4 *)(param_1 + 0x500),
                 (uint)*(byte *)(param_1 + 0x504));
  }

  // If you want to fire a weapon
  if ((*(uint *)(param_1 + 0x2c8) & 0x8000) != 0)
  {
	// Remove the request to fire a weapon, since we will fire it now
    *(uint *)(param_1 + 0x2c8) = *(uint *)(param_1 + 0x2c8) & 0xffff7fff;

	// Set weapon to one bomb
    uVar1 = 1;

    if (
			// If this weapon is not 3 bombs
			(*(char *)(param_1 + 0x36) != '\n') &&

			(
				// Set weapon to missile
				uVar1 = 2,

				// if this weapon is not 3 missiles
				*(char *)(param_1 + 0x36) != '\v'
			)
		)
	{
	  // Set to the original weapon the player has
      uVar1 = (uint)*(byte *)(param_1 + 0x36);
    }

	// whaat???
	// If weapon is bomb, change to missile?????
    if (uVar1 == 1) {
      uVar1 = 2;
    }

	// Weapon_Shoot_Now (player)
    FUN_8006540c(param_1,uVar1,0);
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x80066894)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// Player_MaskGrab_FindDestPos (destination position)
void FUN_8006677c(int param_1,short *param_2)

{
  byte bVar1;
  short sVar2;
  undefined *puVar3;
  long lVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  short *psVar8;
  short *psVar9;

  puVar3 = PTR_DAT_8008d2ac;

  if (
		(
			// if no respawn positions are found in the LEV file
			(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x148) < 1) ||
			(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c) == 0)
		) ||

		// quadblock respawnIndex (0x3e)
		(*(char *)(param_2 + 0x1f) == -1))
  {
	// respawn driver on the last "valid" quadblock they touched

	// posX =
    *(int *)(param_1 + 0x2d4) =
	
		  // lev->mesh_info->ptrVertexArray[(Quadblock*)param_2->index[0]].pos[0]
         ((int)*(short *)((int)*param_2 * 0x10 +
                         *(int *)(**(int **)(PTR_DAT_8008d2ac + 0x160) + 0x10)) +
						 
		  // lev->mesh_info->ptrVertexArray[(Quadblock*)param_2->index[3]].pos[0]
         (int)*(short *)((int)param_2[3] * 0x10 +
                        *(int *)(**(int **)(PTR_DAT_8008d2ac + 0x160) + 0x10))) 
			
		  // midpoint between
		  * 0x80;
    
	// lev->mesh_info->ptrVertexArray
	iVar6 = *(int *)(**(int **)(puVar3 + 0x160) + 0x10);
	
	// posY = 
    *(int *)(param_1 + 0x2d8) =
	
		 // ptrVertexArray[(Quadblock*)param_2->index[0]].pos[1]
         ((int)*(short *)((int)*param_2 * 0x10 + iVar6 + 2) +
		 
		   // ptrVertexArray[(Quadblock*)param_2->index[3]].pos[1]
          (int)*(short *)((int)param_2[3] * 0x10 + iVar6 + 2) + 0x80) 
		  
		  // midpoint between
		  * 0x80;
		  
    iVar6 = *(int *)(**(int **)(puVar3 + 0x160) + 0x10);
	
	// posZ
    *(int *)(param_1 + 0x2dc) =
	
		  
		   // ptrVertexArray[(Quadblock*)param_2->index[0]].pos[2]
         ((int)*(short *)((int)*param_2 * 0x10 + iVar6 + 4) +
		 
		   // ptrVertexArray[(Quadblock*)param_2->index[3]].pos[2]
         (int)*(short *)((int)param_2[3] * 0x10 + iVar6 + 4)) 
		 
		 // midpiont between
		 * 0x80;
  }

  // if respawnIndex is not -1,
  // and respawn points exist on LEV
  else
  {
	// search BSP for valid quadblock near the point, and spawn there

	// thread offset 0x42?

	// a bunch of driver -> instance -> thread -> xxx
	DAT_1f80010e = *(undefined2 *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x42);
    _DAT_1f800110 = *(undefined4 *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x38);
    DAT_1f80011c._2_2_ = *(undefined2 *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x42);
    DAT_1f800120 = *(undefined4 *)(*(int *)(*(int *)(param_1 + 0x1c) + 0x6c) + 0x38);

	DAT_1f800134 = **(int **)(PTR_DAT_8008d2ac + 0x160);
    DAT_1f800130 = 0x4010;

	// ground quadblock flags
    DAT_1f80012c = 0x1000;

	// quadblock respawnIndex (0x3e)
	bVar1 = *(byte *)(param_2 + 0x1f);
	
	// lev -> respawn_points
    iVar6 = *(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c);
	
    *(undefined4 *)(param_1 + 0x490) = 0;
	
	// respawn data
    psVar8 = (short *)(iVar6 + (uint)bVar1 * 0xc);
	
    do {
      do {
		  
		// next respawn data after the one being spawned on
        psVar9 = (short *)(*(int *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0x14c) +
                          (uint)*(byte *)(psVar8 + 4) * 0xc);
		
		// posX
        *(int *)(param_1 + 0x2d4) = (int)*psVar8 << 8;
		
		// posY (+ offset for mask in air)
        *(int *)(param_1 + 0x2d8) = ((int)psVar8[1] + 0x80) * 0x100;
        
		// posZ
		sVar2 = psVar8[2];
        
		// rotX = 0 (not on slant)
		*(undefined2 *)(param_1 + 0x2ec) = 0;
        
		// posZ
		*(int *)(param_1 + 0x2dc) = (int)sVar2 << 8;
        
		// get rotY by comparing positions of cur respawn and next respawn
		lVar4 = ratan2((int)*psVar9 - (int)*psVar8,(int)psVar9[2] - (int)psVar8[2]);
        *(undefined2 *)(param_1 + 0x2ee) = (short)lVar4;
		
		// rotZ = 0 (not on slant)
        *(undefined2 *)(param_1 + 0x2f0) = 0;
        
		// build hitbox for driver
		DAT_1f800118._0_2_ = (short)((uint)*(undefined4 *)(param_1 + 0x2d4) >> 8);
        DAT_1f800118._2_2_ = (ushort)((uint)*(undefined4 *)(param_1 + 0x2d8) >> 8);
        DAT_1f80011c._0_2_ = (ushort)((uint)*(undefined4 *)(param_1 + 0x2dc) >> 8);
        DAT_1f800108 = (short)((uint)*(undefined4 *)(param_1 + 0x2d4) >> 8);
        DAT_1f80010a = (short)((uint)*(undefined4 *)(param_1 + 0x2d8) >> 8) - 0x100;
        
		// low-LOD collision (2 triangles)
		DAT_1f80012a = 0;
		
        DAT_1f80010c = (ushort)((uint)*(undefined4 *)(param_1 + 0x2dc) >> 8);

		// if number of screens is less than 3
        if ((byte)PTR_DAT_8008d2ac[0x1ca8] < 3) 
		{
		  // high-LOD collision (8 triangles)
          DAT_1f80012a = 2;
        }

        DAT_1f800146 = 0;
        DAT_1f800144 = 0;
        DAT_1f80018c = 0x1000;
        DAT_1f8002ac = 0;
        DAT_1f800138 = (short)DAT_1f800118;
        if (DAT_1f800108 < (short)DAT_1f800118) {
          DAT_1f800138 = DAT_1f800108;
        }
        DAT_1f80013a = DAT_1f800118._2_2_;
        if ((int)((uint)DAT_1f80010a << 0x10) < (int)((uint)DAT_1f800118._2_2_ << 0x10)) {
          DAT_1f80013a = DAT_1f80010a;
        }
        DAT_1f80013c = (ushort)DAT_1f80011c;
        if ((int)((uint)DAT_1f80010c << 0x10) < (int)((uint)(ushort)DAT_1f80011c << 0x10)) {
          DAT_1f80013c = DAT_1f80010c;
        }
        DAT_1f80013e = (short)DAT_1f800118;
        if ((short)DAT_1f800118 < DAT_1f800108) {
          DAT_1f80013e = DAT_1f800108;
        }
        DAT_1f800140 = DAT_1f800118._2_2_;
        if ((int)((uint)DAT_1f800118._2_2_ << 0x10) < (int)((uint)DAT_1f80010a << 0x10)) {
          DAT_1f800140 = DAT_1f80010a;
        }
        DAT_1f800142 = (ushort)DAT_1f80011c;
        if ((int)((uint)(ushort)DAT_1f80011c << 0x10) < (int)((uint)DAT_1f80010c << 0x10)) {
          DAT_1f800142 = DAT_1f80010c;
        }
        DAT_1f800124._0_2_ = DAT_1f800108;
        DAT_1f800124._2_2_ = DAT_1f80010a;
        DAT_1f800128 = DAT_1f80010c;

		// Search full BSP tree for COLL_SearchCallback_QuadBlocks_Graphics
        FUN_8001ebec(*(undefined4 *)(DAT_1f800134 + 0x18),&DAT_1f800138,FUN_8001f5f0,&DAT_1f800108);

		// cur respawn = next respawn
        psVar8 = psVar9;
		
		// loop again if no quadblock is found under the driver
      } while ((DAT_1f800146 == 0) || ((DAT_1f8002ac & 0x4000) != 0));

	  // pointer to first Player thread
      iVar6 = *(int *)(PTR_DAT_8008d2ac + 0x1b2c);

	  // if player does not exist, quit
      if (iVar6 == 0) break;

	  // loop through all players
      do
	  {
		// player object
        iVar7 = *(int *)(iVar6 + 0x30);

		// dont check for collision against yourself
        if (iVar7 != param_1) 
		{
		  // compare X
          iVar5 = *(int *)(param_1 + 0x2d4) - *(int *)(iVar7 + 0x2d4);
          
		  // absolute value
		  if (iVar5 < 0) {
            iVar5 = -iVar5;
          }
		  
		  // if distance too close, go to next respawn point
          if (iVar5 < 0x2000) break;
		  
		  // compare Z
          iVar7 = *(int *)(param_1 + 0x2dc) - *(int *)(iVar7 + 0x2dc);
		  
		  // absolute value
          if (iVar7 < 0) {
            iVar7 = -iVar7;
          }
		  
		  // if distance too close, go to next respawn point
          if (iVar7 < 0x2000) break;
        }

		// next player
        iVar6 = *(int *)(iVar6 + 0x10);

	  // if == 0, player does not spawn on top of another,
	  // else, check next driver
      } while (iVar6 != 0);
	 
	// if == 0, player does not spawn on top of another,
	// else, spawn player on the next respawn point
    } while (iVar6 != 0);
  }

  // CameraDC flag
  *(uint *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_1 + 0x4a) * 0xdc + 0x1508) =
       *(uint *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_1 + 0x4a) * 0xdc + 0x1508) | 1;
  return;
}


// Player_MaskGrab_Particles
void FUN_80066cb0(int param_1)

{
  int iVar1;
  int iVar2;

  iVar2 = 10;
  do
  {
	// Create instance in particle pool
    iVar1 = FUN_80040308(0,*(undefined4 *)(PTR_DAT_8008d2ac + 0x2114),&DAT_80089d90);

	iVar2 = iVar2 + -1;
    if (iVar1 == 0) {
      return;
    }

	// position variables
    *(int *)(iVar1 + 0x24) = *(int *)(iVar1 + 0x24) + *(int *)(param_1 + 0x2d4);
    *(int *)(iVar1 + 0x2c) = *(int *)(iVar1 + 0x2c) + *(int *)(param_1 + 0x2d8);
    *(int *)(iVar1 + 0x34) = *(int *)(iVar1 + 0x34) + *(int *)(param_1 + 0x2dc);

  } while (iVar2 != 0);
  return;
}


// Player_MaskGrab_Update
// param1 = thread, param2 = driver
void FUN_80066d4c(undefined4 param_1,int param_2)

{
  int iVar1;

  // NoInput timer = NoInput timer - elapsed milliseconds per frame, ~32
  iVar1 = (uint)*(ushort *)(param_2 + 0x400) - (uint)*(ushort *)(PTR_DAT_8008d2ac + 0x1d04);
  *(undefined2 *)(param_2 + 0x400) = (short)iVar1;

  // if negative
  if (iVar1 * 0x10000 < 0)
  {
	// set to zero
    *(undefined2 *)(param_2 + 0x400) = 0;
  }

  // when input is allowed
  if (*(short *)(param_2 + 0x400) == 0)
  {
    iVar1 = *(int *)(param_2 + 0x580);
    if (iVar1 != 0) {
      *(ushort *)(iVar1 + 4) = *(ushort *)(iVar1 + 4) & 0xfffe;
      *(undefined2 *)(*(int *)(param_2 + 0x580) + 0x12) = 0x1000;
    }

	// CameraDC flag
    *(uint *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_2 + 0x4a) * 0xdc + 0x1508) =
         *(uint *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_2 + 0x4a) * 0xdc + 0x1508) | 8;

	// Player_MaskGrab_FindDestPos
	// driver, and quadblock (last valid)
    FUN_8006677c(param_2,*(undefined4 *)(param_2 + 0x354));

	// Driver_TeleportSelf (back onto track)
    FUN_80057c8c(param_2,0,0x80);

	// Player_EngineRevving_Init
    FUN_80067f4c(param_1,param_2);
  }
  return;
}

// Player_MaskGrab_Input
// param1 = thread, param2 = driver
void FUN_80066e3c(undefined4 param_1,int param_2)

{
  // Player_Driving_Input
  FUN_8006181c(param_1, param_2);

  // reset base speed
  *(undefined2 *)(param_2 + 0x39e) = 0;

  //reset Jump buffer Timer
  *(undefined2 *)(param_2 + 0x3f0) = 0;

  // reset base speed (again?)
  *(undefined2 *)(param_2 + 0x39e) = 0;

  // reset "basic" speed
  *(undefined2 *)(param_2 + 0x39c) = 0;

  // reset turning state
  *(undefined *)(param_2 + 0x4b) = 0;

  *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) & 0xfffdffdb | 8;
  return;
}

// Player_MaskGrab_Animate
// param1 = thread, param2 = driver
void FUN_80066e8c(int param_1,int param_2)
{
  char cVar1;
  short sVar2;
  ushort uVar3;
  undefined2 uVar4;
  undefined4 uVar5;
  int iVar6;

  // get instance from thread
  iVar6 = *(int *)(param_1 + 0x34);

  // if driver touched ground before mask grab
  if (*(char *)(param_2 + 0x58d) == '\0') {

	//reset Kart emote
    *(undefined *)(param_2 + 0x4c) = 0;

	//reset Kart emote Frame
    *(undefined *)(param_2 + 0x4d) = 0;

	// set animation
    *(undefined *)(iVar6 + 0x52) = 0;

	// get number of frames in animation
    uVar5 = FUN_8005b0f4(iVar6,0);

    uVar4 = FUN_8005b0c4(0,uVar5);

    *(undefined2 *)(iVar6 + 0x54) = uVar4;
    *(undefined2 *)(param_2 + 0x368) = *(undefined2 *)(param_2 + 0x584);
    *(undefined2 *)(param_2 + 0x36a) = *(undefined2 *)(param_2 + 0x586);
    *(undefined2 *)(param_2 + 0x36c) = *(undefined2 *)(param_2 + 0x588);
  }

  // if driver did not touch ground (and is falling)
  else
  {
    if (
			// if whistle sound has not played
			(*(char *)(param_2 + 0x58f) == '\0') &&

			(*(short *)(param_2 + 0x400) < 0x3c0)
		)
	{
	  // OtherFX_Play "falling" sound, like a whistle
      FUN_80028468(0x55,1);

	  // whistle sound has played
      *(undefined *)(param_2 + 0x58f) = 1;
    }

    //Kart emote = Crashing
    *(undefined *)(param_2 + 0x4c) = 4;

	if (*(short *)(param_2 + 0x58a) < 3)
	{
      cVar1 = '\a';
    }

	else {
      cVar1 = *(char *)(param_2 + 0x58a) + '\x05';
    }
    //Crashing frame = cVar1
    *(char *)(param_2 + 0x4d) = cVar1;

	// change animation
    *(undefined *)(iVar6 + 0x52) = 2;

    sVar2 = 7;
    if (2 < *(short *)(param_2 + 0x58a)) {
      sVar2 = *(short *)(param_2 + 0x58a) + 5;
    }
    *(short *)(iVar6 + 0x54) = sVar2;
    sVar2 = *(short *)(param_2 + 0x58a) + 1;
    *(short *)(param_2 + 0x58a) = sVar2;
    if (7 < sVar2) {
      *(undefined2 *)(param_2 + 0x58a) = 7;
    }
    if (*(short *)(param_2 + 0x400) < 0x510) {
    	//Kart emote = Crashing
      *(undefined *)(param_2 + 0x4c) = 4;
      //Kart emote Frame = 12
      *(undefined *)(param_2 + 0x4d) = 0xc;

	  // set animation
      *(undefined *)(iVar6 + 0x52) = 2;

	  // set animation frame
      *(undefined2 *)(iVar6 + 0x54) = 0xc;

      if (*(short *)(param_2 + 0x400) < 0x3c1) {
        uVar3 = *(short *)(param_2 + 0x40c) - 800;
        *(ushort *)(param_2 + 0x40c) = uVar3;
        if ((int)((uint)uVar3 << 0x10) < 0) {
          *(undefined2 *)(param_2 + 0x40c) = 0;
        }
      }
      else 
	  {
		// if particles are not spawned
        if (*(char *)(param_2 + 0x58c) == '\0')
		{
		  // Player_MaskGrab_Particles
          FUN_80066cb0(param_2);

		  // now they are spawned
          *(undefined *)(param_2 + 0x58c) = 1;
        }
        sVar2 = *(short *)(param_2 + 0x40c) + 0x2d0;
        *(short *)(param_2 + 0x40c) = sVar2;
        if (8000 < sVar2) {
          *(undefined2 *)(param_2 + 0x40c) = 8000;
        }
      }
    }
    else {
    	//reset Speed and Speed Approximate
      *(undefined2 *)(param_2 + 0x38c) = 0;
      *(undefined2 *)(param_2 + 0x38e) = 0;

      //position backups
      *(undefined4 *)(param_2 + 0x2d4) = *(undefined4 *)(param_2 + 0x2e0);
      *(undefined4 *)(param_2 + 0x2d8) = *(undefined4 *)(param_2 + 0x2e4);
      *(undefined4 *)(param_2 + 0x2dc) = *(undefined4 *)(param_2 + 0x2e8);
    }
  }
  if (*(int *)(param_2 + 0x580) != 0) {
    *(undefined2 *)(*(int *)(param_2 + 0x580) + 6) = 0x1e00;
    if (*(short *)(param_2 + 0x400) < 0x3c1) {
      if (*(char *)(param_2 + 0x58e) == '\0') {
        *(short *)(*(int *)(param_2 + 0x580) + 0xe) =
														// elapsed milliseconds per frame, ~32
             *(short *)(*(int *)(param_2 + 0x580) + 0xe) - *(short *)(PTR_DAT_8008d2ac + 0x1d04);
      }
      else
	  {
				// elapsed milliseconds per frame, ~32
        iVar6 = *(int *)(PTR_DAT_8008d2ac + 0x1d04);

        *(undefined2 *)(param_2 + 0x38c) = 0;
        iVar6 = *(int *)(param_2 + 0x2d8) + iVar6 * 0x80;
        *(int *)(param_2 + 0x2d8) = iVar6;
        *(int *)(param_2 + 0x2e4) = iVar6;
      }
      *(undefined2 *)(*(int *)(param_2 + 0x580) + 0x10) =
           (short)((uint)*(undefined4 *)(param_2 + 0x2dc) >> 8);
      if ((int)*(short *)(*(int *)(param_2 + 0x580) + 0xe) < *(int *)(param_2 + 0x2d8) >> 8) {
        *(undefined2 *)(*(int *)(param_2 + 0x580) + 0xe) =
             (short)((uint)*(int *)(param_2 + 0x2d8) >> 8);
        *(undefined *)(param_2 + 0x58e) = 1;
      }
      *(undefined2 *)(*(int *)(param_2 + 0x580) + 0xc) =
           (short)((uint)*(undefined4 *)(param_2 + 0x2d4) >> 8);
      if ((int)*(short *)(param_2 + 0x400) < 0x2d1) {
        *(undefined2 *)(*(int *)(param_2 + 0x580) + 0x12) = 0x1000;
      }
      else {
        *(undefined2 *)(*(int *)(param_2 + 0x580) + 0x12) =
             (short)(((0x3c0 - (int)*(short *)(param_2 + 0x400)) * 0x1000) / 0xf0);
      }
    }
    else {
      *(undefined2 *)(*(int *)(param_2 + 0x580) + 0x12) = 0;
    }
  }
  return;
}


// Player_MaskGrab_Init
// when falling off track
// param1 = thread, param2 = driver
void FUN_800671b0(int param_1,int param_2)
{
  // When this function executes,
  // mask comes down to catch you

  undefined4 uVar1;
  int iVar2;
  int iVar3;
  int iVar4;

  // get instance from thread
  iVar4 = *(int *)(param_1 + 0x34);

  // now being mask grabbed
  *(undefined *)(param_2 + 0x376) = 5;

  *(undefined *)(param_2 + 0x58c) = 0;
  *(undefined2 *)(param_2 + 0x58a) = 0;
  *(undefined *)(param_2 + 0x58e) = 0;

  // reset whistle bool
  *(undefined *)(param_2 + 0x58f) = 0;

  // reset stillFalling bool
  *(undefined *)(param_2 + 0x58d) = 0;

  // Weapon_Mask_UseWeapon
  uVar1 = FUN_80064c38(param_2,1);

  // Mask Object (580?)
  *(undefined4 *)(param_2 + 0x580) = uVar1;

  *(undefined2 *)(param_2 + 0x3dc) = 0;
  *(undefined2 *)(param_2 + 0x3e2) = 0;
  *(undefined2 *)(param_2 + 0x3de) = 0;
  *(undefined *)(param_2 + 0x4c) = 0;
  *(undefined *)(param_2 + 0x4d) = 0;

  // NoInput timer to 1.44s
  *(undefined2 *)(param_2 + 0x400) = 0x5a0;

  *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) & 0xfff7ffbf;

  // Check if 231 dll is loaded
  iVar2 = FUN_800348e8();

  if (
		// If it is loaded
		(iVar2 != 0) &&

		// If you're not in Adventure Arena
		((*(uint *)PTR_DAT_8008d2ac & 0x100000) == 0)
	  )
  {
	// RB_Player_ModifyWumpa, -2
    FUN_800abefc(param_2,0xfffffffe);
  }
  // if stored quadblock height + 0x8000 < posCurr.y
  if (*(int *)(param_2 + 0x2d0) + 0x8000 < *(int *)(param_2 + 0x2d8)) 
  {
	// mask grab count (for end of race comments)
    *(char *)(param_2 + 0x56a) = *(char *)(param_2 + 0x56a) + '\x01';

	// if driver touched surface before mask grab
	if (
			// if height is low
			// like splashing water on coco park happens on low height,
			// not high height when you're on the grass
			(*(int *)(param_2 + 0x2d8) < -0x8000) &&
			(
				// 10 particles
				iVar2 = 10,

				// if mask should grab you when underwater
				(*(uint *)(*(int *)(PTR_DAT_8008d2ac + 0x160) + 0xdc) & 2) != 0
			)
		)
	{
	  // AngleAxis normalVec
      *(undefined2 *)(param_2 + 0x584) = *(undefined2 *)(param_2 + 0x368);
      *(undefined2 *)(param_2 + 0x586) = *(undefined2 *)(param_2 + 0x36a);
      *(undefined2 *)(param_2 + 0x588) = *(undefined2 *)(param_2 + 0x36c);

	  // spawn particles
      do
	  {
		// 0x2138 = "falling",
		// like splashing in water on coco park

		// Create instance in particle pool
        iVar3 = FUN_80040308(0,*(undefined4 *)(PTR_DAT_8008d2ac + 0x2138),&DAT_80089a94);

		// if particle exists
		if (iVar3 != 0) {
          *(undefined *)(iVar3 + 0x18) = *(undefined *)(*(int *)(param_2 + 0x1c) + 0x50);

		  // driver -> instSelf
          *(undefined4 *)(iVar3 + 0x20) = *(undefined4 *)(param_2 + 0x1c);

		  // driverID
          *(undefined *)(iVar3 + 0x19) = *(undefined *)(param_2 + 0x4a);
        }

		// loop counter
        iVar2 = iVar2 + -1;

      } while (iVar2 != 0);
    }

	// if driver did not touch surface (and is still falling)
    else
	{
	  // save result in a bool
      *(undefined *)(param_2 + 0x58d) = 1;
    }
  }
  else 
  {
	// AngleAxis normalVec
    *(undefined2 *)(param_2 + 0x584) = *(undefined2 *)(param_2 + 0x368);
    *(undefined2 *)(param_2 + 0x586) = *(undefined2 *)(param_2 + 0x36a);
    *(undefined2 *)(param_2 + 0x588) = *(undefined2 *)(param_2 + 0x36c);
  }
  
  // edits position
  *(int *)(param_2 + 0x2d4) = *(int *)(iVar4 + 0x44) << 8;
  iVar2 = *(int *)(param_2 + 0x580);
  *(int *)(param_2 + 0x2d8) = *(int *)(iVar4 + 0x48) << 8;
  *(int *)(param_2 + 0x2dc) = *(int *)(iVar4 + 0x4c) << 8;
  
  //set previous frame velocity to the same as current frame velocity
  *(undefined4 *)(param_2 + 0x2e4) = *(undefined4 *)(param_2 + 0x2d8);
  *(undefined4 *)(param_2 + 0x2e0) = *(undefined4 *)(param_2 + 0x2d4);
  *(undefined4 *)(param_2 + 0x2e8) = *(undefined4 *)(param_2 + 0x2dc);
  
  if (iVar2 != 0) {
    *(ushort *)(iVar2 + 4) = *(ushort *)(iVar2 + 4) | 1;
    *(undefined2 *)(*(int *)(param_2 + 0x580) + 0xc) =
         (short)((uint)*(undefined4 *)(param_2 + 0x2d4) >> 8);
    *(short *)(*(int *)(param_2 + 0x580) + 0xe) =
         (short)((uint)*(undefined4 *)(param_2 + 0x2d8) >> 8) + 0x140;
    *(undefined2 *)(*(int *)(param_2 + 0x580) + 0x10) =
         (short)((uint)*(undefined4 *)(param_2 + 0x2dc) >> 8);
  }

  // Player_MaskGrab_Update
  *(undefined4 *)(param_2 + 0x58) = 0x80066d4c;

  // Player_MaskGrab_Input
  *(undefined4 *)(param_2 + 0x5c) = 0x80066e3c;

  *(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
  *(undefined4 *)(param_2 + 100) = 0x8005fc8c; // OnInterpolate
  *(undefined4 *)(param_2 + 0x68) = 0x8005ea60; // OnApplyForces
  *(undefined4 *)(param_2 + 0x6c) = 0x80020410; // OnPhysics
  *(undefined4 *)(param_2 + 0x70) = 0x8005ebac; // OnCollide -- handle collision with turbo pads and robotcars
  *(undefined4 *)(param_2 + 0x74) = 0x8001d944; // Searches for quadblock
  *(undefined4 *)(param_2 + 0x78) = 0x80060630; // JumpAndFriction
  *(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix

  // Player_MaskGrab_Animate
  *(undefined4 *)(param_2 + 0x80) = 0x80066e8c;

  *(undefined4 *)(param_2 + 0x54) = 0;

  // SpawnParticle_DriverMain
  *(undefined4 *)(param_2 + 0x84) = 0x80059a18;

  return;
}


// Player_MaskRespawn_Update
void FUN_8006749c(int param_1,int param_2)

{
  int iVar1;
  int iVar2;

  // get instance from thread
  iVar2 = *(int *)(param_1 + 0x34);

  // NoInput timer = NoInput timer - elapsed milliseconds per frame, ~32
  iVar1 = (uint)*(ushort *)(param_2 + 0x400) - (uint)*(ushort *)(PTR_DAT_8008d2ac + 0x1d04);
  *(undefined2 *)(param_2 + 0x400) = (short)iVar1;

  // if negative
  if (iVar1 * 0x10000 < 0)
  {
	// set to zero
    *(undefined2 *)(param_2 + 0x400) = 0;
  }

  // when input is now allowed
  if (*(short *)(param_2 + 0x400) == 0)
  {
	// Player_MaskGrab_FindDestPos
	// driver, and quadblock previously touched by driver
    FUN_8006677c(param_2,*(undefined4 *)(param_2 + 0x354));

	// Driver_TeleportSelf (back onto track)
    FUN_80057c8c(param_2,0,0x80);

	// enable collision for this thread
    *(uint *)(param_1 + 0x1c) = *(uint *)(param_1 + 0x1c) & 0xffffefff;

	// make visible
	*(uint *)(iVar2 + 0x28) = *(uint *)(iVar2 + 0x28) & 0xffffff7f;

	// Player_EngineRevving_Init
	// this lets you rev engine while falling
	FUN_80067f4c(param_1,param_2);
  }
  return;
}


// Player_MaskRespawn_Input
void FUN_80067554(undefined4 param_1,int param_2)

{
  undefined *puVar1;

  // Player_Driving_Input
  FUN_8006181c();

  // reset speed
  *(undefined2 *)(param_2 + 0x39e) = 0;

  // reset jump variable
  *(undefined2 *)(param_2 + 0x3f0) = 0;

  // reset two speed variables
  *(undefined2 *)(param_2 + 0x39e) = 0;
  *(undefined2 *)(param_2 + 0x39c) = 0;

  *(undefined *)(param_2 + 0x4b) = 0;
  puVar1 = PTR_DAT_8008d2ac;
  *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) & 0xfffdffdb | 8;
  
  // increment time spent in mask grab
  *(int *)(param_2 + 0x548) = *(int *)(param_2 + 0x548) + *(int *)(puVar1 + 0x1d04);
  
  return;
}



// WARNING: Could not reconcile some variable overlaps

// Player_MaskRespawn_Animate
// param1 = thread, param2 = driver
void FUN_800675c0(undefined4 param_1,int param_2)

{
  short sVar1;
  undefined *puVar2;
  long x;
  int iVar3;
  int iVar4;
  SVECTOR local_38;
  int local_30;
  int local_28;
  long alStack32 [2];

  iVar3 = *(int *)(param_2 + 0x4a8);
  if (((iVar3 != 0) && (*(char *)(param_2 + 0x580) == '\0')) &&
     (*(short *)(param_2 + 0x400) < 0xb40))
  {
	// get instance from thread
    iVar4 = *(int *)(iVar3 + 0x34);

    *(undefined *)(param_2 + 0x580) = 1;
    local_38.vx = -0xfa;
    if (*(short *)(*(int *)(iVar3 + 0x30) + 4) == 0) {
      local_38.vx = 0xfa;
    }
    local_38.vy = 0;
    local_38.vz = 0x2ee;

	// driver -> instance -> matrix
    SetRotMatrix((MATRIX *)(iVar4 + 0x30));

	// driver -> instance -> matrix
    SetTransMatrix((MATRIX *)(iVar4 + 0x30));

    RotTrans(&local_38,(VECTOR *)&local_30,alStack32);
    puVar2 = PTR_DAT_8008d2ac;

	// camera110->posX
    *(undefined2 *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_2 + 0x4a) * 0x110 + 0x168) =
         (undefined2)local_30;

	// camera110->posY
	*(short *)(puVar2 + (uint)*(byte *)(param_2 + 0x4a) * 0x110 + 0x16a) =

		// driverY + 0xc0
         *(short *)(iVar4 + 0x48) + 0xc0;

	// camera110->posZ
    *(undefined2 *)(puVar2 + (uint)*(byte *)(param_2 + 0x4a) * 0x110 + 0x16c) =
		(undefined2)local_28;

	// cameraX = cameraX - driverX
    local_30 = local_30 - *(int *)(iVar4 + 0x44);

	// get camera110->rotX
    sVar1 = *(short *)(puVar2 + (uint)*(byte *)(param_2 + 0x4a) * 0x110 + 0x16a);

	// driverZ
	iVar3 = *(int *)(iVar4 + 0x48);

	// cameraZ = cameraZ - driverZ
    local_28 = local_28 - *(int *)(iVar4 + 0x4c);

	// get direction from camera to driver
    x = ratan2(local_30,local_28);

	// camera110-> ??? right after rotZ
    *(short *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_2 + 0x4a) * 0x110 + 0x170) = (short)x;

	// get distance between car and camera
	x = SquareRoot0(local_30 * local_30 + local_28 * local_28);

	// what???
    x = ratan2(sVar1 - iVar3,x);

    puVar2 = PTR_DAT_8008d2ac;

	// camera->rotZ
    *(short *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_2 + 0x4a) * 0x110 + 0x16e) =
         0x800 - (short)x;

	// camera-> ???
	*(undefined2 *)(puVar2 + (uint)*(byte *)(param_2 + 0x4a) * 0x110 + 0x172) = 0;
  }
  return;
}


// Player_MaskRespawn_Init
// when eaten by plant on papu pyramid
// param1 = thread, param2 = driver
void FUN_800677d0(int param_1,int param_2)
{
  // when this function executes, you are lifted
  // above the track by the mask, where you respawn

  int iVar1;
  int iVar2;

  iVar2 = *(int *)(param_1 + 0x34);
  *(undefined *)(param_2 + 0x376) = 5;
  *(undefined *)(param_2 + 0x580) = 0;
  *(undefined2 *)(param_2 + 0x3dc) = 0;
  *(undefined2 *)(param_2 + 0x3e2) = 0;
  *(undefined2 *)(param_2 + 0x3de) = 0;
  *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) & 0xfff7ffbf;

  // "cloud" is the raincloud after hitting red potion

  // if thread of "cloud" exists
  if (*(int *)(param_2 + 0x4a0) != 0)
  {
    *(undefined2 *)(*(int *)(*(int *)(param_2 + 0x4a0) + 0x30) + 4) = 0;

	// Set driver->cloudTh->funcPerFrame to destroy thread
    *(undefined4 *)(*(int *)(param_2 + 0x4a0) + 0x2c) = 0x800b0f1c;

	// erase pointer to "cloud" thread
    *(undefined4 *)(param_2 + 0x4a0) = 0;
  }

  // Check if 231 dll is loaded
  iVar1 = FUN_800348e8();

  if (
		// If it is loaded
		(iVar1 != 0) &&

		// If you're not in Adventure Arena
		((*(uint *)PTR_DAT_8008d2ac & 0x100000) == 0)
	)
  {
	// RB_Player_ModifyWumpa, -2
    FUN_800abefc(param_2,0xfffffffe);
  }

  // allow this thread to ignore all collisions
  *(uint *)(param_1 + 0x1c) = *(uint *)(param_1 + 0x1c) | 0x1000;

  // make invisible
  *(uint *)(iVar2 + 0x28) = *(uint *)(iVar2 + 0x28) | 0x80;

  // OtherFX_Stop1 (three sounds)
  FUN_80028808(*(undefined4 *)(param_2 + 0x304));
  *(undefined4 *)(param_2 + 0x304) = 0;
  FUN_80028808(*(undefined4 *)(param_2 + 0x308));
  *(undefined4 *)(param_2 + 0x308) = 0;
  FUN_80028808(*(undefined4 *)(param_2 + 0x300));

  // Player_MaskRespawn_Update
  *(undefined4 *)(param_2 + 0x58) = 0x8006749c;

  // Player_MaskRespawn_Input
  *(undefined4 *)(param_2 + 0x5c) = 0x80067554;

  *(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
  *(undefined4 *)(param_2 + 0x300) = 0;
  *(undefined4 *)(param_2 + 0x54) = 0;
  *(undefined4 *)(param_2 + 100) = 0;
  *(undefined4 *)(param_2 + 0x68) = 0;
  *(undefined4 *)(param_2 + 0x6c) = 0; // OnPhysics
  *(undefined4 *)(param_2 + 0x70) = 0; // OnCollide
  *(undefined4 *)(param_2 + 0x74) = 0;
  *(undefined4 *)(param_2 + 0x78) = 0; // cant move anymore
  *(undefined4 *)(param_2 + 0x7c) = 0;

  // Player_MaskRespawn_Animate
  *(undefined4 *)(param_2 + 0x80) = 0x800675c0;

  // no particles
  *(undefined4 *)(param_2 + 0x84) = 0;
  return;
}

// Player_Dead_Init
// param1 = thread, param2 = driver
void FUN_80067930(undefined4 param_1,int param_2)
{
  // Player_MaskRespawn_Init
  FUN_800677d0(param_1, param_2);

  // erase OnUpdate
  *(undefined4 *)(param_2 + 0x58) = 0;

  // erase OnAnimate
  *(undefined4 *)(param_2 + 0x80) = 0;

  // erase invisibleTimer
  *(undefined4 *)(param_2 + 0x28) = 0;

  return;
}


// Player_EngineRevving_Update
// param1 = thread, param2 = driver
void FUN_80067960(undefined4 param_1,int param_2)

{
  undefined4 uVar1;

  // If race has not started
  if (*(char *)(param_2 + 0x594) == '\0')
  {
	// If Traffic Lights are not done counting down
    if (0 < *(int *)(PTR_DAT_8008d2ac + 0x1d0c))
	{
	  // Dont continue with the function,
	  // let your kart stay in a revving state
      return;
    }
  }

  // If race has started
  else
  {

	// If mask grab has not lowered you close
	// enough to the track to let you go
    if (*(int *)(param_2 + 0x2d0) + 0x4000 <= *(int *)(param_2 + 0x2d8))
	{
	  // Dont continue with the function,
	  // let your kart stay in a revving state
      return;
    }
  }

  // Assume it's time to transition out of being
  // frozen, and into driving, last iteration of
  // this function

  if (
		// if reason for revving is mask grab
		(*(char *)(param_2 + 0x594) != '\0') &&

		// mask object?
		(*(int *)(param_2 + 0x580) != 0)
	  )
  {
	// mask object duration ?
    *(undefined2 *)(*(int *)(param_2 + 0x580) + 6) = 0;
  }

  if (
		// If sacred fire constant is less than 				???
		((int)*(short *)(param_2 + 0x42e) < *(int *)(param_2 + 0x588)) &&
		((*(byte *)(param_2 + 0x593) & 3) == 0)
	 )
  {

    if (
		// While not moving, if you rev'd your engine less than...
		*(int *)(param_2 + 0x584) <

        (int)*(short *)(param_2 + 0x42e) + (int)*(short *)(param_2 + 0x432))
	{
	  // You get a small boost
      uVar1 = 0x20;
    }

	// if you rev'd your engine high
    else
	{
	  // you get a big boost
      uVar1 = 0x80;
    }

	// Turbo_Increment
	// one full second of reserves
    FUN_8005abfc(param_2,0x3c0,0,uVar1);
  }
  *(undefined2 *)(param_2 + 0x3dc) = 0;
  *(undefined *)(param_2 + 0x4fe) = 0;

  // Player_Driving_Init
  FUN_80062b74(param_1);
  return;
}


// Player_EngineRevving_Input
// param1 = thread, param2 = driver
void FUN_80067a74(undefined4 param_1,int param_2)

{
  undefined *puVar1;
  int iVar2;

												// elapsed milliseconds per frame, ~32
  iVar2 = (uint)*(ushort *)(param_2 + 0x58e) - (uint)*(ushort *)(PTR_DAT_8008d2ac + 0x1d04);

  *(undefined2 *)(param_2 + 0x58e) = (short)iVar2;
  if (iVar2 * 0x10000 < 0) {
    *(undefined2 *)(param_2 + 0x58e) = 0;
  }
												// elapsed milliseconds per frame, ~32
  iVar2 = (uint)*(ushort *)(param_2 + 0x590) - (uint)*(ushort *)(PTR_DAT_8008d2ac + 0x1d04);
  *(undefined2 *)(param_2 + 0x590) = (short)iVar2;
  if (iVar2 * 0x10000 < 0) {
    *(undefined2 *)(param_2 + 0x590) = 0;
  }

  // Player_Driving_Input
  FUN_8006181c(param_1,param_2);

  puVar1 = PTR_DAT_8008d2ac;

  // if race already started
  if (*(char *)(param_2 + 0x594) != '\0')
  {
	// cameraDC flag
    *(uint *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_2 + 0x4a) * 0xdc + 0x1508) =
         *(uint *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_2 + 0x4a) * 0xdc + 0x1508) | 0x10;

    *(undefined2 *)(puVar1 + (uint)*(byte *)(param_2 + 0x4a) * 0xdc + 0x1530) = 0x40;

    // Y pos -= 0x200
    *(int *)(param_2 + 0x2d8) = *(int *)(param_2 + 0x2d8) + -0x200;
    if (*(int *)(param_2 + 0x580) != 0) {
      *(undefined2 *)(*(int *)(param_2 + 0x580) + 6) = 0x1e00;
    }
  }
  return;
}


// Player_EngineRevving_Animate
// param1 = thread, param2 = driver
void FUN_80067b7c(int param_1,int param_2)

{
  byte bVar1;
  bool bVar2;
  undefined2 uVar3;
  int iVar4;
  int local_18;
  short sVar5;
  undefined4 uVar6;
  int iVar7;
  uint uVar8;
  int iVar9;
  int iVar10;

  // thread -> instance
  iVar10 = *(int *)(param_1 + 0x34);

  if (((0 < *(short *)(param_2 + 0x39e)) && (*(short *)(param_2 + 0x58e) == 0)) &&
     ((*(byte *)(param_2 + 0x593) & 3) == 0)) {

	// Curr revving meter   -   Max revving meter
	iVar4 = *(int *)(param_2 + 0x588) - *(int *)(param_2 + 0x584);

	// absolute value
	if (iVar4 < 0) {
      iVar4 = -iVar4;
    }

	// NOPing will fill meter in
	// slow motion, showing how it works
	iVar4 = iVar4 >> 1;

	iVar7 = iVar4;

	// Speed of filling the meter changes
	// depending on how full the meter is,
	// there are two speeds

	if (5000 < iVar4) {
      iVar7 = 5000;
    }

	if (iVar4 < 0x100) {
      iVar7 = 0x100;
    }

	// Interpolate turboMeter by speed
	// parameters: curr revving meter and meter filling speed
    iVar4 = FUN_80058f54(*(int *)(param_2 + 0x588),iVar7);

	// Set new curr rev
    *(int *)(param_2 + 0x588) = iVar4;

    *(undefined *)(param_2 + 0x592) = 2;

    // if max revv > filling speed
    if (iVar4 < *(int *)(param_2 + 0x584)) {
      *(undefined2 *)(param_2 + 0x58c) = 0;
    }

    else
    {
	  // elapsed milliseconds per frame, ~32
      sVar5 = *(short *)(param_2 + 0x58c) + *(short *)(PTR_DAT_8008d2ac + 0x1d04);
      *(short *)(param_2 + 0x58c) = sVar5;

	  // if more than 0.192s
	  if (0xc0 < sVar5) 
	  {
        *(undefined *)(param_2 + 0x592) = 0;
        *(byte *)(param_2 + 0x593) = *(byte *)(param_2 + 0x593) | 3;

		// OtherFX_Play_Echo
        FUN_80028494(0xf,1,(uint)*(ushort *)(param_2 + 0x2ca) & 1);
      }
    }
    goto LAB_80067dec;
  }
  *(undefined2 *)(param_2 + 0x58c) = 0;
  if (*(char *)(param_2 + 0x592) == '\x02') {
    *(undefined2 *)(param_2 + 0x58e) = 0x100;
    *(undefined *)(param_2 + 0x592) = 0;

    // if curr rev > ???
    if ((int)*(short *)(param_2 + 0x42e) < *(int *)(param_2 + 0x588)) {
      *(undefined *)(param_2 + 0x592) = 1;
    }
  }
  if ((*(char *)(param_2 + 0x592) != '\0') &&

    // curr rev < ???
     (*(int *)(param_2 + 0x588) < (int)*(short *)(param_2 + 0x42e))) {
    *(undefined *)(param_2 + 0x592) = 0;

	  // Interpolate rotation by speed
    // params: max revv, ???
    uVar6 = FUN_80058f54(*(undefined4 *)(param_2 + 0x584),(int)*(short *)(param_2 + 0x432) / 3 + 3);

    // max rev = ???
    *(undefined4 *)(param_2 + 0x584) = uVar6;
  }

  // if curr rev < 1
  if (*(int *)(param_2 + 0x588) < 1) {
    *(byte *)(param_2 + 0x593) = *(byte *)(param_2 + 0x593) & 0xfd;

    // max rev = ???
    *(int *)(param_2 + 0x584) =
         (int)*(short *)(param_2 + 0x42e) + (int)*(short *)(param_2 + 0x432) / 3;
  }

  // if curr rev >= 1
  else {

    // rev deacceleration rate = curr rev / 2
    uVar8 = *(int *)(param_2 + 0x588) >> 1;

    if ((*(byte *)(param_2 + 0x593) & 2) == 0) {
      bVar2 = (int)uVar8 < 0x100;

      // if rev deacceleration rate > 1000
      if (1000 < (int)uVar8) {

        // rev deacceleration rate = 1000
        uVar8 = 1000;
        goto LAB_80067d64;
      }
    }

    else {
      bVar2 = (int)uVar8 < 0x100;

      // if rev deacceleration rate > 3000
      if (3000 < (int)uVar8) {

        // rev deacceleration rate = 3000
        uVar8 = 3000;
LAB_80067d64:
        bVar2 = uVar8 < 0x100;
      }
    }
    if (bVar2) {

      // rev deacceleration rate = 0x100
      uVar8 = 0x100;
    }

    // new rev = curr rev - rev deacceleration rate
    iVar4 = *(int *)(param_2 + 0x588) - uVar8;

    // curr rev = new rev
    *(int *)(param_2 + 0x588) = iVar4;

    // if new rev < 1
    if (iVar4 < 1) {

      *(undefined2 *)(param_2 + 0x590) = 0xc0;

      // curr rev = 0
      *(undefined4 *)(param_2 + 0x588) = 0;
    }
  }
  if (*(short *)(param_2 + 0x39e) < 1) {
    *(byte *)(param_2 + 0x593) = *(byte *)(param_2 + 0x593) & 0xfe;
  }
LAB_80067dec:
  if ((*(uint *)(param_2 + 0x590) & 0x200ffff) == 0) {

    // if curr rev < ???
    if (*(int *)(param_2 + 0x588) < (int)*(short *)(param_2 + 0x42e)) {
      *(undefined *)(param_2 + 0x4fe) = 0;
    }
    else {
      *(undefined *)(param_2 + 0x4fe) = 1;
    }
  }
  else {
    *(undefined *)(param_2 + 0x4fe) = 2;
  }
  iVar4 = (int)*(short *)(param_2 + 0x42e);

  // ??? = curr rev
  *(undefined2 *)(param_2 + 0x36e) = *(undefined2 *)(param_2 + 0x588);

  // if curr rev < ???
  if (*(int *)(param_2 + 0x588) < iVar4)
  {

	// 476 and 447 can be absolutely any value,
	// by default they are 15 and 30, but as long as
	// they are proportional (1 and 2, 4 and 8), they
	// behave the same as 15 and 30

    bVar1 = *(byte *)(param_2 + 0x476);

	// 477 changes when meter turns red
    local_18 = (uint)*(byte *)(param_2 + 0x477) * 0x20 + 1;

	  // curr rev
    uVar6 = *(undefined4 *)(param_2 + 0x588);
    iVar7 = 0;
    iVar9 = iVar4;
  }
  else
  {
	// 477 changes when meter turns red
    bVar1 = *(byte *)(param_2 + 0x477);

    local_18 = 1;

	// curr rev
	uVar6 = *(undefined4 *)(param_2 + 0x588);
    iVar9 = iVar4 + *(short *)(param_2 + 0x432);
    iVar7 = iVar4;
  }

  // Get percentage of uVar6 between iVar7 and iVar9,
  // then return that same percentage between bVar1<<5 and local18
  // Map value from [oldMin, oldMax] to [newMin, newMax]
  // inverting newMin and newMax will give an inverse range mapping
  uVar3 = FUN_80058f9c(uVar6,iVar7,iVar9,(uint)bVar1 << 5,local_18);

  *(undefined2 *)(param_2 + 0x3dc) = uVar3;
  *(undefined4 *)(param_2 + 0x490) = 0;
  iVar4 = (int)((uint)*(ushort *)(param_2 + 0x36e) << 0x10) >> 0x16;

  *(short *)(param_2 + 0x40c) = (short)*(ushort *)(param_2 + 0x36e) >> 6;

  if (iVar4 < 0x401) {
    if (iVar4 < 0) {
      *(undefined2 *)(param_2 + 0x40c) = 0;
    }
  }

  else {
    *(undefined2 *)(param_2 + 0x40c) = 0x400;
  }

  // Set the scale of the car while revving the engine,
  // this is a basic "squash and stretch" concept of animation, before motion

  // Reduce height a little
  *(short *)(iVar10 + 0x1e) = 0xccc - *(short *)(param_2 + 0x40c);

  // Increase X and Z a little
  *(short *)(iVar10 + 0x1c) = (short)(((int)*(short *)(param_2 + 0x40c) * 6) / 10) + 0xccc;
  *(short *)(iVar10 + 0x20) = (short)(((int)*(short *)(param_2 + 0x40c) * 6) / 10) + 0xccc;

  return;
}

// Player_EngineRevving_Init
// param1 = thread, param2 = driver
void FUN_80067f4c(undefined4 param_1,int param_2)

{
  // spawn function that waits for traffic lights

  undefined4 uVar1;

  // kart state to rev
  *(undefined *)(param_2 + 0x376) = 4;

  *(undefined *)(param_2 + 0x4fe) = 0;
  *(undefined4 *)(param_2 + 0x588) = 0;

  // assume reason for revving is: start of race
  *(undefined *)(param_2 + 0x594) = 0;

  *(undefined4 *)(param_2 + 0x580) = 0;

  // if this is a mask grab
  if (*(int *)(param_2 + 0x2d0) + 0x1000 < *(int *)(param_2 + 0x2d8))
  {
	// assume reason for revving is: mask grab
    *(undefined *)(param_2 + 0x594) = 1;

	// Weapon_Mask_UseWeapon
    uVar1 = FUN_80064c38(param_2,0);

	// Mask Object (580?)
    *(undefined4 *)(param_2 + 0x580) = uVar1;

	// Driver flag
    *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) & 0xfffffffe;

	// CameraDC flag
    *(uint *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_2 + 0x4a) * 0xdc + 0x1508) =
         *(uint *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_2 + 0x4a) * 0xdc + 0x1508) | 8;
  }
  *(undefined *)(param_2 + 0x449) = 1;

  // Player_EngineRevving_Update
  *(undefined4 *)(param_2 + 0x58) = 0x80067960;

  // Player_EngineRevving_Input
  *(undefined4 *)(param_2 + 0x5c) = 0x80067a74;

  *(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
  *(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix

  // Player_EngineRevving_Animate
  *(undefined4 *)(param_2 + 0x80) = 0x80067b7c;

  // SpawnParticle_DriverMain
  *(undefined4 *)(param_2 + 0x84) = 0x80059a18;

  *(undefined2 *)(param_2 + 0x58c) = 0;
  *(undefined2 *)(param_2 + 0x58e) = 0;
  *(undefined *)(param_2 + 0x592) = 0;
  *(undefined *)(param_2 + 0x593) = 0;
  *(undefined2 *)(param_2 + 0x590) = 0;
  *(undefined4 *)(param_2 + 0x54) = 0;
  *(undefined4 *)(param_2 + 100) = 0;
  *(undefined4 *)(param_2 + 0x68) = 0;
  *(undefined4 *)(param_2 + 0x6c) = 0; // OnPhysics
  *(undefined4 *)(param_2 + 0x70) = 0; // OnCollide
  *(undefined4 *)(param_2 + 0x74) = 0;
  *(undefined4 *)(param_2 + 0x78) = 0; // cant move anymore
  *(int *)(param_2 + 0x584) =
       (int)*(short *)(param_2 + 0x42e) + (int)*(short *)(param_2 + 0x432) / 3;
  return;
}


// Player_Blasted_Update
// param1 = thread, param2 = driver
void FUN_8006809c(undefined4 param_1,int param_2)

{
  // if you are done being blasted, or done spinning out
  if (*(short *)(param_2 + 0x400) == 0) {
    *(undefined *)(param_2 + 0x4c) = 0;
    *(undefined *)(param_2 + 0x4d) = 0;

	// Player_Driving_Init
    FUN_80062b74();
  }
  return;
}

// Player_Blasted_Input
// param1 = thread, param2 = driver
void FUN_800680d0(undefined4 param_1,int param_2)

{
  int iVar1;

  // NoInput timer = NoInput timer -  elapsed milliseconds per frame, ~32
  iVar1 = (uint)*(ushort *)(param_2 + 0x400) - (uint)*(ushort *)(PTR_DAT_8008d2ac + 0x1d04);
  *(undefined2 *)(param_2 + 0x400) = (short)iVar1;

  // if negative
  if (iVar1 * 0x10000 < 0)
  {
	// set to zero
    *(undefined2 *)(param_2 + 0x400) = 0;
  }

  // Player_Driving_Input
  FUN_8006181c(param_1,param_2);

  // force to jump when hit the ground,
  // lock to 96ms (0.1s) until blasted state is over
  *(undefined2 *)(param_2 + 0x3f6) = 0x60;

  // reset two speed variables
  *(undefined2 *)(param_2 + 0x39c) = 0;
  *(undefined2 *)(param_2 + 0x39e) = 0;

  *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) | 0x5808;
  *(short *)(param_2 + 0x3f8) = *(short *)(param_2 + 0x400) * 2 + 6000;
  return;
}


// Player_Blasted_Interpolate
// param1 = thread, param2 = driver
void FUN_80068150(undefined4 param_1,int param_2)

{
  undefined *puVar1;
  ushort uVar2;
  undefined2 uVar3;
  short sVar4;

  puVar1 = PTR_DAT_8008d2ac;
  *(undefined2 *)(param_2 + 0x3e6) = 10000;
  *(short *)(param_2 + 0x3b4) = *(short *)(param_2 + 0x3b4) - (*(short *)(param_2 + 0x3b4) >> 3);
  sVar4 = *(short *)(param_2 + 0x3d2) - (*(short *)(param_2 + 0x3d2) >> 3);
  *(short *)(param_2 + 0x3d2) = sVar4;
  *(short *)(param_2 + 0xc0) = *(short *)(param_2 + 0x3b4);
  *(short *)(param_2 + 0x3c6) = (*(short *)(param_2 + 0x3c6) + sVar4 + 0x800U & 0xfff) - 0x800;
  *(short *)(param_2 + 0x3d4) = *(short *)(param_2 + 0x3d4) - (*(short *)(param_2 + 0x3d4) >> 3);

  // angle change = angle + (??? * time lapsed between frames) & 0xFFF
  uVar2 = *(short *)(param_2 + 0x39a) +
          (short)((int)*(short *)(param_2 + 0x3b4) * *(int *)(puVar1 + 0x1d04) >> 0xd) & 0xfff;

  // angle = angle change
  *(ushort *)(param_2 + 0x39a) = uVar2;
  *(short *)(param_2 + 0x2ee) = *(short *)(param_2 + 0x3d4) + uVar2 + *(short *)(param_2 + 0x3c6);

  // Interpolate rotation by speed
  uVar3 = FUN_80058f54((int)*(short *)(param_2 + 0x2f2),(*(int *)(puVar1 + 0x1d04) << 5) >> 5,0);

  // set new camera rotation
  *(undefined2 *)(param_2 + 0x2f2) = uVar3;

  // Rot_AxisAngle
  FUN_8005f89c(param_2 + 0x310,param_2 + 0x360,(int)*(short *)(param_2 + 0x39a));
  return;
}

// Player_Blasted_Animate
// param1 = thread, param2 = driver
void FUN_80068244(undefined4 param_1,int param_2)

{
  char cVar1;
  int iVar2;

  // set animation index
  *(undefined *)(param_2 + 0x4c) = 6;

  // get amount of time remaining before you can move (while blasted),
  // use that to determine animation frame of bouncing around
  iVar2 = (int)((uint)*(ushort *)(param_2 + 0x400) << 0x10) >> 0x15;

  // DAT_80087f28 is a constant for how many frames are in "blasted" anim

  // Just a stupid fail-safe to alert the debugger
  if (DAT_80087f28 == 0) trap(0x1c00);
  if ((DAT_80087f28 == -1) && (iVar2 == -0x80000000)) trap(0x1800);

  // get animation frame of blasted
  cVar1 = (char)(iVar2 % DAT_80087f28);

  if (*(char *)(param_2 + 0x580) != '\0')
  {
	// play animation backwards???
    cVar1 = (char)DAT_80087f28 - (cVar1 + '\x01');
  }

  // set animation frame
  *(char *)(param_2 + 0x4d) = cVar1;

  return;
}

// Player_Blasted_Init
// param1 = thread, param2 = driver
void FUN_800682a4(undefined4 param_1,int param_2)

{
  byte bVar1;
  undefined2 uVar2;
  int iVar3;
  undefined4 uVar4;

  // put player in flipping animation after being hit
  *(undefined *)(param_2 + 0x376) = 6;

  *(undefined2 *)(param_2 + 0x3dc) = 0;

  // Check if 231 dll is loaded
  iVar3 = FUN_800348e8();
  if (
		// if it is loaded
		(iVar3 != 0) &&

		// If you're not in Adventure Arena
		((*(uint *)PTR_DAT_8008d2ac & 0x100000) == 0)
	)
  {
	// RB_Player_ModifyWumpa, -3
    FUN_800abefc(param_2,0xfffffffd);
  }

  // set animation to zero
  *(undefined *)(*(int *)(param_2 + 0x1c) + 0x52) = 0;

  // get number of frames in animation
  uVar4 = FUN_8005b0f4(*(undefined4 *)(param_2 + 0x1c),0);

  // Instance_GetStartFrame
  uVar2 = FUN_8005b0c4(0,uVar4);

  // set animation frame
  *(undefined2 *)(*(int *)(param_2 + 0x1c) + 0x54) = uVar2;

  // Get random number
  bVar1 = FUN_8003ea28();

  *(byte *)(param_2 + 0x580) = bVar1 & 4;

  // Player_Blasted_Update
  *(undefined4 *)(param_2 + 0x58) = 0x8006809c;

  // Player_Blasted_Input
  *(undefined4 *)(param_2 + 0x5c) = 0x800680d0;

  *(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio
  *(undefined4 *)(param_2 + 100) = 0x80068150; // OnInterpolate
  *(undefined4 *)(param_2 + 0x68) = 0x8005ea60; // OnApplyForces
  *(undefined4 *)(param_2 + 0x6c) = 0x80020410; // OnPhysics
  *(undefined4 *)(param_2 + 0x70) = 0x8005ebac; // OnCollide -- handle collision with turbo pads and robotcars
  *(undefined4 *)(param_2 + 0x74) = 0x8001d944; // Searches for quadblock
  *(undefined4 *)(param_2 + 0x78) = 0x80060630; // JumpAndFriction
  *(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix

  // Player_Blasted_Animate
  *(undefined4 *)(param_2 + 0x80) = 0x80068244;

  // Erase OnInit, now that it has executed
  *(undefined4 *)(param_2 + 0x54) = 0;

  // SpawnParticle_DriverMain
  *(undefined4 *)(param_2 + 0x84) = 0x80059a18;

  if (*(char *)(param_2 + 0x4b) < '\x01') {
    uVar4 = 0x19;
  }
  else {
    uVar4 = 0x29;
  }

  // controller vibration
  FUN_800263a0(param_2,uVar4,0x60);

  return;
}


// Player_Warp_MoveDustPuff
// "dustpuff" is really lightning under the player,
// without this, lightning is half-stuck under the player
void FUN_800683f4(short *param_1,int param_2,int param_3,short *param_4)

{
  uint uVar1;
  short *psVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  short *psVar6;
  int iVar7;

  // Get random number
  uVar1 = FUN_8003ea28();

  iVar4 = param_3 >> 1;
  iVar5 = (int)((uVar1 & 0xfff) * param_3) >> 0xc;
  if (iVar5 < iVar4) {
    iVar5 = iVar5 - param_3;
  }

  // Get random number
  uVar1 = FUN_8003ea28();

  iVar7 = (int)((uVar1 & 0xfff) * param_3) >> 0xc;
  if (iVar7 < iVar4) {
    iVar7 = iVar7 - param_3;
  }

  // Get random number
  uVar1 = FUN_8003ea28();

  iVar3 = (int)((uVar1 & 0xfff) * param_3) >> 0xc;
  if (iVar3 < iVar4) {
    iVar3 = iVar3 - param_3;
  }
  psVar2 = param_1 + param_2 * 4;
  iVar4 = param_2 >> 1;
  psVar6 = param_1 + iVar4 * 4;
  *psVar6 = (short)((int)*param_1 + (int)*psVar2 >> 1) + (short)(*param_4 * iVar5 >> 0xc);
  psVar6[1] = (short)((int)param_1[1] + (int)psVar2[1] >> 1) + (short)(param_4[1] * iVar7 >> 0xc);
  psVar6[2] = (short)((int)param_1[2] + (int)psVar2[2] >> 1) + (short)(param_4[2] * iVar3 >> 0xc);
  if (2 < param_2) {
    iVar5 = param_3 * 0xc00 >> 0xc;

	// Player_Warp_MoveDustPuff
    FUN_800683f4(param_1,iVar4,iVar5,param_4);

	// Player_Warp_MoveDustPuff
    FUN_800683f4(psVar6,iVar4,iVar5,param_4);
  }
  return;
}


// Add DustPuff particle to warp pad
void FUN_800685b0(short *param_1)

{
  int iVar1;

  if (((*(uint *)(PTR_DAT_8008d2ac + 0x1cec) & 1) == 0) &&
     (
		// Create instance in particle pool
		iVar1 = FUN_80040308(0,*(undefined4 *)(PTR_DAT_8008d2ac + 0x2118),&DAT_8008a180),
		iVar1 != 0
	 ))
  {
	// position variables
    *(int *)(iVar1 + 0x24) = *(int *)(iVar1 + 0x24) + (int)*param_1 * 0x100;
    *(int *)(iVar1 + 0x2c) = *(int *)(iVar1 + 0x2c) + (int)param_1[1] * 0x100;
    *(int *)(iVar1 + 0x34) = *(int *)(iVar1 + 0x34) + (int)param_1[2] * 0x100;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_80068644(int param_1,int param_2)

{
  short sVar1;
  short sVar2;
  ushort uVar3;
  short sVar4;
  short sVar5;
  short sVar6;
  uint *puVar7;
  undefined4 in_zero;
  undefined4 in_at;
  short extraout_var;
  short extraout_var_00;
  int iVar8;
  uint uVar9;
  uint *puVar10;
  undefined4 uVar11;
  uint *puVar12;
  uint *puVar13;
  short *psVar14;
  short *psVar15;
  uint *puVar16;
  undefined4 *puVar17;
  int iVar18;
  uint *puVar19;
  undefined *puVar20;
  int local_30;

  // pointer to each player's camera110 buffer
  puVar20 = PTR_DAT_8008d2ac + (uint)*(byte *)(param_1 + 0x4a) * 0x110 + 0x168;

  // set several camera110 buffer variables to coprocessor
  gte_SetRotMatrix(puVar20 + 0x28);
  gte_SetTransMatrix(puVar20 + 0x28);

  // handle some camera110 buffer variables in RAM
  sVar1 = *(short *)(puVar20 + 0x48);
  sVar2 = *(short *)(puVar20 + 0x4e);
  uVar3 = *(ushort *)(puVar20 + 0x54);

  // handle some camera110 buffer variables in scratchpad
  DAT_1f8001c0 = (undefined2)((int)sVar1 + (int)*(short *)(puVar20 + 0x4a) >> 5);
  DAT_1f8001c2 = (undefined2)
                 ((int)*(short *)(puVar20 + 0x4e) + (int)*(short *)(puVar20 + 0x50) >> 5);
  DAT_1f8001c4 = (undefined2)
                 ((int)*(short *)(puVar20 + 0x54) + (int)*(short *)(puVar20 + 0x56) >> 5);

  // backBuffer->primMem.curr
  puVar19 = *(uint **)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80);

  // if driver -> instance -> flags & INVISIBLE is true
  if ((*(uint *)(*(int *)(param_1 + 0x1c) + 0x28) & 0x80) != 0)
  {
    DAT_1f800188._0_2_ = (short)((uint)*(undefined4 *)(param_1 + 0x2d4) >> 8);
    DAT_1f800188._2_2_ = (undefined2)((uint)*(undefined4 *)(param_2 + 0x10) >> 8);
    DAT_1f80018c._0_2_ = (short)((uint)*(undefined4 *)(param_1 + 0x2dc) >> 8);

	// add dust puff
    FUN_800685b0(&DAT_1f800188);
  }

  local_30 = 0;
  do {
    iVar18 = (local_30 << 0xc) / 6;

	// Sine(angle)
    iVar8 = FUN_8003d184(iVar18 + *(int *)(param_2 + 0xc));

	_DAT_1f800108 =
         CONCAT22((short)((uint)*(undefined4 *)(param_2 + 8) >> 8),
                  (short)((uint)*(undefined4 *)(param_1 + 0x2d4) >> 8) - (short)(iVar8 >> 5));

	// Cosine(angle)
	iVar8 = FUN_8003d1c0(iVar18 + *(int *)(param_2 + 0xc));

	_DAT_1f80010c =
         _DAT_1f80010c & 0xffff0000 |
         (uint)(ushort)((short)((uint)*(undefined4 *)(param_1 + 0x2dc) >> 8) - (short)(iVar8 >> 5));
    DAT_1f800188._0_2_ = (short)((uint)*(undefined4 *)(param_1 + 0x2d4) >> 8);
    DAT_1f800188._2_2_ = (undefined2)((uint)*(undefined4 *)(param_2 + 0x10) >> 8);
    DAT_1f80018c._0_2_ = (short)((uint)*(undefined4 *)(param_1 + 0x2dc) >> 8);

	// driver -> instSelf -> flags -> INVISIBLE is false
    if ((*(uint *)(*(int *)(param_1 + 0x1c) + 0x28) & 0x80) == 0) {

	  // Sine(angle)
	  iVar8 = FUN_8003d184(iVar18 + *(int *)(param_2 + 0xc));

	  _DAT_1f800108 =
           _DAT_1f800108 & 0xffff0000 | (uint)(ushort)(DAT_1f800108 - (short)(iVar8 >> 6));

	  // Cosine(angle)
	  iVar8 = FUN_8003d1c0(iVar18 + *(int *)(param_2 + 0xc));

	  _DAT_1f80010c =
           _DAT_1f80010c & 0xffff0000 | (uint)(ushort)(DAT_1f80010c - (short)(iVar8 >> 6));

	  // Sine(angle)
	  FUN_8003d184(iVar18 + *(int *)(param_2 + 0xc));

	  DAT_1f800188._0_2_ = (short)DAT_1f800188 + extraout_var;

	  // Cosine(angle)
	  FUN_8003d1c0(iVar18 + *(int *)(param_2 + 0xc));

	  DAT_1f80018c._0_2_ = (short)DAT_1f80018c + extraout_var_00;
    }

	// if driver is visible
    else
	{
	  // add dust puff
      FUN_800685b0(&DAT_1f800108);
    }

    uVar11 = 0x10;

	// Player_Warp_MoveDustPuff
	FUN_800683f4(&DAT_1f800108,0x10,0x100,&DAT_1f8001c0);

    iVar18 = 1;
    puVar17 = (undefined4 *)&DAT_1f800108;
    do {
      puVar10 = (uint *)(iVar18 << 7);

	  // Sine(angle)
      iVar8 = FUN_8003d184(puVar10);

	  iVar18 = iVar18 + 1;
      *(short *)((int)puVar17 + 10) = *(short *)((int)puVar17 + 10) + (short)(iVar8 >> 7);
      puVar17 = puVar17 + 2;
    } while (iVar18 < 0x10);
    sVar4 = sVar1 >> 10;
    sVar5 = sVar2 >> 10;
    DAT_1f800190 = CONCAT22(DAT_1f80010a + sVar5,DAT_1f800108 + sVar4);
    sVar6 = (short)uVar3 >> 10;
    DAT_1f800194 = DAT_1f800194 & 0xffff0000 | (uint)(ushort)(DAT_1f80010c + sVar6);
    uVar9 = (_DAT_1f80010c & 0xffff) - ((int)((uint)uVar3 << 0x10) >> 0x1a);
    DAT_1f800198 = CONCAT22(DAT_1f80010a - sVar5,DAT_1f800108 - sVar4);
    DAT_1f80019c = DAT_1f80019c & 0xffff0000 | uVar9 & 0xffff;
    setCopReg(2,in_zero,DAT_1f800190);
    setCopReg(2,in_at,DAT_1f800194);
    setCopReg(2,0x1f800190,_DAT_1f800108);
    setCopReg(2,uVar9,_DAT_1f80010c);
    setCopReg(2,puVar10,DAT_1f800198);
    setCopReg(2,uVar11,DAT_1f80019c);

	// RTPT - Perspective Transformation (triple)
	copFunction(2,0x280030);

    DAT_1f8001a0 = getCopReg(2,0xc);
    DAT_1f8001a4 = getCopReg(2,0xd);
    DAT_1f8001a8 = getCopReg(2,0xe);
    DAT_1f8001ac = getCopReg(2,0x11);
    iVar18 = 0;
    puVar12 = puVar19 + 0x11;
    puVar7 = &DAT_1f8001a0;
    psVar14 = &DAT_1f80010c;
    puVar16 = &DAT_1f8001b0;
    puVar17 = (undefined4 *)&DAT_1f800108;
    do {
      puVar13 = puVar7;
      puVar17 = puVar17 + 2;
      psVar15 = psVar14 + 4;
      DAT_1f800190 = CONCAT22(psVar14[3] + sVar5,*(short *)puVar17 + sVar4);
      DAT_1f800194 = DAT_1f800194 & 0xffff0000 | (uint)(ushort)(*psVar15 + sVar6);
      DAT_1f800198 = CONCAT22(psVar14[3] - sVar5,*(short *)puVar17 - sVar4);
      DAT_1f80019c = DAT_1f80019c & 0xffff0000 | (uint)(ushort)(*psVar15 - sVar6);
      setCopReg(2,in_zero,DAT_1f800190);
      setCopReg(2,in_at,DAT_1f800194);
      setCopReg(2,0x1f800190,*puVar17);
      setCopReg(2,puVar16,puVar17[3]);
      setCopReg(2,puVar10,DAT_1f800198);
      setCopReg(2,puVar12,DAT_1f80019c);

	  // RTPT - Perspective Transformation (triple)
	  copFunction(2,0x280030);

	  uVar9 = getCopReg(2,0xc);
      *puVar16 = uVar9;
      uVar9 = getCopReg(2,0xd);
      puVar16[1] = uVar9;
      uVar9 = getCopReg(2,0xe);
      puVar16[2] = uVar9;
      uVar9 = getCopReg(2,0x11);
      puVar16[3] = uVar9;
      puVar12[-0x10] = 0xe1000a20;
      puVar12[-0xf] = 0x3a000000;
      puVar12[-0xd] = 0x7f1f3f;
      puVar12[-0xb] = 0;
      puVar12[-9] = 0x7f1f3f;
      puVar12[-0xe] = *puVar16;
      puVar12[-0xc] = puVar16[1];
      puVar12[-10] = *puVar13;
      uVar9 = puVar13[1];
      puVar12[-7] = 0x3a000000;
      puVar12[-5] = 0x7f1f3f;
      puVar12[-3] = 0;
      puVar12[-1] = 0x7f1f3f;
      puVar12[-8] = uVar9;
      puVar12[-6] = puVar16[2];
      puVar12[-4] = puVar16[1];
      iVar18 = iVar18 + 1;
      puVar12[-2] = puVar13[2];
      *puVar12 = puVar13[1];
      puVar10 = (uint *)(*(int *)(puVar20 + 0xf4) + ((int)puVar16[3] >> 6) * 4);
      puVar12 = puVar12 + 0x12;
      *puVar19 = *puVar10 | 0x11000000;
      *puVar10 = (uint)puVar19 & 0xffffff;
      puVar19 = puVar19 + 0x12;
      puVar7 = puVar16;
      psVar14 = psVar15;
      puVar16 = puVar13;
      puVar17 = puVar17;
    } while (iVar18 < 0x10);
    local_30 = local_30 + 1;
  } while (local_30 < 6);

  // backBuffer->primMem.curr
  *(uint **)(*(int *)(PTR_DAT_8008d2ac + 0x10) + 0x80) = puVar19;

  return;
}


// Player_Warp_Interpolate
// param1 = thread, param2 = driver
// animate rotation and scale in warppad
void FUN_80068be8(undefined4 param_1,int param_2)

{
  undefined2 uVar1;
  short sVar2;
  int iVar3;
  int iVar4;
  int *piVar5;
  undefined2 local_18;
  short local_16;
  undefined2 local_14;

  // get instance from driver object
  iVar4 = *(int *)(param_2 + 0x1c);

  piVar5 = (int *)(param_2 + 0x580);

  // if driver is visible
  if ((*(uint *)(iVar4 + 0x28) & 0x80) == 0)
  {
	// height + 0x100
    iVar3 = *(int *)(param_2 + 0x2d8) + 0x100;

    *(int *)(param_2 + 0x590) = iVar3;
    if (iVar3 < *(int *)(param_2 + 0x588)) {
      *(int *)(param_2 + 0x590) = *(int *)(param_2 + 0x588);
    }

	// if driver is visible
    if ((*(uint *)(iVar4 + 0x28) & 0x80) == 0) 
	{
	  // stop particle spawning
      *(int *)(param_2 + 0x58c) = *(int *)(param_2 + 0x58c) + -100;
    }

	// add dust puff
    FUN_80068644(param_2,piVar5);
  }

  // timer
  iVar3 = *piVar5;
  *piVar5 = iVar3 + 0x1a;

  // timer < 801
  if (iVar3 + 0x1a < 0x321)
  {
	// interpolate until scale is [0x12c0, 0x960, 0x12c0],
	// car is wide and short

	// Interpolate scale by speed
    uVar1 = FUN_80058f54((int)*(short *)(iVar4 + 0x1c),0x78,0x12c0);
    *(undefined2 *)(iVar4 + 0x1c) = uVar1;

	// Interpolate scale by speed
    uVar1 = FUN_80058f54((int)*(short *)(iVar4 + 0x1e),0x78,0x960);
    *(undefined2 *)(iVar4 + 0x1e) = uVar1;

	// Interpolate scale by speed
    uVar1 = FUN_80058f54((int)*(short *)(iVar4 + 0x20),0x78,0x12c0);


    *(undefined2 *)(iVar4 + 0x20) = uVar1;
    iVar4 = *(int *)(param_2 + 0x2d8) + 0x800;
    if (*(int *)(param_2 + 0x2d0) + 0x8000 <= *(int *)(param_2 + 0x2d8)) goto LAB_80068db0;
  }
  else
  {
	// cap to 800
    *piVar5 = 800;

    *(undefined *)(param_2 + 0x4fe) = 2;

	// interpolate until scale is [0, 24000, 0],
	// car is tall and thin

	// Interpolate scale by speed
    uVar1 = FUN_80058f54((int)*(short *)(iVar4 + 0x1c),600,0);
    *(undefined2 *)(iVar4 + 0x1c) = uVar1;

	// Interpolate scale by speed
    uVar1 = FUN_80058f54((int)*(short *)(iVar4 + 0x1e),0xc80,24000);
    *(undefined2 *)(iVar4 + 0x1e) = uVar1;

	// Interpolate scale by speed
    uVar1 = FUN_80058f54((int)*(short *)(iVar4 + 0x20),600,0);
    *(undefined2 *)(iVar4 + 0x20) = uVar1;

	// if scale shrinks to zero
    if (*(short *)(iVar4 + 0x1c) == 0)
	{
	  // if car is visible
      if ((*(uint *)(iVar4 + 0x28) & 0x80) == 0) {
        local_18 = (undefined2)((uint)*(undefined4 *)(param_2 + 0x2d4) >> 8);
        local_16 = (short)((uint)*(undefined4 *)(param_2 + 0x588) >> 8) + 0x40;
        local_14 = (undefined2)((uint)*(undefined4 *)(param_2 + 0x2dc) >> 8);
        FUN_80025138(&local_18);
      }

	  // make invisible
      *(uint *)(iVar4 + 0x28) = *(uint *)(iVar4 + 0x28) | 0x80;

      goto LAB_80068db0;
    }

	iVar4 = *(int *)(param_2 + 0x584) + -0x1800;
    *(int *)(param_2 + 0x584) = iVar4;

    iVar4 = *(int *)(param_2 + 0x2d8) + iVar4;
  }
  *(int *)(param_2 + 0x2d8) = iVar4;
LAB_80068db0:
  sVar2 = (*(short *)(param_2 + 0x3c6) + *(short *)piVar5 + 0x800U & 0xfff) - 0x800;
  *(short *)(param_2 + 0x3c6) = sVar2;
  *(short *)(param_2 + 0x2ee) = *(short *)(param_2 + 0x3d4) + *(short *)(param_2 + 0x39a) + sVar2;

  // driver is warping
  *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) | 0x4000;
  return;
}


// Player_Warp_Init
// param1 = thread, param2 = driver
void FUN_80068e04(undefined4 param_1,int param_2)

{
  int iVar1;

  // If you are not in a warp pad
  if (*(char *)(param_2 + 0x376) != '\n')
  {
    *(undefined4 *)(param_2 + 0x580) = 0x3c;
    *(undefined4 *)(param_2 + 0x584) = 0;
    *(undefined4 *)(param_2 + 0x588) = *(undefined4 *)(param_2 + 0x2d0);

	// OtherFX_Play
    FUN_80028468(0x97,1);

	// OtherFX_Stop1 (three sounds)
    FUN_80028808(*(undefined4 *)(param_2 + 0x304));
    *(undefined4 *)(param_2 + 0x304) = 0;
    FUN_80028808(*(undefined4 *)(param_2 + 0x308));
    *(undefined4 *)(param_2 + 0x308) = 0;
    FUN_80028808(*(undefined4 *)(param_2 + 0x300));
    *(undefined4 *)(param_2 + 0x300) = 0;

	// engineID from metadata, given characterID
    FUN_80028b54((uint)*(byte *)(param_2 + 0x4a) +
                 *(int *)(&DAT_80086d90 +
                         (int)(short)(&DAT_80086e84)[*(byte *)(param_2 + 0x4a)] * 0x10) * 4 & 0xffff
                );

	// driver -> instSelf
	iVar1 = *(int *)(param_2 + 0x1c);

	// instance flags, now reflective
    *(uint *)(iVar1 + 0x28) = *(uint *)(iVar1 + 0x28) | 0x4000;

	// vertical line for split or reflection
    *(undefined2 *)(iVar1 + 0x56) = (short)((uint)*(undefined4 *)(param_2 + 0x2d0) >> 8);

	// CameraDC, freecam mode
    *(undefined2 *)(PTR_DAT_8008d2ac + (uint)*(byte *)(param_2 + 0x4a) * 0xdc + 0x1532) = 3;

    *(undefined4 *)(param_2 + 0x60) = 0x80062a2c; // OnAudio

	// eventually calls AddDustPuff
    *(undefined4 *)(param_2 + 100) = 0x80068be8;  // OnInterpolate

	*(undefined4 *)(param_2 + 0x7c) = 0x8005ee34; // OnRender -- move position to instance matrix

    *(undefined4 *)(param_2 + 0x80) = 0x8005b178; // OnAnimate_Driving

	// you are now in a warp pad
    *(undefined *)(param_2 + 0x376) = 10;

    *(undefined2 *)(param_2 + 0x38c) = 0;
    *(undefined2 *)(param_2 + 0x38e) = 0;

    *(undefined4 *)(param_2 + 0x54) = 0; // OnInit
    *(undefined4 *)(param_2 + 0x58) = 0; // OnUpdate
	*(undefined4 *)(param_2 + 0x5c) = 0; // OnInput -- disable input, timers, and effects

    *(undefined4 *)(param_2 + 0x68) = 0;
    *(undefined4 *)(param_2 + 0x6c) = 0; // OnPhysics
    *(undefined4 *)(param_2 + 0x70) = 0; // OnCollide
    *(undefined4 *)(param_2 + 0x74) = 0;
    *(undefined4 *)(param_2 + 0x78) = 0; // cant move anymore

	// SpawnParticle_DriverMain
    *(undefined4 *)(param_2 + 0x84) = 0x80059a18;

	// driver is warping
    *(uint *)(param_2 + 0x2c8) = *(uint *)(param_2 + 0x2c8) | 0x4000;
  }
  return;
}


// Talking Mask (adventure hints)
// param1 is thread
void FUN_80068f90(int param_1)

{
  undefined *puVar1;
  undefined2 uVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;

  puVar1 = PTR_DAT_8008d2ac;

  // get object attached to thread
  iVar8 = *(int *)(param_1 + 0x30);

  // get instance attached to thread
  iVar7 = *(int *)(param_1 + 0x34);

  iVar4 = 0x2000;

  // if mask model is nullptr
  if (DAT_8008d0f0 == 0) {
    iVar4 = 0x1000;

	// Check if P1 is valid
    if (*(int *)(PTR_DAT_8008d2ac + 0x24ec) != 0)
	{
	  // Weapon_Mask_boolGoodGuy
      uVar3 = FUN_80064be4();

	  // If you use Uka mask,
	  // uka model
      iVar4 = 0xe8;

	  // If you use Aku mask
      if ((uVar3 & 0xffff) != 0)
	  {
		// aku model
        iVar4 = 0xe4;
      }

	  // set instance's model pointer
      *(undefined4 *)(iVar7 + 0x18) = *(undefined4 *)(puVar1 + iVar4 + 0x2160);

      iVar4 = 0x1000;
    }
  }

  else
  {
	// set model of talking mask
    *(int *)(iVar7 + 0x18) = DAT_8008d0f0;
  }

  // max value in some SPU data
  DAT_8008d9f8 = DAT_8008d6f4;

  uVar2 = (undefined2)(*(short *)(iVar8 + 4) * iVar4 >> 0xc);

  // scale
  *(undefined2 *)(iVar7 + 0x20) = uVar2;
  *(undefined2 *)(iVar7 + 0x1e) = uVar2;
  *(undefined2 *)(iVar7 + 0x1c) = uVar2;

  // number of animFrames
  iVar8 = FUN_8005b0f4(iVar7,0);

  // multiply by 7
  iVar4 = DAT_8008d9f8 * 7;

  if (iVar4 < 0) {
    iVar4 = iVar4 + 0x3fff;
  }

  iVar4 = iVar4 >> 0xe;

  if (DAT_8008d9fc < iVar4) {
    DAT_8008d9fc = iVar4;
  }

  iVar6 = iVar4;
  if (iVar4 < 2) {
    iVar6 = 0;
  }
  if (iVar4 < 4)
  {
	// animFrame
    iVar5 = (int)*(short *)(iVar7 + 0x54);
  }

  else
  {
	// animFrame
	iVar5 = (int)*(short *)(iVar7 + 0x54);

	iVar4 = iVar5 - iVar6;

	if (iVar4 < 0) {
      iVar4 = -iVar4;
    }

    if (3 < iVar4)
	{
	  // animFrame
	  *(undefined2 *)(iVar7 + 0x54) = (short)iVar6;

      goto LAB_800690dc;
    }
  }

  // EngineSound_VolumeAdjust
  uVar2 = FUN_8002fc28(iVar6,iVar5,1);

  // animFrame
  *(undefined2 *)(iVar7 + 0x54) = uVar2;

LAB_800690dc:

  // animFrame
  iVar4 = (int)*(short *)(iVar7 + 0x54) - iVar6;

  if (iVar4 < 0) {
    iVar4 = -iVar4;
  }

  if (iVar4 < 6)
  {
	// EngineSound_VolumeAdjust
    uVar2 = FUN_8002fc28(iVar6,(int)*(short *)(iVar7 + 0x54),1);

	// animFrame
    *(undefined2 *)(iVar7 + 0x54) = uVar2;
  }
  else
  {
	// animFrame
    *(undefined2 *)(iVar7 + 0x54) = (short)iVar6;
  }

  // animation frame goes back and forth
  // 0x00: mouth close
  // 0x0C: mouth open

  // if frame is less than zero, set to zero
  if ((int)*(short *)(iVar7 + 0x54) < 0) {
    *(undefined2 *)(iVar7 + 0x54) = 0;
  }

  // if frame is positive
  else
  {
	// if animation frame goes beyond number of frames
    if (iVar8 + -1 < (int)*(short *)(iVar7 + 0x54))
	{
	  // set animation frame to last frame
      *(undefined2 *)(iVar7 + 0x54) = (short)(iVar8 + -1);
    }
  }

  // If mask should disappear
  if (DAT_8008da00 != '\0')
  {
	// dont need this variable anymore,
	// so set it from one to zero
    DAT_8008da00 = '\0';

	// 0x800 = this thread needs to be deleted
    *(uint *)(param_1 + 0x1c) = *(uint *)(param_1 + 0x1c) | 0x800;
  }
  return;
}


// TalkingMask_Init
void FUN_80069178(void)

{
  int iVar1;

  // mask is now talking (I think)
  DAT_8008d65c = 1;

  // talking mask does not
  // need to go away
  DAT_8008da00 = 0;

  // DAT_8008d660
  // "head"

  // 0x39 = aku aku model pointer
  // it changes in FUN_80068f90

  // Create instance
  // 0x300 flag = SmallStackPool
  // 0xe = "aku aku" thread bucket
  iVar1 = FUN_800309a4(0x39,&DAT_8008d660,0x300,0xe,FUN_80068f90,6,0);

  // get thread from instance
  iVar1 = *(int *)(iVar1 + 0x6c);

  // set funcOnDestroy to remove instance from instance pool
  *(undefined4 *)(iVar1 + 0x24) = 0x80041dfc;

  // object -> 4
  *(undefined2 *)(*(int *)(iVar1 + 0x30) + 4) = 0;
  return;
}


// TalkingMask_PlayXA
void FUN_800691e4(undefined4 param_1,short param_2)

{
  uint uVar1;

  if (
		// If Player Structure pointer is not nullptr
		(*(int *)(PTR_DAT_8008d2ac + 0x24ec) != 0) &&
		(
			// Weapon_Mask_boolGoodGuy
			uVar1 = FUN_80064be4(),

			// if player uses uka
			(uVar1 & 0xffff) == 0
		)
	  )
  {
	// if you use uka, increment parameter
    param_2 = param_2 + 0x1f;
  }

  // if you use aku, leave parameter alone

  // CDSYS_XAPlay(CDSYS_XA_TYPE_EXTRA, (int)param_2);
  FUN_8001cdb4(1,(int)param_2);

  return;
}

// TalkingMask_boolNoXA
bool FUN_8006924c(void)

{
  return DAT_8008d708 == 0;
}

// TalkingMask_End
void FUN_8006925c(void)

{
  // CDSYS_XAPauseRequest
  FUN_8001cf98();

  // mask is not talking (I think)
  DAT_8008d65c = 0;

  // talking mask needs to go away
  DAT_8008da00 = 1;

  return;
}


// Turbo_ProcessBucket
void FUN_80069284(int param_1)

{
  undefined2 uVar1;
  undefined *puVar2;
  undefined *puVar3;
  int iVar4;
  undefined4 uVar5;
  int iVar6;
  int iVar7;
  int iVar8;

  puVar2 = PTR_DAT_8008d2ac;

  // if first thread is valid
  if (param_1 != 0)
  {
	// loop through all threads
    do
	{
      puVar3 = PTR_DAT_8008d2ac;

	  // get instance from thread
      iVar6 = *(int *)(param_1 + 0x34);

	  // get object from thread
      iVar7 = **(int **)(param_1 + 0x30);

	  // object -> driver -> instSelf
      iVar4 = *(int *)((*(int **)(param_1 + 0x30))[1] + 0x1c);

      iVar8 = 0;

	  // number of screens is not zero
      if (puVar2[0x1ca8] != '\0') 
	  {
		// each InstDrawPerPlayer
		// for iVar8 = 0; iVar8 < numScreens; iVar8++
        do
		{
		  // if camera110 does not exist ?
		  // judging by 0x28 being copied to 0xb8 ?
          if ((*(uint *)(iVar4 + 0xb8) & 0x100) == 0)
		  {
			// flags
            *(uint *)(iVar7 + 0xb8) =
                 *(uint *)(iVar7 + 0xb8) & (*(uint *)(iVar4 + 0xb8) | 0xffffffbf);
            *(uint *)(iVar6 + 0xb8) =
                 *(uint *)(iVar6 + 0xb8) & (*(uint *)(iVar4 + 0xb8) | 0xffffffbf);
				 
            uVar5 = *(undefined4 *)(iVar4 + 0xe4);
            *(undefined4 *)(iVar6 + 0xe4) = uVar5;
            *(undefined4 *)(iVar7 + 0xe4) = uVar5;
            uVar5 = *(undefined4 *)(iVar4 + 0xe8);
            *(undefined4 *)(iVar6 + 0xe8) = uVar5;
            *(undefined4 *)(iVar7 + 0xe8) = uVar5;
            uVar1 = *(undefined2 *)(iVar4 + 0xdc);
            *(undefined2 *)(iVar6 + 0xdc) = uVar1;
            *(undefined2 *)(iVar7 + 0xdc) = uVar1;
            uVar1 = *(undefined2 *)(iVar4 + 0xde);
            *(undefined2 *)(iVar6 + 0xde) = uVar1;
            *(undefined2 *)(iVar7 + 0xde) = uVar1;
          }
		  
		  // InstDrawPerPlayer
          iVar6 = iVar6 + 0x88;
          iVar7 = iVar7 + 0x88;
          iVar8 = iVar8 + 1;
          iVar4 = iVar4 + 0x88;
		  
        } while (iVar8 < (int)(uint)(byte)puVar3[0x1ca8]);
      }

	  // go to next thread

	  // thread = thread->sibling
      param_1 = *(int *)(param_1 + 0x10);

    } while (param_1 != 0);
  }
  return;
}


// Turbo_OnDestroy
void FUN_80069370(int param_1)

{
  int iVar1;
  undefined4 *puVar2;

  // thread -> object
  puVar2 = *(undefined4 **)(param_1 + 0x30);

  // get Driver object from Turbo object
  iVar1 = puVar2[1];

  // remove flags for boosting
  *(uint *)(iVar1 + 0x2c8) = *(uint *)(iVar1 + 0x2c8) & 0xfffffdff;

  // INSTANCE_Death
  FUN_80030aa8(*puVar2);
  FUN_80030aa8(*(undefined4 *)(param_1 + 0x34));

  return;
}


// Turbo_FuncPerFrame
void FUN_800693c8(int param_1)

{
  char cVar1;
  short sVar2;
  ushort uVar3;
  undefined *puVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  undefined4 uVar8;
  int *piVar9;
  int iVar10;
  int iVar11;
  int iVar12;

  // get object attached to thread
  piVar9 = *(int **)(param_1 + 0x30);

  // turbo -> driver
  iVar12 = piVar9[1];

  // get instance
  iVar11 = *(int *)(param_1 + 0x34);

  // driver -> instSelf
  iVar10 = *(int *)(iVar12 + 0x1c);

  do {
    if (
		(
			// if not burnt
			(*(short *)(iVar12 + 0x402) == 0) &&

			// if alpha of turbo is zero
			(*(short *)(iVar11 + 0x22) == 0)) &&

		// instance -> thread -> modelID == DYNAMIC_GHOST
		(*(short *)(*(int *)(iVar10 + 0x6c) + 0x44) != 0x4b)
	   )
	{
	  // cut driverInst transparency in half
      *(ushort *)(iVar10 + 0x22) = *(ushort *)(iVar10 + 0x22) >> 1;
    }

	// if instance is not split by water
    if ((*(uint *)(iVar10 + 0x28) & 0x2000) == 0)
	{
	  // instance flags
      *(uint *)(iVar11 + 0x28) = *(uint *)(iVar11 + 0x28) & 0xffffdfff;
      *(uint *)(*piVar9 + 0x28) = *(uint *)(*piVar9 + 0x28) & 0xffffdfff;
    }

	// if instance is split by water
	else
	{
	  // turbos are now split by water, set vertical split height
      *(uint *)(iVar11 + 0x28) = *(uint *)(iVar11 + 0x28) | 0x2000;
      *(undefined2 *)(iVar11 + 0x56) = *(undefined2 *)(iVar10 + 0x56);
	  *(uint *)(*piVar9 + 0x28) = *(uint *)(*piVar9 + 0x28) | 0x2000;
	  *(undefined2 *)(*piVar9 + 0x56) = *(undefined2 *)(iVar10 + 0x56);
    }

	// if driver instance is not reflective
	if ((*(uint *)(iVar10 + 0x28) & 0x4000) == 0)
	{
	  // remove reflection from turbo instances
      *(uint *)(iVar11 + 0x28) = *(uint *)(iVar11 + 0x28) & 0xffffbfff;
      *(uint *)(*piVar9 + 0x28) = *(uint *)(*piVar9 + 0x28) & 0xffffbfff;
    }

	// if driver instance is reflective
	else
	{
      // make turbo instances reflective
	  // copy reflection height axis to instance
	  *(uint *)(iVar11 + 0x28) = *(uint *)(iVar11 + 0x28) | 0x4000;
	  *(undefined2 *)(iVar11 + 0x56) = *(undefined2 *)(iVar10 + 0x56);
	  *(uint *)(*piVar9 + 0x28) = *(uint *)(*piVar9 + 0x28) | 0x4000;
	  *(undefined2 *)(*piVar9 + 0x56) = *(undefined2 *)(iVar10 + 0x56);
    }

	// matrix from instance
    gte_SetRotMatrix(iVar10 + 0x30);
    gte_SetTransMatrix(iVar10 + 0x30);

    iVar6 = (int)*(short *)((int)piVar9 + 10);
    iVar7 = iVar6;
    if (8 < iVar6) {
      iVar7 = 8;
    }
    if (iVar6 < 4) {
      iVar7 = 4;
    }
    
	// matrix of first turbo instance
	*(undefined2 *)(iVar11 + 0x30) = (short)(*(short *)(iVar10 + 0x30) * iVar7 >> 3);
    *(undefined2 *)(iVar11 + 0x32) = (short)(*(short *)(iVar10 + 0x32) * iVar7 >> 3);
    *(undefined2 *)(iVar11 + 0x34) = (short)(*(short *)(iVar10 + 0x34) * iVar7 >> 3);
    *(undefined2 *)(iVar11 + 0x36) = (short)(*(short *)(iVar10 + 0x36) * iVar7 >> 3);
    *(undefined2 *)(iVar11 + 0x38) = (short)(*(short *)(iVar10 + 0x38) * iVar7 >> 3);
    *(undefined2 *)(iVar11 + 0x3a) = (short)(*(short *)(iVar10 + 0x3a) * iVar7 >> 3);
    *(undefined2 *)(iVar11 + 0x3c) = (short)(*(short *)(iVar10 + 0x3c) * iVar7 >> 3);
    *(undefined2 *)(iVar11 + 0x3e) = (short)(*(short *)(iVar10 + 0x3e) * iVar7 >> 3);
    *(undefined2 *)(iVar11 + 0x40) = (short)(*(short *)(iVar10 + 0x40) * iVar7 >> 3);
	
	// driver -> instSelf
    iVar6 = *(int *)(iVar12 + 0x1c);
	
    gte_ldVXY0(*(short *)(iVar6 + 0x1c) * 9 >> 0xb & 0xffffU |
               (*(short *)(iVar6 + 0x1e) * 3 >> 8) << 0x10);
    gte_ldVZ0(*(short *)(iVar6 + 0x20) * -0x34 >> 0xc);
    gte_rt();
	
	// set translation vector
    gte_stlvl((VECTOR *)(iVar11 + 0x44));
	
	// matrix of second turbo instance, negate X axis
    *(undefined2 *)(*piVar9 + 0x30) = (short)(-(int)*(short *)(iVar10 + 0x30) * iVar7 >> 3);
    *(undefined2 *)(*piVar9 + 0x32) = (short)(*(short *)(iVar10 + 0x32) * iVar7 >> 3);
    *(undefined2 *)(*piVar9 + 0x34) = (short)(*(short *)(iVar10 + 0x34) * iVar7 >> 3);
    *(undefined2 *)(*piVar9 + 0x36) = (short)(-(int)*(short *)(iVar10 + 0x36) * iVar7 >> 3);
    *(undefined2 *)(*piVar9 + 0x38) = (short)(*(short *)(iVar10 + 0x38) * iVar7 >> 3);
    *(undefined2 *)(*piVar9 + 0x3a) = (short)(*(short *)(iVar10 + 0x3a) * iVar7 >> 3);
    *(undefined2 *)(*piVar9 + 0x3c) = (short)(-(int)*(short *)(iVar10 + 0x3c) * iVar7 >> 3);
    *(undefined2 *)(*piVar9 + 0x3e) = (short)(*(short *)(iVar10 + 0x3e) * iVar7 >> 3);
    *(undefined2 *)(*piVar9 + 0x40) = (short)(*(short *)(iVar10 + 0x40) * iVar7 >> 3);
	
	// driver -> instSelf
    iVar7 = *(int *)(iVar12 + 0x1c);
	
    gte_ldVXY0(*(short *)(iVar7 + 0x1c) * -0x12 >> 0xc & 0xffffU |
               (*(short *)(iVar7 + 0x1e) * 3 >> 8) << 0x10);
    gte_ldVZ0(*(short *)(iVar7 + 0x20) * -0x34 >> 0xc);
    gte_rt();
	
	// set translation vector
    gte_stlvl((VECTOR *)(*piVar9 + 0x44));

													// elapsed milliseconds per frame, ~32
    iVar7 = (uint)*(ushort *)((int)piVar9 + 0xe) - (uint)*(ushort *)(PTR_DAT_8008d2ac + 0x1d04);

    *(undefined2 *)((int)piVar9 + 0xe) = (short)iVar7;
    if (iVar7 * 0x10000 < 0) {
      *(undefined2 *)((int)piVar9 + 0xe) = 0;
    }

	if (*(short *)((int)piVar9 + 0xe) == 0)
	{
	  // make visible
      *(uint *)(iVar11 + 0x28) = *(uint *)(iVar11 + 0x28) & 0xffffff7f;
      *(uint *)(*piVar9 + 0x28) = *(uint *)(*piVar9 + 0x28) & 0xffffff7f;
    }

	if (*(ushort *)(iVar11 + 0x22) < 0x9c4)
	{
	  // controller vibration
      FUN_80026440(iVar12,4,4);
    }

    puVar4 = PTR_DAT_8008d2ac;

	// set new model pointer, one of seven
    *(undefined4 *)(iVar11 + 0x18) =
         *(undefined4 *)(PTR_DAT_8008d2ac + ((int)*(short *)(piVar9 + 2) + 0x2c) * 4 + 0x2160);

	// set new model pointer, one of seven
	*(undefined4 *)(*piVar9 + 0x18) =
         *(undefined4 *)(puVar4 + (((int)*(short *)(piVar9 + 2) + 3U & 7) + 0x2c) * 4 + 0x2160);

	// increment frame index
	sVar2 = *(short *)(piVar9 + 2);
    *(short *)(piVar9 + 2) = sVar2 + 1;

	// if gone past seven frames of fire
    if (7 < (short)(sVar2 + 1))
	{
	  // back to first frame of fire
      *(undefined2 *)(piVar9 + 2) = 0;
    }

    if ('\0' < *(char *)(piVar9 + 3)) {
      *(char *)(piVar9 + 3) = *(char *)(piVar9 + 3) + -1;
    }

	// instance -> thread -> modelIndex == "player" of any kind
    if (*(short *)(*(int *)(iVar10 + 0x6c) + 0x44) == 0x18) {
      iVar7 = 0x100 - (uint)(*(ushort *)(iVar11 + 0x22) >> 4);
      if (iVar7 < 0) {
        iVar7 = 0;
      }
      else {
        if (0x82 < iVar7) {
          iVar7 = 0x82;
        }
      }
      uVar5 = (uint)*(byte *)((int)piVar9 + 0xd) + 0x10;
      if ((int)uVar5 < 0) {
        uVar5 = 0;
      }
      else {
        if (0x80 < uVar5) {
          uVar5 = 0x80;
        }
      }

	  // distort
      uVar5 = uVar5 << 8;

	  // if echo is required
      if ((*(uint *)(iVar12 + 0x2c8) & 0x10000) != 0)
	  {
		// add echo
		uVar5 = uVar5 | 0x1000000;
      }

	  // driver audio
	  FUN_8002e690(iVar12 + 0x30c,0xe,iVar7 << 0x10 | uVar5 | 0x80);

      if (*(byte *)((int)piVar9 + 0xd) < 0xc0) {
        *(char *)((int)piVar9 + 0xd) = *(byte *)((int)piVar9 + 0xd) + 1;
      }
    }

    if (
			// if this is a ghost
			(*(short *)(*(int *)(iVar10 + 0x6c) + 0x44) == 0x4b) ||

			// kart state
			(((cVar1 = *(char *)(iVar12 + 0x376),

			// if not being mask grabbed, not crashing, not being warped
			cVar1 != '\x05' && (cVar1 != '\x01')) && (cVar1 != '\n')))
		)
	{
	  // if reserves are nearing zero
      if ((*(short *)(iVar12 + 0x3e2) < 0x10) || (*(char *)(piVar9 + 3) == '\0'))
	  {
		// get turboInst alpha
        uVar3 = *(ushort *)(iVar11 + 0x22);

		// if fully transparent, skip lines
        if (0xfff < uVar3) goto LAB_80069b50;

		if (*(char *)(piVar9 + 3) == '\0')
		{
		  // increase transparency
          *(short *)(iVar11 + 0x22) = uVar3 + 0x100;
          *(short *)(*piVar9 + 0x22) = *(short *)(*piVar9 + 0x22) + 0x100;
        }
        else
		{
		  // increase transparency
          *(short *)(iVar11 + 0x22) = uVar3 + 0x40;
          *(short *)(*piVar9 + 0x22) = *(short *)(*piVar9 + 0x22) + 0x40;
        }
      }
      else
	  {
		// if scale is big, skip lines
        if (0xfff < *(ushort *)(iVar11 + 0x22)) goto LAB_80069b50;
      }
    }

	// if not a ghost, and
	// kart state is mask grab, crashed, or warped
    else
	{
	  // restore backup of alpha
      *(undefined2 *)(iVar10 + 0x22) = *(undefined2 *)(iVar12 + 0x508);
LAB_80069b50:

	  // instance -> thread -> modelIndex == "player" of any kind
      if (*(short *)(*(int *)(iVar10 + 0x6c) + 0x44) == 0x18)
	  {
		// volume, distortion, left/right
        uVar8 = 0x8080;

		// if echo is required
		if ((*(uint *)(iVar12 + 0x2c8) & 0x10000) != 0)
		{
		  // add echo, volume, distortion, left/right
          uVar8 = 0x1008080;
        }

		// driver audio
        FUN_8002e690(iVar12 + 0x30c,0xffffffff,uVar8);
      }

	  // 0x800 = this thread needs to be deleted
      *(uint *)(param_1 + 0x1c) = *(uint *)(param_1 + 0x1c) | 0x800;
    }

	// halfway through 800715e8 UpdateAllThreadsInBucket
    FUN_80071694(param_1);

  } while( true );
}


// draws level skybox
// param_1 - lev ptr_skybox
// param_2 - camera110
// param_3 - primMem
void FUN_80069bb0(int param_1,int param_2,int param_3)

{
  // register v0
  undefined4 uVar1;
  
  // register backups
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_retaddr;

  // primMem curr
  uVar1 = *(undefined4 *)(param_3 + 0xc);
  
  // backup
  DAT_1f800000 = unaff_ra;
  DAT_1f800004 = unaff_s0;
  DAT_1f800008 = unaff_s1;
  DAT_1f80000c = unaff_s2;
  
  // level ptr_skybox
  if (param_1 != 0) 
  {
	// camera110 ViewProj
    gte_ldR11R12(*(undefined4 *)(param_2 + 0x28));
    gte_ldR13R21(*(undefined4 *)(param_2 + 0x2c));
    gte_ldR22R23(*(undefined4 *)(param_2 + 0x30));
    gte_ldR31R32(*(undefined4 *)(param_2 + 0x34));
    gte_ldR33(*(undefined4 *)(param_2 + 0x38));
	
	// remove transformation,
	// standard for sky in most games
    gte_ldtr(0,0,0);
	
	// These get modified in between skybox segments,
	// the C output is wrong
    DAT_1f800010 = *(int *)(param_2 + 8) + 0x500U >> 7 & 0x1c;
    DAT_1f800014 = DAT_1f800010 >> 1;
    
	// draw four skybox segments
	uVar1 = FUN_80069cc4(param_1, param_2, param_3, (param_2->0xF4) + 0xFFC);
    uVar1 = FUN_80069cc4(param_1, param_2, param_3, (param_2->0xF4) + 0xFFC);
    uVar1 = FUN_80069cc4(param_1, param_2, param_3, (param_2->0xF4) + 0xFFC);
    uVar1 = FUN_80069cc4(param_1, param_2, param_3, (param_2->0xF4) + 0xFFC);
  }
  
  // restore
  unaff_ra = DAT_1f800000;
  unaff_s0 = DAT_1f800004;
  unaff_s1 = DAT_1f800008;
  unaff_s2 = DAT_1f80000c;
  
  // new primMem curr
  *(undefined4 *)(param_3 + 0xc) = uVar1;
  
  return;
}


// draws skybox segment
// every skybox is splitted in 8 segments, only 4 are drawn at a time
// param_1 - lev ptr_skybox
// param_2 - camera110
// param_3 - primMem
// param_4 - camera110->ptrOT
void FUN_80069cc4(undefined4 param_1,undefined4 param_2,undefined4 param_3,int param_4)
{
  bool bVar1;
  uint *in_v0;
  SVECTOR *r0;
  int in_a3;
  SVECTOR *r0_00;
  SVECTOR *r0_01;
  int iVar2;
  uint uVar3;
  int in_t3;
  ushort *puVar4;
  ushort *puVar5;
  int in_t4;
  int in_t5;
  int iVar6;
  int in_t7;
  uint uVar7;
  uint uVar8;
  uint *puVar9;
  uint *puVar10;
  uint *in_t9;
  
  puVar4 = *(ushort **)(in_t3 + 0x18);
  
  if (*(ushort *)(in_t5 + 8) != 0) 
  {
    r0 = (SVECTOR *)((uint)*puVar4 + in_t4);
    r0_00 = (SVECTOR *)((uint)puVar4[1] + in_t4);
    r0_01 = (SVECTOR *)((*(uint *)(puVar4 + 2) & 0xffff) + in_t4);
    iVar6 = *(ushort *)(in_t5 + 8) - 1;
    puVar9 = (uint *)(((int)*(uint *)(puVar4 + 2) >> 0x10) + param_4);
    
	while( true ) 
	{
      puVar10 = puVar9;
      gte_ldv0(r0);
      gte_ldRGB0(r0 + 1);
      gte_ldv1(r0_00);
      gte_ldRGB1(r0_00 + 1);
      gte_ldv2(r0_01);
      gte_ldRGB2(r0_01 + 1);
      bVar1 = iVar6 == 0;
      iVar6 = iVar6 + -1;
      if (bVar1) break;
      gte_rtpt_b();
      puVar5 = puVar4 + 4;
      r0 = (SVECTOR *)((uint)*puVar5 + in_t4);
      r0_00 = (SVECTOR *)((uint)puVar4[5] + in_t4);
      puVar9 = (uint *)(((int)*(uint *)(puVar4 + 6) >> 0x10) + param_4);
      r0_01 = (SVECTOR *)((*(uint *)(puVar4 + 6) & 0xffff) + in_t4);
      uVar7 = gte_stSXY0();
      iVar2 = gte_stFLAG();
      uVar8 = gte_stSXY1();
      uVar3 = gte_stSXY2();
      puVar4 = puVar5;
      in_t9 = puVar10;
      
	  if ((((uint)(iVar2 << 0xd) >> 0x1d == 0) &&
          (uVar3 = ~(uVar7 - in_t7 | uVar8 - in_t7 | uVar3 - in_t7) | uVar7 & uVar8 & uVar3,
          -1 < (int)uVar3)) && (-1 < (int)(uVar3 << 0x10))) 
	  {
        gte_stRGB0();
        gte_stSXY0();
        gte_stRGB1();
        gte_stSXY1();
        gte_stRGB2();
        gte_stSXY2();
		
		// write PrimMem and OTMem
        uVar3 = (uint)in_v0 & 0xffffff;
        *in_v0 = *puVar10 | 0x6000000;
        in_v0 = in_v0 + 7;
        *puVar10 = uVar3;
      }
    }
    
	gte_rtpt_b();
    uVar7 = gte_stSXY0();
    iVar6 = gte_stFLAG();
    uVar8 = gte_stSXY1();
    uVar3 = gte_stSXY2();
	
    if ((((uint)(iVar6 << 0xd) >> 0x1d == 0) &&
        (uVar3 = ~(uVar7 - in_t7 | uVar8 - in_t7 | uVar3 - in_t7) | uVar7 & uVar8 & uVar3,
        -1 < (int)uVar3)) && (-1 < (int)(uVar3 << 0x10))) 
	{
      gte_stRGB0();
      gte_stSXY0();
      gte_stRGB1();
      gte_stSXY1();
      gte_stRGB2();
      gte_stSXY2();
	  
	  // write PrimMem and OTMem
      *in_v0 = *in_t9 | 0x6000000;
      *in_t9 = (uint)in_v0 & 0xffffff;
    }
  }
  return;
}


// AnimateQuads
// param1 - timer
// param2 - num vertices
// param3 - ptr OVert
// param4 - VisMem 0x30 - 0x3F (visSCVertList)
// animates vertex position and color (i.e. roo's pipes floor and vegetation)
void FUN_80069e70(undefined4 param_1,int param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  undefined4 unaff_s7;
  undefined4 unaff_retaddr;

  // clear GTE color registers
  gte_ldfcdir(0,0,0);

  param_3 = param_3 + -0x10;
  iVar2 = 0x20;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800028 = unaff_retaddr;
  
  // loop through all vertices
  while (bVar1 = param_2 != 0, param_2 = param_2 + -1, bVar1) 
  {
    bVar1 = iVar2 == 0;
    iVar2 = iVar2 + -1;
    if (bVar1) {
      iVar2 = 0x1f;
    }
	
	// next OVert
    param_3 = param_3 + 0x10;
	
	// AnimateQuadVertex
    FUN_80069f0c(param_1,param_2,param_3);
  }
  return;
}


// AnimateQuadVertex
// param1 - timer
// param2 - num vertices
// param3 - ptr OVert
void FUN_80069f0c(undefined4 param_1,undefined4 param_2,uint **param_3)

{
  uint in_t5;
  uint *puVar1;
  uint uVar2;
  int unaff_s1;
  int unaff_s2;
  uint *puVar3;
  uint *puVar4;
  code *UNRECOVERED_JUMPTABLE;

  if ((in_t5 & 1) != 0)
  {
	  // jmp 8 bytes back, which is basically...
	  return;
  }

  // OVert -> xy offset
  puVar4 = param_3[2];
  
  // OVert -> LevVert
  puVar1 = *param_3;
  
  // OVert -> zw offset
  puVar3 = param_3[1];
  
  // r16 = r23 >> 0x10
  uVar2 = (int)puVar4 >> 0x10;

  // r19 = r16 & 0x3ff
  
  // unused parameter copy
  // in the delay slot of jal
  // r4 = r19

  // TRIG_AngleSinCos_r19r17r18
  FUN_80069f94();

  // r16 & 0x8000,
  // 180-360 degrees
  if ((int)uVar2 < 0) 
  {
	// warp position
	
	// LevVert -> position = trig output multiplied by
	// OVert -> position offsets
    *puVar1 = (int)puVar3 + (unaff_s1 >> 7) | (uint)puVar3 & 0xffff0000;
    *(short *)(puVar1 + 1) = (short)puVar4 + (short)(unaff_s2 >> 7);
  }
  
  // 90 - 180, or 270 - 360
  if ((uVar2 & 0x4000) != 0)
  {
	// warp color
	  
    gte_ldIR0(unaff_s1 + 0x1000 >> 2);

	// OVert -> color offset
	// load vector into gte color registers
    gte_ldRGB(param_3 + 3);

	// kernel of dpq color
	gte_dpcs();

    gte_stRGB2();
    gte_stRGB2();
  }

  // jumps to right before
  // the call to FUN_80069f0c
  jmp r20;
}


// TRIG_AngleSinCos_r19r17r18
void FUN_80069f94(void)
{
		// input:
		// s3 = angle [0000 - ffff]
		// [0 - 360] degrees

		// output:
		// s1 = trigApprox (sine or cosine)

		// input,output
		// s3,s1
		// (000-180)	0x000,0x000		0x200,0xB50		0x400,0x1000,	0x600,0xB50
		// (180-360)	0x800,0x000		0xA00,-0xB50	0xC00,-0x1000,	0xE00,-0xB50

		// v1 = 800845a0 (trigApprox)
        80069f94 08 80 03 3c     lui        v1,0x8008
        80069f98 a0 45 63 24     addiu      v1,v1,0x45a0

        80069f9c ff 03 71 32     andi       s1,s3,0x3ff
        80069fa0 80 88 11 00     sll        s1,s1,0x2
        80069fa4 21 18 71 00     addu       v1,v1,s1
        80069fa8 00 00 71 8c     lw         s1,0x0(v1)=>DAT_800845a0
        80069fac 00 04 63 32     andi       v1,s3,0x400
        80069fb0 07 00 60 14     bne        v1,zero,LAB_80069fd0
        80069fb4 00 08 63 32     _andi      v1,s3,0x800
        80069fb8 03 94 11 00     sra        s2,s1,0x10
        80069fbc 00 8c 11 00     sll        s1,s1,0x10
        80069fc0 09 00 60 14     bne        v1,zero,LAB_80069fe8
        80069fc4 03 8c 11 00     _sra       s1,s1,0x10
        80069fc8 08 00 e0 03     jr         ra
        80069fcc 00 00 00 00     _nop

		80069fd0 00 94 11 00     sll        s2,s1,0x10
        80069fd4 03 94 12 00     sra        s2,s2,0x10
        80069fd8 06 00 60 14     bne        v1,zero,LAB_80069ff4
        80069fdc 03 8c 11 00     _sra       s1,s1,0x10
        80069fe0 08 00 e0 03     jr         ra
        80069fe4 22 90 12 00     _sub       s2,zero,s2

		80069fe8 22 90 12 00     sub        s2,zero,s2
        80069fec 08 00 e0 03     jr         ra
        80069ff0 22 88 11 00     _sub       s1,zero,s1

		80069ff4 08 00 e0 03     jr         ra
        80069ff8 22 88 11 00     _sub       s1,zero,s1
}


// Draw Confetti
// param1 - cam110
// param2 - primMem
// param3 - &gGT->confetti
// param4 - frame timer
// param5 - isPaused
void FUN_80069ffc(short *param_1,int param_2,uint *param_3,short param_4,int param_5)

{
  bool bVar1;
  undefined uVar2;
  short sVar3;
  short sVar4;
  short sVar5;
  short sVar6;
  ushort uVar7;
  int iVar8;
  uint *puVar9;
  undefined4 *puVar10;
  uint uVar11;
  short sVar12;
  short sVar13;
  undefined4 *puVar14;
  uint uVar15;
  int iVar16;
  int iVar17;
  int iVar18;
  uint uVar19;
  undefined4 uVar20;
  int iVar21;
  int iVar22;
  uint uVar23;
  int iVar24;
  int iVar25;
  uint uVar26;
  uint *puVar27;
  int unaff_s0;
  int iVar28;
  int unaff_s1;
  int iVar29;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  uint uVar30;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  int iVar31;
  undefined4 unaff_s7;
  uint uVar32;
  uint uVar33;
  short sVar34;
  uint uVar35;
  undefined *puVar36;
  uint uVar37;
  undefined *puVar38;
  undefined4 unaff_s8;
  uint uVar39;
  undefined4 unaff_retaddr;
  int iVar40;
  undefined auStackX0 [16];

  iVar8 = 0x1f800000;

  // backup $gp
  DAT_1f800020 = &DAT_8008cf6c;

  gte_ldtr(0,0,0);
  puVar10 = &DAT_8008a2a0;
  puVar14 = &DAT_1f800058;
  iVar16 = 8;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800024 = (undefined *)register0x00000074;
  DAT_1f800028 = unaff_s8;
  DAT_1f80002c = unaff_retaddr;
  do {
    uVar20 = *puVar10;
    puVar10 = puVar10 + 1;
    *puVar14 = uVar20;
    puVar14 = puVar14 + 1;
    bVar1 = 0 < iVar16;
    iVar16 = iVar16 + -1;
  } while (bVar1);

  // cameara110 matrix m1 (0x28)
  gte_ldR11R12(*(undefined4 *)(param_1 + 0x14));
  gte_ldR13R21(*(undefined4 *)(param_1 + 0x16));
  gte_ldR22R23(*(undefined4 *)(param_1 + 0x18));
  gte_ldR31R32(*(undefined4 *)(param_1 + 0x1a));
  gte_ldR33(*(undefined4 *)(param_1 + 0x1c));

  // TRIG_AngleSinCos_r15r16r17
  puVar9 = (uint *)FUN_8006a4c4();

  iVar28 = unaff_s0 >> 2;
  sVar6 = (short)iVar28 + 0x400;
  iVar16 = unaff_s1 >> 2;
  iVar31 = iVar16 + 0x400;

  // numParticles_max
  uVar30 = param_3[2];

  // sizeX
  iVar25 = *(int *)(param_1 + 0x10);

  // ptrOT
  iVar24 = *(int *)(param_1 + 0x7a);

  // window size X and Y
  gte_ldOFX((int)param_1[0x10] << 0xf);
  gte_ldOFY((int)param_1[0x11] << 0xf);

  // distance to screen
  gte_ldH(*(undefined4 *)(param_1 + 0xc));

  // numParticles_curr
  uVar26 = *param_3;

  // previous frame?
  uVar11 = (uint)*(ushort *)(param_3 + 1);

  // if not paused
  if (param_5 == 0) {
    uVar15 = (uint)*(ushort *)((int)param_3 + 6);

	// change in particles?
    iVar17 = uVar11 - uVar26;

	// if change?
	if (uVar11 != uVar26)
	{
      if (iVar17 < 0) {
        uVar26 = uVar26 - uVar15;
        if (0 < (int)(iVar17 + uVar15)) {
          uVar26 = uVar11;
        }
      }
      else {
        uVar26 = uVar26 + uVar15;
        if ((int)(iVar17 - uVar15) < 0) {
          uVar26 = uVar11;
        }
      }

	  // set new numParticles?
      *param_3 = uVar26;
    }
  }

  // camera position
  sVar3 = *param_1;
  sVar4 = param_1[1];
  sVar5 = param_1[2];

  *(undefined4 *)(iVar8 + 0x34) = 0x28000000;
  uVar39 = 6;
  uVar35 = 0x95000000;
  puVar36 = (undefined *)0xb9000000;
  uVar11 = 0x3583fe30;
  puVar38 = (undefined *)0x59000000;
  uVar15 = 0x59b99549;
  while( true ) {
    uVar39 = uVar39 - 1;
    if (uVar39 == 0) {
      uVar39 = 6;
    }
    bVar1 = uVar26 == 0;
    uVar26 = uVar26 - 1;
    if (bVar1) break;
    *(uint *)(iVar8 + 0x30) = uVar26;
    uVar7 = (short)((int)puVar36 >> 0x15) + ((short)uVar30 * param_4 - sVar4) & 0x7ff;
    uVar37 = ((int)puVar38 >> 0x15) + (iVar31 - sVar5) & 0x7ff;
    sVar34 = ((short)((int)uVar35 >> 0x15) + (sVar6 - sVar3) & 0x7ffU) - sVar6;
    iVar17 = -iVar31;

	// TRIG_AngleSinCos_r15r16r17
    FUN_8006a4c4();

    sVar34 = sVar34 + (short)(iVar28 >> 5);
    iVar21 = iVar16 >> 5;
    iVar18 = iVar28;
    iVar22 = iVar16;

	// TRIG_AngleSinCos_r15r16r17
    puVar9 = (uint *)FUN_8006a4c4();

    iVar29 = iVar16;
    if (iVar16 < 1) {
      iVar29 = -iVar16;
    }
    uVar2 = *(undefined *)((iVar29 >> 7) + iVar8 + 0x58);
    *(undefined *)(iVar8 + 0x34) = 0;
    if ((uVar39 & 1) != 0) {
      *(undefined *)(iVar8 + 0x34) = uVar2;
    }
    *(undefined *)(iVar8 + 0x35) = 0;
    if ((uVar39 & 2) != 0) {
      *(undefined *)(iVar8 + 0x35) = uVar2;
    }
    *(undefined *)(iVar8 + 0x36) = 0;
    if ((uVar39 & 4) != 0) {
      *(undefined *)(iVar8 + 0x36) = uVar2;
    }
    iVar40 = iVar28 * iVar18;
    iVar29 = iVar16 >> 8;
    sVar13 = (short)((uint)iVar16 >> 8);
    sVar12 = (uVar7 - 0x400) - sVar13;
    *(short *)(iVar8 + 0x3a) = sVar12;
    *(short *)(iVar8 + 0x42) = sVar12;
    sVar13 = (uVar7 - 0x400) + sVar13;
    *(short *)(iVar8 + 0x4a) = sVar13;
    *(short *)(iVar8 + 0x52) = sVar13;
    iVar16 = iVar28 * iVar22;
    iVar28 = iVar28 >> 8;
    sVar12 = (short)((uint)iVar22 >> 8);
    sVar13 = (short)(iVar40 >> 0x14);
    *(short *)(iVar8 + 0x38) = (sVar34 - sVar12) - sVar13;
    *(short *)(iVar8 + 0x40) = (sVar34 + sVar12) - sVar13;
    *(short *)(iVar8 + 0x48) = (sVar34 - sVar12) + sVar13;
    *(short *)(iVar8 + 0x50) = sVar34 + sVar12 + sVar13;
    iVar18 = iVar18 >> 8;
    iVar16 = iVar16 >> 0x14;
    *(uint *)(iVar8 + 0x3c) = ((uVar37 + iVar17 + iVar21) - iVar18) + iVar16;
    *(uint *)(iVar8 + 0x44) = uVar37 + iVar17 + iVar21 + iVar18 + iVar16;
    *(uint *)(iVar8 + 0x4c) = ((uVar37 + iVar17 + iVar21) - iVar18) - iVar16;
    *(uint *)(iVar8 + 0x54) = (uVar37 + iVar17 + iVar21 + iVar18) - iVar16;
    gte_ldVXY0(iVar8 + 0x38);
    gte_ldVZ0(iVar8 + 0x3c);
    gte_ldVXY1(iVar8 + 0x40);
    gte_ldVZ1(iVar8 + 0x44);
    gte_ldVXY2(iVar8 + 0x48);
    gte_ldVZ2(iVar8 + 0x4c);
    uVar32 = uVar15 >> 8;
    gte_rtpt_b();
    uVar15 = uVar11 >> 8 | uVar15 << 0x18;
    uVar35 = (uVar11 + uVar32 + (uVar15 >> 8)) * 0x1000000;
    uVar33 = (uVar32 | uVar35) >> 8;
    uVar32 = uVar15 >> 8 | uVar32 << 0x18;
    puVar36 = (undefined *)((uVar15 + uVar33 + (uVar32 >> 8)) * 0x1000000);
    uVar11 = uVar32 >> 8 | uVar33 << 0x18;
    puVar38 = (undefined *)((uVar32 + ((uVar33 | (uint)puVar36) >> 8) + (uVar11 >> 8)) * 0x1000000);
    uVar15 = (uVar33 | (uint)puVar36) >> 8 | (uint)puVar38;
    uVar32 = gte_stSXY0();
    iVar17 = gte_stFLAG();
    uVar33 = gte_stSXY1();
    uVar19 = gte_stSXY2();
    gte_stSXY0();
    gte_ldVXY0(iVar8 + 0x50);
    gte_ldVZ0(iVar8 + 0x54);
    iVar16 = iVar29;
    if (-1 < iVar17 << 0xe) {
      gte_rtps_b();
      uVar23 = gte_stSXY2();
      iVar17 = gte_stFLAG();
      uVar32 = ~(uVar32 - iVar25 | uVar33 - iVar25 | uVar19 - iVar25 | uVar23) |
               uVar32 & uVar33 & uVar19 & uVar23;
      if (-1 < iVar17 << 0xe) {
        gte_avsz4_b();
        if ((-1 < (int)uVar32) && (-1 < (int)(uVar32 << 0x10))) {
          gte_stSXY0();
          gte_stSXY1();
          gte_stSXY2();
          uVar26 = gte_stMAC0();
          puVar9[1] = *(uint *)(iVar8 + 0x34);
          puVar27 = (uint *)((uVar26 >> 0x12) * 4 + iVar24);
          *puVar9 = *puVar27 | 0x5000000;
          *puVar27 = (uint)puVar9 & 0xffffff;
          uVar26 = *(uint *)(iVar8 + 0x30);
          puVar9 = puVar9 + 6;
        }
      }
    }
  }
  *(uint **)(param_2 + 0xc) = puVar9;
  return;
}

// TRIG_AngleSinCos_r15r16r17
void FUN_8006a4c4(void)

{
		// input:
		// t7 = angle [0000 - ffff]
		// [0 - 360] degrees

		// output:
		// s0 = trigApprox (sine or cosine)

		// input,output
		// t7,s0
		// (000-180)	0x000,0x000		0x200,0xB50		0x400,0x1000,	0x600,0xB50
		// (180-360)	0x800,0x000		0xA00,-0xB50	0xC00,-0x1000,	0xE00,-0xB50

		// v1 = 800845a0 (trigApprox)
        8006a4c4 08 80 03 3c     lui        v1,0x8008
        8006a4c8 a0 45 63 24     addiu      v1,v1,0x45a0

		// s0 = t7 & 3fff
		// clamp [0 - 90 degrees]
        8006a4cc ff 03 f0 31     andi       s0,t7,0x3ff

		// multiply by 4, byte offset, int array
        8006a4d0 80 80 10 00     sll        s0,s0,0x2

		// v1 = &trigApprox[t7 & 0x3ff]
        8006a4d4 21 18 70 00     addu       v1,v1,s0

		// s0 = *v1
		// read trigApprox
        8006a4d8 00 00 70 8c     lw         s0,0x0(v1)=>DAT_800845a0

		// if (90 < angle < 180) or (270 < angle < 360), jump 8006a500
        8006a4dc 00 04 e3 31     andi       v1,t7,0x400
        8006a4e0 07 00 60 14     bne        v1,zero,LAB_8006a500

		// if (0 < angle < 90) or (180 < angle < 270)
		// {
			8006a4e4 00 08 e3 31     _andi      v1,t7,0x800
			8006a4e8 03 8c 10 00     sra        s1,s0,0x10
			8006a4ec 00 84 10 00     sll        s0,s0,0x10
			8006a4f0 09 00 60 14     bne        v1,zero,LAB_8006a518
			8006a4f4 03 84 10 00     _sra       s0,s0,0x10
			8006a4f8 08 00 e0 03     jr         ra
			8006a4fc 00 00 00 00     _nop
		// }

        8006a500 00 8c 10 00     sll        s1,s0,0x10
        8006a504 03 8c 11 00     sra        s1,s1,0x10
        8006a508 06 00 60 14     bne        v1,zero,LAB_8006a524
        8006a50c 03 84 10 00     _sra       s0,s0,0x10
        8006a510 08 00 e0 03     jr         ra
        8006a514 22 88 11 00     _sub       s1,zero,s1

        8006a518 22 88 11 00     sub        s1,zero,s1
        8006a51c 08 00 e0 03     jr         ra
        8006a520 22 80 10 00     _sub       s0,zero,s0

        8006a524 08 00 e0 03     jr         ra
        8006a528 22 80 10 00     _sub       s0,zero,s0
}

// RenderBucket_DrawFunc_Normal
void FUN_8006a52c(void)

{
  bool bVar1;
  undefined uVar2;
  short sVar3;
  short sVar4;
  ushort uVar5;
  ushort uVar6;
  int in_at;
  undefined4 in_v0;
  undefined4 extraout_v1;
  undefined4 extraout_v1_00;
  int iVar7;
  code *pcVar8;
  int *piVar9;
  int iVar10;
  uint uVar11;
  int iVar12;
  int in_t0;
  uint uVar13;
  uint uVar14;
  int iVar15;
  undefined4 *puVar16;
  undefined4 uVar17;
  undefined4 uVar18;
  uint in_t3;
  code *unaff_s5;
  code *unaff_s6;
  ushort *puVar19;
  short *psVar20;
  uint *in_t9;
  uint *puVar21;
  undefined4 *puVar22;
  undefined8 uVar23;
  int iStack4;

code_r0x8006a52c:
  puVar21 = in_t9 + 1;
  if (in_t0 == 0) {
    while( true ) {
      piVar9 = *(int **)(in_at + 4);

	  // get pointer to Instance
      iVar7 = *piVar9;

	  // also pointer to instance?
	  iVar12 = piVar9[1];

      *(int **)(in_at + 4) = piVar9 + 2;

	  if (iVar7 == 0) break;

	  // instance -> camera110
      iVar10 = *(int *)(iVar12 + 0x74);
	  
      iVar15 = *(int *)(in_at + 8);
      *(int *)(in_at + 0x10) = iVar7;
      *(int *)(in_at + 8) = iVar10;
      
	  // if not the same camera110 as previous instance
	  if (iVar10 != iVar15) 
	  {
		// take camera110 width, height,
		// and distToScreen, put them all in GTE,
		// and scratchpad
		
		// width, height, distToScreen
        sVar3 = *(short *)(iVar10 + 0x20);
        sVar4 = *(short *)(iVar10 + 0x22);
        uVar17 = *(undefined4 *)(iVar10 + 0x18);
		
		// scratchpad
        *(short *)(in_at + 0x1c) = sVar3;
        *(short *)(in_at + 0x1e) = sVar4;
        
		// GTE
		setCopControlWord(2,0xc000,(int)sVar3 << 0xf);
        setCopControlWord(2,0xc800,(int)sVar4 << 0xf);
        setCopControlWord(2,0xd000,uVar17);
      }

	  // instance flags, duplicate of 0x28
	  uVar11 = *(uint *)(iVar12 + 0xb8);

      sVar3 = *(short *)(iVar12 + 0xbc);

	  if (
			((uVar11 & 0x40) != 0) &&

			// if instance is not invisible
			((uVar11 & 0x80) == 0)
		 )
	  {
		// instance matrix at offset 0x78
		gte_ldR11R12(*(undefined4 *)(iVar12 + 0x78));
		gte_ldR13R21(*(undefined4 *)(iVar12 + 0x7c));
		gte_ldR22R23(*(undefined4 *)(iVar12 + 0x80));
		gte_ldR31R32(*(undefined4 *)(iVar12 + 0x84));
		gte_ldR33(*(undefined4 *)(iVar12 + 0x88));
		
		gte_ldtr(
		  *(undefined4 *)(iVar12 + 0x8c),
		  *(undefined4 *)(iVar12 + 0x90),
		  *(undefined4 *)(iVar12 + 0x94)
		);

        *(uint *)(in_at + 0x24) = uVar11;
        *(int *)(in_at + 0x120) = (int)sVar3;

        if ((uVar11 & 0x7000) != 0)
		{
		  // instance matrix at offset 0x98
		  gte_ldL11L12(*(undefined4 *)(iVar12 + 0x98));
		  gte_ldL13L21(*(undefined4 *)(iVar12 + 0x9c));
		  gte_ldL22L23(*(undefined4 *)(iVar12 + 0xa0));
		  gte_ldL31L32(*(undefined4 *)(iVar12 + 0xa4));
		  gte_ldL33(*(undefined4 *)(iVar12 + 0xa8));

          sVar3 = *(short *)(iVar12 + 0xbe);
          uVar2 = *(undefined *)(iVar7 + 0x53);
          uVar17 = *(undefined4 *)(iVar7 + 0x58);
          *(short *)(in_at + 0x44) = sVar3;
          *(short *)(in_at + 0xda) = sVar3;
          *(short *)(in_at + 0xf2) = sVar3;
          *(undefined *)(in_at + 0x48) = uVar2;
          *(undefined4 *)(in_at + 0x4c) = uVar17;
          *(int *)(in_at + 0x11c) = (int)sVar3 << 0x11;
          *(undefined4 *)(in_at + 0xe0) = 0;
          *(undefined4 *)(in_at + 0xf8) = 0;
        }

		// next origin
		psVar20 = *(short **)(iVar12 + 0xc4);

		// current origin
		puVar19 = *(ushort **)(iVar12 + 0xc0);

		// if there is no pointer to next origin,
		// if there is no 60fps
        if (psVar20 == (short *)0x0)
		{
		  // store origin
          uVar5 = puVar19[1];
          uVar6 = puVar19[2];
          *(ushort *)(in_at + 0x30) = *puVar19 & 0x7fff;
          *(ushort *)(in_at + 0x32) = uVar5;
          *(int *)(in_at + 0x34) = (int)(short)uVar6;
        }

		// if there is a next origin,
		// for 60fps stuff
        else
		{
		  // add them both, for interpolation.
		  // they were both halved before this function was called
          *(ushort *)(in_at + 0x30) = *puVar19 + *psVar20;
          *(ushort *)(in_at + 0x32) = puVar19[1] + psVar20[1];
          *(int *)(in_at + 0x34) = ((int)(short)puVar19[2] + (int)psVar20[2]) * 2;
        }

		// reset reflection color
        *(undefined4 *)(in_at + 0x58) = 0;

		// ptrColorLayout
        puVar22 = *(undefined4 **)(iVar12 + 0xd0);

		// deref ptrCommandList, get numColors
        iVar10 = **(int **)(iVar12 + 200);

        puVar16 = (undefined4 *)(in_at + 0x140);

		// write color array
        while (bVar1 = 0 < iVar10, iVar10 = iVar10 + -1, bVar1) {
          uVar17 = *puVar22;
          puVar22 = puVar22 + 1;
          *puVar16 = uVar17;
          puVar16 = puVar16 + 1;
        }

		// execute instance->funcPtr
        (**(code **)(iVar7 + 0x5c))();

		sVar3 = *(short *)(iVar12 + 0xde);
        *(short *)(in_at + 0x134) = (short)((int)*(short *)(iVar12 + 0xdc) << 2);
        *(short *)(in_at + 0x136) = (short)((int)sVar3 << 2);
        uVar17 = *(undefined4 *)(iVar12 + 0xe4);
        uVar18 = *(undefined4 *)(iVar12 + 0xe8);
        pcVar8 = *(code **)(iVar12 + 0xec);
        *(undefined4 *)(in_at + 0x38) = uVar17;
        *(undefined4 *)(in_at + 0x3c) = uVar17;
        *(undefined4 *)(in_at + 0x40) = uVar18;
        in_v0 = (*pcVar8)(*(undefined4 *)(iVar7 + 100));
      }
    }
    *(undefined4 *)(*(int *)(in_at + 0xc) + 0xc) = in_v0;
    return;
  }
  *(uint *)(in_at + 0x10c) = in_t3;
  (*unaff_s6)();
  setCopReg(2,0,in_t0);
  setCopReg(2,0x800,extraout_v1);
  (*unaff_s6)();
  setCopReg(2,0x1000,in_t0);
  setCopReg(2,0x1800,extraout_v1_00);
  uVar23 = (*unaff_s6)();
  in_v0 = (undefined4)uVar23;
  setCopReg(2,0x2000,in_t0);
  setCopReg(2,0x2800,(int)((ulonglong)uVar23 >> 0x20));
  in_t3 = *(uint *)(in_at + 0x10c);
  copFunction(2,0x280030);
  in_t9 = puVar21 + 1;
  do {
    uVar11 = in_t3 & 0x1ff;
    iVar12 = uVar11 * 4;
    if (uVar11 != 0) {
      iVar12 = (&iStack4)[uVar11];
    }
    iVar7 = *(int *)(in_at + 0x1c);
    uVar11 = getCopReg(2,0x7000);
    iVar10 = getCopControlWord(2,0xf800);
    if (-1 < iVar10 << 0xd) {
      if ((int)(in_t3 << 3) < 0) {
        copFunction(2,0x1400006);
        uVar13 = getCopReg(2,0xc000);
        if ((uVar13 == 0) ||
           (uVar14 = getCopReg(2,0x6000),
           (int)(uVar13 ^ (int)*(short *)(in_at + 0x24) ^ in_t3 << 2) < 1)) goto LAB_8006a610;
      }
      else {
        uVar14 = getCopReg(2,0x6000);
      }
      uVar13 = getCopReg(2,0x6800);
      copFunction(2,0x158002d);
      uVar11 = ~(uVar14 - iVar7 | uVar13 - iVar7 | uVar11 - iVar7) | uVar14 & uVar11 & uVar13;
      if (-1 < (int)uVar11) {
        uVar17 = getCopReg(2,0x18);
        *(undefined4 *)(in_at + 0x2c) = uVar17;
        if (-1 < (int)(uVar11 << 0x10)) {
          *(int *)(in_at + 0x50) = iVar12;
          in_v0 = (*unaff_s5)();
        }
      }
    }
LAB_8006a610:
    do {
      in_t3 = *in_t9;
      in_t9 = in_t9 + 1;
      in_t0 = in_t3 + 1;
      if ((int)in_t3 < 0) goto code_r0x8006a52c;
      uVar11 = in_t3 >> 0x10;
    } while (uVar11 == 0);
    if ((int)(in_t3 << 1) < 0) {
      uVar17 = getCopReg(2,0x6000);
      uVar18 = getCopReg(2,0x8800);
      setCopReg(2,0x6800,uVar17);
      setCopReg(2,0x9000,uVar18);
    }
    uVar23 = (*unaff_s6)();
    in_v0 = (undefined4)uVar23;
    setCopReg(2,0,uVar11);
    setCopReg(2,0x800,(int)((ulonglong)uVar23 >> 0x20));
    copFunction(2,0x180001);
  } while( true );
}

// animated model rendering related?
// called as funcPtr in register $s6 (r22)
// from DrawFunc_Normal
void FUN_8006a8e0(void)

{
  int in_at;
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  char cVar6;
  uint in_t3;
  uint in_t4;
  uint in_t5;
  uint unaff_s1; // int temporalbits
  int unaff_s3;
  uint uVar7;
  uint uVar8;
  int iVar9;
  uint uVar10;
  uint *unaff_s7;
  uint *unaff_s8;

  iVar5 = (in_t3 >> 0xd & 0x7f8) + in_at;
  if (-1 < (int)(in_t3 << 5)) { // check that it is actually a compressed animation
    if (unaff_s8 == (uint *)0x0) {  // 4D delta array pointer is zero i.e. doesn't exist. skip de-compression. and do something??
      uVar1 = *unaff_s7;
    }
    else {
      // some variable names change and flip because variables are re-used( compiler optimisations? ). from: branch


      // uint delta = *deltaArray[0];
      uVar10 = *unaff_s8;
      // uint AAA = delta >> 6 & 7;
      uVar2 = uVar10 >> 6 & 7; // AAA
      // uint bits_needed = AAA + 1;
      uVar3 = uVar2 + 1;
      // current_bits_difference = old_bits_left + bits_needed
      uVar7 = unaff_s3 + uVar3; // bits left in the temporal uint?
      // char temporal_x = (char)((int)temporalbits >> (bits_needed ^ 0x1f));
      cVar6 = (char)((int)unaff_s1 >> (uVar2 ^ 0x1f));
      // temporalBitData = temporalbits;
      uVar1 = unaff_s1;
      // bits_read = current_bits_difference;
      uVar8 = uVar7;
      // if(current_bits_difference < 0)
      if (0 < (int)uVar7) { // do we beed more bits from the temporalArray?
        // temporalBitData = *temporalArray;
        uVar1 = *unaff_s7;
        // temporalArray = temporalArray + 1;
        unaff_s7 = unaff_s7 + 1;
        // temporal_x = (char)((int)(temporalbits | temporalBitData >> (bits_needed - current_bits_difference & 0x1f)) >> (AAA ^ 0x1f));
        cVar6 = (char)((int)(unaff_s1 | uVar1 >> (uVar3 - uVar7 & 0x1f)) >> (uVar2 ^ 0x1f));
        // bits_read = current_bits_difference - 32;
        uVar8 = uVar7 - 0x20; // bitstream bit pointer moved by 32 bits
        // bits_needed = current_bits_difference;
        uVar3 = uVar7;
      }
      // temporalBitData = temporalBitData << (bits_needed & 0x1f);
      uVar1 = uVar1 << (uVar3 & 0x1f); // injecting fresh new bits to temporalBitData
      //if(AAA != 7)
      if (uVar2 != 7) { //if not reset X-counter reset; but if is reset just pass delta.X( accumulator.X gets erased)
        // temporal_x = temporal_x + delta.X * 2 + accumulator.X
        cVar6 = cVar6 + (char)((int)uVar10 >> 0x19) * '\x02' + *(char *)(in_at + 0x58);
      }
      // accumulator.X = temporal_x;
      *(char *)(in_at + 0x58) = cVar6;
      // uint BBB = delta >> 3 & 7;
      uVar4 = uVar10 >> 3 & 7; // BBB
      // bits_needed = BBB + 1;
      uVar2 = uVar4 + 1;
      // current_bits_difference = old_bits_left + bits_needed;
      uVar8 = uVar8 + uVar2;
      // bits_needed = temporalBitData;
      uVar3 = uVar1;
      // bits_read = current_bits_difference;
      uVar7 = uVar8;
      // if(current_bits_difference < 0)
      if (0 < (int)uVar8) { // do we beed more bits from the temporalArray?
        // temporalBitData = *temporalArray;
        uVar3 = *unaff_s7;
        // temporalArray = temporalArray + 1;
        unaff_s7 = unaff_s7 + 1;
        // temporalBitData = temporalBitData | temporalBitData >> (bits_needed - current_bits_difference & 0x1f);
        uVar1 = uVar1 | uVar3 >> (uVar2 - uVar8 & 0x1f);
        // bits_read = current_bits_difference - 32;
        uVar7 = uVar8 - 0x20;
        // bits_needed = current_bits_difference;
        uVar2 = uVar8;
      }
      // temporal_x = temporalBitData >> (BBB ^ 0x1f);
      cVar6 = (char)((int)uVar1 >> (uVar4 ^ 0x1f)); // xor may do the bit-reset, this may make accumulator-axis go to zero
      // temporalBitData = temporalBitData << (bits_needed & 0x1f);
      uVar3 = uVar3 << (uVar2 & 0x1f);
      //if(BBB != 7)
      if (uVar4 != 7) { //if not reset Z-counter reset; but if is reset just pass delta.Z( accumulator.Z gets zeroed)
        // temporal_z = (char)(temporal_z + (char)((delta << 7) >> 0x18)(delta.Z) + accumulator.Z);
        cVar6 = cVar6 + (char)((uVar10 << 7) >> 0x18) + *(char *)(in_at + 0x5a);
      }
      // accumulator.Z = temporal_z;
      *(char *)(in_at + 0x5a) = cVar6;
      // uint CCC = delta & 7;
      uVar1 = uVar10 & 7; // CCC
      // current_bits_difference = bits_read + CCC + 1
      iVar9 = uVar7 + uVar1 + 1;
      // if (0 < current_bits_difference) {
      if (0 < iVar9) { // check signed bit
        // temporalBitData = temporalBitData | (*temporalArray) >> ((CCC + 1) - current_bits_difference & 0x1f);
        uVar3 = uVar3 | *unaff_s7 >> ((uVar1 + 1) - iVar9 & 0x1f);
      }
      // temporal_z = (char)((int)temporalBitData >> (CCC ^ 0x1f));
      cVar6 = (char)((int)uVar3 >> (uVar1 ^ 0x1f)); // xor may do the bit-reset, i.e. this may make accumulator-axis go to zero
      //if(CCC != 7)
      if (uVar1 != 7) { //if not reset Y-counter reset; but if is reset just pass delta.Y( accumulator.Y gets zeroed)
        // temporal_y = (char)(temporal_y + (char)((delta << 15) >> 0x18)(delta.Y) + accumulator.Y);
        cVar6 = cVar6 + (char)((uVar10 << 0xf) >> 0x18) + *(char *)(in_at + 0x59);
      }
      // accumulator.Z = temporal_z;
      *(char *)(in_at + 0x59) = cVar6;
      uVar1 = *(uint *)(in_at + 0x58);
    }
    iVar9 = *(int *)(in_at + 0x34);
    *(uint *)(iVar5 + 0x140) = ((uVar1 & in_t4) + *(int *)(in_at + 0x30)) * 4 & in_t5;
    *(uint *)(iVar5 + 0x144) = ((uVar1 >> 8 & 0xff) + iVar9) * 4;
  }
  if (-1 < (int)(in_t3 << 4)) {
    return;
  }
  return;
}

// param1 is Render Bucket Instance
// param2 is PrimMem pointers
// RenderBucket_Execute
void FUN_8006aaa8(int *param_1,int param_2)

{
  bool bVar1;
  undefined uVar2;
  short sVar3;
  short sVar4;
  ushort uVar5;
  ushort uVar6;
  int iVar7;
  undefined4 uVar8;
  int iVar9;
  uint uVar10;
  code *pcVar11;
  int iVar12;
  int iVar13;
  undefined4 *puVar14;
  undefined4 uVar15;
  ushort *puVar16;
  short *psVar17;
  undefined4 *puVar18;
  int iVar19;
  undefined auStack60 [16];
  undefined1 *local_c;

  DAT_1f800000 = auStack60;
  local_c = &_gp_4;
  iVar7 = 0x1f800000;
  DAT_1f800008 = 0;
  iVar19 = *param_1;
  uVar8 = *(undefined4 *)(param_2 + 0xc);
  DAT_1f80000c = param_2;
  while( true )
  {
	// instance
    iVar12 = param_1[1];

    *(int **)(iVar7 + 4) = param_1 + 2;
    if (iVar19 == 0) break;
    iVar9 = *(int *)(iVar12 + 0x74);
    iVar13 = *(int *)(iVar7 + 8);
    *(int *)(iVar7 + 0x10) = iVar19;
    *(int *)(iVar7 + 8) = iVar9;
	
	// camera110
    if (iVar9 != iVar13) 
	{
	  // width, height, distToScreen
      sVar3 = *(short *)(iVar9 + 0x20);
      sVar4 = *(short *)(iVar9 + 0x22);
      uVar15 = *(undefined4 *)(iVar9 + 0x18);
		
	  // scratchpad
      *(short *)(iVar7 + 0x1c) = sVar3;
      *(short *)(iVar7 + 0x1e) = sVar4;
        
	  // GTE
      setCopControlWord(2,0xc000,(int)sVar3 << 0xf);
      setCopControlWord(2,0xc800,(int)sVar4 << 0xf);
      setCopControlWord(2,0xd000,uVar15);
    }

	// instance flags, duplicate of 0x28
    uVar10 = *(uint *)(iVar12 + 0xb8);

    sVar3 = *(short *)(iVar12 + 0xbc);

	if (
			((uVar10 & 0x40) != 0) &&

			// if instance is not invisible
			((uVar10 & 0x80) == 0)
		)
	{
	  // instance matrix
      gte_ldR11R12(*(undefined4 *)(iVar12 + 0x78));
      gte_ldR13R21(*(undefined4 *)(iVar12 + 0x7c));
      gte_ldR22R23(*(undefined4 *)(iVar12 + 0x80));
      gte_ldR31R32(*(undefined4 *)(iVar12 + 0x84));
      gte_ldR33(*(undefined4 *)(iVar12 + 0x88));
	  
	  gte_ldtr(
	    *(undefined4 *)(iVar12 + 0x8c),
	    *(undefined4 *)(iVar12 + 0x90),
	    *(undefined4 *)(iVar12 + 0x94)
	  );
	  
      *(uint *)(iVar7 + 0x24) = uVar10;
      *(int *)(iVar7 + 0x120) = (int)sVar3;
      if ((uVar10 & 0x7000) != 0) 
	  {
		// instance matrix
		gte_ldL11L12(*(undefined4 *)(iVar12 + 0x98));
		gte_ldL13L21(*(undefined4 *)(iVar12 + 0x9c));
		gte_ldL22L23(*(undefined4 *)(iVar12 + 0xa0));
		gte_ldL31L32(*(undefined4 *)(iVar12 + 0xa4));
		gte_ldL33(*(undefined4 *)(iVar12 + 0xa8));
		
        sVar3 = *(short *)(iVar12 + 0xbe);
        uVar2 = *(undefined *)(iVar19 + 0x53);
        uVar8 = *(undefined4 *)(iVar19 + 0x58);
        *(short *)(iVar7 + 0x44) = sVar3;
        *(short *)(iVar7 + 0xda) = sVar3;
        *(short *)(iVar7 + 0xf2) = sVar3;
        *(undefined *)(iVar7 + 0x48) = uVar2;
        *(undefined4 *)(iVar7 + 0x4c) = uVar8;
        *(int *)(iVar7 + 0x11c) = (int)sVar3 << 0x11;
        *(undefined4 *)(iVar7 + 0xe0) = 0;
        *(undefined4 *)(iVar7 + 0xf8) = 0;
      }
      psVar17 = *(short **)(iVar12 + 0xc4);
      puVar16 = *(ushort **)(iVar12 + 0xc0);
      if (psVar17 == (short *)0x0) {
        uVar5 = puVar16[1];
        uVar6 = puVar16[2];
        *(ushort *)(iVar7 + 0x30) = *puVar16 & 0x7fff;
        *(ushort *)(iVar7 + 0x32) = uVar5;
        *(int *)(iVar7 + 0x34) = (int)(short)uVar6;
      }
      else {
        *(short *)(iVar7 + 0x30) = *puVar16 + *psVar17;
        *(short *)(iVar7 + 0x32) = puVar16[1] + psVar17[1];
        *(int *)(iVar7 + 0x34) = ((int)(short)puVar16[2] + (int)psVar17[2]) * 2;
      }
      *(undefined4 *)(iVar7 + 0x58) = 0;

	  // ptrColorLayout
      puVar18 = *(undefined4 **)(iVar12 + 0xd0);

	  // ptrCommandList,
	  // first int is number of colors
      iVar9 = **(int **)(iVar12 + 200);

	  // pointer to scratchpad
      puVar14 = (undefined4 *)(iVar7 + 0x140);

	  // copy colors to scratchpad
	  while (bVar1 = 0 < iVar9, iVar9 = iVar9 + -1, bVar1) {
        uVar8 = *puVar18;
        puVar18 = puVar18 + 1;
        *puVar14 = uVar8;
        puVar14 = puVar14 + 1;
      }

	  // function pointer in instance
      (**(code **)(iVar19 + 0x5c))();

      sVar3 = *(short *)(iVar12 + 0xde);
      *(undefined2 *)(iVar7 + 0x134) = (short)((int)*(short *)(iVar12 + 0xdc) << 2);
      *(undefined2 *)(iVar7 + 0x136) = (short)((int)sVar3 << 2);
      uVar8 = *(undefined4 *)(iVar12 + 0xe4);
      uVar15 = *(undefined4 *)(iVar12 + 0xe8);

	  // get render function from Instance
	  pcVar11 = *(code **)(iVar12 + 0xec);

      *(undefined4 *)(iVar7 + 0x38) = uVar8;
      *(undefined4 *)(iVar7 + 0x3c) = uVar8;
      *(undefined4 *)(iVar7 + 0x40) = uVar15;

	  // render model
	  uVar8 = (*pcVar11)(*(undefined4 *)(iVar19 + 100));
    }
    param_1 = *(int **)(iVar7 + 4);
    iVar19 = *param_1;
  }
  *(undefined4 *)(*(int *)(iVar7 + 0xc) + 0xc) = uVar8;
  return;
}


// RenderBucket_DrawInstPrim_Normal
// called by jmp inst->0x60 (8006AD88),
// called for every primitive
int FUN_8006ad6c(void)

{
  int in_at;
  u_long *in_v0;
  undefined4 uVar1;
  uint uVar2;
  u_long uVar3;
  u_long *puVar4;
  uint uVar5;
  int iVar6;
  u_long uVar7;
  uint uVar8;
  int in_t3;
  uint *puVar9;
  undefined4 in_t6;
  undefined4 in_t7;
  undefined4 unaff_s0;

  uVar1 = *(undefined4 *)(in_at + 0x3c);
  if (in_t3 << 6 < 1) {
    uVar1 = *(undefined4 *)(in_at + 0x40);
  }
  *(undefined4 *)(in_at + 0x38) = uVar1;
  puVar9 = (uint *)((*(uint *)(in_at + 0x2c) >> 0x11) * 4 + *(int *)(in_at + 0x38));
  puVar4 = *(u_long **)(in_at + 0x50);

  // load colors
  gte_ldRGB0(in_t6);
  gte_ldRGB1(in_t7);
  gte_ldRGB2(unaff_s0);

  // set transparency (which only causes darkness in this func)
  gte_ldIR0((int)*(short *)(in_at + 0x120));
  if ((*(short *)(in_at + 0x120) != 0) && (-1 < (int)puVar9 * 0x80)) {
    gte_dpct_b();
  }
  uVar2 = 0x30000000;

  // if texture data is nullptr,
  // draw prim with no texture
  if (puVar4 == (u_long *)0x0) {
    gte_stsxy3_g3(in_v0);
    uVar5 = gte_stRGB0();

	// prim size
    iVar6 = 0x1c;

    in_v0[1] = uVar2 | uVar5;
    gte_stRGB1();
    gte_stRGB2();
    uVar2 = 0x6000000;
  }

  // if texture data is valid,
  // draw prim with texture
  else {
    uVar3 = *puVar4;
    uVar5 = puVar4[1];
    uVar7 = puVar4[2];
    gte_stsxy3_gt3(in_v0);
    in_v0[3] = uVar3;
    in_v0[6] = uVar5;
    in_v0[9] = uVar7;
    uVar8 = gte_stRGB0();
    uVar2 = 0x34000000;
    if ((uVar5 & 0x600000) != 0x600000) {
      uVar2 = 0x36000000;
    }
    in_v0[1] = uVar2 | uVar8;
    gte_stRGB1();
    gte_stRGB2();

    // prim size
    iVar6 = 0x28;

	uVar2 = 0x9000000;
  }

  // write to PrimMem and OTMem
  *in_v0 = *puVar9 | uVar2;
  *puVar9 = (uint)in_v0 & 0xffffff;

  return (int)in_v0 + iVar6;
}

// RenderBucket_InitDepthGTE
void FUN_8006ae74(void)
{
  // depth queing parameters,
  // A = coeff
  // B = offset
  gte_ldDQA(0);
  gte_ldDQB(0);

  // both impact depth and draw order somehow?
  // documentation says "average Z scale factor"
  gte_ldZSF3(0x555);
  gte_ldZSF4(0x400);

  return;
}

// RenderBucket_DrawInstPrim_KeyRelicToken
// does not apply to Tiger Temple Flamejet, so not "Prim_Specular"
uint * FUN_8006ae90(void)

{
  int in_at;
  uint *in_v0;
  int iVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint *puVar6;
  int iVar7;
  byte *pbVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  int in_t3;
  uint *puVar12;
  uint in_t6;

  gte_nclip_b();
  puVar12 = (uint *)((*(uint *)(in_at + 0x2c) >> 0x11) * 4 + *(int *)(in_at + 0x38));
  puVar6 = *(uint **)(in_at + 0x50);
  uVar11 = gte_stMAC0();
  uVar11 = uVar11 ^ (int)*(short *)(in_at + 0x24) ^ in_t3 << 2;
  gte_stSXY0();
  if ((int)uVar11 < 0) {
    puVar12 = puVar12 + 1;
  }
  gte_stSXY1();
  gte_stSXY2();
  gte_ldIR1((int)(in_t6 << 0x18) >> 0x13);
  gte_ldIR2((int)((in_t6 >> 8) << 0x18) >> 0x13);
  gte_ldIR3((int)((in_t6 >> 0x10) << 0x18) >> 0x13);
  gte_lcir();
  iVar1 = gte_stIR1();
  iVar7 = gte_stIR3();
  uVar2 = (iVar1 + 0x1000) * 7 + 0x2000;
  uVar3 = uVar2 >> 4;
  if ((int)uVar11 < 0) {
    uVar3 = uVar2 >> 5;
  }
  iVar7 = iVar7 >> 3;
  gte_ldIR0(uVar3);
  gte_dpcs_b();
  if (iVar7 < 0) {
    iVar7 = -iVar7;
  }
  uVar2 = 0;
  if (-1 < iVar7 + -0x180) {
    pbVar8 = &DAT_8008a144 + iVar7;
    if (-1 < iVar7 + -0x200) {
      pbVar8 = &DAT_8008a343;
    }
    uVar2 = (uint)*pbVar8;
  }
  uVar3 = gte_stRGB2();
  if ((int)uVar11 < 0) {
    uVar2 = uVar2 >> 3;
  }

  // red
  uVar9 = (uVar3 & 0xff) + uVar2;

  // green
  iVar1 = (uVar3 >> 8 & 0xff) + uVar2;

  // blue
  iVar7 = (uVar3 >> 0x10 & 0xff) + uVar2;

  // blue component
  uVar2 = iVar7 * 0x10000;
  if (0 < iVar7 + -0xff) {
    uVar2 = 0xff0000;
  }

  // green component
  uVar3 = iVar1 * 0x100;
  if (0 < iVar1 + -0xff) {
    uVar3 = 0xff00;
  }

  // red component
  if (0 < (int)(uVar9 - 0xff)) {
    uVar9 = 0xff;
  }

  uVar5 = puVar6[1];
  uVar10 = 0x600000;
  uVar4 = 0x24000000;
  if (((uVar5 & 0x600000) == 0) && (-1 < (int)uVar11)) {
    uVar10 = 0x200000;
    uVar4 = 0x26000000;
  }

  // uVar4 tag, plus 3-byte color
  in_v0[1] = uVar4 | uVar3 | uVar2 | uVar9;

  uVar11 = puVar6[2];
  in_v0[3] = *puVar6;
  in_v0[5] = uVar10 | uVar5;
  in_v0[7] = uVar11;
  *in_v0 = *puVar12 | 0x7000000;
  *puVar12 = (uint)in_v0 & 0xffffff;
  return in_v0 + 8;
}


// RenderBucket_DrawFunc_Split
// cuts models in half, fake depth buffer,
// when in mud or water
void FUN_8006b030(void)

{
  bool bVar1;
  undefined uVar2;
  short sVar3;
  short sVar4;
  ushort uVar5;
  ushort uVar6;
  undefined4 in_zero;
  int in_at;
  undefined4 in_v0;
  code *pcVar7;
  undefined4 extraout_v1;
  undefined4 extraout_v1_00;
  int iVar8;
  int *piVar9;
  int iVar10;
  uint uVar11;
  int iVar12;
  undefined4 *puVar13;
  int in_t0;
  int iVar14;
  uint uVar15;
  uint uVar16;
  undefined4 uVar17;
  undefined4 uVar18;
  uint in_t3;
  code *unaff_s6;
  ushort *puVar19;
  short *psVar20;
  uint *in_t9;
  uint *puVar21;
  undefined4 *puVar22;
  undefined8 uVar23;
  int iStack4;

code_r0x8006b030:
  puVar21 = in_t9 + 1;
  if (in_t0 == 0) {
    while( true ) {
      piVar9 = *(int **)(in_at + 4);

	  // ptrInstance
	  iVar8 = *piVar9;

	  // ptrInstance
      iVar14 = piVar9[1];

	  *(int **)(in_at + 4) = piVar9 + 2;
      if (iVar8 == 0) break;
      iVar10 = *(int *)(iVar14 + 0x74);
      iVar12 = *(int *)(in_at + 8);
      *(int *)(in_at + 0x10) = iVar8;
      *(int *)(in_at + 8) = iVar10;
	  
	  // camera110
      if (iVar10 != iVar12) 
	  {
		// width, height, distToScreen
        sVar3 = *(short *)(iVar10 + 0x20);
        sVar4 = *(short *)(iVar10 + 0x22);
        uVar17 = *(undefined4 *)(iVar10 + 0x18);
		
		// scratchpad
        *(short *)(in_at + 0x1c) = sVar3;
        *(short *)(in_at + 0x1e) = sVar4;
        
		// GTE
        setCopControlWord(2,0xc000,(int)sVar3 << 0xf);
        setCopControlWord(2,0xc800,(int)sVar4 << 0xf);
        setCopControlWord(2,0xd000,uVar17);
      }

	  // instance flags, duplicate of 0x28
	  uVar11 = *(uint *)(iVar14 + 0xb8);

	  sVar3 = *(short *)(iVar14 + 0xbc);

      if (
			((uVar11 & 0x40) != 0) &&

			// if instance is not invisible
			((uVar11 & 0x80) == 0)
		 )
	  {
		// instance offset 0x78
        gte_ldR11R12(*(undefined4 *)(iVar14 + 0x78));
        gte_ldR13R21(*(undefined4 *)(iVar14 + 0x7c));
        gte_ldR22R23(*(undefined4 *)(iVar14 + 0x80));
        gte_ldR31R32(*(undefined4 *)(iVar14 + 0x84));
        gte_ldR33(*(undefined4 *)(iVar14 + 0x88));
		
		gte_ldtr(
		  *(undefined4 *)(iVar14 + 0x8c),
		  *(undefined4 *)(iVar14 + 0x90),
		  *(undefined4 *)(iVar14 + 0x94)
		);

        *(uint *)(in_at + 0x24) = uVar11;
        *(int *)(in_at + 0x120) = (int)sVar3;

		if ((uVar11 & 0x7000) != 0)
		{
		  // instance offset 0x98
          gte_ldL11L12(*(undefined4 *)(iVar14 + 0x98));
          gte_ldL13L21(*(undefined4 *)(iVar14 + 0x9c));
          gte_ldL22L23(*(undefined4 *)(iVar14 + 0xa0));
          gte_ldL31L32(*(undefined4 *)(iVar14 + 0xa4));
          gte_ldL33(*(undefined4 *)(iVar14 + 0xa8));

		  sVar3 = *(short *)(iVar14 + 0xbe);
          uVar2 = *(undefined *)(iVar8 + 0x53);
          uVar17 = *(undefined4 *)(iVar8 + 0x58);
          *(short *)(in_at + 0x44) = sVar3;
          *(short *)(in_at + 0xda) = sVar3;
          *(short *)(in_at + 0xf2) = sVar3;
          *(undefined *)(in_at + 0x48) = uVar2;
          *(undefined4 *)(in_at + 0x4c) = uVar17;
          *(int *)(in_at + 0x11c) = (int)sVar3 << 0x11;
          *(undefined4 *)(in_at + 0xe0) = 0;
          *(undefined4 *)(in_at + 0xf8) = 0;
        }

		// origin next frame
        psVar20 = *(short **)(iVar14 + 0xc4);

		// origin this frame
        puVar19 = *(ushort **)(iVar14 + 0xc0);

		// no next frame,
		// no 60fps
        if (psVar20 == (short *)0x0)
		{
		  // copy origin data
          uVar5 = puVar19[1];
          uVar6 = puVar19[2];
          *(ushort *)(in_at + 0x30) = *puVar19 & 0x7fff;
          *(ushort *)(in_at + 0x32) = uVar5;
          *(int *)(in_at + 0x34) = (int)(short)uVar6;
        }

		// next frame exists,
		// 60fps
		else
		{
		  // interpolate between origins
          *(ushort *)(in_at + 0x30) = *puVar19 + *psVar20;
          *(ushort *)(in_at + 0x32) = puVar19[1] + psVar20[1];
          *(int *)(in_at + 0x34) = ((int)(short)puVar19[2] + (int)psVar20[2]) * 2;
        }

		// reflection color
        *(undefined4 *)(in_at + 0x58) = 0;

		// ptrColorLayout
        puVar22 = *(undefined4 **)(iVar14 + 0xd0);

		// deref ptrCommandList, get numColors
        iVar10 = **(int **)(iVar14 + 200);

        puVar13 = (undefined4 *)(in_at + 0x140);

		// write color array
		while (bVar1 = 0 < iVar10, iVar10 = iVar10 + -1, bVar1) {
          uVar17 = *puVar22;
          puVar22 = puVar22 + 1;
          *puVar13 = uVar17;
          puVar13 = puVar13 + 1;
        }

		// execute instance->funcPtr
		(**(code **)(iVar8 + 0x5c))();

        sVar3 = *(short *)(iVar14 + 0xde);
        *(short *)(in_at + 0x134) = (short)((int)*(short *)(iVar14 + 0xdc) << 2);
        *(short *)(in_at + 0x136) = (short)((int)sVar3 << 2);
        uVar17 = *(undefined4 *)(iVar14 + 0xe4);
        uVar18 = *(undefined4 *)(iVar14 + 0xe8);
        pcVar7 = *(code **)(iVar14 + 0xec);
        *(undefined4 *)(in_at + 0x38) = uVar17;
        *(undefined4 *)(in_at + 0x3c) = uVar17;
        *(undefined4 *)(in_at + 0x40) = uVar18;
        in_v0 = (*pcVar7)(*(undefined4 *)(iVar8 + 100));
      }
    }
    *(undefined4 *)(*(int *)(in_at + 0xc) + 0xc) = in_v0;
    return;
  }
  *(uint *)(in_at + 0x10c) = in_t3;
  (*unaff_s6)();
  *(int *)(in_at + 0x90) = in_t0;
  *(undefined4 *)(in_at + 0x94) = extraout_v1;
  iVar14 = (int)*(short *)(in_at + 0x44) - (in_t0 >> 0x10);
  *(short *)(in_at + 0x9e) = (short)iVar14;
  (*unaff_s6)();
  *(int *)(in_at + 0xa8) = iVar14;
  *(undefined4 *)(in_at + 0xac) = extraout_v1_00;
  iVar14 = (int)*(short *)(in_at + 0x44) - (iVar14 >> 0x10);
  *(short *)(in_at + 0xb6) = (short)iVar14;
  uVar23 = (*unaff_s6)();
  uVar17 = (undefined4)((ulonglong)uVar23 >> 0x20);
  in_v0 = (undefined4)uVar23;
  setCopReg(2,in_zero,*(undefined4 *)(in_at + 0x90));
  setCopReg(2,in_at,*(undefined4 *)(in_at + 0x94));
  setCopReg(2,in_v0,*(undefined4 *)(in_at + 0xa8));
  setCopReg(2,uVar17,*(undefined4 *)(in_at + 0xac));
  setCopReg(2,0x2000,iVar14);
  setCopReg(2,0x2800,uVar17);
  in_t3 = *(uint *)(in_at + 0x10c);
  copFunction(2,0x280030);
  *(int *)(in_at + 0xc0) = iVar14;
  *(undefined4 *)(in_at + 0xc4) = uVar17;
  *(short *)(in_at + 0xce) = *(short *)(in_at + 0x44) - (short)((uint)iVar14 >> 0x10);
  in_t9 = puVar21 + 1;
  do {
    uVar11 = in_t3 & 0x1ff;
    iVar14 = uVar11 * 4;
    if (uVar11 != 0) {
      iVar14 = (&iStack4)[uVar11];
    }
    iVar8 = *(int *)(in_at + 0x1c);
    uVar11 = getCopReg(2,0x7000);
    iVar10 = getCopControlWord(2,0xf800);
    if (-1 < iVar10 << 0xd) {
      if ((int)(in_t3 << 3) < 0) {
        copFunction(2,0x1400006);
        uVar15 = getCopReg(2,0xc000);
        if ((uVar15 == 0) ||
           (uVar16 = getCopReg(2,0x6000),
           (int)(uVar15 ^ (int)*(short *)(in_at + 0x24) ^ in_t3 << 2) < 1)) goto LAB_8006b15c;
      }
      else {
        uVar16 = getCopReg(2,0x6000);
      }
      uVar15 = getCopReg(2,0x6800);
      copFunction(2,0x158002d);
      uVar11 = ~(uVar16 - iVar8 | uVar15 - iVar8 | uVar11 - iVar8) | uVar16 & uVar11 & uVar15;
      if (-1 < (int)uVar11) {
        uVar17 = getCopReg(2,0x18);
        *(undefined4 *)(in_at + 0x2c) = uVar17;
        if (-1 < (int)(uVar11 << 0x10)) {
          *(int *)(in_at + 0x50) = iVar14;
          in_v0 = FUN_8006d094();
        }
      }
    }
LAB_8006b15c:
    do {
      in_t3 = *in_t9;
      in_t9 = in_t9 + 1;
      in_t0 = in_t3 + 1;
      if ((int)in_t3 < 0) goto code_r0x8006b030;
      uVar11 = in_t3 >> 0x10;
    } while (uVar11 == 0);
    if ((int)(in_t3 << 1) < 0) {
      uVar17 = getCopReg(2,0x6000);
      uVar18 = getCopReg(2,0x8800);
      setCopReg(2,0x6800,uVar17);
      setCopReg(2,0x9000,uVar18);
    }
    else {
      *(undefined4 *)(in_at + 0x90) = *(undefined4 *)(in_at + 0xa8);
      *(undefined4 *)(in_at + 0x94) = *(undefined4 *)(in_at + 0xac);
      *(undefined2 *)(in_at + 0x9e) = *(undefined2 *)(in_at + 0xb6);
    }
    *(undefined4 *)(in_at + 0xa8) = *(undefined4 *)(in_at + 0xc0);
    *(undefined4 *)(in_at + 0xac) = *(undefined4 *)(in_at + 0xc4);
    *(undefined2 *)(in_at + 0xb6) = *(undefined2 *)(in_at + 0xce);
    uVar23 = (*unaff_s6)();
    uVar17 = (undefined4)((ulonglong)uVar23 >> 0x20);
    in_v0 = (undefined4)uVar23;
    setCopReg(2,0,uVar11);
    setCopReg(2,0x800,uVar17);
    copFunction(2,0x180001);
    *(uint *)(in_at + 0xc0) = uVar11;
    *(undefined4 *)(in_at + 0xc4) = uVar17;
    *(short *)(in_at + 0xce) = *(short *)(in_at + 0x44) - (short)(uVar11 >> 0x10);
  } while( true );
}
// guessing: model close to camera near clipping or something like that???
void UndefinedFunction_8006b24c(void)

{
  char cVar1;
  int in_at;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  uint uVar7;
  char cVar8;
  uint uVar9;
  char cVar10;
  uint uVar11;
  uint in_t3;
  uint in_t4;
  uint in_t5;
  uint unaff_s1;
  uint unaff_s2;
  int unaff_s3;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  uint *unaff_s7;
  uint *in_t8;
  uint *unaff_s8;

  iVar5 = (in_t3 >> 0xd & 0x7f8) + in_at;
  if (-1 < (int)(in_t3 << 5)) {
    if (unaff_s8 == (uint *)0x0) {
      uVar9 = *unaff_s7;
      uVar11 = *in_t8;
    }
    else {
      *(int *)(in_at + 0x20) = iVar5;
      uVar14 = *unaff_s8;
      uVar2 = uVar14 >> 6 & 7;
      uVar7 = uVar2 ^ 0x1f;
      uVar3 = uVar2 + 1;
      uVar12 = unaff_s3 + uVar3;
      cVar8 = (char)((int)unaff_s1 >> uVar7);
      cVar10 = (char)((int)unaff_s2 >> uVar7);
      uVar9 = unaff_s1;
      uVar11 = unaff_s2;
      uVar13 = uVar12;
      if (0 < (int)uVar12) {
        uVar9 = *unaff_s7;
        uVar11 = *in_t8;
        unaff_s7 = unaff_s7 + 1;
        in_t8 = in_t8 + 1;
        cVar8 = (char)((int)(unaff_s1 | uVar9 >> (uVar3 - uVar12 & 0x1f)) >> uVar7);
        cVar10 = (char)((int)(unaff_s2 | uVar11 >> (uVar3 - uVar12 & 0x1f)) >> uVar7);
        uVar13 = uVar12 - 0x20;
        uVar3 = uVar12;
      }
      uVar9 = uVar9 << (uVar3 & 0x1f);
      uVar11 = uVar11 << (uVar3 & 0x1f);
      if (uVar2 != 7) {
        cVar1 = (char)((int)uVar14 >> 0x19) * '\x02';
        cVar8 = cVar8 + cVar1 + *(char *)(in_at + 0x58);
        cVar10 = cVar10 + cVar1 + *(char *)(in_at + 0x5c);
      }
      *(char *)(in_at + 0x58) = cVar8;
      *(char *)(in_at + 0x5c) = cVar10;
      uVar4 = uVar14 >> 3 & 7;
      uVar7 = uVar4 + 1;
      uVar13 = uVar13 + uVar7;
      uVar3 = uVar9;
      uVar2 = uVar11;
      uVar12 = uVar13;
      if (0 < (int)uVar13) {
        uVar3 = *unaff_s7;
        uVar2 = *in_t8;
        unaff_s7 = unaff_s7 + 1;
        in_t8 = in_t8 + 1;
        uVar9 = uVar9 | uVar3 >> (uVar7 - uVar13 & 0x1f);
        uVar11 = uVar11 | uVar2 >> (uVar7 - uVar13 & 0x1f);
        uVar12 = uVar13 - 0x20;
        uVar7 = uVar13;
      }
      cVar10 = (char)((int)uVar11 >> (uVar4 ^ 0x1f));
      cVar8 = (char)((int)uVar9 >> (uVar4 ^ 0x1f));
      uVar3 = uVar3 << (uVar7 & 0x1f);
      uVar2 = uVar2 << (uVar7 & 0x1f);
      if (uVar4 != 7) {
        cVar1 = (char)((uVar14 << 7) >> 0x18);
        cVar8 = cVar8 + cVar1 + *(char *)(in_at + 0x5a);
        cVar10 = cVar10 + cVar1 + *(char *)(in_at + 0x5e);
      }
      *(char *)(in_at + 0x5a) = cVar8;
      *(char *)(in_at + 0x5e) = cVar10;
      uVar9 = uVar14 & 7;
      iVar5 = uVar12 + uVar9 + 1;
      if (0 < iVar5) {
        uVar11 = (uVar9 + 1) - iVar5;
        uVar3 = uVar3 | *unaff_s7 >> (uVar11 & 0x1f);
        uVar2 = uVar2 | *in_t8 >> (uVar11 & 0x1f);
      }
      cVar10 = (char)((int)uVar2 >> (uVar9 ^ 0x1f));
      cVar8 = (char)((int)uVar3 >> (uVar9 ^ 0x1f));
      if (uVar9 != 7) {
        cVar1 = (char)((uVar14 << 0xf) >> 0x18);
        cVar8 = cVar8 + cVar1 + *(char *)(in_at + 0x59);
        cVar10 = cVar10 + cVar1 + *(char *)(in_at + 0x5d);
      }
      *(char *)(in_at + 0x59) = cVar8;
      *(char *)(in_at + 0x5d) = cVar10;
      uVar9 = *(uint *)(in_at + 0x58);
      uVar11 = *(uint *)(in_at + 0x5c);
      iVar5 = *(int *)(in_at + 0x20);
    }
    iVar6 = *(int *)(in_at + 0x34);
    *(uint *)(iVar5 + 0x140) =
         ((uVar9 & in_t4) + (uVar11 & in_t4) + *(int *)(in_at + 0x30)) * 2 & in_t5;
    *(uint *)(iVar5 + 0x144) = ((uVar9 & 0xff00) + (uVar11 & 0xff00) >> 7) + iVar6;
  }
  if (-1 < (int)(in_t3 << 4)) {
    return;
  }
  return;
}

// Draw_KartFlames
undefined8 FUN_8006bad0(void)

{
  int in_at;
  uint *in_v0;
  uint uVar1;
  int iVar2;
  uint *puVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  uint *puVar8;
  undefined4 in_t6;
  undefined4 in_t7;
  undefined4 unaff_s0;

  iVar2 = *(int *)(in_at + 0x38);
  iVar7 = (*(uint *)(in_at + 0x2c) >> 0x11) * 4;
  if (iVar7 - *(short *)(in_at + 0x134) < 0) {
    puVar8 = (uint *)(*(short *)(in_at + 0x134) + iVar2);
  }
  else {
    puVar8 = (uint *)(iVar7 + iVar2);
    if (0 < iVar7 - *(short *)(in_at + 0x136)) {
      puVar8 = (uint *)(*(short *)(in_at + 0x136) + iVar2);
    }
  }
  puVar3 = *(uint **)(in_at + 0x50);
  setCopReg(2,0xa000,in_t6);
  setCopReg(2,0xa800,in_t7);
  setCopReg(2,0xb000,unaff_s0);
  setCopReg(2,0x4000,(int)*(short *)(in_at + 0x120));
  if ((*(short *)(in_at + 0x120) != 0) && (-1 < (int)puVar8 << 7)) {
    copFunction(2,0xf8002a);
  }
  if (puVar3 == (uint *)0x0) {
    uVar4 = getCopReg(2,0xc);
    in_v0[2] = uVar4;
    uVar4 = getCopReg(2,0xd);
    in_v0[4] = uVar4;
    uVar4 = getCopReg(2,0xe);
    in_v0[6] = uVar4;
    uVar4 = getCopReg(2,0xa000);
    iVar2 = 0x1c;
    in_v0[1] = uVar4 | 0x30000000;
    uVar4 = getCopReg(2,0x15);
    in_v0[3] = uVar4;
    uVar4 = getCopReg(2,0x16);
    in_v0[5] = uVar4;
    uVar4 = 0x6000000;
  }
  else {
    uVar1 = *puVar3;
    uVar5 = puVar3[1];
    uVar6 = puVar3[2];
    uVar4 = getCopReg(2,0xc);
    in_v0[2] = uVar4;
    uVar4 = getCopReg(2,0xd);
    in_v0[5] = uVar4;
    uVar4 = getCopReg(2,0xe);
    in_v0[8] = uVar4;
    in_v0[3] = uVar1;
    in_v0[6] = uVar5;
    in_v0[9] = uVar6;
    uVar1 = getCopReg(2,0xa000);
    uVar4 = 0x34000000;
    if ((uVar5 & 0x600000) != 0x600000) {
      uVar4 = 0x36000000;
    }
    in_v0[1] = uVar4 | uVar1;
    uVar4 = getCopReg(2,0x15);
    in_v0[4] = uVar4;
    uVar4 = getCopReg(2,0x16);
    in_v0[7] = uVar4;
    iVar2 = 0x28;
    uVar4 = 0x9000000;
  }
  uVar1 = *puVar8;
  *in_v0 = uVar1 | uVar4;
  *puVar8 = (uint)in_v0 & 0xffffff;
  return CONCAT44(uVar1 | uVar4,(int)in_v0 + iVar2);
}

// something to do with drawing.
void FUN_8006bbc0(void)

{
  bool bVar1;
  undefined uVar2;
  short sVar3;
  short sVar4;
  ushort uVar5;
  ushort uVar6;
  int in_at;
  undefined4 in_v0;
  int iVar7;
  code *pcVar8;
  undefined4 extraout_v1;
  undefined4 extraout_v1_00;
  int iVar9;
  int *piVar10;
  int iVar11;
  int iVar12;
  undefined4 *puVar13;
  int in_t0;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  uint in_t1;
  uint uVar17;
  undefined4 uVar18;
  uint uVar19;
  undefined4 uVar20;
  uint in_t3;
  undefined4 in_t4;
  undefined4 in_t5;
  uint uVar21;
  uint uVar22;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  code *unaff_s5;
  code *unaff_s6;
  ushort *puVar23;
  short *psVar24;
  uint *in_t9;
  uint *puVar25;
  undefined4 *puVar26;
  undefined8 uVar27;
  int iStack4;

code_r0x8006bbc0:
  puVar25 = in_t9 + 1;
  if (in_t0 == 0) {
    while( true )
      piVar10 = *(int **)(in_at + 4);
      iVar11 = *piVar10;
      iVar9 = piVar10[1];
      *(int **)(in_at + 4) = piVar10 + 2;
      if (iVar11 == 0) break;
      iVar7 = *(int *)(iVar9 + 0x74);
      iVar12 = *(int *)(in_at + 8);
      *(int *)(in_at + 0x10) = iVar11;
      *(int *)(in_at + 8) = iVar7;
	  
	  // camera110
      if (iVar7 != iVar12) 
	  {
		// width, height, distToScreen
        sVar3 = *(short *)(iVar7 + 0x20);
        sVar4 = *(short *)(iVar7 + 0x22);
        uVar18 = *(undefined4 *)(iVar7 + 0x18);
		
		// scratchpad
        *(short *)(in_at + 0x1c) = sVar3;
        *(short *)(in_at + 0x1e) = sVar4;
        
		// GTE
		setCopControlWord(2,0xc000,(int)sVar3 << 0xf);
        setCopControlWord(2,0xc800,(int)sVar4 << 0xf);
        setCopControlWord(2,0xd000,uVar18);
      }
      uVar21 = *(uint *)(iVar9 + 0xb8);
      sVar3 = *(short *)(iVar9 + 0xbc);
      if (((uVar21 & 0x40) != 0) && ((uVar21 & 0x80) == 0)) 
	  {
		// instance matrix
		gte_ldR11R12(*(undefined4 *)(iVar9 + 0x78));
		gte_ldR13R21(*(undefined4 *)(iVar9 + 0x7c));
		gte_ldR22R23(*(undefined4 *)(iVar9 + 0x80));
		gte_ldR31R32(*(undefined4 *)(iVar9 + 0x84));
		gte_ldR33(*(undefined4 *)(iVar9 + 0x88));
		
		gte_ldtr(
		  *(undefined4 *)(iVar9 + 0x8c),
		  *(undefined4 *)(iVar9 + 0x90),
		  *(undefined4 *)(iVar9 + 0x94)
		);
		  
        *(uint *)(in_at + 0x24) = uVar21;
        *(int *)(in_at + 0x120) = (int)sVar3;
        if ((uVar21 & 0x7000) != 0) 
		{
		  // instance matrix
          gte_ldL11L12(*(undefined4 *)(iVar9 + 0x98));
          gte_ldL13L21(*(undefined4 *)(iVar9 + 0x9c));
          gte_ldL22L23(*(undefined4 *)(iVar9 + 0xa0));
          gte_ldL31L32(*(undefined4 *)(iVar9 + 0xa4));
          gte_ldL33(*(undefined4 *)(iVar9 + 0xa8));
			
          sVar3 = *(short *)(iVar9 + 0xbe);
          uVar2 = *(undefined *)(iVar11 + 0x53);
          uVar18 = *(undefined4 *)(iVar11 + 0x58);
          *(short *)(in_at + 0x44) = sVar3;
          *(short *)(in_at + 0xda) = sVar3;
          *(short *)(in_at + 0xf2) = sVar3;
          *(undefined *)(in_at + 0x48) = uVar2;
          *(undefined4 *)(in_at + 0x4c) = uVar18;
          *(int *)(in_at + 0x11c) = (int)sVar3 << 0x11;
          *(undefined4 *)(in_at + 0xe0) = 0;
          *(undefined4 *)(in_at + 0xf8) = 0;
        }
        psVar24 = *(short **)(iVar9 + 0xc4);
        puVar23 = *(ushort **)(iVar9 + 0xc0);
        if (psVar24 == (short *)0x0) {
          uVar5 = puVar23[1];
          uVar6 = puVar23[2];
          *(ushort *)(in_at + 0x30) = *puVar23 & 0x7fff;
          *(ushort *)(in_at + 0x32) = uVar5;
          *(int *)(in_at + 0x34) = (int)(short)uVar6;
        }
        else {
          *(ushort *)(in_at + 0x30) = *puVar23 + *psVar24;
          *(ushort *)(in_at + 0x32) = puVar23[1] + psVar24[1];
          *(int *)(in_at + 0x34) = ((int)(short)puVar23[2] + (int)psVar24[2]) * 2;
        }
        *(undefined4 *)(in_at + 0x58) = 0;
        puVar26 = *(undefined4 **)(iVar9 + 0xd0);
        iVar7 = **(int **)(iVar9 + 200);
        puVar13 = (undefined4 *)(in_at + 0x140);
        while (bVar1 = 0 < iVar7, iVar7 = iVar7 + -1, bVar1) {
          uVar18 = *puVar26;
          puVar26 = puVar26 + 1;
          *puVar13 = uVar18;
          puVar13 = puVar13 + 1;
        }
        (**(code **)(iVar11 + 0x5c))();
        sVar3 = *(short *)(iVar9 + 0xde);
        *(short *)(in_at + 0x134) = (short)((int)*(short *)(iVar9 + 0xdc) << 2);
        *(short *)(in_at + 0x136) = (short)((int)sVar3 << 2);
        uVar18 = *(undefined4 *)(iVar9 + 0xe4);
        uVar20 = *(undefined4 *)(iVar9 + 0xe8);
        pcVar8 = *(code **)(iVar9 + 0xec);
        *(undefined4 *)(in_at + 0x38) = uVar18;
        *(undefined4 *)(in_at + 0x3c) = uVar18;
        *(undefined4 *)(in_at + 0x40) = uVar20;
        in_v0 = (*pcVar8)(*(undefined4 *)(iVar11 + 100));
      }
    }
    *(undefined4 *)(*(int *)(in_at + 0xc) + 0xc) = in_v0;
    return;
  }
  *(uint *)(in_at + 0x10c) = in_t3;
  (*unaff_s6)();
  setCopReg(2,0,in_t0);
  setCopReg(2,0x800,extraout_v1);
  uVar21 = in_t1;
  (*unaff_s6)();
  setCopReg(2,0x1000,in_t0);
  setCopReg(2,0x1800,extraout_v1_00);
  uVar22 = in_t1;
  uVar27 = (*unaff_s6)();
  in_v0 = (undefined4)uVar27;
  setCopReg(2,0x2000,in_t0);
  setCopReg(2,0x2800,(int)((ulonglong)uVar27 >> 0x20));
  in_t3 = *(uint *)(in_at + 0x10c);
  copFunction(2,0x280030);
  in_t9 = puVar25 + 1;
  uVar18 = getCopReg(2,0xc);
  *(undefined4 *)(in_at + 0x90) = uVar18;
  uVar18 = getCopReg(2,0x11);
  *(undefined4 *)(in_at + 0x94) = uVar18;
  uVar18 = getCopReg(2,0xd);
  *(undefined4 *)(in_at + 0xa8) = uVar18;
  uVar18 = getCopReg(2,0x12);
  *(undefined4 *)(in_at + 0xac) = uVar18;
  uVar18 = getCopReg(2,0xe);
  *(undefined4 *)(in_at + 0xc0) = uVar18;
  uVar18 = getCopReg(2,0x13);
  *(undefined4 *)(in_at + 0xc4) = uVar18;
  iVar9 = *(int *)(in_at + 0x11c);
  uVar14 = getCopReg(2,0);
  uVar17 = getCopReg(2,0x1000);
  uVar19 = getCopReg(2,0x2000);
  setCopReg(2,0,iVar9 - (uVar14 & 0xffff0000) | uVar14 & 0xffff);
  setCopReg(2,0x1000,iVar9 - (uVar17 & 0xffff0000) | uVar17 & 0xffff);
  setCopReg(2,0x2000,iVar9 - (uVar19 & 0xffff0000) | uVar19 & 0xffff);
  copFunction(2,0x280030);
  do {
    uVar14 = in_t3 & 0x1ff;
    iVar9 = uVar14 * 4;
    if (uVar14 != 0) {
      iVar9 = (&iStack4)[uVar14];
    }
    *(ushort *)(in_at + 0x24) = *(ushort *)(in_at + 0x24) ^ 0x8000;
    *(int *)(in_at + 0x50) = iVar9;
    iVar9 = *(int *)(in_at + 0x1c);
    uVar17 = getCopReg(2,0x7000);
    iVar11 = getCopControlWord(2,0xf800);
    uVar14 = in_t1;
    if (-1 < iVar11 << 0xd) {
      if ((int)(in_t3 << 3) < 0) {
        copFunction(2,0x1400006);
        uVar15 = getCopReg(2,0xc000);
        if ((uVar15 == 0) ||
           (uVar19 = getCopReg(2,0x6000),
           (int)(uVar15 ^ (int)*(short *)(in_at + 0x24) ^ in_t3 << 2) < 1)) goto LAB_8006bd64;
      }
      else {
        uVar19 = getCopReg(2,0x6000);
      }
      uVar15 = getCopReg(2,0x6800);
      copFunction(2,0x158002d);
      uVar17 = ~(uVar19 - iVar9 | uVar15 - iVar9 | uVar17 - iVar9) | uVar19 & uVar17 & uVar15;
      if (-1 < (int)uVar17) {
        uVar18 = getCopReg(2,0x18);
        *(undefined4 *)(in_at + 0x2c) = uVar18;
        if (-1 < (int)(uVar17 << 0x10)) {
          *(uint *)(in_at + 0x98) = uVar21;
          *(uint *)(in_at + 0xb0) = uVar22;
          *(uint *)(in_at + 200) = in_t1;
          *(undefined4 *)(in_at + 0x38) = *(undefined4 *)(in_at + 0x40);
          in_v0 = (*unaff_s5)();
          uVar21 = *(uint *)(in_at + 0x98);
          uVar22 = *(uint *)(in_at + 0xb0);
          uVar14 = *(uint *)(in_at + 200);
        }
      }
    }
LAB_8006bd64:
    uVar18 = getCopReg(2,0xc);
    *(undefined4 *)(in_at + 0xa0) = uVar18;
    uVar18 = getCopReg(2,0x11);
    *(undefined4 *)(in_at + 0xa4) = uVar18;
    uVar18 = getCopReg(2,0xd);
    *(undefined4 *)(in_at + 0xb8) = uVar18;
    uVar18 = getCopReg(2,0x12);
    *(undefined4 *)(in_at + 0xbc) = uVar18;
    uVar18 = getCopReg(2,0xe);
    *(undefined4 *)(in_at + 0xd0) = uVar18;
    uVar18 = getCopReg(2,0x13);
    *(undefined4 *)(in_at + 0xd4) = uVar18;
    setCopReg(2,in_t4,*(undefined4 *)(in_at + 0x90));
    setCopReg(2,unaff_s1,*(undefined4 *)(in_at + 0x94));
    setCopReg(2,in_t5,*(undefined4 *)(in_at + 0xa8));
    setCopReg(2,unaff_s2,*(undefined4 *)(in_at + 0xac));
    setCopReg(2,uVar21,*(undefined4 *)(in_at + 0xc0));
    setCopReg(2,unaff_s3,*(undefined4 *)(in_at + 0xc4));
    *(ushort *)(in_at + 0x24) = *(ushort *)(in_at + 0x24) ^ 0x8000;
    iVar9 = *(int *)(in_at + 0x1c);
    uVar19 = getCopReg(2,0x7000);
    iVar11 = getCopControlWord(2,0xf800);
    in_t1 = in_t3 << 2;
    uVar17 = uVar22;
    if (-1 < iVar11 << 0xd) {
      if ((int)(in_t3 << 3) < 0) {
        copFunction(2,0x1400006);
        uVar16 = getCopReg(2,0xc000);
        in_t1 = (int)*(short *)(in_at + 0x24) ^ in_t1;
        if ((uVar16 == 0) || (uVar15 = getCopReg(2,0x6000), (int)(uVar16 ^ in_t1) < 1))
        goto LAB_8006be24;
      }
      else {
        uVar15 = getCopReg(2,0x6000);
      }
      uVar16 = getCopReg(2,0x6800);
      copFunction(2,0x158002d);
      in_t1 = uVar16 - iVar9;
      uVar19 = ~(uVar15 - iVar9 | in_t1 | uVar19 - iVar9) | uVar15 & uVar19 & uVar16;
      if (-1 < (int)uVar19) {
        uVar18 = getCopReg(2,0x18);
        *(undefined4 *)(in_at + 0x2c) = uVar18;
        if (-1 < (int)(uVar19 << 0x10)) {
          *(undefined4 *)(in_at + 0x38) = *(undefined4 *)(in_at + 0x3c);
          in_v0 = (*unaff_s5)();
          uVar17 = uVar22;
        }
      }
    }
LAB_8006be24:
    while( true ) {
      uVar22 = uVar14;
      in_t3 = *in_t9;
      in_t9 = in_t9 + 1;
      in_t0 = in_t3 + 1;
      if ((int)in_t3 < 0) goto code_r0x8006bbc0;
      uVar14 = in_t3 >> 0x10;
      in_t1 = in_t3 << 1;
      if (uVar14 != 0) break;
      uVar21 = in_t3 >> 7 & 0x1fc;
      if ((int)(in_t3 << 0x1f) < 0) {
        uVar21 = *(uint *)(uVar21 + in_at + 0x140);
      }
      else {
        uVar21 = *(uint *)(&gp0x00000000 + uVar21);
      }
      uVar17 = uVar21;
      if ((int)(in_t3 << 0x1e) < 0) {
        uVar14 = *(uint *)((in_t3 & 0x1fc) + in_at + 0x140);
      }
      else {
        uVar14 = *(uint *)(&gp0x00000000 + (in_t3 & 0x1fc));
      }
    }
    if ((int)in_t1 < 0) {
      uVar18 = getCopReg(2,0x6000);
      uVar20 = getCopReg(2,0x8800);
      setCopReg(2,0x6800,uVar18);
      setCopReg(2,0x9000,uVar20);
      in_t1 = *(uint *)(in_at + 0xa0);
      *(uint *)(in_at + 0xb8) = in_t1;
      *(undefined4 *)(in_at + 0xbc) = *(undefined4 *)(in_at + 0xa4);
      uVar17 = uVar21;
    }
    uVar21 = uVar17;
    uVar27 = (*unaff_s6)();
    in_v0 = (undefined4)uVar27;
    setCopReg(2,0,uVar14);
    setCopReg(2,0x800,(int)((ulonglong)uVar27 >> 0x20));
    copFunction(2,0x180001);
    uVar18 = getCopReg(2,0xc);
    *(undefined4 *)(in_at + 0x90) = uVar18;
    uVar18 = getCopReg(2,0x11);
    *(undefined4 *)(in_at + 0x94) = uVar18;
    uVar18 = getCopReg(2,0xd);
    *(undefined4 *)(in_at + 0xa8) = uVar18;
    uVar18 = getCopReg(2,0x12);
    *(undefined4 *)(in_at + 0xac) = uVar18;
    uVar18 = getCopReg(2,0xe);
    *(undefined4 *)(in_at + 0xc0) = uVar18;
    uVar18 = getCopReg(2,0x13);
    *(undefined4 *)(in_at + 0xc4) = uVar18;
    uVar14 = getCopReg(2,0);
    setCopReg(2,0,*(int *)(in_at + 0x11c) - (uVar14 & 0xffff0000) | uVar14 & 0xffff);
    setCopReg(2,in_t5,*(undefined4 *)(in_at + 0xb8));
    setCopReg(2,unaff_s2,*(undefined4 *)(in_at + 0xbc));
    setCopReg(2,uVar21,*(undefined4 *)(in_at + 0xd0));
    setCopReg(2,unaff_s3,*(undefined4 *)(in_at + 0xd4));
    copFunction(2,0x180001);
  } while( true );
}

// Draw_KartInWaterMud
void FUN_8006bf30(void)

{
  int in_at;
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  undefined4 uVar5;
  int iVar6;
  char cVar7;
  uint in_t3;
  uint in_t4;
  uint in_t5;
  uint unaff_s1;
  int unaff_s3;
  uint uVar8;
  uint uVar9;
  int iVar10;
  uint uVar11;
  uint *unaff_s7;
  uint *unaff_s8;

  iVar6 = (in_t3 >> 0xd & 0x7f8) + in_at;
  if (-1 < (int)(in_t3 << 5)) {
    if (unaff_s8 == (uint *)0x0) {
      uVar1 = *unaff_s7;
    }
    else {
      uVar11 = *unaff_s8;
      uVar2 = uVar11 >> 6 & 7;
      uVar3 = uVar2 + 1;
      uVar8 = unaff_s3 + uVar3;
      cVar7 = (char)((int)unaff_s1 >> (uVar2 ^ 0x1f));
      uVar1 = unaff_s1;
      uVar9 = uVar8;
      if (0 < (int)uVar8) {
        uVar1 = *unaff_s7;
        unaff_s7 = unaff_s7 + 1;
        cVar7 = (char)((int)(unaff_s1 | uVar1 >> (uVar3 - uVar8 & 0x1f)) >> (uVar2 ^ 0x1f));
        uVar9 = uVar8 - 0x20;
        uVar3 = uVar8;
      }
      uVar1 = uVar1 << (uVar3 & 0x1f);
      if (uVar2 != 7) {
        cVar7 = cVar7 + (char)((int)uVar11 >> 0x19) * '\x02' + *(char *)(in_at + 0x58);
      }
      *(char *)(in_at + 0x58) = cVar7;
      uVar4 = uVar11 >> 3 & 7;
      uVar2 = uVar4 + 1;
      uVar9 = uVar9 + uVar2;
      uVar3 = uVar1;
      uVar8 = uVar9;
      if (0 < (int)uVar9) {
        uVar3 = *unaff_s7;
        unaff_s7 = unaff_s7 + 1;
        uVar1 = uVar1 | uVar3 >> (uVar2 - uVar9 & 0x1f);
        uVar8 = uVar9 - 0x20;
        uVar2 = uVar9;
      }
      cVar7 = (char)((int)uVar1 >> (uVar4 ^ 0x1f));
      uVar3 = uVar3 << (uVar2 & 0x1f);
      if (uVar4 != 7) {
        cVar7 = cVar7 + (char)((uVar11 << 7) >> 0x18) + *(char *)(in_at + 0x5a);
      }
      *(char *)(in_at + 0x5a) = cVar7;
      uVar1 = uVar11 & 7;
      iVar10 = uVar8 + uVar1 + 1;
      if (0 < iVar10) {
        uVar3 = uVar3 | *unaff_s7 >> ((uVar1 + 1) - iVar10 & 0x1f);
      }
      cVar7 = (char)((int)uVar3 >> (uVar1 ^ 0x1f));
      if (uVar1 != 7) {
        cVar7 = cVar7 + (char)((uVar11 << 0xf) >> 0x18) + *(char *)(in_at + 0x59);
      }
      *(char *)(in_at + 0x59) = cVar7;
      uVar1 = *(uint *)(in_at + 0x58);
    }
    setCopReg(2,0,((uVar1 & in_t4) + *(int *)(in_at + 0x30)) * 4 & in_t5);
    setCopReg(2,0x800,((uVar1 >> 8 & 0xff) + *(int *)(in_at + 0x34)) * 4);
    copFunction(2,0x4a6012);
    uVar5 = getCopReg(2,0x5800);
    iVar10 = getCopReg(2,0x5000);
    uVar1 = getCopReg(2,0x4800);
    *(uint *)(iVar6 + 0x140) = iVar10 << 0x10 | uVar1 & 0xffff;
    *(undefined4 *)(iVar6 + 0x144) = uVar5;
  }
  if (-1 < (int)(in_t3 << 4)) {
    return;
  }
  return;
}

// ConvertRotToMatrix_InverseTranspose_NoRotY
// param1 MATRIX
// param2 vec3s rotation (similar to R_to_M)
void FUN_8006c124(uint *param_1,short *param_2)

{
  short sVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  undefined4 unaff_s0;
  int unaff_s1;
  uint unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_retaddr;

  sVar1 = *param_2;
  uVar5 = 0;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f80002c = unaff_retaddr;

  // TRIG_AngleSinCos_r16r17r18_duplicate
  FUN_8006c430();

  uVar6 = 0x1000;
  uVar2 = unaff_s1 * -0x10000 | unaff_s2;
  uVar3 = unaff_s1 << 0x10;
  uVar4 = unaff_s2;
  FUN_8006c540();

  if (sVar1 != 0) {
    uVar2 = 0x1000;

	// TRIG_AngleSinCos_r16r17r18_duplicate
	FUN_8006c430();

	uVar3 = 0;
    uVar4 = unaff_s1 * -0x10000 | unaff_s2;
    uVar5 = unaff_s1 << 0x10;
	FUN_8006c49c();
	uVar6 = unaff_s2;
  }
  *param_1 = uVar2;
  param_1[1] = uVar3;
  param_1[2] = uVar4;
  param_1[3] = uVar5;
  param_1[4] = uVar6;
  return;
}

// ConvertRotToMatrix_InverseTranspose
// param1 MATRIX
// param2 vec3s rotation (similar to R_to_M)
void FUN_8006c1d0(uint *param_1,short *param_2)
{
  // 8006c1d0(DC0,D80,D40)
  // 8006c378(240,280,2C0)

  short sVar1;
  short sVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  undefined4 unaff_s0;
  uint unaff_s1;
  uint unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_retaddr;

  sVar1 = *param_2;
  sVar2 = param_2[1];
  uVar6 = 0;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f80002c = unaff_retaddr;

  // TRIG_AngleSinCos_r16r17r18_duplicate
  FUN_8006c430();

  uVar7 = 0x1000;
  uVar3 = unaff_s1 * -0x10000 | unaff_s2;
  uVar4 = unaff_s1 << 0x10;
  uVar5 = unaff_s2;
  FUN_8006c540();
  if (sVar1 != 0) {
    uVar3 = 0x1000;

	// TRIG_AngleSinCos_r16r17r18_duplicate
	FUN_8006c430();

    uVar4 = 0;
    uVar5 = unaff_s1 * -0x10000 | unaff_s2;
    uVar6 = unaff_s1 << 0x10;
    uVar7 = unaff_s2;
	FUN_8006c49c();
  }
  if (sVar2 != 0) {
    uVar5 = 0x1000;

	// TRIG_AngleSinCos_r16r17r18_duplicate
    FUN_8006c430();

    uVar6 = -unaff_s1 & 0xffff;
    uVar7 = unaff_s2;
    FUN_8006c49c();

    uVar3 = unaff_s2;
    uVar4 = unaff_s1;
  }
  *param_1 = uVar3;
  param_1[1] = uVar4;
  param_1[2] = uVar5;
  param_1[3] = uVar6;
  param_1[4] = uVar7;
  return;
}


// ConvertRotToMatrix
// param1 is matrix, param2 is vec3s rotation,
void FUN_8006c2a4(uint *param_1,short *param_2)

{
  short sVar1;
  short sVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  undefined4 unaff_s0;
  uint unaff_s1;
  uint unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_retaddr;

  sVar1 = *param_2;
  sVar2 = param_2[2];
  uVar5 = 0x1000;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f80002c = unaff_retaddr;

  // TRIG_AngleSinCos_r16r17r18_duplicate
  FUN_8006c430();

  uVar6 = -unaff_s1 & 0xffff;
  uVar3 = unaff_s2;
  uVar4 = unaff_s1;
  uVar7 = unaff_s2;
  FUN_8006c540();
  if (sVar1 != 0) {
    uVar3 = 0x1000;

	// TRIG_AngleSinCos_r16r17r18_duplicate
    FUN_8006c430();

    uVar4 = 0;
    uVar5 = unaff_s1 * -0x10000 | unaff_s2;
    uVar6 = unaff_s1 << 0x10;
    uVar7 = unaff_s2;
    FUN_8006c49c();
  }
  if (sVar2 != 0) {
    uVar6 = 0;

	// TRIG_AngleSinCos_r16r17r18_duplicate
	FUN_8006c430();

    uVar7 = 0x1000;
    uVar3 = unaff_s1 * -0x10000 | unaff_s2;
    uVar4 = unaff_s1 << 0x10;
    FUN_8006c49c();
    uVar5 = unaff_s2;
  }

  // Set 5 ints,
  // which is 10 shorts,
  // m[3][3] in matrix
  *param_1 = uVar3;
  param_1[1] = uVar4;
  param_1[2] = uVar5;
  param_1[3] = uVar6;
  param_1[4] = uVar7;
  return;
}



// WARNING: Removing unreachable block (ram,0x8006c3b0)

// ConvertRotToMatrix_Transpose
// param_1 - MATRIX
// param_2 - vec3s rotation (similar to R_to_M)
void FUN_8006c378(uint *param_1,short *param_2)

{
  short sVar1;
  short sVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  undefined4 unaff_s0;
  uint unaff_s1;
  uint unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_retaddr;

  sVar1 = *param_2;
  sVar2 = param_2[1];
  uVar6 = 0;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f80002c = unaff_retaddr;

  // TRIG_AngleSinCos_r16r17r18_duplicate
  FUN_8006c430();

  uVar7 = 0x1000;
  uVar3 = unaff_s1 * -0x10000 | unaff_s2;
  uVar4 = unaff_s1 << 0x10;
  uVar5 = unaff_s2;
  FUN_8006c540();
  if (sVar1 != 0) {
    uVar3 = 0x1000;

	// TRIG_AngleSinCos_r16r17r18_duplicate
	FUN_8006c430();

	uVar4 = 0;
    uVar5 = unaff_s1 * -0x10000 | unaff_s2;
    uVar6 = unaff_s1 << 0x10;
    uVar7 = unaff_s2;
    FUN_8006c49c();
  }
  if (sVar2 != 0) {
    uVar5 = 0x1000;

	// TRIG_AngleSinCos_r16r17r18_duplicate
    FUN_8006c430();

    uVar6 = -unaff_s1 & 0xffff;
    uVar7 = unaff_s2;
    FUN_8006c49c();
    uVar3 = unaff_s2;
    uVar4 = unaff_s1;
  }
  *param_1 = uVar3;
  param_1[1] = uVar4;
  param_1[2] = uVar5;
  param_1[3] = uVar6;
  param_1[4] = uVar7;
  return;
}



void FUN_8006c3b0(undefined4 *param_1,undefined4 param_2,undefined4 *param_3)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_retaddr;

  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f80002c = unaff_retaddr;
  FUN_8006c540();
  uVar1 = *param_3;
  uVar2 = param_3[1];
  uVar3 = param_3[2];
  uVar4 = param_3[3];
  uVar5 = param_3[4];
  FUN_8006c49c();
  *param_1 = uVar1;
  param_1[1] = uVar2;
  param_1[2] = uVar3;
  param_1[3] = uVar4;
  param_1[4] = uVar5;
  return;
}


// TRIG_AngleSinCos_r16r17r18_duplicate
void FUN_8006c430(void)

{
        8006c430 08 80 03 3c     lui        v1,0x8008
        8006c434 a0 45 63 24     addiu      v1,v1,0x45a0
        8006c438 ff 03 11 32     andi       s1,s0,0x3ff
        8006c43c 80 88 11 00     sll        s1,s1,0x2
        8006c440 21 18 71 00     addu       v1,v1,s1
        8006c444 00 00 71 8c     lw         s1,0x0(v1)=>DAT_800845a0
        8006c448 00 04 03 32     andi       v1,s0,0x400
        8006c44c 05 00 60 14     bne        v1,zero,LAB_8006c464
        8006c450 00 08 03 32     _andi      v1,s0,0x800
        8006c454 09 00 60 14     bne        v1,zero,LAB_8006c47c
        8006c458 02 94 11 00     _srl       s2,s1,0x10
        8006c45c 08 00 e0 03     jr         ra
        8006c460 ff ff 31 32     _andi      s1,s1,0xffff
                             LAB_8006c464                                    XREF[1]:     8006c44c(j)
        8006c464 ff ff 32 32     andi       s2,s1,0xffff
        8006c468 09 00 60 14     bne        v1,zero,LAB_8006c490
        8006c46c 02 8c 11 00     _srl       s1,s1,0x10
        8006c470 22 90 12 00     sub        s2,zero,s2
        8006c474 08 00 e0 03     jr         ra
        8006c478 ff ff 52 32     _andi      s2,s2,0xffff
                             LAB_8006c47c                                    XREF[1]:     8006c454(j)
        8006c47c 22 90 12 00     sub        s2,zero,s2
        8006c480 22 88 11 00     sub        s1,zero,s1
        8006c484 ff ff 52 32     andi       s2,s2,0xffff
        8006c488 08 00 e0 03     jr         ra
        8006c48c ff ff 31 32     _andi      s1,s1,0xffff
                             LAB_8006c490                                    XREF[1]:     8006c468(j)
        8006c490 22 88 11 00     sub        s1,zero,s1
        8006c494 08 00 e0 03     jr         ra
        8006c498 ff ff 31 32     _andi      s1,s1,0xffff

}


void FUN_8006c49c(void)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint in_t3;
  uint uVar5;
  uint in_t4;
  int iVar6;
  uint in_t5;
  uint uVar7;
  uint in_t6;
  uint uVar8;
  undefined4 in_t7;
  undefined4 uVar9;

  gte_ldVXY0(in_t3 & 0xffff | in_t4 & 0xffff0000);
  gte_ldVZ0(in_t6);
  gte_rtv0_b();

  gte_ldVXY1(in_t3 >> 0x10 | in_t5 << 0x10);
  gte_ldVZ1(in_t6 >> 0x10);
  uVar5 = gte_stIR1();
  iVar6 = gte_stIR2();
  uVar8 = gte_stIR3();
  gte_rtv1_b();

  gte_ldVXY2(in_t4 & 0xffff | in_t5 & 0xffff0000);
  gte_ldVZ2(in_t7);
  iVar1 = gte_stIR1();
  uVar7 = gte_stIR2();
  iVar3 = gte_stIR3();
  gte_rtv2_b();

  uVar2 = gte_stIR1();
  iVar4 = gte_stIR2();
  uVar9 = gte_stIR3();
  gte_ldR11R12(uVar5 & 0xffff | iVar1 << 0x10);
  gte_ldR13R21(iVar6 << 0x10 | uVar2 & 0xffff);
  gte_ldR22R23(uVar7 & 0xffff | iVar4 << 0x10);
  gte_ldR31R32(uVar8 & 0xffff | iVar3 << 0x10);
  gte_ldR33(uVar9);

  return;
}


void FUN_8006c540(void)

{
  undefined4 in_t3;
  undefined4 in_t4;
  undefined4 in_t5;
  undefined4 in_t6;
  undefined4 in_t7;

  gte_ldR11R12(in_t3);
  gte_ldR13R21(in_t4);
  gte_ldR22R23(in_t5);
  gte_ldR31R32(in_t6);
  gte_ldR33(in_t7);
  return;
}



void FUN_8006c558(void)

{
  uint in_t3;
  uint in_t4;
  uint in_t5;
  uint in_t6;
  undefined4 in_t7;

  gte_ldVXY0(in_t3 & 0xffff | in_t4 & 0xffff0000);
  gte_ldVZ0(in_t6);

  // llv0     v0 * light matrix
  gte_llv0_b();

  gte_ldVXY1(in_t3 >> 0x10 | in_t5 << 0x10);
  gte_ldVZ1(in_t6 >> 0x10);
  gte_stIR1();
  gte_stIR2();
  gte_stIR3();

  // llv1     v1 * light matrix
  gte_llv1_b();

  gte_ldVXY2(in_t4 & 0xffff | in_t5 & 0xffff0000);
  gte_ldVZ2(in_t7);
  gte_stIR1();
  gte_stIR2();
  gte_stIR3();

  // llv2     v2 * light matrix
  gte_llv2_b();

  gte_stIR1();
  gte_stIR2();
  gte_stIR3();
  return;
}



void FUN_8006c600(void)

{
  undefined4 in_t3;
  undefined4 in_t4;
  undefined4 in_t5;
  undefined4 in_t6;
  undefined4 in_t7;

  gte_ldL11L12(in_t3);
  gte_ldL13L21(in_t4);
  gte_ldL22L23(in_t5);
  gte_ldL31L32(in_t6);
  gte_ldL33(in_t7);
  return;
}

//FUN_8006c618 SquareRoot0.

void FUN_8006c684(uint *param_1)

{
  uint uVar1;
  uint uVar2;

  uVar1 = param_1[1] >> 8;
  uVar2 = *param_1 >> 8 | param_1[1] << 0x18;
  param_1[1] = (uVar1 | (*param_1 + uVar1 + (uVar2 >> 8)) * 0x1000000) ^ 0xdeadc0ed;
  *param_1 = uVar2;
  return;
}


int * FUN_8006c6c8(uint *param_1,int *param_2,undefined4 *param_3)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int iVar6;

  gte_ldR11R12(*param_3);
  gte_ldR13R21(param_3[1]);
  gte_ldR22R23(param_3[2]);
  gte_ldR31R32(param_3[3]);
  gte_ldR33(param_3[4]);

  // 4,5,6
  iVar4 = (int)*param_1 >> 0xf;
  iVar5 = (int)param_1[1] >> 0xf;
  iVar6 = (int)param_1[2] >> 0xf;

  // 4,5,6
  gte_ldsv_(iVar4,iVar5,iVar6);

  // 1,2,3
  uVar1 = *param_1 & 0x7fff;
  gte_rtir_sf0_b();
  uVar2 = param_1[1] & 0x7fff;
  uVar3 = param_1[2] & 0x7fff;

  // 4,5,6
  read_mt(iVar4,iVar5,iVar6);

  // 1,2,3
  gte_ldsv_(uVar1,uVar2,uVar3);
  gte_rtir_b();

  // 1,2,3
  read_mt(uVar1,uVar2,uVar3);

  // combine all
  *param_2 = uVar1 + iVar4 * 8;
  param_2[1] = uVar2 + iVar5 * 8;
  param_2[2] = uVar3 + iVar6 * 8;
  return param_2;
}

//FUN_8006c6f0 ApplyMatrixLV.
//FUN_8006d094 used to be here, but it was deleted.
//FUN_8006d258 used to be here, but it was deleted.
//FUN_8006d2bc used to be here, but it was deleted.
//FUN_8006d324 used to be here, but it was deleted.
//FUN_8006d38c used to be here, but it was deleted.
//FUN_8006d3c8 used to be here, but it was deleted.
//FUN_8006d4a4 used to be here, but it was deleted.

// Draw_KartGhost
void FUN_8006c984(void)

{
  bool bVar1;
  short sVar2;
  ushort uVar3;
  ushort uVar4;
  short sVar5;
  int in_at;
  undefined4 in_v0;
  int iVar6;
  code *pcVar7;
  uint uVar8;
  int *piVar9;
  int iVar10;
  int iVar11;
  undefined4 *puVar12;
  undefined4 uVar13;
  undefined uVar14;
  undefined4 uVar15;
  code *UNRECOVERED_JUMPTABLE;
  ushort *puVar16;
  short *psVar17;
  undefined4 *puVar18;
  int iVar19;
  int unaff_retaddr;

  uVar8 = *(uint *)(unaff_retaddr + 0x24);
  sVar5 = *(short *)(unaff_retaddr + 0x22);
  if (uVar8 == 0) {
    uVar14 = (undefined)(0x1000U - (int)sVar5 >> 5);
    *(undefined *)(in_at + 0x124) = uVar14;
    *(undefined *)(in_at + 0x125) = uVar14;
    *(undefined *)(in_at + 0x126) = uVar14;
    *(undefined *)(in_at + 0x127) = 0x22;
    if (sVar5 == 0x1000) {
      while( true ) {
        piVar9 = *(int **)(in_at + 4);
        iVar19 = *piVar9;
        iVar10 = piVar9[1];
        *(int **)(in_at + 4) = piVar9 + 2;
        if (iVar19 == 0) break;
        iVar6 = *(int *)(iVar10 + 0x74);
        iVar11 = *(int *)(in_at + 8);
        *(int *)(in_at + 0x10) = iVar19;
        *(int *)(in_at + 8) = iVar6;
		
		// camera110
        if (iVar6 != iVar11) 
		{
		  // width, height, distToScreen
          sVar5 = *(short *)(iVar6 + 0x20);
          sVar2 = *(short *)(iVar6 + 0x22);
          uVar15 = *(undefined4 *)(iVar6 + 0x18);
		  
		  // scratchpad
          *(short *)(in_at + 0x1c) = sVar5;
          *(short *)(in_at + 0x1e) = sVar2;
          
		  // GTE
		  setCopControlWord(2,0xc000,(int)sVar5 << 0xf);
          setCopControlWord(2,0xc800,(int)sVar2 << 0xf);
          setCopControlWord(2,0xd000,uVar15);
        }
        uVar8 = *(uint *)(iVar10 + 0xb8);
        sVar5 = *(short *)(iVar10 + 0xbc);
        
		if (((uVar8 & 0x40) != 0) && ((uVar8 & 0x80) == 0)) 
		{
		  // instance matrix
          gte_ldR11R12(*(undefined4 *)(iVar10 + 0x78));
          gte_ldR13R21(*(undefined4 *)(iVar10 + 0x7c));
          gte_ldR22R23(*(undefined4 *)(iVar10 + 0x80));
          gte_ldR31R32(*(undefined4 *)(iVar10 + 0x84));
          gte_ldR33(*(undefined4 *)(iVar10 + 0x88));
          
		  gte_ldtr(
			*(undefined4 *)(iVar10 + 0x8c),
			*(undefined4 *)(iVar10 + 0x90),
			*(undefined4 *)(iVar10 + 0x94)
		  );
          
		  *(uint *)(in_at + 0x24) = uVar8;
          *(int *)(in_at + 0x120) = (int)sVar5;
          
		  if ((uVar8 & 0x7000) != 0) 
		  {
			// instance matrix
            gte_ldL11L12(*(undefined4 *)(iVar10 + 0x98));
            gte_ldL13L21(*(undefined4 *)(iVar10 + 0x9c));
            gte_ldL22L23(*(undefined4 *)(iVar10 + 0xa0));
            gte_ldL31L32(*(undefined4 *)(iVar10 + 0xa4));
            gte_ldL33(*(undefined4 *)(iVar10 + 0xa8));
            
			sVar5 = *(short *)(iVar10 + 0xbe);
            uVar14 = *(undefined *)(iVar19 + 0x53);
            uVar15 = *(undefined4 *)(iVar19 + 0x58);
            *(short *)(in_at + 0x44) = sVar5;
            *(short *)(in_at + 0xda) = sVar5;
            *(short *)(in_at + 0xf2) = sVar5;
            *(undefined *)(in_at + 0x48) = uVar14;
            *(undefined4 *)(in_at + 0x4c) = uVar15;
            *(int *)(in_at + 0x11c) = (int)sVar5 << 0x11;
            *(undefined4 *)(in_at + 0xe0) = 0;
            *(undefined4 *)(in_at + 0xf8) = 0;
          }
          psVar17 = *(short **)(iVar10 + 0xc4);
          puVar16 = *(ushort **)(iVar10 + 0xc0);
          if (psVar17 == (short *)0x0) {
            uVar3 = puVar16[1];
            uVar4 = puVar16[2];
            *(ushort *)(in_at + 0x30) = *puVar16 & 0x7fff;
            *(ushort *)(in_at + 0x32) = uVar3;
            *(int *)(in_at + 0x34) = (int)(short)uVar4;
          }
          else {
            *(ushort *)(in_at + 0x30) = *puVar16 + *psVar17;
            *(ushort *)(in_at + 0x32) = puVar16[1] + psVar17[1];
            *(int *)(in_at + 0x34) = ((int)(short)puVar16[2] + (int)psVar17[2]) * 2;
          }
          *(undefined4 *)(in_at + 0x58) = 0;
          puVar18 = *(undefined4 **)(iVar10 + 0xd0);
          iVar6 = **(int **)(iVar10 + 200);
          puVar12 = (undefined4 *)(in_at + 0x140);
          while (bVar1 = 0 < iVar6, iVar6 = iVar6 + -1, bVar1) {
            uVar15 = *puVar18;
            puVar18 = puVar18 + 1;
            *puVar12 = uVar15;
            puVar12 = puVar12 + 1;
          }
          (**(code **)(iVar19 + 0x5c))();
          sVar5 = *(short *)(iVar10 + 0xde);
          *(short *)(in_at + 0x134) = (short)((int)*(short *)(iVar10 + 0xdc) << 2);
          *(short *)(in_at + 0x136) = (short)((int)sVar5 << 2);
          uVar15 = *(undefined4 *)(iVar10 + 0xe4);
          uVar13 = *(undefined4 *)(iVar10 + 0xe8);
          pcVar7 = *(code **)(iVar10 + 0xec);
          *(undefined4 *)(in_at + 0x38) = uVar15;
          *(undefined4 *)(in_at + 0x3c) = uVar15;
          *(undefined4 *)(in_at + 0x40) = uVar13;
          in_v0 = (*pcVar7)(*(undefined4 *)(iVar19 + 100));
        }
      }
      *(undefined4 *)(*(int *)(in_at + 0xc) + 0xc) = in_v0;
      return;
    }
  }
  setCopReg(2,0x3000,0);
  setCopControlWord(2,0xa800,uVar8 >> 0x10 & 0xff0);
  setCopControlWord(2,0xb000,uVar8 >> 8 & 0xff0);
                    /* WARNING: Could not recover jumptable at 0x8006c96c. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  setCopControlWord(2,0xb800,uVar8 & 0xff0);
  (*UNRECOVERED_JUMPTABLE)();
  return;
}

// Draw_KartBodyReflection
void FUN_8006c9c4(void)

{
  bool bVar1;
  undefined uVar2;
  short sVar3;
  short sVar4;
  ushort uVar5;
  ushort uVar6;
  undefined4 in_zero;
  int in_at;
  undefined4 in_v0;
  int iVar7;
  code *pcVar8;
  undefined4 extraout_v1;
  undefined4 extraout_v1_00;
  undefined4 uVar9;
  uint uVar10;
  int *piVar11;
  int iVar12;
  int iVar13;
  undefined4 *puVar14;
  int in_t0;
  int iVar15;
  uint uVar16;
  uint uVar17;
  undefined4 uVar18;
  uint uVar19;
  uint in_t1;
  uint uVar20;
  undefined4 uVar21;
  uint uVar22;
  undefined4 uVar23;
  uint in_t3;
  undefined4 in_t4;
  undefined4 in_t5;
  uint uVar24;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  code *unaff_s6;
  ushort *puVar25;
  short *psVar26;
  uint *in_t9;
  uint *puVar27;
  undefined4 *puVar28;
  undefined8 uVar29;
  int iStack4;

code_r0x8006c9c4:
  puVar27 = in_t9 + 1;
  if (in_t0 == 0) {
    while( true ) {
      piVar11 = *(int **)(in_at + 4);
      iVar12 = *piVar11;
      iVar15 = piVar11[1];
      *(int **)(in_at + 4) = piVar11 + 2;
      if (iVar12 == 0) break;
	  
	  // instance -> camera110
      iVar7 = *(int *)(iVar15 + 0x74);
	  
      iVar13 = *(int *)(in_at + 8);
      *(int *)(in_at + 0x10) = iVar12;
      *(int *)(in_at + 8) = iVar7;
	  
	  // if this camera110 is not previous
      if (iVar7 != iVar13) 
	  {
		// camera110 width, height, distToScreen
        sVar3 = *(short *)(iVar7 + 0x20);
        sVar4 = *(short *)(iVar7 + 0x22);
        uVar9 = *(undefined4 *)(iVar7 + 0x18);
		
		// scratchpad
        *(short *)(in_at + 0x1c) = sVar3;
        *(short *)(in_at + 0x1e) = sVar4;
		
		// GTE
        setCopControlWord(2,0xc000,(int)sVar3 << 0xf);
        setCopControlWord(2,0xc800,(int)sVar4 << 0xf);
        setCopControlWord(2,0xd000,uVar9);
      }
      uVar10 = *(uint *)(iVar15 + 0xb8);
      sVar3 = *(short *)(iVar15 + 0xbc);
      if (((uVar10 & 0x40) != 0) && ((uVar10 & 0x80) == 0)) 
	  {
		// instance matrix
		gte_ldR11R12(*(undefined4 *)(iVar15 + 0x78));
		gte_ldR13R21(*(undefined4 *)(iVar15 + 0x7c));
		gte_ldR22R23(*(undefined4 *)(iVar15 + 0x80));
		gte_ldR31R32(*(undefined4 *)(iVar15 + 0x84));
		gte_ldR33(*(undefined4 *)(iVar15 + 0x88));
		
		gte_ldtr(
		  *(undefined4 *)(iVar15 + 0x8c),
		  *(undefined4 *)(iVar15 + 0x90),
		  *(undefined4 *)(iVar15 + 0x94)
		);
		
        *(uint *)(in_at + 0x24) = uVar10;
        *(int *)(in_at + 0x120) = (int)sVar3;
        if ((uVar10 & 0x7000) != 0) 
		{
		  // instance matrix
          gte_ldL11L12(*(undefined4 *)(iVar15 + 0x98));
          gte_ldL13L21(*(undefined4 *)(iVar15 + 0x9c));
          gte_ldL22L23(*(undefined4 *)(iVar15 + 0xa0));
          gte_ldL31L32(*(undefined4 *)(iVar15 + 0xa4));
          gte_ldL33(*(undefined4 *)(iVar15 + 0xa8));
			
          sVar3 = *(short *)(iVar15 + 0xbe);
          uVar2 = *(undefined *)(iVar12 + 0x53);
          uVar9 = *(undefined4 *)(iVar12 + 0x58);
          *(short *)(in_at + 0x44) = sVar3;
          *(short *)(in_at + 0xda) = sVar3;
          *(short *)(in_at + 0xf2) = sVar3;
          *(undefined *)(in_at + 0x48) = uVar2;
          *(undefined4 *)(in_at + 0x4c) = uVar9;
          *(int *)(in_at + 0x11c) = (int)sVar3 << 0x11;
          *(undefined4 *)(in_at + 0xe0) = 0;
          *(undefined4 *)(in_at + 0xf8) = 0;
        }
        psVar26 = *(short **)(iVar15 + 0xc4);
        puVar25 = *(ushort **)(iVar15 + 0xc0);
        if (psVar26 == (short *)0x0) {
          uVar5 = puVar25[1];
          uVar6 = puVar25[2];
          *(ushort *)(in_at + 0x30) = *puVar25 & 0x7fff;
          *(ushort *)(in_at + 0x32) = uVar5;
          *(int *)(in_at + 0x34) = (int)(short)uVar6;
        }
        else {
          *(ushort *)(in_at + 0x30) = *puVar25 + *psVar26;
          *(ushort *)(in_at + 0x32) = puVar25[1] + psVar26[1];
          *(int *)(in_at + 0x34) = ((int)(short)puVar25[2] + (int)psVar26[2]) * 2;
        }
        *(undefined4 *)(in_at + 0x58) = 0;
        puVar28 = *(undefined4 **)(iVar15 + 0xd0);
        iVar7 = **(int **)(iVar15 + 200);
        puVar14 = (undefined4 *)(in_at + 0x140);
        while (bVar1 = 0 < iVar7, iVar7 = iVar7 + -1, bVar1) {
          uVar9 = *puVar28;
          puVar28 = puVar28 + 1;
          *puVar14 = uVar9;
          puVar14 = puVar14 + 1;
        }
        (**(code **)(iVar12 + 0x5c))();
        sVar3 = *(short *)(iVar15 + 0xde);
        *(short *)(in_at + 0x134) = (short)((int)*(short *)(iVar15 + 0xdc) << 2);
        *(short *)(in_at + 0x136) = (short)((int)sVar3 << 2);
        uVar9 = *(undefined4 *)(iVar15 + 0xe4);
        uVar18 = *(undefined4 *)(iVar15 + 0xe8);
        pcVar8 = *(code **)(iVar15 + 0xec);
        *(undefined4 *)(in_at + 0x38) = uVar9;
        *(undefined4 *)(in_at + 0x3c) = uVar9;
        *(undefined4 *)(in_at + 0x40) = uVar18;
        in_v0 = (*pcVar8)(*(undefined4 *)(iVar12 + 100));
      }
    }
    *(undefined4 *)(*(int *)(in_at + 0xc) + 0xc) = in_v0;
    return;
  }
  *(uint *)(in_at + 0x10c) = in_t3;
  (*unaff_s6)();
  *(int *)(in_at + 0x90) = in_t0;
  *(undefined4 *)(in_at + 0x94) = extraout_v1;
  iVar15 = (int)*(short *)(in_at + 0x44) - (in_t0 >> 0x10);
  *(short *)(in_at + 0x9e) = (short)iVar15;
  uVar10 = in_t1;
  (*unaff_s6)();
  *(int *)(in_at + 0xa8) = iVar15;
  *(undefined4 *)(in_at + 0xac) = extraout_v1_00;
  iVar15 = (int)*(short *)(in_at + 0x44) - (iVar15 >> 0x10);
  *(short *)(in_at + 0xb6) = (short)iVar15;
  uVar24 = in_t1;
  uVar29 = (*unaff_s6)();
  uVar9 = (undefined4)((ulonglong)uVar29 >> 0x20);
  in_v0 = (undefined4)uVar29;
  setCopReg(2,in_zero,*(undefined4 *)(in_at + 0x90));
  setCopReg(2,in_at,*(undefined4 *)(in_at + 0x94));
  setCopReg(2,in_v0,*(undefined4 *)(in_at + 0xa8));
  setCopReg(2,uVar9,*(undefined4 *)(in_at + 0xac));
  setCopReg(2,0x2000,iVar15);
  setCopReg(2,0x2800,uVar9);
  in_t3 = *(uint *)(in_at + 0x10c);
  copFunction(2,0x280030);
  *(int *)(in_at + 0xc0) = iVar15;
  *(undefined4 *)(in_at + 0xc4) = uVar9;
  *(short *)(in_at + 0xce) = *(short *)(in_at + 0x44) - (short)((uint)iVar15 >> 0x10);
  in_t9 = puVar27 + 1;
  uVar9 = getCopReg(2,0xc);
  *(undefined4 *)(in_at + 0x6c) = uVar9;
  uVar9 = getCopReg(2,0x11);
  *(undefined4 *)(in_at + 0x70) = uVar9;
  uVar9 = getCopReg(2,0xd);
  *(undefined4 *)(in_at + 0x74) = uVar9;
  uVar9 = getCopReg(2,0x12);
  *(undefined4 *)(in_at + 0x78) = uVar9;
  uVar9 = getCopReg(2,0xe);
  *(undefined4 *)(in_at + 0x7c) = uVar9;
  uVar9 = getCopReg(2,0x13);
  *(undefined4 *)(in_at + 0x80) = uVar9;
  iVar15 = *(int *)(in_at + 0x11c);
  uVar16 = getCopReg(2,0);
  uVar20 = getCopReg(2,0x1000);
  uVar22 = getCopReg(2,0x2000);
  setCopReg(2,0,iVar15 - (uVar16 & 0xffff0000) | uVar16 & 0xffff);
  setCopReg(2,0x1000,iVar15 - (uVar20 & 0xffff0000) | uVar20 & 0xffff);
  setCopReg(2,0x2000,iVar15 - (uVar22 & 0xffff0000) | uVar22 & 0xffff);
  copFunction(2,0x280030);
  uVar16 = in_t1;
  do {
    uVar20 = in_t3 & 0x1ff;
    iVar15 = uVar20 * 4;
    if (uVar20 != 0) {
      iVar15 = (&iStack4)[uVar20];
    }
    *(ushort *)(in_at + 0x24) = *(ushort *)(in_at + 0x24) ^ 0x8000;
    *(int *)(in_at + 0x50) = iVar15;
    uVar9 = *(undefined4 *)(in_at + 0x3c);
    *(undefined4 *)(in_at + 0x3c) = *(undefined4 *)(in_at + 0x40);
    *(undefined4 *)(in_at + 0x40) = uVar9;
    *(undefined4 *)(in_at + 0x108) = 0;
    iVar15 = *(int *)(in_at + 0x1c);
    uVar20 = getCopReg(2,0x7000);
    iVar12 = getCopControlWord(2,0xf800);
    if (-1 < iVar12 << 0xd) {
      if ((int)(in_t3 << 3) < 0) {
        copFunction(2,0x1400006);
        uVar17 = getCopReg(2,0xc000);
        if ((uVar17 == 0) ||
           (uVar22 = getCopReg(2,0x6000),
           (int)(uVar17 ^ (int)*(short *)(in_at + 0x24) ^ in_t3 << 2) < 1)) goto LAB_8006cb88;
      }
      else {
        uVar22 = getCopReg(2,0x6000);
      }
      uVar17 = getCopReg(2,0x6800);
      copFunction(2,0x158002d);
      uVar20 = ~(uVar22 - iVar15 | uVar17 - iVar15 | uVar20 - iVar15) | uVar22 & uVar20 & uVar17;
      if (-1 < (int)uVar20) {
        uVar9 = getCopReg(2,0x18);
        *(undefined4 *)(in_at + 0x2c) = uVar9;
        if (-1 < (int)(uVar20 << 0x10)) {
          in_v0 = FUN_8006d094();
        }
      }
    }
LAB_8006cb88:
    uVar9 = getCopReg(2,0x6000);
    uVar18 = getCopReg(2,0x8800);
    uVar21 = getCopReg(2,0x6800);
    uVar23 = getCopReg(2,0x9000);
    setCopReg(2,in_t4,*(undefined4 *)(in_at + 0x6c));
    setCopReg(2,unaff_s1,*(undefined4 *)(in_at + 0x70));
    setCopReg(2,in_t5,*(undefined4 *)(in_at + 0x74));
    setCopReg(2,unaff_s2,*(undefined4 *)(in_at + 0x78));
    *(undefined4 *)(in_at + 0x6c) = uVar9;
    *(undefined4 *)(in_at + 0x70) = uVar18;
    *(undefined4 *)(in_at + 0x74) = uVar21;
    *(undefined4 *)(in_at + 0x78) = uVar23;
    uVar9 = getCopReg(2,0x7000);
    uVar18 = getCopReg(2,0x9800);
    setCopReg(2,uVar10,*(undefined4 *)(in_at + 0x7c));
    setCopReg(2,unaff_s3,*(undefined4 *)(in_at + 0x80));
    *(undefined4 *)(in_at + 0x7c) = uVar9;
    *(undefined4 *)(in_at + 0x80) = uVar18;
    *(ushort *)(in_at + 0x24) = *(ushort *)(in_at + 0x24) ^ 0x8000;
    uVar9 = *(undefined4 *)(in_at + 0x40);
    *(undefined4 *)(in_at + 0x40) = *(undefined4 *)(in_at + 0x3c);
    *(undefined4 *)(in_at + 0x3c) = uVar9;
    *(undefined4 *)(in_at + 0x108) = 0xffffffff;
    iVar15 = *(int *)(in_at + 0x1c);
    uVar22 = getCopReg(2,0x7000);
    iVar12 = getCopControlWord(2,0xf800);
    in_t1 = in_t3 << 2;
    uVar20 = uVar24;
    if (-1 < iVar12 << 0xd) {
      if ((int)(in_t3 << 3) < 0) {
        copFunction(2,0x1400006);
        uVar19 = getCopReg(2,0xc000);
        in_t1 = (int)*(short *)(in_at + 0x24) ^ in_t1;
        if ((uVar19 == 0) || (uVar17 = getCopReg(2,0x6000), (int)(uVar19 ^ in_t1) < 1))
        goto LAB_8006cc74;
      }
      else {
        uVar17 = getCopReg(2,0x6000);
      }
      uVar19 = getCopReg(2,0x6800);
      copFunction(2,0x158002d);
      in_t1 = uVar19 - iVar15;
      uVar22 = ~(uVar17 - iVar15 | in_t1 | uVar22 - iVar15) | uVar17 & uVar22 & uVar19;
      if (-1 < (int)uVar22) {
        uVar9 = getCopReg(2,0x18);
        *(undefined4 *)(in_at + 0x2c) = uVar9;
        if (-1 < (int)(uVar22 << 0x10)) {
          in_v0 = FUN_8006d094();
          uVar20 = uVar24;
        }
      }
    }
LAB_8006cc74:
    while( true ) {
      uVar24 = uVar16;
      in_t3 = *in_t9;
      in_t9 = in_t9 + 1;
      in_t0 = in_t3 + 1;
      if ((int)in_t3 < 0) goto code_r0x8006c9c4;
      uVar22 = in_t3 >> 0x10;
      in_t1 = in_t3 << 1;
      if (uVar22 != 0) break;
      uVar10 = in_t3 >> 7 & 0x1fc;
      if ((int)(in_t3 << 0x1f) < 0) {
        uVar10 = *(uint *)(uVar10 + in_at + 0x140);
      }
      else {
        uVar10 = *(uint *)(&gp0x00000000 + uVar10);
      }
      uVar20 = uVar10;
      if ((int)(in_t3 << 0x1e) < 0) {
        uVar16 = *(uint *)((in_t3 & 0x1fc) + in_at + 0x140);
      }
      else {
        uVar16 = *(uint *)(&gp0x00000000 + (in_t3 & 0x1fc));
      }
    }
    if ((int)in_t1 < 0) {
      uVar9 = getCopReg(2,0x6000);
      uVar18 = getCopReg(2,0x8800);
      setCopReg(2,0x6800,uVar9);
      setCopReg(2,0x9000,uVar18);
      *(undefined4 *)(in_at + 0x74) = *(undefined4 *)(in_at + 0x6c);
      *(undefined4 *)(in_at + 0x78) = *(undefined4 *)(in_at + 0x70);
    }
    else {
      *(undefined4 *)(in_at + 0x90) = *(undefined4 *)(in_at + 0xa8);
      *(undefined4 *)(in_at + 0x94) = *(undefined4 *)(in_at + 0xac);
      *(undefined2 *)(in_at + 0x9e) = *(undefined2 *)(in_at + 0xb6);
      uVar10 = uVar20;
    }
    *(undefined4 *)(in_at + 0xa8) = *(undefined4 *)(in_at + 0xc0);
    uVar16 = (uint)*(short *)(in_at + 0xce);
    *(undefined4 *)(in_at + 0xac) = *(undefined4 *)(in_at + 0xc4);
    *(short *)(in_at + 0xb6) = *(short *)(in_at + 0xce);
    uVar29 = (*unaff_s6)();
    uVar9 = (undefined4)((ulonglong)uVar29 >> 0x20);
    in_v0 = (undefined4)uVar29;
    setCopReg(2,0,uVar22);
    setCopReg(2,0x800,uVar9);
    copFunction(2,0x180001);
    *(uint *)(in_at + 0xc0) = uVar22;
    *(undefined4 *)(in_at + 0xc4) = uVar9;
    *(short *)(in_at + 0xce) = *(short *)(in_at + 0x44) - (short)(uVar22 >> 0x10);
    uVar9 = getCopReg(2,0x6000);
    uVar18 = getCopReg(2,0x8800);
    uVar21 = getCopReg(2,0x6800);
    uVar23 = getCopReg(2,0x9000);
    setCopReg(2,in_t4,*(undefined4 *)(in_at + 0x6c));
    setCopReg(2,unaff_s1,*(undefined4 *)(in_at + 0x70));
    setCopReg(2,in_t5,*(undefined4 *)(in_at + 0x74));
    setCopReg(2,unaff_s2,*(undefined4 *)(in_at + 0x78));
    *(undefined4 *)(in_at + 0x6c) = uVar9;
    *(undefined4 *)(in_at + 0x70) = uVar18;
    *(undefined4 *)(in_at + 0x74) = uVar21;
    *(undefined4 *)(in_at + 0x78) = uVar23;
    uVar9 = getCopReg(2,0x7000);
    uVar18 = getCopReg(2,0x9800);
    setCopReg(2,uVar10,*(undefined4 *)(in_at + 0x7c));
    setCopReg(2,unaff_s3,*(undefined4 *)(in_at + 0x80));
    *(undefined4 *)(in_at + 0x7c) = uVar9;
    *(undefined4 *)(in_at + 0x80) = uVar18;
    uVar20 = getCopReg(2,0);
    setCopReg(2,0,*(int *)(in_at + 0x11c) - (uVar20 & 0xffff0000) | uVar20 & 0xffff);
    copFunction(2,0x180001);
  } while( true );
}


void FUN_8006cdec(void)
{
  char cVar1;
  int in_at;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  undefined4 uVar5;
  int iVar6;
  uint uVar7;
  int iVar8;
  char cVar9;
  uint uVar10;
  char cVar11;
  uint uVar12;
  uint in_t3;
  uint in_t4;
  uint in_t5;
  uint unaff_s1;
  uint unaff_s2;
  int unaff_s3;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  uint *unaff_s7;
  uint *in_t8;
  uint *unaff_s8;

  iVar6 = (in_t3 >> 0xd & 0x7f8) + in_at;
  if (-1 < (int)(in_t3 << 5)) {
    if (unaff_s8 == (uint *)0x0) {
      uVar10 = *unaff_s7;
      uVar12 = *in_t8;
    }
    else {
      *(int *)(in_at + 0x20) = iVar6;
      uVar15 = *unaff_s8;
      uVar2 = uVar15 >> 6 & 7;
      uVar7 = uVar2 ^ 0x1f;
      uVar3 = uVar2 + 1;
      uVar13 = unaff_s3 + uVar3;
      cVar9 = (char)((int)unaff_s1 >> uVar7);
      cVar11 = (char)((int)unaff_s2 >> uVar7);
      uVar10 = unaff_s1;
      uVar12 = unaff_s2;
      uVar14 = uVar13;
      if (0 < (int)uVar13) {
        uVar10 = *unaff_s7;
        uVar12 = *in_t8;
        unaff_s7 = unaff_s7 + 1;
        in_t8 = in_t8 + 1;
        cVar9 = (char)((int)(unaff_s1 | uVar10 >> (uVar3 - uVar13 & 0x1f)) >> uVar7);
        cVar11 = (char)((int)(unaff_s2 | uVar12 >> (uVar3 - uVar13 & 0x1f)) >> uVar7);
        uVar14 = uVar13 - 0x20;
        uVar3 = uVar13;
      }
      uVar10 = uVar10 << (uVar3 & 0x1f);
      uVar12 = uVar12 << (uVar3 & 0x1f);
      if (uVar2 != 7) {
        cVar1 = (char)((int)uVar15 >> 0x19) * '\x02';
        cVar9 = cVar9 + cVar1 + *(char *)(in_at + 0x58);
        cVar11 = cVar11 + cVar1 + *(char *)(in_at + 0x5c);
      }
      *(char *)(in_at + 0x58) = cVar9;
      *(char *)(in_at + 0x5c) = cVar11;
      uVar4 = uVar15 >> 3 & 7;
      uVar7 = uVar4 + 1;
      uVar14 = uVar14 + uVar7;
      uVar3 = uVar10;
      uVar2 = uVar12;
      uVar13 = uVar14;
      if (0 < (int)uVar14) {
        uVar3 = *unaff_s7;
        uVar2 = *in_t8;
        unaff_s7 = unaff_s7 + 1;
        in_t8 = in_t8 + 1;
        uVar10 = uVar10 | uVar3 >> (uVar7 - uVar14 & 0x1f);
        uVar12 = uVar12 | uVar2 >> (uVar7 - uVar14 & 0x1f);
        uVar13 = uVar14 - 0x20;
        uVar7 = uVar14;
      }
      cVar11 = (char)((int)uVar12 >> (uVar4 ^ 0x1f));
      cVar9 = (char)((int)uVar10 >> (uVar4 ^ 0x1f));
      uVar3 = uVar3 << (uVar7 & 0x1f);
      uVar2 = uVar2 << (uVar7 & 0x1f);
      if (uVar4 != 7) {
        cVar1 = (char)((uVar15 << 7) >> 0x18);
        cVar9 = cVar9 + cVar1 + *(char *)(in_at + 0x5a);
        cVar11 = cVar11 + cVar1 + *(char *)(in_at + 0x5e);
      }
      *(char *)(in_at + 0x5a) = cVar9;
      *(char *)(in_at + 0x5e) = cVar11;
      uVar10 = uVar15 & 7;
      iVar6 = uVar13 + uVar10 + 1;
      if (0 < iVar6) {
        uVar12 = (uVar10 + 1) - iVar6;
        uVar3 = uVar3 | *unaff_s7 >> (uVar12 & 0x1f);
        uVar2 = uVar2 | *in_t8 >> (uVar12 & 0x1f);
      }
      cVar11 = (char)((int)uVar2 >> (uVar10 ^ 0x1f));
      cVar9 = (char)((int)uVar3 >> (uVar10 ^ 0x1f));
      if (uVar10 != 7) {
        cVar1 = (char)((uVar15 << 0xf) >> 0x18);
        cVar9 = cVar9 + cVar1 + *(char *)(in_at + 0x59);
        cVar11 = cVar11 + cVar1 + *(char *)(in_at + 0x5d);
      }
      *(char *)(in_at + 0x59) = cVar9;
      *(char *)(in_at + 0x5d) = cVar11;
      uVar10 = *(uint *)(in_at + 0x58);
      uVar12 = *(uint *)(in_at + 0x5c);
      iVar6 = *(int *)(in_at + 0x20);
    }
    setCopReg(2,0,((uVar10 & in_t4) + (uVar12 & in_t4) + *(int *)(in_at + 0x30)) * 2 & in_t5);
    setCopReg(2,0x800,((uVar10 & 0xff00) + (uVar12 & 0xff00) >> 7) + *(int *)(in_at + 0x34));
    copFunction(2,0x4a6012);
    uVar5 = getCopReg(2,0x5800);
    iVar8 = getCopReg(2,0x5000);
    uVar10 = getCopReg(2,0x4800);
    *(uint *)(iVar6 + 0x140) = iVar8 << 0x10 | uVar10 & 0xffff;
    *(undefined4 *)(iVar6 + 0x144) = uVar5;
  }
  if (-1 < (int)(in_t3 << 4)) {
    return;
  }
  return;
}

void FUN_8006d5b8(void)

{
  int in_at;
  uint in_t0;
  uint uVar1;
  code *UNRECOVERED_JUMPTABLE;

  if (-1 < (int)(in_t0 ^ (int)*(char *)(in_at + 0x48))) {
    
	uVar1 = gte_stSXY0();
    gte_ldSXY0(uVar1 & 0xffff0000 | (uVar1 & 0xffff) + 3 & 0xffff);
	
    uVar1 = gte_stSXY1();
    gte_ldSXY1(uVar1 & 0xffff0000 | (uVar1 & 0xffff) + 3 & 0xffff);
	
    uVar1 = gte_stSXY2();
    gte_ldSXY2(uVar1 & 0xffff0000 | (uVar1 & 0xffff) + 3 & 0xffff);
  }

  // JR $s5
}

// several hand-written asm functions in this range

// RenderBucket_DrawInstPrim_Ghost
// called directly by instance->0x60
u_long * FUN_8006d670(void)

{
  int in_at;
  u_long *in_v0;
  u_long *puVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  u_long uVar5;
  uint uVar6;
  u_long uVar7;
  uint *puVar8;
  undefined4 in_t6;
  undefined4 in_t7;
  undefined4 unaff_s0;

  puVar8 = (uint *)((*(uint *)(in_at + 0x2c) >> 0x11) * 4 + *(int *)(in_at + 0x38));
  puVar1 = *(u_long **)(in_at + 0x50);

  // load colors
  gte_ldRGB0(in_t6);
  gte_ldRGB1(in_t7);
  gte_ldRGB2(unaff_s0);

  // set transparency
  // 0xA00 for some (if not all) ghosts
  gte_ldIR0(*(int *)(in_at + 0x120));

  // if no transparency
  if (*(int *)(in_at + 0x120) == 0)
  {
    uVar3 = 0x30000000;

	// if no texture data,
	// draw prim without texture
    if (puVar1 == (u_long *)0x0) {
      gte_stsxy3_g3(in_v0);
      uVar2 = gte_stRGB0();

	  // prim size
	  iVar4 = 0x1c;

	  in_v0[1] = uVar3 | uVar2;
      gte_stRGB1();
      gte_stRGB2();
      uVar3 = 0x6000000;
    }

	// if texture data,
	// draw prim with texture
    else {
      uVar7 = *puVar1;
      uVar2 = puVar1[1];
      uVar5 = puVar1[2];
      gte_stsxy3_gt3(in_v0);
      in_v0[3] = uVar7;
      in_v0[6] = uVar2;
      in_v0[9] = uVar5;
      uVar6 = gte_stRGB0();
      uVar3 = 0x34000000;
      if ((uVar2 & 0x600000) != 0x600000) {
        uVar3 = 0x36000000;
      }
      in_v0[1] = uVar3 | uVar6;
      gte_stRGB1();
      gte_stRGB2();

	  // prim size
	  iVar4 = 0x28;

      uVar3 = 0x9000000;
    }

	// write PrimMem and OTMem
    *in_v0 = *puVar8 | uVar3;
    *puVar8 = (uint)in_v0 & 0xffffff;

	return (u_long *)((int)in_v0 + iVar4);
  }

  // if transparency

  gte_dpct_b();
  in_v0[1] = 0xe1000a40;
  in_v0[2] = 0;
  gte_stSXY0();
  gte_stSXY1();
  in_v0[3] = *(u_long *)(in_at + 0x124);
  gte_stSXY2();

  // if texture data,
  // draw prim with texture
  if (puVar1 != (u_long *)0x0) {
    uVar3 = puVar1[1];
    uVar7 = puVar1[2];
    gte_stSXY0();
    gte_stSXY1();
    gte_stSXY2();
    in_v0[9] = *puVar1;
    in_v0[0xc] = uVar3 & 0xff9fffff | 0x200000;
    in_v0[0xf] = uVar7;
    uVar3 = gte_stRGB0();
    in_v0[7] = uVar3 | 0x36000000;
    gte_stRGB1();
    gte_stRGB2();

    // PrimMem and OTMem
    *in_v0 = *puVar8 | 0xf000000;
    *puVar8 = (uint)in_v0 & 0xffffff;

	return in_v0 + 0x10;
  }

  // draw prim without texture

  in_v0[7] = 0xe1000a20;
  in_v0[8] = 0;
  uVar3 = gte_stRGB0();
  in_v0[9] = uVar3 | 0x32000000;
  gte_stSXY0();
  gte_stRGB1();
  gte_stSXY1();
  gte_stRGB2();
  gte_stSXY2();

  // PrimMem and OTMem
  *in_v0 = *puVar8 | 0xe000000;
  *puVar8 = (uint)in_v0 & 0xffffff;

  return in_v0 + 0xf;
}


// animates water, 1P mode
// param_1 is frame timer (gGT->1cec)
// param_2 is lev->water_count
// param_3 is lev->water_ptr
void FUN_8006d79c(uint param_1,int param_2)

{
  bool bVar1;
  int iVar2;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  undefined4 unaff_s7;
  undefined4 unaff_retaddr;

  gte_ldIR0((param_1 & 7) << 9);
  iVar2 = 0x20;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800028 = unaff_retaddr;

  // iVar2 is not a loop counter,
  // it assigns each water vertex
  // a number [0 to 0x1f]

  // loop for all lev->water_count
  while (bVar1 = param_2 != 0, param_2 = param_2 + -1, bVar1)
  {
    bVar1 = iVar2 == 0;
    iVar2 = iVar2 + -1;
    if (bVar1) {
      iVar2 = 0x1f;
    }

	// AnimateWaterVertex
    FUN_8006db7c(param_1, param_2, param_3, param_4);
  }
  return;
}


// animates water, 2P mode
// param_1 is frame timer (gGT->1cec)
// param_2 is lev->water_count
// param_3 is lev->water_ptr
void FUN_8006d864(uint param_1,int param_2)

{
  bool bVar1;
  int iVar2;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  undefined4 unaff_s7;
  undefined4 unaff_retaddr;

  gte_ldIR0((param_1 & 7) << 9);
  iVar2 = 0x20;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800028 = unaff_retaddr;

  // iVar2 is not a loop counter,
  // it assigns each water vertex
  // a number [0 to 0x1f]

  // loop for all lev->water_count
  while (bVar1 = param_2 != 0, param_2 = param_2 + -1, bVar1) {
    bVar1 = iVar2 == 0;
    iVar2 = iVar2 + -1;
    if (bVar1) {
      iVar2 = 0x1f;
    }

	// AnimateWaterVertex
    FUN_8006db7c(param_1, param_2, param_3, param_4);
  }
  return;
}


// animates water, 3P mode
// param_1 is frame timer (gGT->1cec)
// param_2 is lev->water_count
// param_3 is lev->water_ptr
void FUN_8006d948(uint param_1,int param_2)

{
  bool bVar1;
  int iVar2;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  undefined4 unaff_s7;
  undefined4 unaff_retaddr;

  DAT_1f800020 = &_gp_4;
  gte_ldIR0((param_1 & 7) << 9);
  iVar2 = 0x20;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800028 = unaff_retaddr;

  // iVar2 is not a loop counter,
  // it assigns each water vertex
  // a number [0 to 0x1f]

  // loop for all lev->water_count
  while (bVar1 = param_2 != 0, param_2 = param_2 + -1, bVar1) {
    bVar1 = iVar2 == 0;
    iVar2 = iVar2 + -1;
    if (bVar1) {
      iVar2 = 0x1f;
    }

	// AnimateWaterVertex
    FUN_8006db7c(param_1, param_2, param_3, param_4);
  }
  return;
}


// animates water, 4P mode
// param_1 is frame timer (gGT->1cec)
// param_2 is lev->water_count
// param_3 is lev->water_ptr
void FUN_8006da50(uint param_1,int param_2)

{
  bool bVar1;
  int iVar2;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  undefined4 unaff_s7;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];
  undefined4 param_8;

  DAT_1f800020 = &_gp_4;
  gte_ldIR0((param_1 & 7) << 9);
  iVar2 = 0x20;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800024 = (undefined *)register0x00000074;
  DAT_1f800028 = unaff_retaddr;

  // iVar2 is not a loop counter,
  // it assigns each water vertex
  // a number [0 to 0x1f]

  // loop for all lev->water_count
  while (bVar1 = param_2 != 0, param_2 = param_2 + -1, bVar1) {
    bVar1 = iVar2 == 0;
    iVar2 = iVar2 + -1;
    if (bVar1) {
      iVar2 = 0x1f;
    }

	// AnimateWaterVertex
    FUN_8006db7c(param_1, param_2, param_3, param_4);
  }
  return;
}


// AnimateWaterVertex
void FUN_8006db7c(undefined4 param_1,undefined4 param_2,int *param_3,short param_4)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  int in_t3;
  int in_t4;
  uint in_t5;
  int iVar4;

  if ((in_t5 & 1) != 0) {
    /*
    some details missing but the gist of it:
    water data in .lev is an animated lookup table, it's a 28 long 16-bit array which is interpolated
     a = ( water_color_data & 0x003f)
     b = ( (water_color_data & 0x0fc0) >> 6 )
     c = ( (water_color_data & 0xf000) >> 12 )
     color components c one is used twice?


     new Color( b, b, max(b,a), 1f-c ) seems to result in correct looking pattern but this needs verification.

     the different player modes use less detail.
    */
	
	// WaterVert -> LevVert
    iVar4 = *param_3;
	
	// OVert data is in pairs of two,
	// so this is aligned to 4 bytes
	
	// OVert 1
	// t3 = 0
    uVar1 = (uint)*(ushort *)(param_3[1] + in_t3);
	
	// OVert 2
	// t4 = 2
    uVar3 = (uint)*(ushort *)(param_3[1] + in_t4);
	
	// OVert 1
    uVar2 = (uVar1 & 0xf000) << 8;
    gte_ldRGB(uVar1 & 0x3f | (uVar1 & 0xfc0) << 2 | uVar2 | uVar2 >> 4);
    
	// OVert 2
	gte_ldRFC((uVar3 & 0x3f) << 4);
    gte_ldGFC((uVar3 & 0xfc0) >> 2);
    gte_ldBFC((uVar3 & 0xf000) >> 4 | (uVar3 & 0xf000) >> 8);

	// DPCS - Depth Cueing (single)
	gte_dpcs();

	uVar1 = gte_stRGB2();
	
	// LevVert color_low
    *(short *)(iVar4 + 0xc) = (short)uVar1 + param_4;
    
	// LevVert color_hi
	uVar1 = uVar1 >> 0x10 & 0xff;
    *(uint *)(iVar4 + 8) = (uVar1 << 8 | uVar1) << 8 | uVar1;
    
	return;
  }
  return;
}




// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// RedBeaker_RenderRain
// param1 - camera110
// param2 - primMem
// param3 - rainPool
// param4 - numScreens
// param5 - check if game is paused
void FUN_8006dc30(int param_1,int param_2,int param_3,int param_4,int param_5)

{
  bool bVar1;
  uint uVar2;
  uint *puVar3;
  uint uVar4;
  int *piVar5;
  int iVar6;
  uint uVar7;
  char cVar8;
  char cVar9;
  uint uVar10;
  int iVar11;
  int iVar12;
  uint *puVar13;
  int iVar14;
  int iVar15;
  undefined4 unaff_s0;
  uint uVar16;
  undefined4 unaff_s1;
  uint uVar17;
  undefined4 unaff_s2;
  int iVar18;
  undefined4 unaff_s3;
  int iVar19;
  undefined4 unaff_s4;
  int iVar20;
  undefined4 unaff_s5;
  uint uVar21;
  undefined4 unaff_s6;
  int iVar22;
  undefined4 unaff_s7;
  uint uVar23;
  int iVar24;
  uint uVar25;
  uint uVar26;
  uint uVar27;
  uint uVar28;
  undefined4 unaff_s8;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];

  // backup $gp
  DAT_1f800020 = &DAT_8008cf6c;

  puVar3 = *(uint **)(param_2 + 0xc);
  DAT_1f800038 = *(int *)(param_3 + 0xc);
  param_4 = param_4 + -1;
  iVar18 = 0;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800024 = (undefined *)register0x00000074;
  DAT_1f800028 = unaff_s8;
  DAT_1f80002c = unaff_retaddr;
  if (DAT_1f800038 != 0) {
    DAT_1f800048 = 0;
    DAT_1f80004c = 0;
    DAT_1f800030 = 0x2000080;
    do 
	{
	  // camera110 ViewProj
      gte_ldR11R12(*(undefined4 *)(param_1 + 0x28));
      gte_ldR13R21(*(undefined4 *)(param_1 + 0x2c));
      gte_ldR22R23(*(undefined4 *)(param_1 + 0x30));
      gte_ldR31R32(*(undefined4 *)(param_1 + 0x34));
      gte_ldR33(*(undefined4 *)(param_1 + 0x38));
	  
      iVar14 = *(int *)(param_1 + 0x20);
	  
	  // ptrOT
      DAT_1f800034 = *(int *)(param_1 + 0xf4);
	  
	  // window parameters
      gte_ldOFX((int)*(short *)(param_1 + 0x20) << 0xf);
      gte_ldOFY((int)*(short *)(param_1 + 0x22) << 0xf);
      gte_ldH(*(undefined4 *)(param_1 + 0x18));
	  
      for (piVar5 = (int *)DAT_1f800038; piVar5 != (int *)0x0; piVar5 = (int *)*piVar5) {
        iVar15 = piVar5[2];
        iVar19 = piVar5[3];
        if (piVar5[9] != 0) {
          iVar20 = (int)*(short *)(piVar5 + 4);
          iVar24 = (int)*(short *)(piVar5 + 6);
          uVar23 = piVar5[5] & 0xfffeffff;
          iVar22 = iVar20 + iVar24;
          uVar21 = iVar19 + uVar23 & 0xfffeffff;
          if (param_5 == 0) {
            piVar5[3] = uVar21;
            piVar5[4] = iVar22;
          }
          iVar12 = piVar5[9] + iVar18;
          iVar6 = (int)*(short *)(iVar12 + 0x94);
          gte_ldtr((int)*(short *)(iVar12 + 0x8c),(int)*(short *)(iVar12 + 0x90),iVar6);
          if ((-1 < iVar6) && (iVar6 + -0xc00 < 0)) {
            uVar10 = iVar6 - 0x400U >> 3;
            if ((int)(iVar6 - 0x400U) < 0) {
              uVar10 = 0;
            }
            iVar11 = 0xff - (uVar10 & 0xff);
            cVar8 = (char)iVar11;
            DAT_1f80004c = DAT_1f80004c & 0xff000000 | (uint)CONCAT12(cVar8,CONCAT11(cVar8,cVar8));
            cVar9 = cVar8 - (char)(iVar11 >> 2);
            DAT_1f800048 = CONCAT22(CONCAT11(DAT_1f800048._3_1_,cVar8),CONCAT11(cVar9,cVar9));
            iVar6 = (iVar6 >> 7) + *(char *)(iVar12 + 0x50) + -6;
            iVar12 = iVar6 * 4;
            if (iVar6 < 0) {
              iVar12 = 0;
            }
            if (-1 < iVar12 + -0x1000) {
              iVar12 = 0xffc;
            }
            puVar13 = (uint *)(DAT_1f800034 + iVar12);
            uVar10 = 0x30125400;
            uVar17 = 0x493583fe;
            while( true ) {
              uVar2 = DAT_1f800048;
              uVar4 = uVar17 >> 8;
              uVar17 = uVar10 >> 8 | uVar17 << 0x18;
              uVar7 = (uVar10 + uVar4 + (uVar17 >> 8)) * 0x1000000;
              uVar10 = (uVar4 | uVar7) >> 8;
              uVar4 = uVar17 >> 8 | uVar4 << 0x18;
              uVar25 = (uVar17 + uVar10 + (uVar4 >> 8)) * 0x1000000;
              uVar16 = (uVar10 | uVar25) >> 8;
              uVar10 = uVar4 >> 8 | uVar10 << 0x18;
              uVar27 = (uVar4 + uVar16 + (uVar10 >> 8)) * 0x1000000;
              uVar17 = uVar16 | uVar27;
              bVar1 = iVar15 == 0;
              iVar15 = iVar15 + -1;
              if (bVar1) break;
              uVar7 = (int)uVar7 >> 0x18 & 0xffffU | (int)uVar25 >> 7;
              uVar4 = (uVar7 + iVar19 & 0x1fe00ff) - DAT_1f800030;
              uVar7 = (uVar7 + uVar21 & 0x1fe00ff) - DAT_1f800030;
              if (uVar7 - uVar4 == uVar23) {
                uVar7 = uVar7 & 0xfffeffff;
                gte_ldVXY0(uVar4 & 0xfffeffff);
                gte_ldVXY1(uVar7);
                gte_ldVXY2(uVar7);
                iVar6 = (int)uVar27 >> 0x17;
                uVar4 = iVar6 + iVar20 & 0xff;
                uVar7 = iVar6 + iVar22 & 0xff;
                if (uVar7 - uVar4 == iVar24) {
                  iVar6 = uVar7 - 0x80;
                  gte_ldVZ0(uVar4 - 0x80);
                  gte_ldVZ1(iVar6);
                  gte_ldVZ2(iVar6);
                  uVar17 = uVar17 >> 8;
                  gte_rtpt_b();
                  uVar4 = uVar10 >> 8 | uVar16 << 0x18;
                  uVar10 = (uVar17 | (uVar10 + uVar17 + (uVar4 >> 8)) * 0x1000000) >> 8;
                  uVar16 = uVar4 >> 8 | uVar17 << 0x18;
                  uVar17 = (uVar10 | (uVar4 + uVar10 + (uVar16 >> 8)) * 0x1000000) >> 8;
                  uVar10 = uVar16 >> 8 | uVar10 << 0x18;
                  uVar17 = uVar17 | (uVar16 + uVar17 + (uVar10 >> 8)) * 0x1000000;
                  uVar4 = gte_stSXY0();
                  iVar6 = gte_stFLAG();
                  uVar16 = gte_stSXY1();
                  if (((-1 < iVar6 << 0xe) &&
                      (uVar4 = ~(uVar4 - iVar14 | uVar16 - iVar14) | uVar4 & uVar16, -1 < (int)uVar4
                      )) && (-1 < (int)(uVar4 << 0x10))) {
                    puVar3[1] = 0x52000000;
                    puVar3[3] = uVar2;
                    *puVar3 = *puVar13 | 0x4000000;
                    gte_stSXY0();
                    gte_stSXY1();
                    *puVar13 = (uint)puVar3 & 0xffffff;
                    puVar3 = puVar3 + 5;
                  }
                }
              }
            }
            iVar15 = piVar5[2];
            puVar3[1] = 0xe1000a20;
            puVar3[2] = 0;
            *puVar3 = *puVar13 | 0x2000000;
            *puVar13 = (uint)puVar3 & 0xffffff;
            puVar3 = puVar3 + 3;
            uVar10 = 0x30125400;
            uVar17 = 0x493583fe;
            while( true ) {
              uVar2 = DAT_1f80004c;
              uVar4 = uVar17 >> 8;
              uVar17 = uVar10 >> 8 | uVar17 << 0x18;
              uVar7 = (uVar10 + uVar4 + (uVar17 >> 8)) * 0x1000000;
              uVar10 = (uVar4 | uVar7) >> 8;
              uVar4 = uVar17 >> 8 | uVar4 << 0x18;
              uVar26 = (uVar17 + uVar10 + (uVar4 >> 8)) * 0x1000000;
              uVar16 = (uVar10 | uVar26) >> 8;
              uVar10 = uVar4 >> 8 | uVar10 << 0x18;
              uVar28 = (uVar4 + uVar16 + (uVar10 >> 8)) * 0x1000000;
              uVar17 = uVar16 | uVar28;
              bVar1 = iVar15 == 0;
              iVar15 = iVar15 + -1;
              if (bVar1) break;
              uVar7 = (int)uVar7 >> 0x18 & 0xffffU | (int)uVar26 >> 7;
              uVar4 = (uVar7 + iVar19 & 0x1fe00ff) - DAT_1f800030;
              uVar7 = (uVar7 + uVar21 & 0x1fe00ff) - DAT_1f800030;
              if (uVar7 - uVar4 == uVar23) {
                uVar7 = uVar7 & 0xfffeffff;
                gte_ldVXY0(uVar4 & 0xfffeffff);
                gte_ldVXY1(uVar7);
                gte_ldVXY2(uVar7);
                iVar6 = (int)uVar28 >> 0x17;
                uVar4 = iVar6 + iVar20 & 0xff;
                uVar7 = iVar6 + iVar22 & 0xff;
                if (uVar7 - uVar4 == iVar24) {
                  iVar6 = uVar7 - 0x80;
                  gte_ldVZ0(uVar4 - 0x80);
                  gte_ldVZ1(iVar6);
                  gte_ldVZ2(iVar6);
                  uVar17 = uVar17 >> 8;
                  gte_rtpt_b();
                  uVar4 = uVar10 >> 8 | uVar16 << 0x18;
                  uVar10 = (uVar17 | (uVar10 + uVar17 + (uVar4 >> 8)) * 0x1000000) >> 8;
                  uVar16 = uVar4 >> 8 | uVar17 << 0x18;
                  uVar17 = (uVar10 | (uVar4 + uVar10 + (uVar16 >> 8)) * 0x1000000) >> 8;
                  uVar10 = uVar16 >> 8 | uVar10 << 0x18;
                  uVar17 = uVar17 | (uVar16 + uVar17 + (uVar10 >> 8)) * 0x1000000;
                  uVar4 = gte_stSXY0();
                  iVar6 = gte_stFLAG();
                  uVar16 = gte_stSXY1();
                  if (((-1 < iVar6 << 0xe) &&
                      (uVar4 = ~(uVar4 - iVar14 | uVar16 - iVar14) | uVar4 & uVar16, -1 < (int)uVar4
                      )) && (-1 < (int)(uVar4 << 0x10))) {
                    puVar3[1] = 0x52000000;
                    puVar3[3] = uVar2;
                    *puVar3 = *puVar13 | 0x4000000;
                    gte_stSXY0();
                    gte_stSXY1();
                    *puVar13 = (uint)puVar3 & 0xffffff;
                    puVar3 = puVar3 + 5;
                  }
                }
              }
            }
            puVar3[1] = 0xe1000a40;
            puVar3[2] = 0;
            *puVar3 = *puVar13 | 0x2000000;
            *puVar13 = (uint)puVar3 & 0xffffff;
            puVar3 = puVar3 + 3;
          }
        }
      }
      param_1 = param_1 + 0x110;
      iVar18 = iVar18 + 0x88;
      bVar1 = param_4 != 0;
      param_4 = param_4 + -1;
    } while (bVar1);
  }
  *(uint **)(param_2 + 0xc) = puVar3;
  return;
}


//apparently this function renders stars in various levels, i.e. cutsenes, nd box, oxide station.
//https://media.discordapp.net/attachments/637616020177289236/823950457101221988/unknown.png

// param1 - camera110
// param2 - PrimMem
// param3 - numStars
// param4 - numPlayers
void FUN_8006e26c(int param_1,int param_2,ushort *param_3,int param_4)

{
  bool bVar1;
  ushort uVar2;
  ushort uVar3;
  uint *puVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  uint *puVar12;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  uint uVar13;
  undefined4 unaff_s7;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  undefined4 unaff_s8;
  undefined4 unaff_retaddr;
  int iVar19;
  undefined auStackX0 [16];

  // backup $gp
  DAT_1f800020 = &DAT_8008cf6c;

  gte_ldtr(0,0,0);
  param_4 = param_4 + -1;

  // new PrimMem curr
  puVar4 = *(uint **)(param_2 + 0xc);

  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800024 = (undefined *)register0x00000074;
  DAT_1f800028 = unaff_s8;
  DAT_1f80002c = unaff_retaddr;
  do
  {
	// camera110 matrix 0x28
    gte_ldR11R12(*(undefined4 *)(param_1 + 0x28));
    gte_ldR13R21(*(undefined4 *)(param_1 + 0x2c));
    gte_ldR22R23(*(undefined4 *)(param_1 + 0x30));
    gte_ldR31R32(*(undefined4 *)(param_1 + 0x34));
    gte_ldR33(*(undefined4 *)(param_1 + 0x38));

	// window size X and Y
    gte_ldOFX((int)*(short *)(param_1 + 0x20) << 0xf);
    gte_ldOFY((int)*(short *)(param_1 + 0x22) << 0xf);

	// distance to screen
    gte_ldH(*(undefined4 *)(param_1 + 0x18));

    gte_ldtr(0,0,0);

	// number of stars
    uVar13 = (uint)*param_3;

	// ???
	uVar2 = param_3[1];

	// ???
    uVar3 = param_3[2];

	// camera110 ptrOT + offset?
    puVar12 = (uint *)(*(int *)(param_1 + 0xf4) + (uint)param_3[3] * 4);

	// RNG seed,
	// produces different random numbers for each iteration
	// of the loop, but will generate same random numbers each frame,
	// putting stars in the same place each frame
    uVar14 = 0x30125400;
    uVar16 = 0x493583fe;

	// loop for every star
    while (bVar1 = -1 < (int)uVar13, uVar13 = uVar13 - 1, bVar1)
	{
      uVar5 = uVar14 + (uVar16 >> 8);
      uVar15 = uVar14 >> 8 | uVar5;
      uVar14 = (uVar5 + (uVar15 >> 8)) * 0x1000000;
      uVar17 = (uVar16 >> 8 | uVar14) >> 8;
      uVar5 = uVar15 >> 8 | uVar14;
      uVar16 = (uVar15 + uVar17 + (uVar5 >> 8)) * 0x1000000;
      uVar17 = (uVar17 | uVar16) >> 8;
      uVar15 = uVar5 >> 8 | uVar14;
      uVar5 = (uVar5 + uVar17 + (uVar15 >> 8)) * 0x1000000;
      iVar6 = (int)uVar14 >> 0x14;
      iVar7 = (int)uVar16 >> (uVar3 + 0x14 & 0x1f);
      iVar8 = (int)uVar5 >> 0x14;
      iVar19 = iVar6;
      if (iVar6 < 0) {
        iVar19 = -iVar6;
      }
      iVar10 = iVar7;
      if ((iVar7 < 0) && (iVar10 = -iVar7, uVar2 == 0)) {
        iVar7 = iVar10;
      }
      iVar11 = iVar8;
      if (iVar8 < 0) {
        iVar11 = -iVar8;
      }
      iVar9 = iVar19;
      if (iVar19 - iVar10 < 1) {
        iVar9 = iVar10;
        iVar10 = iVar19;
      }
      iVar19 = iVar9;
      if (iVar9 - iVar11 < 1) {
        iVar19 = iVar11;
        iVar11 = iVar9;
      }
      iVar19 = 0x1000000 / (iVar19 + (iVar10 >> 2) + (iVar11 >> 2));
      uVar14 = iVar6 * iVar19 >> 0xc & 0xffffU | (iVar7 * iVar19 >> 0xc) << 0x10;
      gte_ldVXY0(uVar14);
      gte_ldVZ0(iVar8 * iVar19 >> 0xc);
      uVar5 = (uVar17 | uVar5) >> 8;
      uVar14 = uVar15 >> 8 | uVar14;
      uVar16 = uVar5 | (uVar15 + uVar5 + (uVar14 >> 8)) * 0x1000000;
      gte_rtps_b();
      uVar18 = uVar15 + uVar5 + (uVar14 >> 8) & 0xff | 0x40;
      iVar19 = gte_stFLAG();
      uVar5 = gte_stSXY2();

      if (
			((-1 < iVar19 << 0xd) && (uVar15 = uVar5 - 0xd90200 | uVar5, (int)uVar15 < 0)) &&
			(-1 < (int)(~uVar15 << 0x10))
		 )
	  {
		// write Pimitive
        uVar15 = *puVar12;
        puVar4[1] = uVar18 | uVar18 << 8 | uVar18 << 0x10 | 0x68000000;
        *puVar4 = uVar15 | 0x2000000;
        puVar4[2] = uVar5;
        *puVar12 = (uint)puVar4 & 0xffffff;

		// advance to next primitive
		puVar4 = puVar4 + 3;
      }
    }

	// write Pimitive
    puVar4[1] = 0xe1000a20;
    puVar4[2] = 0;
    *puVar4 = *puVar12 | 0x2000000;
    *puVar12 = (uint)puVar4 & 0xffffff;

	// advance to next primitive
    puVar4 = puVar4 + 3;

	// next camera110
    param_1 = param_1 + 0x110;

	// next player
    bVar1 = param_4 != 0;
    param_4 = param_4 + -1;

  } while (bVar1);

  // new PrimMem curr
  *(uint **)(param_2 + 0xc) = puVar4;

  return;
}


// draw normal tires (not reflected)
// param1 - first thread
// param2 - PrimMem
// param3 - numPlayers
void FUN_8006e588(int param_1,int param_2,int param_3)

{
  bool bVar1;
  short sVar2;
  int iVar3;
  int iVar4;
  char *pcVar5;
  short *psVar6;
  int iVar7;
  undefined **ppuVar8;
  uint uVar9;
  int iVar10;
  code *UNRECOVERED_JUMPTABLE;
  short sVar11;
  undefined2 uVar12;
  undefined4 *puVar13;
  int iVar14;
  undefined4 uVar15;
  int iVar16;
  undefined *puVar17;
  int iVar18;
  uint uVar19;
  uint uVar20;
  int iVar21;
  int iVar22;
  int iVar23;
  int iVar24;
  undefined4 unaff_s0;
  undefined4 uVar25;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  uint unaff_s6;
  undefined4 unaff_s7;
  int iVar26;
  int iVar27;
  undefined4 *puVar28;
  undefined4 unaff_s8;
  int iVar29;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];

  iVar3 = 0x1f800000;

  // backup $gp
  DAT_1f800020 = &DAT_8008cf6c;

  // if 3P or 4P
  DAT_1f800054 = 0;
  if (param_3 + -2 < 1)
  {
	// if 1P or 2P
    DAT_1f800054 = 2;
  }

  // loop 8 times
  iVar4 = 7;

  // tire jmp pointers
  ppuVar8 = &PTR_LAB_8008a344;

  puVar13 = &DAT_1f800130;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800024 = (undefined *)register0x00000074;
  DAT_1f800028 = unaff_s8;
  DAT_1f80002c = unaff_retaddr;

  // store number of players
  DAT_1f800030 = param_3;

  // loop 8 times
  do {
    puVar17 = *ppuVar8;
    ppuVar8 = ppuVar8 + 1;
    *puVar13 = puVar17;
    puVar13 = puVar13 + 1;
    bVar1 = iVar4 != 0;
    iVar4 = iVar4 + -1;
  } while (bVar1);

  // PrimMem data
  iVar4 = *(int *)(param_2 + 0xc);
  uVar25 = *(undefined4 *)(param_2 + 0x14);

  // loop through all threads (player or robotcar)
  do
  {
	// get instance from thread
    iVar7 = *(int *)(param_1 + 0x34);

	// get object from thread
    puVar28 = *(undefined4 **)(param_1 + 0x30);

	// vertical line for split or reflection
    uVar12 = *(undefined2 *)(iVar7 + 0x56);

	// number of screens to render tires on
    *(undefined4 *)(iVar3 + 0x34) = *(undefined4 *)(iVar3 + 0x30);

	// vertical line for split or reflection
    *(undefined2 *)(iVar3 + 0x4c) = uVar12;

	// store instance
    iVar29 = iVar7;

	// loop through all cameras
	// that tires need to render on
    do
	{
      sVar2 = *(short *)(iVar29 + 0xde);
      *(short *)(iVar3 + 0x16c) = (short)((int)*(short *)(iVar29 + 0xdc) << 2);
      *(short *)(iVar3 + 0x16e) = (short)((int)sVar2 << 2);

	  // instance flags, duplicate of 0x28
      uVar9 = *(uint *)(iVar29 + 0xb8);

	  // model LOD index
      iVar14 = *(int *)(iVar29 + 0xd8);

      *(uint *)(iVar3 + 0x160) = uVar9;

      if (
			(
				((uVar9 & 0x40) != 0) &&

				// if instance is not invisible
				((uVar9 & 0x80) == 0)
			) &&

			// if tires shouldn't disappear on this model LOD
			(iVar14 - *(int *)(iVar3 + 0x54) < 1)
		  )
      {
		// tire color
        uVar15 = 0x2e808080;

        if ((uVar9 & 0x100) == 0)
		{
		  // driver->tireColor
          uVar15 = puVar28[2];
        }

		// driver ptr, thread -> object
        *(undefined4 *)(iVar3 + 0x38) = *puVar28;

		// tire color
		*(undefined4 *)(iVar3 + 0x3c) = uVar15;

		// instance -> camera110
        psVar6 = *(short **)(iVar29 + 0x74);

		// if camera110 exists
        if (psVar6 != (short *)0x0)
		{
		  // instance scale
          sVar2 = *(short *)(iVar7 + 0x1e);
          iVar4 = *(short *)(iVar7 + 0x1c) * 0x90 >> 0xc;

          sVar11 = (short)iVar4;
          *(short *)(iVar3 + 0x58) = sVar11;
          *(short *)(iVar3 + 0x78) = sVar11;
          iVar4 = -iVar4;
          uVar12 = (undefined2)iVar4;
          *(undefined2 *)(iVar3 + 0x68) = uVar12;
          *(undefined2 *)(iVar3 + 0x88) = uVar12;
          *(short *)(iVar3 + 0x60) = sVar11 + -0x1000;
          *(short *)(iVar3 + 0x80) = sVar11 + -0x1000;
          iVar4 = iVar4 + 0x1000;
          *(short *)(iVar3 + 0x70) = (short)iVar4;
          *(short *)(iVar3 + 0x90) = (short)iVar4;

		  // instance scale
          sVar11 = *(short *)(iVar7 + 0x20);
          uVar12 = (undefined2)(sVar2 * 0x40 >> 0xc);

          *(undefined2 *)(iVar3 + 0x5a) = uVar12;
          *(undefined2 *)(iVar3 + 0x62) = 0;
          *(undefined2 *)(iVar3 + 0x6a) = uVar12;
          *(undefined2 *)(iVar3 + 0x72) = 0;
          *(undefined2 *)(iVar3 + 0x7a) = uVar12;
          *(undefined2 *)(iVar3 + 0x82) = 0;
          *(undefined2 *)(iVar3 + 0x8a) = uVar12;
          *(undefined2 *)(iVar3 + 0x92) = 0;
          iVar14 = sVar11 * 199 >> 0xc;
          *(int *)(iVar3 + 0x5c) = iVar14;
          *(int *)(iVar3 + 0x6c) = iVar14;
          iVar14 = sVar11 * -0x60 >> 0xc;
          *(int *)(iVar3 + 0x7c) = iVar14;
          *(int *)(iVar3 + 0x84) = iVar14;
          *(int *)(iVar3 + 0x8c) = iVar14;
          *(int *)(iVar3 + 0x94) = iVar14;
          iVar14 = *(int *)(iVar29 + 0xe8);
          sVar2 = *(short *)(puVar28 + 1);
          *(undefined4 *)(iVar3 + 0x40) = *(undefined4 *)(iVar29 + 0xe4);
          *(int *)(iVar3 + 0x44) = iVar14;
          *(int *)(iVar3 + 0x48) = (int)sVar2;

		  // TRIG_AngleSinCos_r9r8r10
		  FUN_8006ef30();

		  *(short *)(iVar3 + 0x60) = *(short *)(iVar3 + 0x58) - (short)iVar4;
          *(int *)(iVar3 + 100) = *(int *)(iVar3 + 0x5c) + iVar14;
          sVar2 = *(short *)((int)puVar28 + 0xe);
          *(short *)(iVar3 + 0x70) = *(short *)(iVar3 + 0x68) + (short)iVar4;
          *(int *)(iVar3 + 0x74) = *(int *)(iVar3 + 0x6c) - iVar14;
          uVar9 = (int)sVar2 & 1;
          uVar20 = 9;
          if (uVar9 != 0) {
            uVar20 = 6;
          }

		  // TRIG_AngleSinCos_r9r8r10
          FUN_8006ef30();

		  iVar4 = iVar4 >> (uVar20 & 0x1f);
          iVar14 = (int)uVar9 >> (uVar20 & 0x1f);
          *(short *)(iVar3 + 0x62) = *(short *)(iVar3 + 0x62) + (short)iVar4;
          *(short *)(iVar3 + 100) = *(short *)(iVar3 + 100) + (short)iVar14;

		  // TRIG_AngleSinCos_r9r8r10
		  FUN_8006ef30();

		  iVar4 = iVar4 >> (uVar20 & 0x1f);
          iVar14 = iVar14 >> (uVar20 & 0x1f);
          *(short *)(iVar3 + 0x82) = *(short *)(iVar3 + 0x82) + (short)iVar4;
          *(short *)(iVar3 + 0x84) = *(short *)(iVar3 + 0x84) + (short)iVar14;

		  // TRIG_AngleSinCos_r9r8r10
		  FUN_8006ef30();

		  iVar4 = iVar4 >> (uVar20 & 0x1f);
          iVar14 = iVar14 >> (uVar20 & 0x1f);
          *(short *)(iVar3 + 0x72) = *(short *)(iVar3 + 0x72) + (short)iVar4;
          *(short *)(iVar3 + 0x74) = *(short *)(iVar3 + 0x74) + (short)iVar14;

		  // TRIG_AngleSinCos_r9r8r10
		  FUN_8006ef30();

		  *(short *)(iVar3 + 0x92) = *(short *)(iVar3 + 0x92) + (short)(iVar4 >> (uVar20 & 0x1f));
          *(short *)(iVar3 + 0x94) = *(short *)(iVar3 + 0x94) + (short)(iVar14 >> (uVar20 & 0x1f));

		  // instance matrix
		  gte_ldLR1LR2(*(undefined4 *)(iVar7 + 0x30));
          gte_ldLR3LG1(*(undefined4 *)(iVar7 + 0x34));
          gte_ldLG2LG3(*(undefined4 *)(iVar7 + 0x38));
          gte_ldLB1LB2(*(undefined4 *)(iVar7 + 0x3c));
          gte_ldLB3(*(undefined4 *)(iVar7 + 0x40));

		  // another matrix in instance?
		  gte_ldL11L12(*(undefined4 *)(iVar29 + 0x98));
          gte_ldL13L21(*(undefined4 *)(iVar29 + 0x9c));
          gte_ldL22L23(*(undefined4 *)(iVar29 + 0xa0));
          gte_ldL31L32(*(undefined4 *)(iVar29 + 0xa4));
          gte_ldL33(*(undefined4 *)(iVar29 + 0xa8));

		  // instance position - camera position
		  iVar14 = (*(int *)(iVar7 + 0x44) - (int)*psVar6) * 4;
          iVar10 = (*(int *)(iVar7 + 0x48) - (int)psVar6[1]) * 4;
          iVar16 = (*(int *)(iVar7 + 0x4c) - (int)psVar6[2]) * 4;
          gte_ldtr(iVar14,iVar10,iVar16);

		  // vertical line split - camera posY
          *(short *)(iVar3 + 0x50) = (*(short *)(iVar3 + 0x4c) - psVar6[1]) * 4;

          iVar26 = iVar3 + 0x30;
          iVar27 = iVar3 + 0x18;
          do {
            gte_ldVXY0(iVar26 + 0x58);
            gte_ldVZ0(iVar26 + 0x5c);
            gte_ldVXY1(iVar26 + 0x60);
            gte_ldVZ1(iVar26 + 100);
            gte_lcv0tr_b();
            iVar4 = gte_stIR1();
            iVar21 = gte_stIR2();
            iVar23 = gte_stIR3();
            gte_sqr0_b(0);
            *(short *)(iVar26 + 0x58) = (short)iVar4;
            *(short *)(iVar26 + 0x5a) = (short)iVar21;
            read_mt(iVar14,iVar10,iVar16);
            FUN_8006ef98();
            iVar18 = 0x10000;
            gte_lcv1_b();
            *(int *)(iVar26 + 0x5c) = iVar23;
            iVar14 = -(0x10000 / unaff_s6);
            uVar15 = gte_stIR1();
            iVar10 = gte_stIR2();
            iVar16 = gte_stIR3();
            *(short *)(iVar27 + 0xb8) = (short)uVar15;
            uVar9 = iVar4 * iVar14 >> 4;
            *(short *)(iVar27 + 0x98) = (short)uVar9;
            *(short *)(iVar27 + 0xba) = (short)iVar10;
            *(int *)(iVar27 + 0xbc) = iVar16;
            iVar4 = iVar23 * iVar14 >> 4;
            uVar9 = uVar9 & 0xffff;
            uVar20 = iVar21 * iVar14 >> 4 & 0xffff;
            gte_ldR11R12(uVar9);
            gte_ldR22R23(uVar20);
            gte_ldR33(iVar4);
            *(short *)(iVar27 + 0x9a) = (short)uVar20;
            *(int *)(iVar27 + 0x9c) = iVar4;
            gte_op12_b();
            read_mt(uVar9,uVar20,iVar4);
            gte_sqr0_b(0);
            read_mt(uVar15,iVar10,iVar16);
            FUN_8006ef98();
            iVar14 = iVar18 / iVar14;
            iVar21 = (int)(uVar9 * iVar14) >> 4;
            gte_ldIR1(iVar21);
            iVar22 = (int)(uVar20 * iVar14) >> 4;
            gte_ldIR2(iVar22);
            iVar24 = iVar4 * iVar14 >> 4;
            gte_ldIR3(iVar24);
            iVar4 = *(int *)(iVar3 + 0x48);
            gte_op12_b();
            iVar21 = iVar21 * iVar4;
            iVar23 = iVar21 >> 0x12;
            *(short *)(iVar27 + 0xd8) = (short)(iVar21 >> 0x12);
            iVar22 = iVar22 * iVar4;
            iVar21 = iVar22 >> 0x12;
            *(short *)(iVar27 + 0xda) = (short)(iVar22 >> 0x12);
            iVar24 = iVar24 * iVar4;
            iVar22 = iVar24 >> 0x12;
            *(short *)(iVar27 + 0xdc) = (short)(iVar24 >> 0x12);
            read_mt(iVar23,iVar21,iVar22);
            gte_sqr0_b(0);
            read_mt(iVar4,iVar10,iVar16);
            iVar4 = FUN_8006ef98();
            unaff_s6 = *(int *)(iVar3 + 0x48) * -(iVar18 / iVar14) >> 0xc;
            *(short *)(iVar27 + 0xf8) = (short)((int)(iVar23 * unaff_s6) >> 10);
            *(short *)(iVar27 + 0xfa) = (short)((int)(iVar21 * unaff_s6) >> 10);
            *(short *)(iVar27 + 0xfc) = (short)((int)(iVar22 * unaff_s6) >> 10);
            iVar26 = iVar26 + -0x10;
            iVar14 = iVar26 - iVar3;
            iVar27 = iVar27 + -8;
          } while (-1 < iVar14);

		  // camera110 ViewProj
		  // (multiply by 2, offset 0x28)
          gte_ldR11R12(*(undefined4 *)(psVar6 + 0x14));
          gte_ldR13R21(*(undefined4 *)(psVar6 + 0x16));
          gte_ldR22R23(*(undefined4 *)(psVar6 + 0x18));
          gte_ldR31R32(*(undefined4 *)(psVar6 + 0x1a));
          gte_ldR33(*(undefined4 *)(psVar6 + 0x1c));

		  // no translation, rotation only
          gte_ldtr(0,0,0);

		  // screen dimensions, and distance from screen
		  gte_ldOFX((int)psVar6[0x10] << 0xf);
          gte_ldOFY((int)psVar6[0x11] << 0xf);
          gte_ldH(*(undefined4 *)(psVar6 + 0xc));

          iVar14 = iVar3 + 0x30;
          iVar10 = iVar3 + 0x18;
          uVar9 = iVar3 + 0xc;
          do {
            gte_ldVXY0(((int)*(short *)(iVar14 + 0x58) - (int)*(short *)(iVar10 + 0xd8)) -
                       (int)*(short *)(iVar10 + 0xf8) & 0xffffU |
                       (((int)*(short *)(iVar14 + 0x5a) - (int)*(short *)(iVar10 + 0xda)) -
                       (int)*(short *)(iVar10 + 0xfa)) * 0x10000);
            gte_ldVZ0(((int)*(short *)(iVar14 + 0x5c) - (int)*(short *)(iVar10 + 0xdc)) -
                      (int)*(short *)(iVar10 + 0xfc));
            gte_ldVXY1(((int)*(short *)(iVar14 + 0x58) + (int)*(short *)(iVar10 + 0xd8)) -
                       (int)*(short *)(iVar10 + 0xf8) & 0xffffU |
                       (((int)*(short *)(iVar14 + 0x5a) + (int)*(short *)(iVar10 + 0xda)) -
                       (int)*(short *)(iVar10 + 0xfa)) * 0x10000);
            gte_ldVZ1(((int)*(short *)(iVar14 + 0x5c) + (int)*(short *)(iVar10 + 0xdc)) -
                      (int)*(short *)(iVar10 + 0xfc));
            gte_ldVXY2(((int)*(short *)(iVar14 + 0x58) - (int)*(short *)(iVar10 + 0xd8)) +
                       (int)*(short *)(iVar10 + 0xf8) & 0xffffU |
                       (((int)*(short *)(iVar14 + 0x5a) - (int)*(short *)(iVar10 + 0xda)) +
                       (int)*(short *)(iVar10 + 0xfa)) * 0x10000);
            gte_ldVZ2(((int)*(short *)(iVar14 + 0x5c) - (int)*(short *)(iVar10 + 0xdc)) +
                      (int)*(short *)(iVar10 + 0xfc));
            gte_rtpt_b();
            gte_stSXY0();
            gte_stSXY1();
            gte_stSXY2();
            gte_ldVXY0((int)*(short *)(iVar14 + 0x58) + (int)*(short *)(iVar10 + 0xd8) +
                       (int)*(short *)(iVar10 + 0xf8) & 0xffffU |
                       ((int)*(short *)(iVar14 + 0x5a) + (int)*(short *)(iVar10 + 0xda) +
                       (int)*(short *)(iVar10 + 0xfa)) * 0x10000);
            gte_ldVZ0((int)*(short *)(iVar14 + 0x5c) + (int)*(short *)(iVar10 + 0xdc) +
                      (int)*(short *)(iVar10 + 0xfc));
            uVar15 = *(undefined4 *)(iVar10 + 0xb8);
            gte_rtps_b();

			// poly_ft4->color = tireColor
            *(undefined4 *)(iVar4 + 4) = *(undefined4 *)(iVar3 + 0x3c);

            gte_stSXY2();
            gte_avsz4_b();
            iVar16 = *(int *)(iVar3 + 0x40);
            if (-1 < (int)*(short *)(iVar3 + 0x50) - (int)*(short *)(iVar14 + 0x5a)) {
              iVar16 = *(int *)(iVar3 + 0x44);
            }
            gte_ldVXY0(iVar10 + 0x98);
            gte_ldVZ0(iVar10 + 0x9c);
            gte_ldL11L12(uVar15);
            gte_ldL13L21(*(undefined4 *)(iVar10 + 0xbc));
            gte_llv0_b();
            gte_stMAC0();
            *(int *)(iVar3 + 0x170) = *(short *)(iVar3 + 0x16c) + iVar16;
            *(int *)(iVar3 + 0x174) = *(short *)(iVar3 + 0x16e) + iVar16;
            iVar26 = gte_stIR1();
            iVar16 = iVar26 >> 5;
            if (iVar26 < 0) {
              iVar16 = -iVar16;
            }

			// tire sprite index to render,
			// based on camera rotation
            pcVar5 = &DAT_8008a384 + iVar16;
            if (0 < iVar16 + -0x80) {
              pcVar5 = &DAT_8008a404;
            }

			// iVar3 + 38, is a copy of driver ptr on scratchpad
			// driver->wheelSprites[*pcVar5]
            iVar16 = *(int *)(*pcVar5 * 4 + *(int *)(iVar3 + 0x38));

			// if wheel sprite exists
            if (iVar16 != 0)
			{
              uVar25 = *(undefined4 *)(iVar16 + 0x18);
              uVar19 = *(uint *)(iVar16 + 0x1c);
              *(undefined4 *)(iVar4 + 0xc) = *(undefined4 *)(iVar16 + 0x14);
              uVar20 = gte_stIR1();
              *(undefined4 *)(iVar4 + 0x14) = uVar25;
              *(uint *)(iVar4 + 0x1c) = uVar19;

			  // function pointer from 8008a344
              UNRECOVERED_JUMPTABLE = *(code **)((uVar20 >> 0x1a & 0x10 | uVar9) + 0x130);

              *(uint *)(iVar4 + 0x24) = uVar19 >> 0x10;

			  // execute render function
              (*UNRECOVERED_JUMPTABLE)();
              return;
            }
            iVar14 = iVar14 + -0x10;
            iVar10 = iVar10 + -8;
            uVar9 = uVar9 - 4;
          } while (-1 < iVar14 - iVar3);
        }
      }
      iVar29 = iVar29 + 0x88;

	  // subtract number of players
      iVar14 = *(int *)(iVar3 + 0x34) + -1;
      *(int *)(iVar3 + 0x34) = iVar14;

    } while (0 < iVar14);

	// next thread
    param_1 = *(int *)(param_1 + 0x10);

	// if no threads remain
    if (param_1 == 0)
	{
	  // finalize PrimMem
      *(undefined4 *)(param_2 + 0x14) = uVar25;
      *(int *)(param_2 + 0xc) = iVar4;

	  // quit loop
	  return;
    }

  } while( true );
}


// TRIG_AngleSinCos_r9r8r10
void FUN_8006ef30(void)
{
        8006ef30 08 80 03 3c     lui        v1,0x8008
        8006ef34 a0 45 63 24     addiu      v1,v1,0x45a0
        8006ef38 ff 03 28 31     andi       t0,t1,0x3ff
        8006ef3c 80 40 08 00     sll        t0,t0,0x2
        8006ef40 21 18 68 00     addu       v1,v1,t0
        8006ef44 00 00 68 8c     lw         t0,0x0(v1)=>DAT_800845a0
        8006ef48 00 04 23 31     andi       v1,t1,0x400
        8006ef4c 07 00 60 14     bne        v1,zero,LAB_8006ef6c
        8006ef50 00 08 23 31     _andi      v1,t1,0x800
        8006ef54 03 54 08 00     sra        t2,t0,0x10
        8006ef58 00 44 08 00     sll        t0,t0,0x10
        8006ef5c 09 00 60 14     bne        v1,zero,LAB_8006ef84
        8006ef60 03 44 08 00     _sra       t0,t0,0x10
        8006ef64 08 00 e0 03     jr         ra
        8006ef68 00 00 00 00     _nop
                             LAB_8006ef6c                                    XREF[1]:     8006ef4c(j)
        8006ef6c 00 54 08 00     sll        t2,t0,0x10
        8006ef70 03 54 0a 00     sra        t2,t2,0x10
        8006ef74 06 00 60 14     bne        v1,zero,LAB_8006ef90
        8006ef78 03 44 08 00     _sra       t0,t0,0x10
        8006ef7c 08 00 e0 03     jr         ra
        8006ef80 22 50 0a 00     _sub       t2,zero,t2
                             LAB_8006ef84                                    XREF[1]:     8006ef5c(j)
        8006ef84 22 50 0a 00     sub        t2,zero,t2
        8006ef88 08 00 e0 03     jr         ra
        8006ef8c 22 40 08 00     _sub       t0,zero,t0
                             LAB_8006ef90                                    XREF[1]:     8006ef74(j)
        8006ef90 08 00 e0 03     jr         ra
        8006ef94 22 40 08 00     _sub       t0,zero,t0
}



// WARNING: Instruction at (ram,0x8006eff0) overlaps instruction at (ram,0x8006efec)
//

void FUN_8006ef98(void)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  int unaff_s5;
  uint uVar4;
  int iVar5;

  gte_ldLZCS(unaff_s5);
  iVar5 = 0;
  if (unaff_s5 == 0) {
    return;
  }
  uVar3 = gte_stLZCR();
  uVar1 = 0;
  uVar4 = unaff_s5 << (uVar3 & 0x1e);
  uVar3 = uVar3 & 0x1e ^ 0x1e;
  do {
    if ((int)uVar3 < 0) {
      return;
    }
    while( true ) {
      uVar3 = uVar3 - 2;
      uVar1 = uVar1 | uVar4 >> 0x1e;
      iVar2 = iVar5 * 4;
      iVar5 = iVar5 * 2;
      iVar2 = uVar1 - (iVar2 + 1);
      uVar4 = uVar4 << 2;
      if (-1 < iVar2) break;
      uVar1 = uVar1 << 2;
      if ((int)uVar3 < 0) {
        return;
      }
    }
    iVar5 = iVar5 + 1;
    uVar1 = iVar2 * 4;
  } while( true );
}


// draw reflected tires (reflected on ice)
// param1 - first thread
// param2 - PrimMem
// param3 - numPlayers
void FUN_8006f004(int param_1,int param_2,int param_3)

{
  bool bVar1;
  short sVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  char *pcVar6;
  short *psVar7;
  int iVar8;
  undefined **ppuVar9;
  uint uVar10;
  code *UNRECOVERED_JUMPTABLE;
  short sVar11;
  undefined2 uVar12;
  undefined4 *puVar13;
  int iVar14;
  undefined4 uVar15;
  int iVar16;
  undefined *puVar17;
  int iVar18;
  uint uVar19;
  int iVar20;
  uint uVar21;
  int iVar22;
  int iVar23;
  int iVar24;
  undefined4 unaff_s0;
  undefined4 uVar25;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  uint unaff_s6;
  undefined4 unaff_s7;
  int iVar26;
  int iVar27;
  undefined4 *puVar28;
  undefined4 unaff_s8;
  int iVar29;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];

  iVar3 = 0x1f800000;

  // backup $gp
  DAT_1f800020 = &DAT_8008cf6c;

  // if 3P or 4P
  DAT_1f800054 = 0;
  if (param_3 + -2 < 1)
  {
	// if 1P or 2P
    DAT_1f800054 = 2;
  }

  // loop 8 times
  iVar4 = 7;

  // tire (reflect) jmp pointers
  ppuVar9 = &PTR_LAB_8008a364;

  puVar13 = &DAT_1f800130;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800024 = (undefined *)register0x00000074;
  DAT_1f800028 = unaff_s8;
  DAT_1f80002c = unaff_retaddr;

  // store number of players
  DAT_1f800030 = param_3;

  // loop 8 times
  do {
    puVar17 = *ppuVar9;
    ppuVar9 = ppuVar9 + 1;
    *puVar13 = puVar17;
    puVar13 = puVar13 + 1;
    bVar1 = iVar4 != 0;
    iVar4 = iVar4 + -1;
  } while (bVar1);

  // PrimMem data
  iVar4 = *(int *)(param_2 + 0xc);
  uVar25 = *(undefined4 *)(param_2 + 0x14);

  // loop through all threads (player or robotcar)
  do
  {
	// get instance from thread
    iVar8 = *(int *)(param_1 + 0x34);

	// get object from thread
    puVar28 = *(undefined4 **)(param_1 + 0x30);

	// vertical line for split or reflection
    uVar12 = *(undefined2 *)(iVar8 + 0x56);

	// number of screens to render tires on
    *(undefined4 *)(iVar3 + 0x34) = *(undefined4 *)(iVar3 + 0x30);

	// vertical line for split or reflection
    *(undefined2 *)(iVar3 + 0x4c) = uVar12;

	// store instance
    iVar29 = iVar8;

	// loop through all cameras
	// that tires need to render on
    do {
      sVar2 = *(short *)(iVar29 + 0xde);
      *(short *)(iVar3 + 0x16c) = (short)((int)*(short *)(iVar29 + 0xdc) << 2);
      *(short *)(iVar3 + 0x16e) = (short)((int)sVar2 << 2);

	  // instance flags, duplicate of 0x28
      uVar10 = *(uint *)(iVar29 + 0xb8);

	  // model LOD index
      iVar14 = *(int *)(iVar29 + 0xd8);

      *(uint *)(iVar3 + 0x160) = uVar10;

	  if (
			(
				(
					((uVar10 & 0x40) != 0) &&

					((uVar10 & 0x4000) != 0)
				) &&
				(
					// instance -> camera110
					psVar7 = *(short **)(iVar29 + 0x74),

					// if tires shouldn't disappear on this model LOD
					iVar14 - *(int *)(iVar3 + 0x54) < 1
				)
			) &&

			// if camera110 exists
			(psVar7 != (short *)0x0)
		 )
	  {
		// tire color
        uVar15 = 0x2e808080;

        if ((uVar10 & 0x100) == 0)
		{
		  // driver->tireColor
          uVar15 = puVar28[2];
        }

		// driver ptr, thread -> object
		*(undefined4 *)(iVar3 + 0x38) = *puVar28;

		// tire color
        *(undefined4 *)(iVar3 + 0x3c) = uVar15;

		// instance scale
        sVar2 = *(short *)(iVar8 + 0x1e);
        iVar4 = (int)((uVar10 & 0x100) * 0x90) >> 0xc;

		sVar11 = (short)iVar4;
        *(short *)(iVar3 + 0x58) = sVar11;
        *(short *)(iVar3 + 0x78) = sVar11;
        iVar4 = -iVar4;
        uVar12 = (undefined2)iVar4;
        *(undefined2 *)(iVar3 + 0x68) = uVar12;
        *(undefined2 *)(iVar3 + 0x88) = uVar12;
        *(short *)(iVar3 + 0x60) = sVar11 + -0x1000;
        *(short *)(iVar3 + 0x80) = sVar11 + -0x1000;
        iVar4 = iVar4 + 0x1000;
        *(short *)(iVar3 + 0x70) = (short)iVar4;
        *(short *)(iVar3 + 0x90) = (short)iVar4;

		// instance scale
        sVar11 = *(short *)(iVar8 + 0x20);
        uVar12 = (undefined2)(sVar2 * 0x40 >> 0xc);

		*(undefined2 *)(iVar3 + 0x5a) = uVar12;
        *(undefined2 *)(iVar3 + 0x62) = 0;
        *(undefined2 *)(iVar3 + 0x6a) = uVar12;
        *(undefined2 *)(iVar3 + 0x72) = 0;
        *(undefined2 *)(iVar3 + 0x7a) = uVar12;
        *(undefined2 *)(iVar3 + 0x82) = 0;
        *(undefined2 *)(iVar3 + 0x8a) = uVar12;
        *(undefined2 *)(iVar3 + 0x92) = 0;
        iVar14 = sVar11 * 199 >> 0xc;
        *(int *)(iVar3 + 0x5c) = iVar14;
        *(int *)(iVar3 + 0x6c) = iVar14;
        iVar14 = sVar11 * -0x60 >> 0xc;
        *(int *)(iVar3 + 0x7c) = iVar14;
        *(int *)(iVar3 + 0x84) = iVar14;
        *(int *)(iVar3 + 0x8c) = iVar14;
        *(int *)(iVar3 + 0x94) = iVar14;
        iVar14 = *(int *)(iVar29 + 0xe8);
        sVar2 = *(short *)(puVar28 + 1);
        *(undefined4 *)(iVar3 + 0x40) = *(undefined4 *)(iVar29 + 0xe4);
        *(int *)(iVar3 + 0x44) = iVar14;
        *(int *)(iVar3 + 0x48) = (int)sVar2;

		// TRIG_AngleSinCos_r9r8r10
        FUN_8006ef30();

        *(short *)(iVar3 + 0x60) = *(short *)(iVar3 + 0x58) - (short)iVar4;
        *(int *)(iVar3 + 100) = *(int *)(iVar3 + 0x5c) + iVar14;
        sVar2 = *(short *)((int)puVar28 + 0xe);
        *(short *)(iVar3 + 0x70) = *(short *)(iVar3 + 0x68) + (short)iVar4;
        *(int *)(iVar3 + 0x74) = *(int *)(iVar3 + 0x6c) - iVar14;
        uVar10 = (int)sVar2 & 1;
        uVar21 = 9;
        if (uVar10 != 0) {
          uVar21 = 6;
        }

		// TRIG_AngleSinCos_r9r8r10
		FUN_8006ef30();

        iVar4 = iVar4 >> (uVar21 & 0x1f);
        iVar14 = (int)uVar10 >> (uVar21 & 0x1f);
        *(short *)(iVar3 + 0x62) = *(short *)(iVar3 + 0x62) + (short)iVar4;
        *(short *)(iVar3 + 100) = *(short *)(iVar3 + 100) + (short)iVar14;

		// TRIG_AngleSinCos_r9r8r10
        FUN_8006ef30();

		iVar4 = iVar4 >> (uVar21 & 0x1f);
        iVar14 = iVar14 >> (uVar21 & 0x1f);
        *(short *)(iVar3 + 0x82) = *(short *)(iVar3 + 0x82) + (short)iVar4;
        *(short *)(iVar3 + 0x84) = *(short *)(iVar3 + 0x84) + (short)iVar14;

		// TRIG_AngleSinCos_r9r8r10
		FUN_8006ef30();

		iVar4 = iVar4 >> (uVar21 & 0x1f);
        iVar14 = iVar14 >> (uVar21 & 0x1f);
        *(short *)(iVar3 + 0x72) = *(short *)(iVar3 + 0x72) + (short)iVar4;
        *(short *)(iVar3 + 0x74) = *(short *)(iVar3 + 0x74) + (short)iVar14;

		// TRIG_AngleSinCos_r9r8r10
		FUN_8006ef30();

		*(short *)(iVar3 + 0x92) = *(short *)(iVar3 + 0x92) + (short)(iVar4 >> (uVar21 & 0x1f));
        *(short *)(iVar3 + 0x94) = *(short *)(iVar3 + 0x94) + (short)(iVar14 >> (uVar21 & 0x1f));

		// instance matrix
		gte_ldLR1LR2(*(undefined4 *)(iVar8 + 0x30));
        gte_ldLR3LG1(*(undefined4 *)(iVar8 + 0x34));
        gte_ldLG2LG3(*(undefined4 *)(iVar8 + 0x38));
        gte_ldLB1LB2(*(undefined4 *)(iVar8 + 0x3c));
        gte_ldLB3(*(undefined4 *)(iVar8 + 0x40));

		// another matrix in instance?
		gte_ldL11L12(*(undefined4 *)(iVar29 + 0x98));
        gte_ldL13L21(*(undefined4 *)(iVar29 + 0x9c));
        gte_ldL22L23(*(undefined4 *)(iVar29 + 0xa0));
        gte_ldL31L32(*(undefined4 *)(iVar29 + 0xa4));
        gte_ldL33(*(undefined4 *)(iVar29 + 0xa8));

		// instance position - camera position
		iVar5 = (*(int *)(iVar8 + 0x44) - (int)*psVar7) * 4;
        iVar14 = (*(int *)(iVar8 + 0x48) - (int)psVar7[1]) * 4;
        iVar16 = (*(int *)(iVar8 + 0x4c) - (int)psVar7[2]) * 4;
        gte_ldtr(iVar5,iVar14,iVar16);

		// vertical line split - camera posY
        *(short *)(iVar3 + 0x50) = (*(short *)(iVar3 + 0x4c) - psVar7[1]) * 4;

		iVar26 = iVar3 + 0x30;
        iVar27 = iVar3 + 0x18;
        do {
          gte_ldVXY0(iVar26 + 0x58);
          gte_ldVZ0(iVar26 + 0x5c);
          gte_ldVXY1(iVar26 + 0x60);
          gte_ldVZ1(iVar26 + 100);
          gte_lcv0tr_b();
          iVar20 = gte_stIR1();
          iVar4 = gte_stIR2();
          iVar23 = gte_stIR3();
          iVar4 = *(short *)(iVar3 + 0x50) * 2 - iVar4;
          gte_sqr0_b(0);
          *(short *)(iVar26 + 0x58) = (short)iVar20;
          *(short *)(iVar26 + 0x5a) = (short)iVar4;
          read_mt(iVar5,iVar14,iVar16);
          FUN_8006ef98();
          iVar18 = 0x10000;
          gte_lcv1_b();
          *(int *)(iVar26 + 0x5c) = iVar23;
          iVar5 = -(0x10000 / unaff_s6);
          uVar15 = gte_stIR1();
          iVar14 = gte_stIR2();
          iVar16 = gte_stIR3();
          iVar14 = -iVar14;
          *(short *)(iVar27 + 0xb8) = (short)uVar15;
          uVar10 = iVar20 * iVar5 >> 4;
          *(short *)(iVar27 + 0x98) = (short)uVar10;
          *(short *)(iVar27 + 0xba) = (short)iVar14;
          *(int *)(iVar27 + 0xbc) = iVar16;
          iVar23 = iVar23 * iVar5 >> 4;
          uVar10 = uVar10 & 0xffff;
          uVar21 = iVar4 * iVar5 >> 4 & 0xffff;
          gte_ldR11R12(uVar10);
          gte_ldR22R23(uVar21);
          gte_ldR33(iVar23);
          *(short *)(iVar27 + 0x9a) = (short)uVar21;
          *(int *)(iVar27 + 0x9c) = iVar23;
          gte_op12_b();
          read_mt(uVar10,uVar21,iVar23);
          gte_sqr0_b(0);
          read_mt(uVar15,iVar14,iVar16);
          FUN_8006ef98();
          iVar5 = iVar18 / iVar5;
          iVar20 = (int)(uVar10 * iVar5) >> 4;
          gte_ldIR1(iVar20);
          iVar22 = (int)(uVar21 * iVar5) >> 4;
          gte_ldIR2(iVar22);
          iVar24 = iVar23 * iVar5 >> 4;
          gte_ldIR3(iVar24);
          iVar4 = *(int *)(iVar3 + 0x48);
          gte_op12_b();
          iVar20 = iVar20 * iVar4;
          iVar23 = iVar20 >> 0x12;
          *(short *)(iVar27 + 0xd8) = (short)(iVar20 >> 0x12);
          iVar22 = iVar22 * iVar4;
          iVar20 = iVar22 >> 0x12;
          *(short *)(iVar27 + 0xda) = (short)(iVar22 >> 0x12);
          iVar24 = iVar24 * iVar4;
          iVar22 = iVar24 >> 0x12;
          *(short *)(iVar27 + 0xdc) = (short)(iVar24 >> 0x12);
          read_mt(iVar23,iVar20,iVar22);
          gte_sqr0_b(0);
          read_mt(iVar4,iVar14,iVar16);
          iVar4 = FUN_8006ef98();
          unaff_s6 = *(int *)(iVar3 + 0x48) * -(iVar18 / iVar5) >> 0xc;
          *(short *)(iVar27 + 0xf8) = (short)((int)(iVar23 * unaff_s6) >> 10);
          *(short *)(iVar27 + 0xfa) = (short)((int)(iVar20 * unaff_s6) >> 10);
          *(short *)(iVar27 + 0xfc) = (short)((int)(iVar22 * unaff_s6) >> 10);
          iVar26 = iVar26 + -0x10;
          iVar5 = iVar26 - iVar3;
          iVar27 = iVar27 + -8;
        } while (-1 < iVar5);

		// camera110 ViewProj
		// (multiply by 2, offset 0x28)
        gte_ldR11R12(*(undefined4 *)(psVar7 + 0x14));
        gte_ldR13R21(*(undefined4 *)(psVar7 + 0x16));
        gte_ldR22R23(*(undefined4 *)(psVar7 + 0x18));
        gte_ldR31R32(*(undefined4 *)(psVar7 + 0x1a));
        gte_ldR33(*(undefined4 *)(psVar7 + 0x1c));

		// no translation, rotation only
        gte_ldtr(0,0,0);

		// screen dimensions, and distance from screen
		gte_ldOFX((int)psVar7[0x10] << 0xf);
        gte_ldOFY((int)psVar7[0x11] << 0xf);
        gte_ldH(*(undefined4 *)(psVar7 + 0xc));

        iVar14 = iVar3 + 0x30;
        iVar5 = iVar3 + 0x18;
        uVar10 = iVar3 + 0xc;
        do {
          gte_ldVXY0(((int)*(short *)(iVar14 + 0x58) - (int)*(short *)(iVar5 + 0xd8)) -
                     (int)*(short *)(iVar5 + 0xf8) & 0xffffU |
                     (((int)*(short *)(iVar14 + 0x5a) - (int)*(short *)(iVar5 + 0xda)) -
                     (int)*(short *)(iVar5 + 0xfa)) * 0x10000);
          gte_ldVZ0(((int)*(short *)(iVar14 + 0x5c) - (int)*(short *)(iVar5 + 0xdc)) -
                    (int)*(short *)(iVar5 + 0xfc));
          gte_ldVXY1(((int)*(short *)(iVar14 + 0x58) + (int)*(short *)(iVar5 + 0xd8)) -
                     (int)*(short *)(iVar5 + 0xf8) & 0xffffU |
                     (((int)*(short *)(iVar14 + 0x5a) + (int)*(short *)(iVar5 + 0xda)) -
                     (int)*(short *)(iVar5 + 0xfa)) * 0x10000);
          gte_ldVZ1(((int)*(short *)(iVar14 + 0x5c) + (int)*(short *)(iVar5 + 0xdc)) -
                    (int)*(short *)(iVar5 + 0xfc));
          gte_ldVXY2(((int)*(short *)(iVar14 + 0x58) - (int)*(short *)(iVar5 + 0xd8)) +
                     (int)*(short *)(iVar5 + 0xf8) & 0xffffU |
                     (((int)*(short *)(iVar14 + 0x5a) - (int)*(short *)(iVar5 + 0xda)) +
                     (int)*(short *)(iVar5 + 0xfa)) * 0x10000);
          gte_ldVZ2(((int)*(short *)(iVar14 + 0x5c) - (int)*(short *)(iVar5 + 0xdc)) +
                    (int)*(short *)(iVar5 + 0xfc));
          gte_rtpt_b();
          gte_stSXY0();
          gte_stSXY1();
          gte_stSXY2();
          gte_ldVXY0((int)*(short *)(iVar14 + 0x58) + (int)*(short *)(iVar5 + 0xd8) +
                     (int)*(short *)(iVar5 + 0xf8) & 0xffffU |
                     ((int)*(short *)(iVar14 + 0x5a) + (int)*(short *)(iVar5 + 0xda) +
                     (int)*(short *)(iVar5 + 0xfa)) * 0x10000);
          gte_ldVZ0((int)*(short *)(iVar14 + 0x5c) + (int)*(short *)(iVar5 + 0xdc) +
                    (int)*(short *)(iVar5 + 0xfc));
          uVar15 = *(undefined4 *)(iVar5 + 0xb8);
          gte_rtps_b();
          *(undefined4 *)(iVar4 + 4) = *(undefined4 *)(iVar3 + 0x3c);
          gte_stSXY2();
          gte_avsz4_b();
          gte_stMAC0();
          gte_ldVXY0(iVar5 + 0x98);
          gte_ldVZ0(iVar5 + 0x9c);
          gte_ldL11L12(uVar15);
          gte_ldL13L21(*(undefined4 *)(iVar5 + 0xbc));
          gte_llv0_b();
          *(int *)(iVar3 + 0x170) = (int)*(short *)(iVar3 + 0x16c) + *(int *)(iVar3 + 0x44);
          *(int *)(iVar3 + 0x174) = (int)*(short *)(iVar3 + 0x16e) + *(int *)(iVar3 + 0x44);
          iVar26 = gte_stIR1();
          iVar16 = iVar26 >> 5;
          if (iVar26 < 0) {
            iVar16 = -iVar16;
          }

		  // tire sprite index to render,
		  // based on camera rotation
          pcVar6 = &DAT_8008a384 + iVar16;
          if (0 < iVar16 + -0x80) {
            pcVar6 = &DAT_8008a404;
          }

		  // iVar3 + 38, is a copy of driver ptr on scratchpad
		  // driver->wheelSprites[*pcVar5]
          iVar16 = *(int *)(*pcVar6 * 4 + *(int *)(iVar3 + 0x38));

		  // if wheel sprite exists
          if (iVar16 != 0)
		  {
            uVar25 = *(undefined4 *)(iVar16 + 0x18);
            uVar19 = *(uint *)(iVar16 + 0x1c);
            *(undefined4 *)(iVar4 + 0xc) = *(undefined4 *)(iVar16 + 0x14);
            uVar21 = gte_stIR1();
            *(undefined4 *)(iVar4 + 0x14) = uVar25;
            *(uint *)(iVar4 + 0x1c) = uVar19;

			// function pointer from global array
            UNRECOVERED_JUMPTABLE = *(code **)((uVar21 >> 0x1a & 0x10 | uVar10) + 0x130);

            *(uint *)(iVar4 + 0x24) = uVar19 >> 0x10;

			// execute function pointer
            (*UNRECOVERED_JUMPTABLE)();
            return;
          }
          iVar14 = iVar14 + -0x10;
          iVar5 = iVar5 + -8;
          uVar10 = uVar10 - 4;
        } while (-1 < iVar14 - iVar3);
      }
      iVar29 = iVar29 + 0x88;

	  // subtract number of players
      iVar14 = *(int *)(iVar3 + 0x34) + -1;
      *(int *)(iVar3 + 0x34) = iVar14;

    } while (0 < iVar14);

	// next thread
	param_1 = *(int *)(param_1 + 0x10);

	// if no threads remain
    if (param_1 == 0)
	{
	  // finalize PrimMem
      *(undefined4 *)(param_2 + 0x14) = uVar25;
      *(int *)(param_2 + 0xc) = iVar4;

	  // quit loop
      return;
    }
  } while( true );
}



// RenderWeather
// param_1 camera110
// param_2 PrimMem
// param_3 RainBuffer
// param_4 numScreens
// param_5 paused?
void FUN_8006f9a8(uint *param_1,int param_2,uint *param_3,undefined4 param_4,int param_5)
{
  bool bVar1;
  short sVar2;
  short sVar3;
  int iVar4;
  uint *puVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  int iVar9;
  uint uVar10;
  uint uVar11;
  uint *puVar12;
  uint uVar13;
  uint uVar14;
  undefined4 unaff_s0;
  int unaff_s1;
  uint uVar15;
  int unaff_s2;
  int iVar16;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  int iVar17;
  undefined4 unaff_s5;
  uint uVar18;
  undefined4 unaff_s6;
  uint uVar19;
  undefined4 unaff_s7;
  uint uVar20;
  undefined *puVar21;
  uint uVar22;
  undefined *puVar23;
  undefined4 unaff_s8;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];

  iVar4 = 0x1f800000;
  DAT_1f800020 = &DAT_8008cf6c;
  gte_ldtr(0,0,0);
  gte_ldR11R12(param_1[10]);
  gte_ldR13R21(param_1[0xb]);
  gte_ldR22R23(param_1[0xc]);
  gte_ldR31R32(param_1[0xd]);
  gte_ldR33(param_1[0xe]);
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800024 = (undefined *)register0x00000074;
  DAT_1f800028 = unaff_s8;
  DAT_1f80002c = unaff_retaddr;

  // TRIG_AngleSinCos_r16r17r18
  puVar5 = (uint *)FUN_8006fe08();

  // sin and cos output
  iVar16 = (unaff_s2 >> 2) + 0x400;
  uVar15 = (unaff_s1 >> 2) + 0x400;

  *(uint *)(iVar4 + 0x38) = uVar15 | 0x4000000;
  *(int *)(iVar4 + 0x3c) = iVar16;
  uVar13 = param_1[8];
  uVar11 = param_1[0x3d];
  gte_ldOFX((int)*(short *)(param_1 + 8) << 0xf);
  gte_ldOFY((int)*(short *)((int)param_1 + 0x22) << 0xf);
  gte_ldH(param_1[6]);
  uVar14 = *param_3;
  uVar6 = (uint)*(ushort *)(param_3 + 1);
  if (param_5 == 0) {
    uVar8 = (uint)*(ushort *)((int)param_3 + 6);
    iVar9 = uVar6 - uVar14;
    if (uVar6 != uVar14) {
      if (iVar9 < 0) {
        uVar14 = uVar14 - uVar8;
        if (0 < (int)(iVar9 + uVar8)) {
          uVar14 = uVar6;
        }
      }
      else {
        uVar14 = uVar14 + uVar8;
        if ((int)(iVar9 - uVar8) < 0) {
          uVar14 = uVar6;
        }
      }
      *param_3 = uVar14;
    }
  }
  uVar6 = param_3[2];
  uVar8 = param_3[3];
  uVar19 = uVar8 + param_3[5];
  uVar18 = uVar6 + (param_3[4] & 0xfffeffff) & 0xfffeffff;
  if (param_5 == 0) {
    param_3[2] = uVar18;
    param_3[3] = uVar19;
  }
  sVar2 = *(short *)(param_1 + 1);
  iVar9 = (int)sVar2;
  uVar10 = param_3[6];
  sVar3 = *(short *)(param_3 + 7);
  uVar7 = *param_1 & 0xfffeffff;
  if (param_5 == 0) {
    param_3[6] = uVar7;
    *(short *)(param_3 + 7) = sVar2;
  }
  uVar10 = ((uVar6 + ((int)(param_3[4] & 0xfffeffff) >> 1 & 0xfffeffffU) & 0xfffeffff) -
            (uVar7 - ((int)((uVar7 - uVar10) * 0x10000) >> 0x13 & 0xffffU |
                     ((int)(uVar7 - uVar10) >> 0x14) << 0x11) & 0xfffeffff) & 0xfffeffff) + uVar15 &
           0xfffeffff;
  uVar18 = (uVar18 - uVar7 & 0xfffeffff) + uVar15 & 0xfffeffff;
  iVar17 = ((uVar8 + ((int)param_3[5] >> 1)) - (iVar9 - (iVar9 - sVar3 >> 3))) + iVar16;
  iVar16 = (uVar19 - iVar9) + iVar16;
  uVar6 = param_3[9];
  uVar15 = param_3[10];
  puVar12 = (uint *)(uVar11 + param_3[0xb] * 4);
  *(uint *)(iVar4 + 0x30) = param_3[8] | 0x52000000;
  *(uint *)(iVar4 + 0x34) = uVar6;
  uVar6 = 0x30125400;
  uVar11 = 0x493583fe;
  do {
    uVar8 = uVar11 >> 8;
    uVar11 = uVar6 >> 8 | uVar11 << 0x18;
    uVar19 = (uVar6 + uVar8 + (uVar11 >> 8)) * 0x1000000;
    uVar6 = (uVar8 | uVar19) >> 8;
    uVar8 = uVar11 >> 8 | uVar8 << 0x18;
    uVar22 = (uVar11 + uVar6 + (uVar8 >> 8)) * 0x1000000;
    uVar11 = (uVar6 | uVar22) >> 8;
    uVar6 = uVar8 >> 8 | uVar6 << 0x18;
    puVar23 = (undefined *)((uVar8 + uVar11 + (uVar6 >> 8)) * 0x1000000);
    uVar11 = uVar11 | (uint)puVar23;
    puVar21 = (undefined *)((int)uVar22 >> 5);
    uVar8 = (int)uVar19 >> 0x15 & 0xffff;
    while( true ) {
      bVar1 = uVar14 == 0;
      uVar14 = uVar14 - 1;
      if (bVar1) {
        puVar5[1] = uVar15;
        puVar5[2] = 0;
        *puVar5 = *puVar12 | 0x2000000;
        *puVar12 = (uint)puVar5 & 0xffffff;
        *(uint **)(param_2 + 0xc) = puVar5 + 3;
        return;
      }
      uVar19 = ((uVar8 | (uint)puVar21) + uVar10 & 0x7fe07ff) - *(int *)(iVar4 + 0x38);
      uVar8 = ((uVar8 | (uint)puVar21) + uVar18 & 0x7fe07ff) - *(int *)(iVar4 + 0x38);
      if (uVar8 - uVar19 != uVar18 - uVar10) break;
      uVar8 = uVar8 & 0xfffeffff;
      gte_ldVXY0(uVar19 & 0xfffeffff);
      gte_ldVXY1(uVar8);
      gte_ldVXY2(uVar8);
      uVar8 = ((uint)puVar23 >> 0x15) + iVar17 & 0x7ff;
      uVar19 = ((uint)puVar23 >> 0x15) + iVar16 & 0x7ff;
      if (uVar19 - uVar8 != iVar16 - iVar17) break;
      iVar9 = uVar19 - *(int *)(iVar4 + 0x3c);
      gte_ldVZ0(uVar8 - *(int *)(iVar4 + 0x3c));
      gte_ldVZ1(iVar9);
      gte_ldVZ2(iVar9);
      uVar8 = uVar11 >> 8;
      gte_rtpt_b();
      uVar11 = uVar6 >> 8 | uVar11 << 0x18;
      uVar19 = (uVar6 + uVar8 + (uVar11 >> 8)) * 0x1000000;
      uVar6 = (uVar8 | uVar19) >> 8;
      uVar8 = uVar11 >> 8 | uVar8 << 0x18;
      uVar20 = (uVar11 + uVar6 + (uVar8 >> 8)) * 0x1000000;
      uVar11 = (uVar6 | uVar20) >> 8;
      uVar6 = uVar8 >> 8 | uVar6 << 0x18;
      puVar23 = (undefined *)((uVar8 + uVar11 + (uVar6 >> 8)) * 0x1000000);
      uVar11 = uVar11 | (uint)puVar23;
      puVar21 = (undefined *)((int)uVar20 >> 5);
      uVar8 = (int)uVar19 >> 0x15 & 0xffff;
      uVar19 = gte_stSXY0();
      iVar9 = gte_stFLAG();
      uVar7 = gte_stSXY1();
      if (((-1 < iVar9 << 0xe) &&
          (uVar19 = ~(uVar19 - uVar13 | uVar7 - uVar13) | uVar19 & uVar7, -1 < (int)uVar19)) &&
         (-1 < (int)(uVar19 << 0x10))) {
        uVar19 = *(uint *)(iVar4 + 0x34);
        puVar5[1] = *(uint *)(iVar4 + 0x30);
        puVar5[3] = uVar19;
        *puVar5 = *puVar12 | 0x4000000;
        gte_stSXY0();
        gte_stSXY1();
        *puVar12 = (uint)puVar5 & 0xffffff;
        puVar5 = puVar5 + 5;
      }
    }
  } while( true );
}


// TRIG_AngleSinCos_r16r17r18
void FUN_8006fe08(void)
{
	// input: s0
	// output: s1 SIN, s2 COS

        8006fe08 08 80 03 3c     lui        v1,0x8008
        8006fe0c a0 45 63 24     addiu      v1,v1,0x45a0
        8006fe10 ff 03 11 32     andi       s1,s0,0x3ff
        8006fe14 80 88 11 00     sll        s1,s1,0x2
        8006fe18 21 18 71 00     addu       v1,v1,s1
        8006fe1c 00 00 71 8c     lw         s1,0x0(v1)=>DAT_800845a0
        8006fe20 00 04 03 32     andi       v1,s0,0x400
        8006fe24 07 00 60 14     bne        v1,zero,LAB_8006fe44
        8006fe28 00 08 03 32     _andi      v1,s0,0x800
        8006fe2c 03 94 11 00     sra        s2,s1,0x10
        8006fe30 00 8c 11 00     sll        s1,s1,0x10
        8006fe34 09 00 60 14     bne        v1,zero,LAB_8006fe5c
        8006fe38 03 8c 11 00     _sra       s1,s1,0x10
        8006fe3c 08 00 e0 03     jr         ra
        8006fe40 00 00 00 00     _nop

		8006fe44 00 94 11 00     sll        s2,s1,0x10
        8006fe48 03 94 12 00     sra        s2,s2,0x10
        8006fe4c 06 00 60 14     bne        v1,zero,LAB_8006fe68
        8006fe50 03 8c 11 00     _sra       s1,s1,0x10
        8006fe54 08 00 e0 03     jr         ra
        8006fe58 22 90 12 00     _sub       s2,zero,s2

		8006fe5c 22 90 12 00     sub        s2,zero,s2
        8006fe60 08 00 e0 03     jr         ra
        8006fe64 22 88 11 00     _sub       s1,zero,s1

		8006fe68 08 00 e0 03     jr         ra
        8006fe6c 22 88 11 00     _sub       s1,zero,s1

}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// CreateRenderLists_1P2P
// param1 is lev->mesh_info->ptrVisDataArray
// param2 is VisMem 0x00-0x0F (visLeafList)
// param3 is camera110
// param4 is pointer of linked list VisData (1808) to draw in 226
// param5 is VisMem 0x80-0x8F (bspList)
// param6 is number of players
undefined4 FUN_8006fe70(ushort *param_1,int param_2,int param_3,int param_4,int param_5,int param_6)

{
  short *psVar1;
  short sVar2;
  ushort uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  ushort *puVar13;
  undefined4 unaff_s3;
  uint uVar14;
  int *piVar15;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  uint uVar16;
  undefined4 unaff_s7;
  int iVar17;
  int *piVar18;
  code *pcVar19;
  undefined4 unaff_s8;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];

  // function pointer back to itself
  pcVar19 = FUN_8006fe70;

  iVar4 = 0x1f800000;
  _DAT_1f800050 = &_gp_4;
  _DAT_1f800080 = 0;
  iVar5 = 0x1f800000;

  // if 1 player
  DAT_1f8000a4 = DAT_1f800018;

  // if not 1 player
  if (param_6 != 1) {
    DAT_1f8000a4 = 0x1540;
  }

  // load matrix at camera110 0x28, into GTE registers
  gte_ldR11R12(*(undefined4 *)(param_3 + 0x28));
  gte_ldR13R21(*(undefined4 *)(param_3 + 0x2c));
  gte_ldR22R23(*(undefined4 *)(param_3 + 0x30));
  gte_ldR31R32(*(undefined4 *)(param_3 + 0x34));
  gte_ldR33(*(undefined4 *)(param_3 + 0x38));
  gte_ldtr(*(undefined4 *)(param_3 + 0x3c),*(undefined4 *)(param_3 + 0x40),
           *(undefined4 *)(param_3 + 0x44));

  // camera110 sizeX and sizeY
  gte_ldOFX((int)*(short *)(param_3 + 0x20) << 0xf);
  gte_ldOFY((int)*(short *)(param_3 + 0x22) << 0xf);

  // distance to screen
  gte_ldH(*(undefined4 *)(param_3 + 0x18));

  // all this is frustum related
  iVar8 = (int)*(short *)(param_3 + 0xe8);
  iVar9 = (int)*(short *)(param_3 + 0xea);
  iVar10 = (int)*(short *)(param_3 + 0xec);
  iVar11 = (int)*(short *)(param_3 + 0xee);
  iVar12 = (int)*(short *)(param_3 + 0xf0);
  sVar2 = *(short *)(param_3 + 0xf2);
  _DAT_1f800060 = *(undefined4 *)(param_3 + 0xa8);
  DAT_1f800064 = *(undefined4 *)(param_3 + 0xac);
  _DAT_1f800068 = *(undefined4 *)(param_3 + 0xb0);
  DAT_1f80006c = *(undefined4 *)(param_3 + 0xb4);
  _DAT_1f800070 = *(undefined4 *)(param_3 + 0xb8);
  DAT_1f800074 = *(undefined4 *)(param_3 + 0xbc);
  _DAT_1f800078 = *(undefined4 *)(param_3 + 0xc0);
  DAT_1f80007c = *(undefined4 *)(param_3 + 0xc4);
  DAT_1f8000ac = (&DAT_1f800084)[*(int *)(param_3 + 0xd0)];
  _DAT_1f8000b0 = (&DAT_1f800084)[*(int *)(param_3 + 0xd4)];
  DAT_1f8000b4 = (&DAT_1f800084)[*(int *)(param_3 + 0xd8)];
  DAT_1f8000b8 = (&DAT_1f800084)[*(int *)(param_3 + 0xdc)];
  DAT_1f8000c0 = (&DAT_1f800084)[*(int *)(param_3 + 0xe4)];

  // VisMem 0x80-0x8F
  iVar7 = param_5;

  // lev -> mesh -> visData
  puVar13 = param_1;

  DAT_1f800030 = unaff_s0;
  DAT_1f800034 = unaff_s1;
  DAT_1f800038 = unaff_s2;
  DAT_1f80003c = unaff_s3;
  DAT_1f800040 = unaff_s4;
  DAT_1f800044 = unaff_s5;
  DAT_1f800048 = unaff_s6;
  _DAT_1f80004c = unaff_s7;
  DAT_1f800054 = (undefined *)register0x00000074;
  _DAT_1f800058 = unaff_s8;
  DAT_1f80005c = unaff_retaddr;
  do
  {
	// Assume VisData branch, not leaf

	// leftChildID
    uVar14 = *(uint *)(puVar13 + 0xc);

	// rightChildID
	uVar16 = (int)uVar14 >> 0x10;

	// (if left child exists)
	if (((uVar14 & 0x8000) == 0) &&
	
		// if visLeafList says this visData node is not a leaf
		(*(int *)((uVar14 >> 3 & 0x7fc) + param_2) << (uVar14 & 0x1f) < 0)) {

	  // leftChild = array + index * 0x10 (short ptr, 0x10 -> 0x20)
	  puVar13 = param_1 + (uVar14 & 0x3fff) * 0x10;

	  // minPos x,y
	  iVar6 = *(int *)(puVar13 + 2);

	  // minPos z, maxPos x
	  iVar17 = *(int *)(puVar13 + 4);

	  if (((iVar6 >> 0x10) - iVar12 < 1) &&
         (*(int *)(iVar5 + 0xd4) = iVar6, (short)iVar6 - iVar11 < 1)) {

		// maxPos y,z
		iVar6 = *(int *)(puVar13 + 6);

		if ((((iVar8 - (iVar17 >> 0x10) < 1) && ((int)(short)iVar17 - (int)sVar2 < 1)) &&
            (iVar10 - (iVar6 >> 0x10) < 1)) &&
           (*(int *)(iVar5 + 0xd8) = iVar17, iVar9 - (short)iVar6 < 1)) {
          *(int *)(iVar5 + 0xdc) = iVar6;
          *(undefined2 *)(iVar5 + 0xd0) = (short)uVar14;
          iVar5 = iVar5 + 0x10;
        }
      }
    }

	// (if right child exists)
    if ((-1 < (int)uVar16) &&
	
		// if visLeafList says this visData node is not a leaf
		(*(int *)((uVar16 >> 3 & 0x7fc) + param_2) << (uVar16 & 0x1f) < 0)) {

	  // rightChild = array + index * 0x10 (short ptr, 0x10 -> 0x20)
	  puVar13 = param_1 + (uVar16 & 0x3fff) * 0x10;

	  // minPos x,y
      iVar6 = *(int *)(puVar13 + 2);

	  // minPos z, maxPos x
      iVar17 = *(int *)(puVar13 + 4);
      if (((iVar6 >> 0x10) - iVar12 < 1) &&
         (*(int *)(iVar5 + 0xd4) = iVar6, (short)iVar6 - iVar11 < 1)) {

		// maxPos y,z
		iVar6 = *(int *)(puVar13 + 6);

		if ((((iVar8 - (iVar17 >> 0x10) < 1) && ((int)(short)iVar17 - (int)sVar2 < 1)) &&
            (iVar10 - (iVar6 >> 0x10) < 1)) &&
           (*(int *)(iVar5 + 0xd8) = iVar17, iVar9 - (short)iVar6 < 1)) {
          *(int *)(iVar5 + 0xdc) = iVar6;
          *(undefined2 *)(iVar5 + 0xd0) = (short)(uVar14 >> 0x10);
          iVar5 = iVar5 + 0x10;
        }
      }
    }
	
	
    while( true ) {
      if (iVar5 == iVar4) {
        return *(undefined4 *)(iVar4 + 0x80);
      }

	  // get child VisData index (and flags)
      psVar1 = (short *)(iVar5 + 0xc0);

      iVar5 = iVar5 + -0x10;

	  // get just the index
      uVar14 = (int)*psVar1 & 0x3fff;

	  // pointer to VisData node
      puVar13 = param_1 + uVar14 * 0x10;

	  // If this is not a leaf node, break
	  if (((int)*psVar1 & 0x4000U) == 0) break;

	  // as long as we have leaf nodes, keep going...

	  // VisData flag
	  uVar3 = *puVar13;

      iVar5 = FUN_80070284();
      if ((((int)pcVar19 < 1) && (iVar5 = FUN_80070284(), (int)pcVar19 < 1)) &&
         (iVar5 = FUN_80070284(), (int)pcVar19 < 1)) {
        iVar5 = FUN_80070284();
        if ((int)pcVar19 < 1) 
		{
		  // VisDataList_Water
          piVar18 = (int *)(param_4 + 0x24);
		  
          if (
				(
				
				// is VisData flag is not water
				(uVar3 & 2) == 0) && 
				
				(
					// VisDataList_DynamicSubdiv
					piVar18 = (int *)(param_4 + 0xc), 
					
					// if forcedDynamicSubdiv is disabled
					(uVar3 & 0x20) == 0
				)
			  ) 
		  {
            iVar5 = FUN_80070308();

			// $gp overwritten temporarily
			gte_ldVXY0($gp);
            gte_ldVZ0(unaff_s8);

			// RTPS - Perspective Transformation (single)
			gte_rtps();

			// replace with "li t0, 0" for max LOD,
			// the higher t0, the higher the distance
            iVar6 = gte_stSZ3();
			
			// anything min LOD to max LOD
			// VisDataList_FullDynamic
            piVar18 = (int *)(param_4 + 0x28);
			
            if (
				(
					// if distance < *(int *)(iVar4+0xa4)
					(iVar6 - *(int *)(iVar4 + 0xa4) < 1) &&
					(
						(
							// VisDataList_4x4
							piVar18 = (int *)(param_4 + 4), 
							
							// if forced 4x4 is disabled
							(uVar3 & 0x80) == 0 &&
						
							(
								// VisDataList_4x1
								piVar18 = (int *)(param_4 + 0x1c), 
								
								// if forced 4x1 is disabled
								(uVar3 & 8) == 0
							)
						)
					)
				) &&
				 
				(
					// VisDataList_4x2
					piVar18 = (int *)(param_4 + 0x14), 
					
					// if forced 4x2 is disabled
					(uVar3 & 0x10) == 0
				)
			  ) 
			{
			  // if distance is close,
			  // and all force-subdiv flags are disabled
				
			  // pick 4x1 - 4x4 depending on distance
			  // VisDataList_DynamicSubdiv
			  piVar18 = (int *)(param_4 + 0xc);
            }
          }
		  
		  // VisMem 0x80-0x8F (bspList)
		  // linked list of VisData nodes
		  
		  // region after quadblock int flags
		  // vismem + VisData index * 8
          piVar15 = (int *)(uVar14 * 8 + iVar7);
		  
		  // get most recent addition to VisDataList
          iVar17 = *piVar18;
		  
		  // VisDataList pointer = VisMem pointer
          *(int **)piVar18 = piVar15;
		  
		  // 1f800080 count
          iVar6 = *(int *)(iVar4 + 0x80);

		  // VisDataList->next = the former
          *piVar15 = iVar17;

		  // increment counter
		  *(int *)(iVar4 + 0x80) = iVar6 + 1;
        }
      }
    }
  } while( true );
}


// part of FindVisData
void FUN_80070284(void)
{
	// jr to s7,
	// then the end of the function at s7 jumps to t9,
	// which is set here, 80070290 (next function after this)
	
	// s7 can be 80070308 to 8007037c,
	// each is only 3 instructions, one of which jumps to t9
	
        80070284 07 80 19 3c     lui        t9,0x8007
        80070288 08 00 e0 02     jr         s7
        8007028c 90 02 39 37     _ori       t9,t9,0x290
}


// called from FUN_80070284,
// which is part of FindVisData
void FUN_80070290(void)

{
  int in_at;
  int iVar1;
  int in_t8;
  undefined4 unaff_s8;

  // in_at is a scratchpad pointer
  iVar1 = *(int *)(in_t8 + in_at + 100);

  // $gp is overwritten temporarily
  // by hand-written assembly
  gte_ldVXY0($gp);

  gte_ldVZ0(unaff_s8);
  gte_ldL11L12(*(undefined4 *)(in_t8 + in_at + 0x60));
  gte_ldL13L21(iVar1);
  gte_ldRBK((iVar1 >> 0x10) * -2);
  gte_llv0bk();
  gte_stIR1();
  return;
}

// called before every FindLevVisData
void FUN_800702d4(void)

{
  bool bVar1;
  undefined *puVar2;
  undefined **ppuVar3;
  undefined4 *puVar4;
  int iVar5;

  iVar5 = 7;
  ppuVar3 = &PTR_LAB_8008a408;
  puVar4 = &DAT_1f800084;
  do {
    puVar2 = *ppuVar3;
    ppuVar3 = ppuVar3 + 1;
    *(undefined **)puVar4 = puVar2;
    puVar4 = puVar4 + 1;
    bVar1 = iVar5 != 0;
    iVar5 = iVar5 + -1;
  } while (bVar1);
  return;
}



void FUN_80070308(void)

{
        80070308 08 00 e0 02     jr         s7
        8007030c 21 c8 e0 03     _move      t9,ra
}

// After that, are 8 functions that are used from JMP pointers,
// each only a few bytes large



// CreateRenderLists_3P4P
// param1 is lev->mesh_info->ptrVisDataArray
// param2 is VisMem 0x00-0x0F
// param3 is camera110
// param4 is pointer of linked list VisData (1808) to draw in 226
// param5 is VisMem 0x80-0x8F
// param6 is number of players
undefined4 FUN_80070388(ushort *param_1,int param_2,int param_3,int param_4,int param_5)

{
  short *psVar1;
  short sVar2;
  ushort uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  ushort *puVar13;
  undefined4 unaff_s3;
  uint uVar14;
  int *piVar15;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  uint uVar16;
  undefined4 unaff_s7;
  int iVar17;
  int *piVar18;
  code *pcVar19;
  undefined4 unaff_s8;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];

  pcVar19 = FUN_80070388;
  _DAT_1f800050 = &_gp_4;
  iVar4 = 0x1f800000;
  _DAT_1f800080 = 0;
  iVar5 = 0x1f800000;

  // matrix
  gte_ldR11R12(*(undefined4 *)(param_3 + 0x28));
  gte_ldR13R21(*(undefined4 *)(param_3 + 0x2c));
  gte_ldR22R23(*(undefined4 *)(param_3 + 0x30));
  gte_ldR31R32(*(undefined4 *)(param_3 + 0x34));
  gte_ldR33(*(undefined4 *)(param_3 + 0x38));
  gte_ldtr(*(undefined4 *)(param_3 + 0x3c),*(undefined4 *)(param_3 + 0x40),
           *(undefined4 *)(param_3 + 0x44));
		   
  // screen dimensions
  gte_ldOFX((int)*(short *)(param_3 + 0x20) << 0xf);
  gte_ldOFY((int)*(short *)(param_3 + 0x22) << 0xf);
  
  // distance to screen
  gte_ldH(*(undefined4 *)(param_3 + 0x18));

  iVar8 = (int)*(short *)(param_3 + 0xe8);
  iVar9 = (int)*(short *)(param_3 + 0xea);
  iVar10 = (int)*(short *)(param_3 + 0xec);
  iVar11 = (int)*(short *)(param_3 + 0xee);
  iVar12 = (int)*(short *)(param_3 + 0xf0);
  sVar2 = *(short *)(param_3 + 0xf2);
  _DAT_1f800060 = *(undefined4 *)(param_3 + 0xa8);
  DAT_1f800064 = *(undefined4 *)(param_3 + 0xac);
  _DAT_1f800068 = *(undefined4 *)(param_3 + 0xb0);
  DAT_1f80006c = *(undefined4 *)(param_3 + 0xb4);
  _DAT_1f800070 = *(undefined4 *)(param_3 + 0xb8);
  DAT_1f800074 = *(undefined4 *)(param_3 + 0xbc);
  _DAT_1f800078 = *(undefined4 *)(param_3 + 0xc0);
  DAT_1f80007c = *(undefined4 *)(param_3 + 0xc4);
  DAT_1f8000ac = (&DAT_1f800084)[*(int *)(param_3 + 0xd0)];
  _DAT_1f8000b0 = (&DAT_1f800084)[*(int *)(param_3 + 0xd4)];
  DAT_1f8000b4 = (&DAT_1f800084)[*(int *)(param_3 + 0xd8)];
  DAT_1f8000b8 = (&DAT_1f800084)[*(int *)(param_3 + 0xdc)];
  
  // VisMem 0x80 - 0x8F
  iVar7 = param_5;
  
  // ptrVisDataArray
  puVar13 = param_1;
  
  DAT_1f800030 = unaff_s0;
  DAT_1f800034 = unaff_s1;
  DAT_1f800038 = unaff_s2;
  DAT_1f80003c = unaff_s3;
  DAT_1f800040 = unaff_s4;
  DAT_1f800044 = unaff_s5;
  DAT_1f800048 = unaff_s6;
  _DAT_1f80004c = unaff_s7;
  DAT_1f800054 = (undefined *)register0x00000074;
  _DAT_1f800058 = unaff_s8;
  DAT_1f80005c = unaff_retaddr;
  do {
    uVar14 = *(uint *)(puVar13 + 0xc);
    uVar16 = (int)uVar14 >> 0x10;
    if (((uVar14 & 0x8000) == 0) &&
       (*(int *)((uVar14 >> 3 & 0x7fc) + param_2) << (uVar14 & 0x1f) < 0)) {
      puVar13 = param_1 + (uVar14 & 0x3fff) * 0x10;
      iVar6 = *(int *)(puVar13 + 2);
      iVar17 = *(int *)(puVar13 + 4);
      if (((iVar6 >> 0x10) - iVar12 < 1) &&
         (*(int *)(iVar5 + 0xd4) = iVar6, (short)iVar6 - iVar11 < 1)) {
        iVar6 = *(int *)(puVar13 + 6);
        if ((((iVar8 - (iVar17 >> 0x10) < 1) && ((int)(short)iVar17 - (int)sVar2 < 1)) &&
            (iVar10 - (iVar6 >> 0x10) < 1)) &&
           (*(int *)(iVar5 + 0xd8) = iVar17, iVar9 - (short)iVar6 < 1)) {
          *(int *)(iVar5 + 0xdc) = iVar6;
          *(undefined2 *)(iVar5 + 0xd0) = (short)uVar14;
          iVar5 = iVar5 + 0x10;
        }
      }
    }
    if ((-1 < (int)uVar16) && (*(int *)((uVar16 >> 3 & 0x7fc) + param_2) << (uVar16 & 0x1f) < 0)) {
      puVar13 = param_1 + (uVar16 & 0x3fff) * 0x10;
      iVar6 = *(int *)(puVar13 + 2);
      iVar17 = *(int *)(puVar13 + 4);
      if (((iVar6 >> 0x10) - iVar12 < 1) &&
         (*(int *)(iVar5 + 0xd4) = iVar6, (short)iVar6 - iVar11 < 1)) {
        iVar6 = *(int *)(puVar13 + 6);
        if ((((iVar8 - (iVar17 >> 0x10) < 1) && ((int)(short)iVar17 - (int)sVar2 < 1)) &&
            (iVar10 - (iVar6 >> 0x10) < 1)) &&
           (*(int *)(iVar5 + 0xd8) = iVar17, iVar9 - (short)iVar6 < 1)) {
          *(int *)(iVar5 + 0xdc) = iVar6;
          *(undefined2 *)(iVar5 + 0xd0) = (short)(uVar14 >> 0x10);
          iVar5 = iVar5 + 0x10;
        }
      }
    }
    while( true ) {
      if (iVar5 == iVar4) {
        return *(undefined4 *)(iVar4 + 0x80);
      }
      psVar1 = (short *)(iVar5 + 0xc0);
      iVar5 = iVar5 + -0x10;

	  // VisData index
	  uVar14 = (int)*psVar1 & 0x3fff;

      puVar13 = param_1 + uVar14 * 0x10;

	  // If this is not a leaf node, break
      if (((int)*psVar1 & 0x4000U) == 0) break;
	  
	  // as long as we have leaf nodes, keep going...

	  // VisData flag
      uVar3 = *puVar13;
	  
      iVar5 = FUN_80070284();
      
	  if ((((int)pcVar19 < 1) && (iVar5 = FUN_80070284(), (int)pcVar19 < 1)) &&
         (iVar5 = FUN_80070284(), (int)pcVar19 < 1)) 
	  {
        iVar5 = FUN_80070284();
        
		if ((int)pcVar19 < 1) 
		{
		
		  // VisDataList inside RenderList is not
		  // the same in 3P4P as it is 1P2P, different offsets
		  
		  // VisDataList_Water (ocean)
          piVar18 = (int *)(param_4 + 0x14);
		  
          if (
				(
					// if VisData flag is not water
					((uVar3 & 2) == 0) && 
					
					(
						// force high LOD
						// scrolling textures (waterfall)
						piVar18 = (int *)(param_4 + 0x1c),

						// if force high LOD is disabled
						(uVar3 & 0x20) == 0
					)
				) &&
				
				(piVar18 = (int *)(param_4 + 4), (uVar3 & 0x80) == 0)
			  ) 
		  {
			// almost all 3P4P rendering
            piVar18 = (int *)(param_4 + 0xc);
          }
		  
		  // build upon linked lists
		  
		  // VisMem 0x80-0x8F
		  // region after quadblock int flags
          piVar15 = (int *)(uVar14 * 8 + iVar7);
          
		  iVar17 = *piVar18;
          *(int **)piVar18 = piVar15;
          iVar6 = *(int *)(iVar4 + 0x80);
          *piVar15 = iVar17;
		  
		  // 0x1f800080
		  // increment length of linked list
          *(int *)(iVar4 + 0x80) = iVar6 + 1;
        }
      }
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// param1 - cameraDC pointer
// param2 - otMem
// param3 - render bucket instance, unused?
// param4 - trackLOD
// param5 - numScreens
// param6 - isPaused?
// RenderBucket_QueueLevInstances
undefined4
FUN_80070720(int param_1,int param_2,undefined4 param_3,undefined4 param_4,int param_5,
            undefined4 param_6)

{
  int iVar1;
  int iVar2;
  int iVar3;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  undefined4 unaff_s7;
  undefined *puVar4;
  undefined4 unaff_s8;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];

  iVar1 = 0x1f800000;
  DAT_1f800020 = &_gp_4;
  DAT_1f800034 = *(undefined4 *)(param_2 + 0xc);

  // number of players
  DAT_1f80005c = param_5;

  _DAT_1f800090 = param_6;
  DAT_1f800038 = *(int *)(param_2 + 8) + -4;

  // increment to last player's CameraDC
  _DAT_1f800060 = param_1 + (param_5 + -1) * 0xdc;

  // InstDrawPerPlayer
  DAT_1f800054 = (param_5 + -1) * 0x88;

  // CameraDC -> 0x28 (comes from QuadBlock + 0x44)
  iVar2 = *(int *)(_DAT_1f800060 + 0x28);

  _DAT_1f800058 = 0;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800024 = (undefined *)register0x00000074;
  DAT_1f800028 = unaff_s8;
  DAT_1f80002c = unaff_retaddr;
  _DAT_1f800050 = param_4;
  FUN_80071590();

  // loop for all players
  do
  {
	// derefrence pointer to array,
	// get first instance pointer
    puVar4 = *(undefined **)iVar2;

	if (iVar2 != 0)
	{
	  // every instance that is visible from QuadBlock,
	  // loop until nullptr is found
      while (iVar2 = iVar2 + 4, puVar4 != (undefined *)0x0)
	  {
		// RenderBucket_QueueDraw
        FUN_80070950(puVar4);

		// get next instance pointer
        puVar4 = *(undefined **)iVar2;
      }
    }

	// cameraDC
    iVar2 = *(int *)(iVar1 + 0x60);

	// previous camera
    *(int *)(iVar1 + 0x60) = iVar2 + -0xdc;

	// minus 0xdc, plus 0x28,
	// next camera's 0x28 offset
    iVar2 = *(int *)(iVar2 + -0xb4);

	// decrease number of remaining players
	iVar3 = *(int *)(iVar1 + 0x5c) + -1;

	// InstDrawPerPlayer
	*(int *)(iVar1 + 0x54) = *(int *)(iVar1 + 0x54) + -0x88;

    *(int *)(iVar1 + 0x5c) = iVar3;

  } while (0 < iVar3);

  *(undefined4 *)(param_2 + 0xc) = *(undefined4 *)(iVar1 + 0x34);

  return param_3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// param1 - instance pool "taken" list
// param2 - otMem
// param3 - RenderBucketInstance
// param4 - track LOD
// param5 - numScreens
// param6 - isPaused?
// RenderBucket_QueueNonLevInstances
undefined4
FUN_8007084c(undefined *param_1,int param_2,undefined4 param_3,undefined4 param_4,int param_5,
            undefined4 param_6)

{
  int iVar1;
  int iVar2;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  undefined4 unaff_s7;
  undefined *puVar3;
  undefined4 unaff_s8;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];

  iVar1 = 0x1f800000;
  DAT_1f800020 = &_gp_4;
  DAT_1f800034 = *(undefined4 *)(param_2 + 0xc);

  // put numScreens on scratchpad
  DAT_1f80005c = param_5;

  _DAT_1f800090 = param_6;
  DAT_1f800038 = *(int *)(param_2 + 8) + -4;
  
  // InstDrawPerPlayer
  DAT_1f800054 = (param_5 + -1) * 0x88;
  
  _DAT_1f800058 = 0;
  DAT_1f800000 = unaff_s0;
  DAT_1f800004 = unaff_s1;
  DAT_1f800008 = unaff_s2;
  DAT_1f80000c = unaff_s3;
  DAT_1f800010 = unaff_s4;
  DAT_1f800014 = unaff_s5;
  DAT_1f800018 = unaff_s6;
  DAT_1f80001c = unaff_s7;
  DAT_1f800024 = (undefined *)register0x00000074;
  DAT_1f800028 = unaff_s8;
  DAT_1f80002c = unaff_retaddr;
  _DAT_1f800050 = param_4;
  FUN_80071590();

  // pointer to instance
  puVar3 = param_1;

  // loop for every screen
  do
  {
	// every instance in InstancePool
    while (puVar3 != (undefined *)0x0)
	{
	  // RenderBucket_QueueDraw
      FUN_80070950(puVar3);

	  // instance = instance->next
      puVar3 = *(undefined **)puVar3;
    }

	// decrease number of screens
    iVar2 = *(int *)(iVar1 + 0x5c) + -1;

	// InstDrawPerPlayer
    *(int *)(iVar1 + 0x54) = *(int *)(iVar1 + 0x54) + -0x88;

	// store number of screens
    *(int *)(iVar1 + 0x5c) = iVar2;

	// go back to start of instance pool,
	// to add all instances again, for other screens
    puVar3 = param_1;

  } while (0 < iVar2);

  *(undefined4 *)(param_2 + 0xc) = *(undefined4 *)(iVar1 + 0x34);
  return param_3;
}



// WARNING: Instruction at (ram,0x8007144c) overlaps instruction at (ram,0x80071448)
//
// WARNING: Removing unreachable block (ram,0x80070a1c)
// WARNING: Removing unreachable block (ram,0x800709e4)
// WARNING: Removing unreachable block (ram,0x80070a04)
// WARNING: Removing unreachable block (ram,0x80070a70)
// WARNING: Removing unreachable block (ram,0x80070a7c)
// WARNING: Removing unreachable block (ram,0x80070abc)
// WARNING: Removing unreachable block (ram,0x80070edc)
// WARNING: Removing unreachable block (ram,0x80070f0c)
// WARNING: Removing unreachable block (ram,0x80071468)
// WARNING: Removing unreachable block (ram,0x80071470)
// WARNING: Removing unreachable block (ram,0x80070d54)
// WARNING: Removing unreachable block (ram,0x80070d5c)
// WARNING: Removing unreachable block (ram,0x80070d38)
// WARNING: Removing unreachable block (ram,0x80070d44)


// RenderBucket_QueueDraw
void FUN_80070950(undefined4 param_1,undefined4 param_2,int param_3)

{
  short sVar1;
  short sVar2;
  undefined4 in_zero;
  int in_at;
  int extraout_v1;
  int iVar3;
  uint uVar4;
  undefined4 extraout_v1_00;
  undefined4 extraout_v1_01;
  int extraout_v1_02;
  undefined *puVar5;
  short *psVar6;
  ushort uVar7;
  short *psVar8;
  int iVar9;
  uint uVar10;
  uint *puVar11;
  undefined *puVar12;
  undefined4 uVar13;
  int iVar14;
  uint uVar15;
  undefined4 uVar16;
  uint *puVar17;
  undefined4 uVar18;
  int iVar19;
  uint *puVar20;
  uint uVar21;
  uint uVar22;
  uint uVar23;
  uint uVar24;
  uint uVar25;
  int unaff_s3;
  int iVar26;
  int iVar27;
  uint *puVar28;
  undefined *puVar29;
  undefined *unaff_s8;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];
  short param_8_00;
  undefined4 param_8;
  short sStack0000001e;
  short param_9_00;
  undefined4 param_9;
  undefined2 uStack00000022;
  int param_16;
  int param_17;
  int param_18;
  char param_19;
  char param_20;
  byte param_21;
  undefined4 param_19_00;
  uint param_22;
  short sStack00000056;
  undefined4 param_23;
  undefined4 param_24;
  undefined4 param_25;
  undefined4 param_26;
  uint param_28;

  puVar29 = &_gp_4;

  // camera110
  psVar6 = *(short **)(unaff_s8 + 0x74);

  *(undefined4 *)(in_at + 0x40) = unaff_retaddr;

  // $gp temporarily overwritten
  if (((*(uint *)(in_at + 0x50) & $gp) != 0) &&
     (psVar8 = *(short **)(in_at + 0x58), psVar6 != (short *)0x0)) {
    *(short **)(in_at + 0x58) = psVar6;
    if (psVar8 != psVar6) {
      FUN_8006c600();

	  // copy camera110 position to instance
      sVar1 = psVar6[1];
      sVar2 = psVar6[2];
      *(int *)(in_at + 0x44) = (int)*psVar6;
      *(int *)(in_at + 0x48) = (int)sVar1;
      *(int *)(in_at + 0x4c) = (int)sVar2;

	  sVar1 = psVar6[0x11];
      uVar13 = *(undefined4 *)(psVar6 + 0xc);
      uVar18 = *(undefined4 *)(psVar6 + 0x7a);
      *(undefined2 *)(in_at + 0x3c) = (short)extraout_v1;
      *(short *)(in_at + 0x3e) = sVar1;
	  
      gte_ldOFX(extraout_v1 << 0xf);
      gte_ldOFY((int)sVar1 << 0xf);
      gte_ldH(uVar13);
      
	  *(undefined4 *)(in_at + 0x30) = uVar18;
    }
    puVar29 = &_gp_4;
    *(int *)(in_at + 0x7c) = param_17;
    *(undefined2 *)(unaff_s8 + 0xbc) = uStack00000022;
    *(int *)(in_at + 0x8c) = param_18;
    iVar19 = 0;
    iVar3 = param_16;
    iVar9 = param_17;
    iVar14 = param_18;
    if (param_18 + -0x1000 < 0) {
      iVar19 = 2;
      iVar3 = param_16 << 2;
      iVar9 = param_17 << 2;
      iVar14 = param_18 << 2;
    }

	// model -> headers
	iVar26 = *(int *)(unaff_s3 + 0x14);

	*(int *)(unaff_s8 + 0x8c) = iVar3;
    *(int *)(unaff_s8 + 0x90) = iVar9;

	// Model -> numHeaders
    iVar27 = (int)*(short *)(unaff_s3 + 0x12);

    *(int *)(unaff_s8 + 0x94) = iVar14;
	
	gte_ldtr(iVar3,iVar9,iVar14);
    
	iVar9 = gte_stH();
    iVar3 = 0;

	// loop through all headers
	do
	{
	  // keep count of headers
      iVar27 = iVar27 + -1;

	  // make comparison with header->maxDistanceLOD,
	  // loop until the first LOD is found with a higher distance,
	  // than the current camera distance to this instance
      if ((int)((((int)*(short *)(in_at + 0x3c) >> 1) * *(int *)(in_at + 0x8c)) / iVar9 -
               (uint)*(ushort *)(iVar26 + 0x14)) < 0)
	  {
		// store pointer to which model header LOD is rendered
        *(int *)(unaff_s8 + 0xe0) = iVar26;

		// store which LOD index gets rendered
		*(int *)(unaff_s8 + 0xd8) = iVar3;

        FUN_8006c540();
        uVar15 = -iVar19 + 0x12;
        
		gte_ldLR1LR2((*(uint *)(iVar26 + 0x18) << 0x10) >> (uVar15 & 0x1f));
        gte_ldLR3LG1(0);
        gte_ldLG2LG3(*(uint *)(iVar26 + 0x18) >> (uVar15 & 0x1f));
        gte_ldLB1LB2(0);
        gte_ldLB3((int)(uint)*(ushort *)(iVar26 + 0x1c) >> (-iVar19 + 2U & 0x1f));
        
		gte_ldVXY0(param_8);
        gte_ldVZ0(param_9);
		
        iVar3 = (*(int *)(in_at + 0x8c) >> 1) + 0x1000;
		
        gte_ldVXY0(iVar3 * param_8_00 >> 0xc & 0xffffU | (iVar3 * sStack0000001e >> 0xc) << 0x10);
        gte_ldVZ0(iVar3 * param_9_00 >> 0xc);
        
		uVar22 = 0;
        uVar24 = 0;

		// lcv0     cop2 $04C6012  v0 * color matrix
		gte_lcv0_b();

        uVar21 = gte_stIR1();
        uVar23 = gte_stIR2();
        uVar25 = gte_stIR3();
		
        *(undefined2 *)(in_at + 0x74) = (short)uVar21;
        *(undefined2 *)(in_at + 0x76) = (short)uVar23;
        *(uint *)(in_at + 0x78) = uVar25;
        uVar21 = uVar21 & 0xffff;
        uVar23 = uVar23 & 0xffff;
        uVar25 = uVar25 & 0xffff;
        FUN_8006c49c();
        *(int *)(in_at + 0xbc) = (int)param_19;
        *(int *)(in_at + 0xc0) = (int)param_20;
        uVar15 = *(uint *)(in_at + 0x5c);
        
		if ((param_28 != 0) && (uVar15 != param_28 >> 0x18)) 
		{
          gte_ldLR3LG1((int)(param_28 << 8) >> 0x18);
          gte_ldLR1LR2((int)(char)param_28 & 0xffffU |
                      ((int)(param_28 << 0x10) >> 0x18) << 0x10);
					  
          gte_ldVXY0(*(undefined4 *)(in_at + 0xb4));
          gte_ldVZ0(*(undefined4 *)(in_at + 0xb8));
		  
          uVar15 = *(uint *)(in_at + 0xc0);

		  // lcv0     cop2 $04C6012  v0 * color matrix
		  gte_lcv0_b();

          iVar3 = gte_stMAC1();
          if (0 < iVar3) {
            uVar15 = uVar15 + 10;
            *(int *)(in_at + 0xbc) = *(int *)(in_at + 0xbc) + 10;
            *(uint *)(in_at + 0xc0) = uVar15;
          }
        }

        psVar8 = (short *)0x0;

		// if no animation data
		if (*(int *)(iVar26 + 0x38) == 0) {
          puVar5 = &_gp_4;
          psVar8 = (short *)0x0;

		  // vertex data of non-animated model
		  puVar28 = *(uint **)(iVar26 + 0x24);

          *(undefined4 *)(unaff_s8 + 0xd4) = *(undefined4 *)(iVar26 + 0x30);
        }

		// if animation data
        else
		{
		  // pointer to animation
          iVar3 = *(int *)(*(int *)(iVar26 + 0x38) + (uint)param_21 * 4);

		  // current animation frame
		  uVar4 = param_22 & 0xffff;

		  // number of frames in animation
		  sVar1 = *(short *)(iVar3 + 0x10);

		  // frame size
		  uVar15 = (uint)*(ushort *)(iVar3 + 0x12);

		  // model -> anim -> offset0x14
		  *(undefined4 *)(unaff_s8 + 0xd4) = *(undefined4 *)(iVar3 + 0x14);

		  // current animation frame
		  *(uint *)(in_at + 0x80) = uVar4;

		  // last frame index
		  uVar10 = ((int)sVar1 & 0x7fffU) - 1;

		  // last frame index
          *(uint *)(in_at + 0x84) = uVar10;

		  // if negative number of frames in animation,
		  // 60fps
          if ((int)sVar1 < 0)
		  {
			// cut last frame in half
            uVar10 = uVar10 >> 1;

			// cut current frame in half
            uVar4 = param_22 >> 1 & 0x7fff;

			// odd numbered frames
            if ((param_22 & 1) != 0) {
              psVar8 = (short *)0xffffffff;
            }
          }

		  // if current frame is bigger than last frame
          if ((int)(uVar10 - uVar4) < 0)
		  {
			// set current frame to last frame
            uVar4 = uVar10;
          }

          if (((*(int *)(in_at + 0x90) == 0) && ((undefined *)register0x00000074 == unaff_s8)) &&
             (param_22 = *(int *)(in_at + 0x80) - 1, *(int *)(in_at + 0x80) < 1)) {
            puVar29 = (undefined *)0x8008cf7c;
            param_22 = 1;
          }

		  // model -> anim -> offset0x18, plus frame index * frame size ???
		  puVar28 = (uint *)(iVar3 + 0x18 + uVar4 * uVar15);

		  puVar5 = puVar29;
        }

		// short pos[x,y,z]
        uVar10 = *puVar28;
        iVar3 = (int)*(short *)(puVar28 + 1);

        uVar4 = 0xfff8ffff;

        *(short **)(in_at + 100) = psVar8;

		// if 60fps mode
		if (psVar8 != (short *)0x0)
		{
		  // origin data of next frame
          psVar8 = (short *)((int)puVar28 + uVar15);

		  // interpolate between
          uVar10 = ((int)psVar8[1] + ((int)uVar10 >> 0x10) >> 2) << 0x11 |
                   (int)*psVar8 + (int)(short)uVar10 >> 1 & 0xffffU;

		  // interpolate between
          iVar3 = iVar3 + psVar8[2] >> 1;
        }

		// origin data
        *(uint **)(unaff_s8 + 0xc0) = puVar28;

		// origin next frame?
        *(short **)(unaff_s8 + 0xc4) = psVar8;

        *(uint *)(unaff_s8 + 0x98) = uVar21;
        *(uint *)(unaff_s8 + 0x9c) = uVar22;
        *(uint *)(unaff_s8 + 0xa0) = uVar23;
        *(uint *)(unaff_s8 + 0xa4) = uVar24;
        *(uint *)(unaff_s8 + 0xa8) = uVar25;
        *(undefined4 *)(in_at + 0x68) = 0;
        *(undefined4 *)(in_at + 0x6c) = 0;
        if (((uint)puVar5 & 0x7000) == 0) {
LAB_80070f6c:

		  // model -> flags
          uVar7 = *(ushort *)(iVar26 + 0x16);

          puVar29 = puVar5;
LAB_80070f70:
          uVar4 = 0xfff8ffff;
          if ((((uint)puVar29 & 0x800) == 0) && ((uVar7 & 1) == 0)) {
            FUN_8006c558();
            *(uint *)(unaff_s8 + 0x78) = uVar21;
            *(uint *)(unaff_s8 + 0x7c) = uVar22;
            *(uint *)(unaff_s8 + 0x80) = uVar23;
            *(uint *)(unaff_s8 + 0x84) = uVar24;
            *(uint *)(unaff_s8 + 0x88) = uVar25;
            FUN_8006c540();
          }
          else {
LAB_80070f84:
            uVar4 = 0xfff8ffff;
            iVar9 = gte_stTRX();
            iVar14 = gte_stTRZ();
            if (((uint)puVar29 & 0x8000) != 0) {
              iVar9 = -iVar9;
            }
			
            gte_ldIR1(iVar9);
            gte_ldIR2(iVar14);
            gte_sqr0(0);
            iVar19 = gte_stMAC1();
            iVar27 = gte_stMAC2();

			// instance
			*(undefined4 *)(in_at + 0x88) = param_1;

			iVar19 = SquareRoot0(iVar19 + iVar27);
            uVar13 = 0x1000;
            uVar21 = (iVar14 << 0xc) / iVar19 & 0xffff;
            uVar22 = (iVar9 << 0xc) / iVar19 & 0xffff;
            uVar23 = -uVar22 & 0xffff;
            uVar15 = uVar21;

			// instance
            FUN_8006c49c(*(undefined4 *)(in_at + 0x88));

            gte_ldR11R12(0x1000);
            gte_ldR13R21(0);
            gte_ldR22R23(0xfffff600);
            gte_ldR31R32(0);
            gte_ldR33(0x1000);

			// same instance?
			FUN_8006c49c();

            *(uint *)(unaff_s8 + 0x78) = uVar21;
            *(uint *)(unaff_s8 + 0x7c) = uVar22;
            *(undefined4 *)(unaff_s8 + 0x80) = uVar13;
            *(uint *)(unaff_s8 + 0x84) = uVar23;
            *(uint *)(unaff_s8 + 0x88) = uVar15;
          }
        }
        else {
          *(undefined4 *)(in_at + 0x70) = 0;
          iVar9 = (int)sStack00000056 -
                  (*(int *)(in_at + 0x7c) +
                  (((int)uVar10 >> 0x10) / (int)*(short *)(in_at + 0x76) >> 0xc));
          if ((uVar21 | uVar22 | uVar23 | uVar24 | uVar25) == 0x1000) {
            iVar9 = (iVar9 * 0x1000) / (int)*(short *)(in_at + 0x76) << 2;
            *(short *)(unaff_s8 + 0xbe) = (short)iVar9;
            *(int *)(in_at + 0x68) = iVar9;
            puVar5 = (undefined *)((uint)puVar5 & 0xfffffeff);
            goto LAB_80070f6c;
          }
          iVar9 = iVar9 * 4;
          *(short *)(unaff_s8 + 0xbe) = (short)iVar9;
          if (((uint)puVar5 & 0x4000) == 0)
		  {
			// model -> flags
            uVar7 = *(ushort *)(iVar26 + 0x16);

			puVar29 = puVar5;
            if (-1 < iVar9 + 0x16a) goto code_r0x80070e84;
            goto LAB_80070f70;
          }

		  // model -> flags
          uVar7 = *(ushort *)(iVar26 + 0x16);

code_r0x80070e84:
          puVar29 = (undefined *)((uint)puVar5 & 0xfffffeff);
          *(undefined4 *)(in_at + 0x6c) = 0xfffffeff;
          
		  if ((((uint)puVar5 & 0x800) != 0) || ((uVar7 & 1) != 0)) goto LAB_80070f84;
		  
          FUN_8006c558();
		  
          uVar13 = gte_stL11L12();
          uVar18 = gte_stL13L21();
          uVar16 = gte_stL22L23();
          *(undefined4 *)(unaff_s8 + 0x78) = uVar13;
          *(undefined4 *)(unaff_s8 + 0x7c) = uVar18;
          *(undefined4 *)(unaff_s8 + 0x80) = uVar16;
          uVar13 = gte_stL31L32();
          uVar18 = gte_stL33();
		  
		  *(undefined4 *)(unaff_s8 + 0x84) = uVar13;
          FUN_8006c540();
          *(undefined4 *)(unaff_s8 + 0x88) = uVar18;
        }
        iVar9 = (uVar10 & 0x3ffe3fff) * 4;
        iVar3 = iVar3 << 2;

        gte_ldVXY0(iVar9);
        gte_ldVZ0(iVar3);
        uVar4 = iVar9 + 0x3fcU & uVar4;
        gte_ldVXY1(uVar4);
        gte_ldVZ1(iVar3);
        gte_ldVXY2(uVar4 + 0x3fc0000);
        gte_ldVZ2(iVar3);
        gte_rtpt_b();
        iVar9 = gte_stSXY0();
        iVar27 = gte_stSZ1();
        iVar19 = iVar9 >> 0x10;
        uVar21 = (uint)(short)iVar9;

        gte_stSXY1();
        gte_stSZ2();

        uVar15 = uVar21;
        iVar9 = iVar19;
        iVar14 = iVar27;

        FUN_80071524();
        gte_stSXY2();
        gte_stSZ3();
        FUN_80071524();
        gte_ldVZ0(extraout_v1_00);
        gte_ldVZ1(extraout_v1_00);
        gte_ldVZ2(extraout_v1_00);
        gte_rtpt_b();
        gte_stSXY0();
        gte_stSZ1();
        FUN_80071524();
        gte_stSXY1();
        gte_stSZ2();
        FUN_80071524();
        gte_stSXY2();
        gte_stSZ3();
        FUN_80071524();
        gte_ldVXY0(extraout_v1_01);
        gte_ldVZ0(iVar3);
        gte_ldVXY1(extraout_v1_01);
        gte_ldVXY2(0);
        gte_ldVZ2(0);
        gte_rtpt();
        gte_stSXY0();
        gte_stSZ1();
        gte_stH();
        FUN_80071524();
        gte_stSXY1();
        gte_stSZ2();
        FUN_80071524();

        if (((uint)puVar29 & 0x100) != 0) {
          *(uint *)(psVar6 + 0x80) = iVar19 << 0x10 | uVar21 & 0xffff;
          uVar22 = uVar15 - uVar21 & 0xffff;
          *(uint *)(psVar6 + 0x82) = (iVar9 - iVar19) * 0x10000 | uVar22;
          if ((((((int)uVar21 < 0) || (iVar19 < 0)) || (0 < (iVar9 - iVar19) + -0x40)) ||
              ((0 < (int)(uVar22 - 0x60) || (-1 < (int)(uVar15 - (int)*(short *)(in_at + 0x3c))))))
             || (-1 < iVar9 - *(short *)(in_at + 0x3e))) {
            puVar29 = (undefined *)((uint)puVar29 & 0xfffffeff);
          }
        }
        if (((-1 < (int)uVar15) && (-1 < iVar9)) &&
           ((-1 < iVar27 - extraout_v1_02 &&
            (((int)(uVar21 - *(ushort *)(in_at + 0x3c)) < 1 &&
             ((int)(iVar19 - (uint)*(ushort *)(in_at + 0x3e)) < 1)))))) {
          iVar3 = (iVar14 >> 5) + -2;
          iVar9 = (iVar27 >> 5) + 1;
          *(short *)(unaff_s8 + 0xdc) = (short)iVar3;
          *(short *)(unaff_s8 + 0xde) = (short)iVar9;
          puVar28 = *(uint **)(in_at + 0x34);
          puVar11 = puVar28 + (iVar9 - iVar3);
          if (0 < *(int *)(in_at + 0x38) - (int)(puVar11 + 1)) {
            *(uint **)(in_at + 0x34) = puVar11 + 1;
            iVar14 = *(int *)(in_at + 0x8c) >> 6;
            puVar17 = puVar28;
            if (((uint)puVar29 & 0x100) == 0) {
              iVar14 = *(int *)(in_at + 0xbc) + iVar14;
              iVar19 = iVar14 * 4;
              if (iVar14 < 0) {
                iVar19 = 0;
              }
              else {
                if (0 < iVar19 + -0xffc) {
                  iVar19 = 0xffc;
                }
              }
              puVar20 = (uint *)(*(int *)(in_at + 0x30) + iVar19);
              uVar15 = *puVar20;
              *puVar20 = (uint)puVar11 & 0xffffff;
              *puVar28 = uVar15;
            }
            else {
              iVar14 = *(int *)(in_at + 0xbc) + iVar14;
              iVar19 = iVar14 * 4;
              if (iVar14 < 0) {
                iVar19 = 0;
              }
              else {
                if (0 < iVar19 + -0xffc) {
                  iVar19 = 0xffc;
                }
              }
              *(uint **)(psVar6 + 0x7a) = puVar28;
              *(uint **)(psVar6 + 0x7c) = puVar11;
              *(int *)(psVar6 + 0x7e) = iVar19;
              *puVar28 = 0;
            }
            while (puVar17 != puVar11) {
              puVar17[1] = (uint)puVar17 & 0xffffff;
              puVar17 = puVar17 + 1;
            }
            *(uint **)(unaff_s8 + 0xe4) = puVar28 + iVar3 * 0x3fffffff;
            *(uint **)(unaff_s8 + 0xe8) = puVar28 + iVar3 * 0x3fffffff;
            if ((((uint)puVar29 & 0x100) != 0) || (((uint)puVar29 & 0x6000) == 0)) {
LAB_80071478:
			  // RenderBucket_DrawFunc_Normal
              puVar5 = &FUN_8006a52c;

              goto LAB_80071480;
            }
            if (((uint)puVar29 & 0x4000) == 0) {
              puVar28 = *(uint **)(in_at + 0x34);
              if ((*(uint *)(in_at + 0x68) | *(uint *)(in_at + 0x6c)) == 0) goto LAB_80071478;
            }
            else {
              puVar28 = *(uint **)(in_at + 0x34);
            }
            puVar11 = puVar28 + (iVar9 - iVar3);
            if (*(int *)(in_at + 0x38) - (int)(puVar11 + 1) < 1) goto LAB_80071514;
            *(uint **)(in_at + 0x34) = puVar11 + 1;
            iVar9 = *(int *)(in_at + 0xc0) + (*(int *)(in_at + 0x8c) >> 6);
            iVar14 = iVar9 * 4;
            if (iVar9 < 0) {
              iVar14 = 0;
            }
            else {
              if (0 < iVar14 + -0xffc) {
                iVar14 = 0xffc;
              }
            }
            puVar17 = (uint *)(*(int *)(in_at + 0x30) + iVar14);
            uVar15 = *puVar17;
            *puVar17 = (uint)puVar11 & 0xffffff;
            *puVar28 = uVar15;
            puVar17 = puVar28;
            while (puVar17 != puVar11) {
              puVar17[1] = (uint)puVar17 & 0xffffff;
              puVar17 = puVar17 + 1;
            }
            uVar15 = *(uint *)(in_at + 0x68);
            if (((uint)puVar29 & 0x6000) == 0) goto LAB_80071478;
            uVar21 = *(uint *)(in_at + 0x6c);
            *(uint **)(unaff_s8 + 0xe8) = puVar28 + iVar3 * 0x3fffffff;
            if ((uVar15 | uVar21) == 0) {
code_r0x80071450:
              puVar5 = &LAB_8006bbc0;
LAB_80071480:
              puVar12 = &LAB_8006a8e0; // reference to FUN_8006a8e0(void), called later in this function indirectly. normal rendering, no special case like reflection, water/mud and or near clip
              if (*(int *)(in_at + 100) != 0) {
                puVar12 = &LAB_8006b24c; // reference to undefinedFunction_8006b24c(void), called later in this function indirectly, near clip maybe?
              }
            }
            else {
              if (uVar21 == 0) {
                if ((int)uVar15 < 0) {
                  if (((uint)puVar29 & 0x4000) == 0) goto LAB_80071478;
                  goto code_r0x80071450;
                }

				if (((uint)puVar29 & 0x4000) == 0)
				{
				  // RenderBucket_DrawFunc_Split
                  puVar5 = &UNK_8006b030;
                }

                else
				{
				  // Draw_KartBodyReflection
                  puVar5 = &LAB_8006c9c4; // reference to FUN_8006c9c4(void), called later in this function indirectly, reflection rendering

				  puVar29 = (undefined *)((uint)puVar29 | 0x100000);
                }

                goto LAB_80071480;
              }

              if (((uint)puVar29 & 0x4000) == 0)
			  {
				// RenderBucket_DrawFunc_Split
                puVar5 = &UNK_8006b030;
              }

			  else
			  {
				// Draw_KartBodyReflection
                puVar5 = &LAB_8006c9c4; // reference to FUN_8006c9c4(void), called later in this function indirectly, reflection rendering

				puVar29 = (undefined *)((uint)puVar29 | 0x100000);
              }

			  // Draw_KartInWaterMud
			  puVar12 = &LAB_8006bf30; // reference to FUN_8006bf30(void), called later in this function indirectly, under water or mud

			  if (*(int *)(in_at + 100) != 0) {
                puVar12 = &LAB_8006cdec; // reference to FUN_8006cdec(void), called later in this function indirectly. underwater or in mud something and near clip??
              }
            }
            *(BADSPACEBASE **)param_3 = register0x00000074;
            *(undefined **)(param_3 + 4) = unaff_s8;
            puVar29 = (undefined *)((uint)puVar29 | 0x40);

			// function to render the instance
            *(undefined **)(unaff_s8 + 0xec) = puVar5;

			// function for something else?
			*(undefined **)(unaff_s8 + 0xf0) = puVar12;

			// ptrCommandList, ptrTexLayout, and ptrColors
            uVar13 = *(undefined4 *)(iVar26 + 0x28);
            uVar18 = *(undefined4 *)(iVar26 + 0x2c);
            *(undefined4 *)(unaff_s8 + 200) = *(undefined4 *)(iVar26 + 0x20);
            *(undefined4 *)(unaff_s8 + 0xcc) = uVar13;
            *(undefined4 *)(unaff_s8 + 0xd0) = uVar18;
          }
        }
        goto LAB_80071514;
      }

	  // keep count of model header
      iVar3 = iVar3 + 1;

	  // next model header
      iVar26 = iVar26 + 0x40;

    } while (iVar27 != 0);

	// erase pointer to model header
    *(undefined4 *)(unaff_s8 + 0xe0) = 0;
  }
LAB_80071514:
  *(undefined **)(unaff_s8 + 0xb8) = puVar29;
  return;
}


void FUN_80071524(void)
{
        80071524 03 44 09 00     sra        t0,t1,0x10
        80071528 23 40 0d 01     subu       t0,t0,t5
        8007152c 02 00 01 05     bgez       t0,LAB_80071538
        80071530 03 44 09 00     _sra       t0,t1,0x10
        80071534 03 6c 09 00     sra        t5,t1,0x10
                             LAB_80071538                                    XREF[1]:     8007152c(j)  
        80071538 23 40 0e 01     subu       t0,t0,t6
        8007153c 02 00 00 19     blez       t0,LAB_80071548
        80071540 00 00 00 00     _nop
        80071544 03 74 09 00     sra        t6,t1,0x10
                             LAB_80071548                                    XREF[1]:     8007153c(j)  
        80071548 00 4c 09 00     sll        t1,t1,0x10
        8007154c 03 44 09 00     sra        t0,t1,0x10
        80071550 23 40 0b 01     subu       t0,t0,t3
        80071554 02 00 01 05     bgez       t0,LAB_80071560
        80071558 03 44 09 00     _sra       t0,t1,0x10
        8007155c 03 5c 09 00     sra        t3,t1,0x10
                             LAB_80071560                                    XREF[1]:     80071554(j)  
        80071560 23 40 0c 01     subu       t0,t0,t4
        80071564 02 00 00 19     blez       t0,LAB_80071570
        80071568 23 40 4f 01     _subu      t0,t2,t7
        8007156c 03 64 09 00     sra        t4,t1,0x10
                             LAB_80071570                                    XREF[1]:     80071564(j)  
        80071570 02 00 01 05     bgez       t0,LAB_8007157c
        80071574 23 40 50 01     _subu      t0,t2,s0
        80071578 21 78 40 01     move       t7,t2
                             LAB_8007157c                                    XREF[1]:     80071570(j)  
        8007157c 02 00 00 19     blez       t0,LAB_80071588
        80071580 00 00 00 00     _nop
        80071584 21 80 40 01     move       s0,t2
                             LAB_80071588                                    XREF[1]:     8007157c(j)  
        80071588 08 00 e0 03     jr         ra
        8007158c 00 00 00 00     _nop

}



void FUN_80071590(void)

{
  bool bVar1;
  int in_at;
  int iVar2;
  undefined **ppuVar3;
  undefined4 *puVar4;
  undefined *puVar5;

  // in_at = 0x1F800000

  iVar2 = 7;
  ppuVar3 = &PTR_LAB_8008a428;
  puVar4 = (undefined4 *)(in_at + 0x94);
  do {
    puVar5 = *ppuVar3;
    ppuVar3 = ppuVar3 + 1;
    *(undefined **)puVar4 = puVar5;
    puVar4 = puVar4 + 1;
    bVar1 = 0 < iVar2;
    iVar2 = iVar2 + -1;
  } while (bVar1);

  iVar2 = 7;
  ppuVar3 = &PTR_LAB_8008a444;
  puVar4 = (undefined4 *)(in_at + 0xc4);
  do {
    puVar5 = *ppuVar3;
    ppuVar3 = ppuVar3 + 1;
    *(undefined **)puVar4 = puVar5;
    puVar4 = puVar4 + 1;
    bVar1 = 0 < iVar2;
    iVar2 = iVar2 + -1;
  } while (bVar1);

  return;
}



// WARNING: Removing unreachable block (ram,0x80071690)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// execute all thread update functions
void FUN_800715e8(undefined4 param_1)

{
  undefined4 *puVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined4 unaff_s2;
  undefined4 unaff_s3;
  undefined4 unaff_s4;
  undefined4 unaff_s5;
  undefined4 unaff_s6;
  undefined4 unaff_s7;
  undefined4 unaff_s8;
  undefined4 unaff_retaddr;
  undefined auStackX0 [16];

  _DAT_1f8000d0 = &_gp_4;
  DAT_1f8000e4 = &DAT_1f800004;
  _DAT_1f8000b0 = unaff_s0;
  DAT_1f8000b4 = unaff_s1;
  DAT_1f8000b8 = unaff_s2;
  DAT_1f8000bc = unaff_s3;
  DAT_1f8000c0 = unaff_s4;
  DAT_1f8000c4 = unaff_s5;
  DAT_1f8000c8 = unaff_s6;
  DAT_1f8000cc = unaff_s7;
  DAT_1f8000d4 = (undefined *)register0x00000074;
  _DAT_1f8000d8 = unaff_s8;
  DAT_1f8000dc = unaff_retaddr;
  _DAT_1f8000e8 = param_1;
  while( true )
  {
	// get thread
    iVar3 = DAT_1f8000e4[0x39];

	// check if we go out of range
    if ((int)(DAT_1f8000e4 + -0x7e00001) < 0) break;

	// thread -> next
    iVar2 = *(int *)(iVar3 + 0x10);

	// cooldown
    iVar4 = *(int *)(iVar3 + 0x18);

	// get next thread
    DAT_1f8000e4[0x39] = iVar2;

    puVar1 = DAT_1f8000e4 + -1;
    if (iVar2 != 0) {
      puVar1 = DAT_1f8000e4;
    }
    DAT_1f8000e4 = puVar1;

	// if cooldown is not negative
    if (-1 < iVar4)
	{
	  // if there is no cooldown, execute thread
      if (iVar4 == 0)
	  {
		// if thread has per-frame funcPtr
        if (*(code **)(iVar3 + 0x2c) != (code *)0x0)
		{
          DAT_1f8000e0 = iVar3;

		  // execute PerFrame funcPtr
		  (**(code **)(iVar3 + 0x2c))();

		  iVar3 = DAT_1f8000e0;
        }

		// child thread
        iVar3 = *(int *)(iVar3 + 0x14);
        DAT_1f8000e4[0x3a] = iVar3;

		if (iVar3 != 0) {
          DAT_1f8000e4 = DAT_1f8000e4 + 1;
        }
      }

	  // if cooldown exists
      else
	  {
		// reduce cooldown
        *(int *)(iVar3 + 0x18) = iVar4 + -1;
      }
    }
  }
  DAT_1f8000e4 = DAT_1f8000e4 + -1;
  return;
}


// SetPerFrame_AndExec
void FUN_800716ec(int param_1,code *UNRECOVERED_JUMPTABLE)

{
  // Set per-frame funcPtr
  *(code **)(param_1 + 0x2c) = UNRECOVERED_JUMPTABLE;

  // Execute the weapon's function pointer
  (*UNRECOVERED_JUMPTABLE)();
  return;
}


// SetPerFrame
void FUN_80071704(int param_1,undefined4 param_2)

{
  *(undefined4 *)(param_1 + 0x2c) = param_2;
  return;
}

//Function CdLastCom used to be here, but it was deleted.

//FUN_800771b0 used to be here, probably a library func

// WARNING: Removing unreachable block (ram,0x80077a24)

// This function was not written by Naughty Dog, it was
// automatically generated by the compiler. We know this
// because we can decompile our own homebrew and we will
// see another auto-generated "start". We can use CTR's "start"
// to compare to our "start" to let us see if we have the
// right compiler (with the same auto-gen function).
void start(void)

{
  int iVar1;
  undefined4 *puVar2;
  undefined4 unaff_s0;
  undefined4 unaff_s1;
  undefined *puVar3;
  undefined4 unaff_retaddr;
  undefined4 uVar4;

  // memset BSS to zero
  puVar2 = &DAT_8008d668;
  do {
    *puVar2 = 0;
    puVar2 = puVar2 + 1;
  } while (puVar2 < &DAT_8009f6fc);

  puVar3 = (undefined *)(DAT_8008cb38 - 8U | 0x80000000);
  DAT_8008c058 = ((DAT_8008cb38 - 8U) - DAT_8008cb34) + -0x9f6fc;

  // end of BSS, start of overlay1
  DAT_8008c054 = &DAT_8009f6fc;

  // save $ra
  DAT_8008da04 = unaff_retaddr;

  InitHeap(&DAT_8009f700,DAT_8008c058,*puVar3);
  uVar4 = 0x800779e0;

  // start the "main" function
  main();

  iVar1 = DAT_8008c050;
  trap(1);
  *(undefined4 *)(puVar3 + -0xc) = unaff_s0;
  *(undefined4 *)(puVar3 + -8) = unaff_s1;
  *(undefined4 *)(puVar3 + -4) = uVar4;
  if (iVar1 == 0) {
    DAT_8008c050 = 1;
  }

  // $ra is not restored from 8008da04,
  // so this just goes back to trap(1),
  // and the game can never really "end"
  return;
}



// WARNING: Removing unreachable block (ram,0x80077a24)

void __main(void)

{
  if (DAT_8008c050 == 0) {
    DAT_8008c050 = 1;
  }
  return;
}

// .text
// ram:800123e0-ram:8008099f
